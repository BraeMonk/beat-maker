<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <!-- ðŸŒˆ Theming -->
  <meta name="theme-color" content="#7c83ff" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <!-- ðŸ§  Title -->
  <title>8-Beat Studio</title>

  <!-- ðŸ“± PWA Manifest -->
  <link rel="manifest" href="./manifest.json">

  <!-- ðŸŽ¨ App Icons (unified: 8beat1-7.png) -->
  <link rel="apple-touch-icon" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./8beat1-7.png">

  <!-- ðŸ’¬ Open Graph (Discord / Facebook / Messenger) -->
  <meta property="og:title" content="8-Beat Studio â€” Browser-Based DAW">
  <meta property="og:description"
        content="Create, record, mix, and master â€” all inside your browser. A full digital audio workstation built by hand.">
  <meta property="og:image"
        content="https://braemonk.github.io/beat-maker/8beat1-7.png">
  <meta property="og:url" content="https://braemonk.github.io/beat-maker/">
  <meta property="og:type" content="website">

  <!-- ðŸ¦ Twitter Card (X / mobile previews) -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="8-Beat Studio â€” Browser-Based DAW">
  <meta name="twitter:description"
        content="A full digital audio workstation that runs entirely in your browser.">
  <meta name="twitter:image"
        content="https://braemonk.github.io/beat-maker/8beat1-7.png">
  <style>
/* =========================================================
   8-BEAT STUDIO â€” PROFESSIONAL RESPONSIVE REDESIGN
   Premium glassmorphic design with advanced micro-interactions
   Full mobile/tablet/desktop support â€¢ PWA optimized
========================================================= */

/* Professional Font Stack */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;600;700&display=swap');

/* -------- Design System Tokens -------- */
:root {
  /* Typography Scale */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --font-mono: 'JetBrains Mono', 'Courier New', monospace;
  
  --text-xs: clamp(0.7rem, 0.65rem + 0.25vw, 0.75rem);
  --text-sm: clamp(0.8rem, 0.75rem + 0.25vw, 0.875rem);
  --text-base: clamp(0.9rem, 0.85rem + 0.25vw, 1rem);
  --text-lg: clamp(1rem, 0.95rem + 0.25vw, 1.125rem);
  --text-xl: clamp(1.125rem, 1rem + 0.5vw, 1.25rem);
  --text-2xl: clamp(1.25rem, 1.125rem + 0.625vw, 1.5rem);
  --text-3xl: clamp(1.5rem, 1.25rem + 1vw, 2rem);
  --text-4xl: clamp(1.875rem, 1.5rem + 1.5vw, 2.5rem);

  /* Spacing System */
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-5: 1.25rem;
  --space-6: 1.5rem;
  --space-7: 1.75rem;
  --space-8: 2rem;
  --space-10: 2.5rem;
  --space-12: 3rem;
  --space-16: 4rem;
  --space-20: 5rem;
  
  /* Layout */
  --container-max: 1800px;
  --gutter: clamp(1rem, 3vw, 2rem);
  --sidebar-width: clamp(280px, 18vw, 340px);
  
  /* Border Radius System */
  --radius-xs: 6px;
  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 18px;
  --radius-xl: 24px;
  --radius-2xl: 32px;
  --radius-full: 9999px;

  /* Professional Shadow System */
  --shadow-xs: 0 1px 2px rgba(0,0,0,.05);
  --shadow-sm: 0 2px 8px rgba(0,0,0,.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,.12);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.16);
  --shadow-xl: 0 12px 48px rgba(0,0,0,.22);
  --shadow-2xl: 0 20px 64px rgba(0,0,0,.32);
  --shadow-inner: inset 0 2px 8px rgba(0,0,0,.08);
  
  /* Glow Effects */
  --glow-sm: 0 0 20px;
  --glow-md: 0 0 40px;
  --glow-lg: 0 0 60px;

  /* Component Heights */
  --header-h: clamp(68px, 8vh, 80px);
  --tabs-h: clamp(52px, 6vh, 60px);
  --transport-h: clamp(88px, 10vh, 104px);

  /* Focus Ring */
  --ring-w: 3px;
  --ring-offset: 2px;
  --ring: rgba(180,190,255,.6);
  
  /* Glass Effects */
  --glass-border: rgba(255,255,255,.12);
  --glass-border-strong: rgba(255,255,255,.2);
  --glass-bg: rgba(255,255,255,.04);
  --glass-bg-strong: rgba(255,255,255,.08);

  /* Safe Areas */
  --inset-top: env(safe-area-inset-top, 0px);
  --inset-right: env(safe-area-inset-right, 0px);
  --inset-bottom: env(safe-area-inset-bottom, 0px);
  --inset-left: env(safe-area-inset-left, 0px);

  /* Animation Curves */
  --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
  --ease-elastic: cubic-bezier(0.68, -0.6, 0.32, 1.6);
  
  /* Transition Durations */
  --duration-fast: 150ms;
  --duration-base: 200ms;
  --duration-slow: 300ms;
  --duration-slower: 500ms;

  /* Default Theme */
  --bg-primary: #0a0e1a;
  --bg-secondary: #0f1420;
  --bg-tertiary: #141824;
  
  --text-primary: #e9ecff;
  --text-secondary: #c8ccff;
  --text-tertiary: #9aa0c7;
  --text-muted: #6b7199;
  
  --accent-primary: #7c83ff;
  --accent-secondary: #8d6cff;
  --accent-tertiary: #9f7eff;
  
  --success: #22c55e;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;

  --surface: linear-gradient(135deg, rgba(255,255,255,.08) 0%, rgba(255,255,255,.04) 100%);
  --surface-elevated: linear-gradient(135deg, rgba(255,255,255,.12) 0%, rgba(255,255,255,.06) 100%);
}

/* -------- Premium Vibe Palettes -------- */

/* Cool, deep studio night */
body[data-vibe="moon"] {
  --bg-primary: #070b16;
  --bg-secondary: #0b1020;
  --bg-tertiary: #111728;
  --accent-primary: #7c83ff;
  --accent-secondary: #5ea8ff;
  --accent-tertiary: #8fa2ff;
  --text-primary: #e9ecff;
  --text-secondary: #cfd4ff;
  --text-tertiary: #a6acd6;
}

/* Soft pink sunrise / lo-fi morning */
body[data-vibe="dawn"] {
  --bg-primary: #190d13;
  --bg-secondary: #21131a;
  --bg-tertiary: #2a1822;
  --accent-primary: #ff8fb1;
  --accent-secondary: #ffb385;
  --accent-tertiary: #ffd4a8;
  --text-primary: #fff4f8;
  --text-secondary: #ffdfe9;
  --text-tertiary: #f2cbd8;
}

/* Cosmic purples & cyan sparks */
body[data-vibe="nebula"] {
  --bg-primary: #060816;
  --bg-secondary: #0c081d;
  --bg-tertiary: #150f26;
  --accent-primary: #9a6bff;
  --accent-secondary: #33d1ff;
  --accent-tertiary: #66e0ff;
  --text-primary: #eaf5ff;
  --text-secondary: #cfe7ff;
  --text-tertiary: #a6c9e6;
}

/* Mossy forest synth den */
body[data-vibe="forest"] {
  --bg-primary: #04100d;
  --bg-secondary: #071716;
  --bg-tertiary: #0b1f1f;
  --accent-primary: #5de6a4;
  --accent-secondary: #86f7c1;
  --accent-tertiary: #a0ffd0;
  --text-primary: #e7fff5;
  --text-secondary: #c9ffe9;
  --text-tertiary: #a1d4c2;
}

/* Golden-hour studio glow */
body[data-vibe="sunset"] {
  --bg-primary: #1a0e0f;
  --bg-secondary: #221215;
  --bg-tertiary: #2b171b;
  --accent-primary: #ff7a59;
  --accent-secondary: #ffb86b;
  --accent-tertiary: #ffd699;
  --text-primary: #fff1eb;
  --text-secondary: #ffd9c9;
  --text-tertiary: #ffc6ae;
}

/* --- NEW VIBES --- */

/* Deep ocean / underwater club */
body[data-vibe="ocean"] {
  --bg-primary: #040b12;
  --bg-secondary: #05121c;
  --bg-tertiary: #071a25;
  --accent-primary: #42c5ff;
  --accent-secondary: #2ee6d6;
  --accent-tertiary: #6af5ff;
  --text-primary: #e5f7ff;
  --text-secondary: #c8eaff;
  --text-tertiary: #9dbed4;
}

/* Charcoal & lava â€“ late-night rock / metal */
body[data-vibe="ember"] {
  --bg-primary: #100607;
  --bg-secondary: #18090b;
  --bg-tertiary: #210e12;
  --accent-primary: #ff5540;
  --accent-secondary: #ff9140;
  --accent-tertiary: #ffb36b;
  --text-primary: #ffeceb;
  --text-secondary: #ffd1ca;
  --text-tertiary: #f2a89a;
}

/* Northern lights â€“ dreamy & floaty */
body[data-vibe="aurora"] {
  --bg-primary: #040b14;
  --bg-secondary: #04111b;
  --bg-tertiary: #061a24;
  --accent-primary: #68ffb5;
  --accent-secondary: #7fe0ff;
  --accent-tertiary: #d597ff;
  --text-primary: #eafff7;
  --text-secondary: #c8f7eb;
  --text-tertiary: #9fd5c7;
}

/* Neon cyber/synthwave */
body[data-vibe="cyber"] {
  --bg-primary: #070812;
  --bg-secondary: #0a0b18;
  --bg-tertiary: #101322;
  --accent-primary: #ff64c2;
  --accent-secondary: #42f5ff;
  --accent-tertiary: #ffe35b;
  --text-primary: #f9efff;
  --text-secondary: #e2d4ff;
  --text-tertiary: #b6a5e6;
}

/* Desert night / warm neutral â€œfocusâ€ mode */
body[data-vibe="sandstorm"] {
  --bg-primary: #120f0a;
  --bg-secondary: #18140d;
  --bg-tertiary: #211a10;
  --accent-primary: #f7c979;
  --accent-secondary: #ffdf9b;
  --accent-tertiary: #ffe9b8;
  --text-primary: #fff7e8;
  --text-secondary: #f2ddbc;
  --text-tertiary: #c9b38e;
}

/* -------- Splash Screen -------- */
#splashOverlay {
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-6);
  background:
    radial-gradient(circle at top, rgba(148, 163, 253, 0.3), transparent 60%),
    radial-gradient(circle at bottom, rgba(45, 212, 191, 0.25), transparent 60%),
    rgba(3, 7, 18, 0.95);
  backdrop-filter: blur(10px);
}

#splashOverlay.hidden {
  display: none;
}

#splashOverlay .splash-inner {
  background: var(--surface-elevated);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  border: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-2xl);
  max-width: 420px;
  width: 100%;
  text-align: center;
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
}

#splashOverlay .splash-logo {
  font-size: var(--text-2xl);
  font-weight: 900;
  margin-bottom: var(--space-4);
  letter-spacing: 0.08em;
  text-transform: uppercase;
  background: linear-gradient(135deg, #a5b4fc, #f97316);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#splashOverlay .splash-message {
  font-size: var(--text-base);
  color: var(--text-primary);
  margin-bottom: var(--space-4);
}

#splashOverlay .splash-progress {
  width: 100%;
  height: 0.5rem;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.85);
  border: 1px solid var(--glass-border);
  overflow: hidden;
  margin-bottom: var(--space-3);
}

#splashOverlay .splash-progress-bar {
  height: 100%;
  width: 0%;
  border-radius: inherit;
  background: linear-gradient(90deg, #22d3ee, #a855f7, #f97316);
  transition: width 220ms var(--ease-smooth);
}

#splashOverlay .splash-sub {
  font-size: var(--text-xs);
  color: var(--text-muted);
  opacity: 0.85;
}

/* -------- Global Canvas -------- */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 16px;
  height: 100%;
  scroll-behavior: smooth;
}

body {
  min-height: 100%;
  font-family: var(--font-sans);
  font-size: var(--text-base);
  font-weight: 400;
  line-height: 1.6;
  color: var(--text-primary);
  background: 
    radial-gradient(ellipse 1200px 800px at 15% -5%, 
      color-mix(in oklab, var(--accent-primary) 15%, transparent), 
      transparent 65%),
    radial-gradient(ellipse 1000px 700px at 85% 105%, 
      color-mix(in oklab, var(--accent-secondary) 12%, transparent), 
      transparent 65%),
    radial-gradient(ellipse 800px 600px at 50% 50%, 
      color-mix(in oklab, var(--accent-tertiary) 6%, transparent), 
      transparent 70%),
    linear-gradient(135deg, 
      var(--bg-primary) 0%, 
      var(--bg-secondary) 50%, 
      var(--bg-tertiary) 100%);
  background-attachment: fixed;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  
  padding:
    calc(var(--space-4) + var(--inset-top))
    calc(var(--space-4) + var(--inset-right))
    calc(var(--space-4) + var(--inset-bottom))
    calc(var(--space-4) + var(--inset-left));
}

@media (display-mode: standalone) {
  body { 
    min-height: 100dvh;
    padding-top: calc(var(--space-6) + var(--inset-top));
  }
}

/* -------- App Container -------- */
.app {
  max-width: var(--container-max);
  margin: 0 auto;
  display: grid;
  gap: var(--gutter);
  padding: clamp(var(--space-4), 2vw, var(--space-8));
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--bg-secondary) 85%, transparent) 0%, 
      color-mix(in oklab, var(--bg-primary) 70%, transparent) 100%);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-2xl);
  box-shadow: 
    var(--shadow-2xl),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 -1px 0 rgba(0,0,0,.2);
  backdrop-filter: blur(32px) saturate(140%);
  position: relative;
  overflow: hidden;
  
  grid-template-columns: 1fr;
  grid-template-areas:
    "header"
    "transport"
    "main"
    "footer";
}

.app::before {
  content: '';
  position: absolute;
  inset: -50%;
  background: 
    radial-gradient(circle at 20% 30%, 
      color-mix(in oklab, var(--accent-primary) 8%, transparent), 
      transparent 40%),
    radial-gradient(circle at 80% 70%, 
      color-mix(in oklab, var(--accent-secondary) 6%, transparent), 
      transparent 40%);
  opacity: 0.6;
  animation: ambientPulse 8s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes ambientPulse {
  0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
  50% { transform: scale(1.1) rotate(5deg); opacity: 0.4; }
}

.app > * {
  position: relative;
  z-index: 1;
}

header { grid-area: header; }
.transport { grid-area: transport; }
section.section { grid-area: main; }
footer.footer { grid-area: footer; }

/* -------- Header -------- */
header {
  position: sticky;
  top: var(--space-4);
  z-index: 50;
  height: auto;
  min-height: var(--header-h);
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-4);
  align-items: center;
  padding: var(--space-4) var(--space-5);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: 
    var(--shadow-lg),
    inset 0 1px 0 rgba(255,255,255,.1);
  backdrop-filter: blur(24px) saturate(150%);
  transition: all var(--duration-base) var(--ease-smooth);
}

header:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent),
    inset 0 1px 0 rgba(255,255,255,.15);
}

.logo-section {
  display: flex;
  gap: var(--space-3);
  align-items: center;
}

.logo {
  width: clamp(48px, 6vw, 56px);
  height: clamp(48px, 6vw, 56px);
  border-radius: var(--radius-md);
  display: grid;
  place-items: center;
  font-size: var(--text-2xl);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  font-weight: 900;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  position: relative;
  overflow: hidden;
  transition: transform var(--duration-base) var(--ease-bounce);
}

.logo::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.2) 50%, transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
}

.logo:hover {
  transform: scale(1.05) rotate(5deg);
}

.logo:hover::before {
  transform: translateX(100%);
}

h1 {
  margin: 0;
  font-size: var(--text-2xl);
  font-weight: 900;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.tagline {
  font-size: var(--text-sm);
  color: var(--text-tertiary);
  font-weight: 500;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  margin-top: calc(-1 * var(--space-1));
}

/* Genre Selector */
.genre-selector {
  display: flex;
  gap: var(--space-2);
  flex-wrap: wrap;
  justify-content: center;
}

.genre-btn {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  letter-spacing: 0.01em;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.genre-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.genre-btn > span {
  position: relative;
  z-index: 1;
}

.genre-btn:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.genre-btn:hover::before {
  opacity: 0.1;
}

.genre-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  transform: translateY(-2px);
}

.genre-btn.active::before {
  opacity: 0;
}

.genre-btn:active {
  transform: translateY(0);
}

.header-actions {
  display: flex;
  gap: var(--space-2);
}

/* -------- Sidebar Navigation -------- */
.sidebar-toggle {
  position: fixed;
  top: calc(var(--space-4) + var(--inset-top));
  left: calc(var(--space-4) + var(--inset-left));
  z-index: 9995;
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  backdrop-filter: blur(12px) saturate(130%);
  color: var(--text-primary);
  font-size: var(--text-2xl);
  cursor: pointer;
  display: grid;
  place-items: center;
  box-shadow: var(--shadow-lg);
  transition: all var(--duration-base) var(--ease-smooth);
}

.sidebar-toggle:hover {
  background: var(--glass-bg-strong);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent);
  transform: scale(1.05);
}

.sidebar-toggle:active {
  transform: scale(0.95);
}

.sidebar-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  z-index: 9997;
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
}

.sidebar-backdrop.open {
  opacity: 1;
  visibility: visible;
}

.sidebar-nav {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  width: min(85vw, 380px);
  background: var(--surface-elevated);
  border-right: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-2xl);
  backdrop-filter: blur(32px) saturate(150%);
  z-index: 9998;
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  padding: calc(var(--space-20) + var(--inset-top)) var(--space-4) calc(var(--space-4) + var(--inset-bottom)) var(--space-4);
}

.sidebar-nav.open {
  transform: translateX(0);
}

.sidebar-section {
  margin-bottom: var(--space-8);
}

.sidebar-section-title {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 2px solid var(--glass-border);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.sidebar-tabs {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.sidebar-tab {
  padding: var(--space-4) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-base);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  text-align: left;
  display: flex;
  align-items: center;
  gap: var(--space-3);
  border: 1px solid transparent;
}

.sidebar-tab:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: translateX(4px);
}

.sidebar-tab.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 35%, transparent);
  transform: translateX(8px);
}

.sidebar-presets {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-3);
}

.sidebar-preset {
  padding: var(--space-4);
  border-radius: var(--radius-md);
  cursor: pointer;
  text-align: center;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.sidebar-preset::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.sidebar-preset > * {
  position: relative;
  z-index: 1;
}

.sidebar-preset:hover {
  transform: translateY(-2px);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  box-shadow: var(--shadow-md);
}

.sidebar-preset:hover::before {
  opacity: 0.08;
}

.sidebar-preset-icon {
  font-size: var(--text-3xl);
  line-height: 1;
}

.sidebar-preset-name {
  font-size: var(--text-sm);
  color: var(--text-secondary);
  transition: color var(--duration-base) var(--ease-smooth);
}

.sidebar-preset:hover .sidebar-preset-name {
  color: var(--text-primary);
}

/* -------- Transport Bar -------- */
.transport {
  position: sticky;
  top: calc(var(--header-h) + var(--space-4) + var(--space-2));
  z-index: 48;
  padding: var(--space-5) var(--space-6);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: 
    var(--shadow-lg),
    inset 0 1px 0 rgba(255,255,255,.08);
  backdrop-filter: blur(24px) saturate(140%);
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-6);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
}

.transport:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 12%, transparent),
    inset 0 1px 0 rgba(255,255,255,.12);
}

.transport-controls {
  display: flex;
  gap: var(--space-2);
  align-items: center;
  flex-wrap: wrap;
}

.progress-area {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  min-width: 0;
  flex: 1;
}

.time-info {
  display: flex;
  gap: var(--space-3);
  justify-content: space-between;
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-sm);
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
}

.progress-bar {
  height: 14px;
  border-radius: var(--radius-full);
  overflow: hidden;
  background: 
    linear-gradient(90deg, 
      rgba(255,255,255,.06) 0%, 
      rgba(255,255,255,.08) 50%, 
      rgba(255,255,255,.06) 100%);
  border: 1px solid rgba(255,255,255,.1);
  box-shadow: var(--shadow-inner);
  position: relative;
}

.progress-bar::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    90deg,
    transparent 0px,
    transparent 4px,
    rgba(255,255,255,.03) 4px,
    rgba(255,255,255,.03) 8px
  );
  pointer-events: none;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
  width: 0%;
  transition: width 120ms linear;
  box-shadow: 
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 0 0 1px rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.progress-fill::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255,255,255,.3) 50%, 
    transparent 100%);
  animation: progressShimmer 2s linear infinite;
}

@keyframes progressShimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.transport-params {
  display: grid;
  grid-auto-flow: column;
  gap: var(--space-4);
  align-items: center;
}

/* -------- Button System -------- */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  letter-spacing: 0.01em;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  white-space: nowrap;
  text-decoration: none;
  outline: none;
  position: relative;
  overflow: hidden;
  transform: translateY(0);
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.15) 50%, transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
}

.btn:hover::before {
  transform: translateX(100%);
}

.btn-sm {
  padding: var(--space-2) var(--space-4);
  font-size: var(--text-xs);
  border-radius: var(--radius-sm);
}

.btn:active {
  transform: translateY(1px) scale(0.98);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

.btn:focus-visible {
  box-shadow: 
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.2);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent),
    inset 0 1px 0 rgba(255,255,255,.25);
}

.btn-secondary {
  background: var(--surface);
  color: var(--text-primary);
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-sm);
}

.btn-secondary:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  background: var(--surface-elevated);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn-ghost {
  background: transparent;
  color: var(--text-secondary);
  border: 1px solid transparent;
}

.btn-ghost:hover {
  background: var(--glass-bg-strong);
  border-color: var(--glass-border);
  color: var(--text-primary);
}

.btn-success {
  background: linear-gradient(135deg, var(--success), color-mix(in oklab, var(--success) 70%, #ffffff));
  color: #042013;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--success) 35%, transparent);
}

.btn-success:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--success) 30%, transparent);
}

#generateSongBtn {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.05); opacity: 0.9; }
}

/* -------- Sections & Panels -------- */
.section {
  display: none;
}

.section.active {
  display: grid;
  gap: var(--gutter);
  margin-top: var(--space-2);
  animation: sectionFadeIn var(--duration-slow) var(--ease-smooth) both;
}

@keyframes sectionFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.panel {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: var(--space-6);
  box-shadow: 
    var(--shadow-md),
    inset 0 1px 0 rgba(255,255,255,.04);
  position: relative;
  overflow: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
}

.panel:hover::before {
  opacity: 0.6;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 1px solid var(--glass-border);
  flex-wrap: wrap;
  gap: var(--space-3);
}

.panel-title {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: var(--space-3);
  letter-spacing: -0.01em;
}

/* -------- Input Controls -------- */
.param-control {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.param-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  color: var(--text-secondary);
  font-weight: 600;
  font-size: var(--text-sm);
}

.param-value {
  color: var(--text-primary);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  padding: var(--space-1) var(--space-2);
  background: var(--glass-bg);
  border-radius: var(--radius-xs);
}

input[type="range"] {
  width: 100%;
  height: 12px;
  border-radius: var(--radius-full);
  appearance: none;
  -webkit-appearance: none;
  cursor: pointer;
  background: 
    linear-gradient(90deg, 
      rgba(255,255,255,.06) 0%, 
      rgba(255,255,255,.08) 50%, 
      rgba(255,255,255,.06) 100%);
  border: 1px solid rgba(255,255,255,.1);
  box-shadow: var(--shadow-inner);
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

input[type="range"]:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, rgba(255,255,255,.1));
}

input[type="range"]:focus-visible {
  box-shadow: 
    var(--shadow-inner),
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.3);
  border: 2px solid rgba(255,255,255,.4);
  cursor: grab;
  transition: all var(--duration-fast) var(--ease-smooth);
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.1);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.4);
}

input[type="range"]::-webkit-slider-thumb:active {
  cursor: grabbing;
  transform: scale(0.95);
}

input[type="range"]::-moz-range-thumb {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.3);
  border: 2px solid rgba(255,255,255,.4);
  cursor: grab;
  transition: all var(--duration-fast) var(--ease-smooth);
}

input[type="range"]::-moz-range-thumb:hover {
  transform: scale(1.1);
}

input[type="range"]::-moz-range-thumb:active {
  cursor: grabbing;
  transform: scale(0.95);
}

/* Text and number inputs - use text cursor */
input[type="text"],
input[type="email"],
input[type="number"] {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: text; /* Changed from pointer to text */
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

/* Select dropdown - keep pointer cursor */
select {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: pointer; /* Pointer is correct for dropdowns */
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="number"]:focus,
select:focus {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
  background: var(--glass-bg-strong);
  box-shadow: 
    var(--shadow-sm),
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

input[type="text"]::placeholder {
  color: var(--text-muted);
  font-weight: 500;
}

select {
  background-image: 
    linear-gradient(45deg, transparent 50%, var(--text-tertiary) 50%),
    linear-gradient(135deg, var(--text-tertiary) 50%, transparent 50%);
  background-position: 
    calc(100% - 16px) calc(50% - 2px),
    calc(100% - 11px) calc(50% - 2px);
  background-size: 5px 5px, 5px 5px;
  background-repeat: no-repeat;
  padding-right: var(--space-8);
  cursor: pointer;
}

/* -------- Chips & Tags -------- */
.chips {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.chip {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  cursor: pointer;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-sm);
  transition: all var(--duration-fast) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.chip::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.chip > * {
  position: relative;
  z-index: 1;
}

.chip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.chip:hover::before {
  opacity: 0.1;
}

.chip.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.chip.active::before {
  opacity: 0;
}

/* -------- Preset Grid -------- */
.preset-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: var(--space-4);
}

.preset {
  padding: var(--space-5);
  border-radius: var(--radius-md);
  cursor: pointer;
  text-align: center;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.preset::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.preset > * {
  position: relative;
  z-index: 1;
}

.preset:hover {
  transform: translateY(-4px);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

.preset:hover::before {
  opacity: 0.08;
}

.preset:active {
  transform: translateY(-2px);
}

.preset-icon {
  font-size: var(--text-3xl);
  line-height: 1;
  filter: drop-shadow(0 2px 8px rgba(0,0,0,.3));
}

.preset-name {
  font-size: var(--text-sm);
  color: var(--text-secondary);
  transition: color var(--duration-base) var(--ease-smooth);
}

.preset:hover .preset-name {
  color: var(--text-primary);
}

.preset.active {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.25);
  transform: scale(1.03);
}

.preset.active .preset-icon {
  filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.4));
}

/* -------- Visualizer -------- */
.visualizer {
  height: clamp(160px, 20vh, 220px);
  border-radius: var(--radius-lg);
  position: relative;
  background:
    linear-gradient(135deg, 
      color-mix(in oklab, var(--accent-primary) 10%, transparent), 
      color-mix(in oklab, var(--accent-secondary) 8%, transparent)),
    linear-gradient(180deg, rgba(0,0,0,.2), transparent 70%);
  border: 1px solid var(--glass-border-strong);
  overflow: hidden;
  box-shadow: 
    var(--shadow-md),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 0 0 1px rgba(255,255,255,.03);
}

.visualizer::before {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    repeating-linear-gradient(
      0deg,
      transparent 0px,
      rgba(255,255,255,.01) 1px,
      transparent 2px,
      transparent 20px
    );
  pointer-events: none;
  z-index: 1;
}

.viz-bar {
  position: absolute;
  bottom: 0;
  width: 5px;
  border-radius: 3px 3px 0 0;
  opacity: 0.9;
  background: linear-gradient(
    to top, 
    var(--accent-primary) 0%,
    var(--accent-secondary) 50%,
    var(--accent-tertiary) 100%
  );
  transition: height 80ms ease-out;
  will-change: height;
  box-shadow: 
    0 -4px 12px color-mix(in oklab, var(--accent-primary) 30%, transparent),
    inset 0 0 0 1px rgba(255,255,255,.15);
  filter: brightness(1.1);
}

.viz-overlay {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  background: 
    linear-gradient(180deg, 
      color-mix(in oklab, var(--bg-primary) 40%, transparent), 
      color-mix(in oklab, var(--bg-secondary) 50%, transparent));
  backdrop-filter: blur(4px);
  font-weight: 800;
  font-size: var(--text-lg);
  color: var(--text-tertiary);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  pointer-events: none;
  z-index: 2;
}

/* -------- Sequencer Grid -------- */
.sequencer {
  overflow-x: auto;
  overflow-y: visible;
  scrollbar-width: thin;
  padding-bottom: var(--space-2);
}

.seq-grid {
  display: grid;
  gap: var(--space-3);
  min-width: 900px;
  position: relative;
}

.seq-grid::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: var(--radius-md);
  background:
    repeating-linear-gradient(
      to right,
      transparent 0,
      transparent calc(100% / 16 - 1px),
      rgba(255,255,255,.04) calc(100% / 16 - 1px),
      rgba(255,255,255,.04) calc(100% / 16)
    );
  pointer-events: none;
  z-index: 0;
}

.seq-row {
  display: grid;
  grid-template-columns: 180px repeat(16, 1fr);
  gap: var(--space-2);
  align-items: center;
  position: relative;
  z-index: 1;
}

.seq-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-3) var(--space-4);
  background: var(--surface);
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  font-size: var(--text-sm);
  transition: all var(--duration-base) var(--ease-smooth);
}

.seq-icon[data-action="play"] {
  display: none;
}

.seq-label:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
  background: var(--surface-elevated);
}

.seq-icons {
  display: flex;
  gap: var(--space-1);
}

.seq-icon {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-xs);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.seq-icon:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: scale(1.05);
}

.seq-icon.active {
  background: var(--error);
  color: #fff;
  box-shadow: var(--shadow-sm);
}

.step {
  aspect-ratio: 1 / 1;
  min-height: 48px;
  width: 100%;
  border-radius: var(--radius-md);
  cursor: pointer;
  background: 
    linear-gradient(135deg, 
      rgba(255,255,255,.06), 
      rgba(255,255,255,.04));
  border: 1px solid var(--glass-border);
  position: relative;
  display: grid;
  place-items: center;
  transition: all var(--duration-fast) var(--ease-smooth);
  overflow: hidden;
}

.step::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.step:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.step:hover::before {
  opacity: 0.1;
}

.step:active {
  transform: translateY(0) scale(0.97);
}

.step.active {
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--accent-primary) 75%, transparent), 
      color-mix(in oklab, var(--accent-secondary) 80%, transparent));
  border-color: color-mix(in oklab, var(--accent-primary) 70%, transparent);
  box-shadow: 
    var(--shadow-sm),
    0 0 16px color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.2);
}

.step.active::before {
  opacity: 0;
}

.step.playing {
  animation: stepPulse 280ms ease-out;
  box-shadow: 
    var(--shadow-md),
    0 0 28px var(--warning),
    0 0 48px color-mix(in oklab, var(--warning) 25%, transparent);
  border-color: var(--warning);
}

@keyframes stepPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.12); }
}

.step-prob {
  position: absolute;
  top: var(--space-1);
  right: var(--space-1);
  font-size: var(--text-xs);
  background: rgba(0,0,0,.6);
  padding: 2px var(--space-2);
  border-radius: var(--radius-xs);
  color: #fff;
  font-weight: 800;
  pointer-events: none;
  z-index: 2;
  font-family: var(--font-mono);
  backdrop-filter: blur(4px);
}

.step-vel {
  position: absolute;
  bottom: var(--space-1);
  left: var(--space-1);
  right: var(--space-1);
  height: 6px;
  background: rgba(255,255,255,.15);
  border-radius: var(--radius-full);
  overflow: hidden;
  z-index: 2;
}

.step-vel-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0.95;
  transition: width 200ms var(--ease-smooth);
  box-shadow: 0 0 8px color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

.playhead {
  position: sticky;
  left: 0;
  top: 0;
  height: 100%;
  width: 0;
  pointer-events: none;
  z-index: 10;
}

.playhead::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  border-radius: var(--radius-xs);
  background: linear-gradient(
    to bottom,
    var(--warning),
    color-mix(in oklab, var(--warning) 20%, transparent)
  );
  box-shadow: 
    0 0 16px color-mix(in oklab, var(--warning) 50%, transparent),
    0 0 32px color-mix(in oklab, var(--warning) 25%, transparent);
  transform: translateX(-2px);
}

/* -------- Mixer Channels -------- */
#mixerGrid {
  display: grid;
  gap: var(--space-4);
  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
}

.mixer-channel {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  transition: all var(--duration-base) var(--ease-smooth);
}

.mixer-channel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.channel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: var(--space-2);
  border-bottom: 1px solid var(--glass-border);
}

.channel-name {
  font-weight: 800;
  font-size: var(--text-sm);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.channel-btns {
  display: flex;
  gap: var(--space-1);
}

.channel-btn {
  width: 34px;
  height: 34px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  font-weight: 800;
  font-size: var(--text-xs);
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.channel-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: scale(1.05);
}

.channel-btn.active {
  color: #fff;
}

.channel-btn.mute.active {
  background: var(--error);
  box-shadow: var(--shadow-sm);
}

.channel-btn.solo.active {
  background: var(--warning);
  box-shadow: var(--shadow-sm);
}

/* -------- FX Units -------- */
#fxGrid {
  display: grid;
  gap: var(--space-4);
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
}

.fx-unit {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: var(--space-5);
  box-shadow: var(--shadow-md);
  transition: all var(--duration-base) var(--ease-smooth);
}

.fx-unit:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.fx-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 1px solid var(--glass-border);
}

.fx-name {
  font-weight: 800;
  font-size: var(--text-base);
  color: var(--text-primary);
}

.fx-toggle {
  width: 60px;
  height: 32px;
  border-radius: var(--radius-full);
  cursor: pointer;
  background: color-mix(in oklab, var(--bg-secondary) 60%, transparent);
  border: 2px solid var(--glass-border);
  position: relative;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-inner);
}

.fx-toggle::after {
  content: '';
  position: absolute;
  left: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: var(--text-muted);
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
}

.fx-toggle:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
}

.fx-toggle.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  border-color: transparent;
  box-shadow: 
    var(--shadow-sm),
    0 0 16px color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.fx-toggle.active::after {
  left: calc(100% - 26px);
  background: var(--bg-primary);
}

/* -------- Footer -------- */
.footer {
  padding: var(--space-5) var(--space-6);
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  text-align: center;
  color: var(--text-secondary);
  font-size: var(--text-sm);
  line-height: 1.8;
  box-shadow: var(--shadow-sm);
}

.footer strong {
  color: var(--text-primary);
  font-weight: 800;
}

kbd {
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  padding: var(--space-1) var(--space-2);
  border-radius: var(--radius-xs);
  font-weight: 700;
  font-size: var(--text-xs);
  color: var(--text-primary);
  font-family: var(--font-mono);
  box-shadow: 
    var(--shadow-xs),
    inset 0 -1px 0 rgba(0,0,0,.2);
}

/* -------- Grid System -------- */
.grid {
  display: grid;
  gap: var(--space-4);
}

.grid-2 {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

.grid-3 {
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}

.grid-4 {
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}

.grid-5 {
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
}

/* -------- Flex Utilities -------- */
.flex {
  display: flex;
  gap: var(--space-3);
  align-items: center;
  flex-wrap: wrap;
}

.flex-col {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

/* -------- Spacing -------- */
.mb-2 { margin-bottom: var(--space-2); }
.mb-3 { margin-bottom: var(--space-3); }
.mb-4 { margin-bottom: var(--space-4); }
.mt-2 { margin-top: var(--space-2); }
.mt-3 { margin-top: var(--space-3); }
.mt-4 { margin-top: var(--space-4); }

/* -------- Badge -------- */
.badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-1) var(--space-3);
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: 800;
  letter-spacing: 0.02em;
  text-transform: uppercase;
  line-height: 1;
}

.badge-primary {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.badge-success {
  background: var(--success);
  color: #042013;
}

.badge-warning {
  background: var(--warning);
  color: #451a03;
}

.badge-error {
  background: var(--error);
  color: #fff;
}

.badge-ghost {
  background: var(--glass-bg-strong);
  color: var(--text-secondary);
  border: 1px solid var(--glass-border);
}

/* -------- Scrollbars -------- */
* {
  scrollbar-color: 
    color-mix(in oklab, var(--accent-primary) 50%, transparent) 
    transparent;
  scrollbar-width: thin;
}

*::-webkit-scrollbar {
  height: 10px;
  width: 10px;
}

*::-webkit-scrollbar-track {
  background: transparent;
}

*::-webkit-scrollbar-thumb {
  background: linear-gradient(
    135deg, 
    color-mix(in oklab, var(--accent-primary) 85%, #fff), 
    color-mix(in oklab, var(--accent-secondary) 85%, #fff)
  );
  border-radius: var(--radius-xs);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

*::-webkit-scrollbar-corner {
  background: transparent;
}

/* -------- Selection -------- */
::selection {
  background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  text-shadow: none;
}

::-moz-selection {
  background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  text-shadow: none;
}

/* -------- Loading States -------- */
.loading {
  position: relative;
  pointer-events: none;
  opacity: 0.6;
}

.loading::after {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    linear-gradient(
      90deg,
      transparent 0%,
      color-mix(in oklab, var(--accent-primary) 15%, transparent) 50%,
      transparent 100%
    );
  animation: shimmer 2s infinite;
  border-radius: inherit;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.spinner {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 4px solid var(--glass-border);
  border-top-color: var(--accent-primary);
  animation: spin 0.8s linear infinite;
  margin: var(--space-4) auto;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* -------- Toast Notifications -------- */
.toast-container {
  position: fixed;
  bottom: calc(var(--space-4) + var(--inset-bottom));
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-width: 90vw;
  width: min(400px, 90vw);
  pointer-events: none;
  align-items: center;
}

.toast {
  padding: var(--space-2) var(--space-4);
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-full);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent);
  backdrop-filter: blur(24px) saturate(150%);
  display: inline-flex;
  gap: var(--space-2);
  align-items: center;
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--text-primary);
  animation: toastSlideUp var(--duration-base) var(--ease-smooth);
  pointer-events: auto;
  position: relative;
  overflow: hidden;
  white-space: nowrap;
  max-width: 400px;
}

.toast.success {
  border-color: rgba(34, 197, 94, 0.5);
  box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
}

.toast.error {
  border-color: rgba(239, 68, 68, 0.5);
  box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
}

.toast.warning {
  border-color: rgba(245, 158, 11, 0.5);
  box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
}

.toast.info {
  border-color: rgba(59, 130, 246, 0.5);
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
}

@keyframes toastSlideUp {
  from {
    transform: translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.toast-icon {
  font-size: var(--text-base);
  line-height: 1;
}

.toast-close {
  margin-left: var(--space-2);
  width: 20px;
  height: 20px;
  border: none;
  border-radius: var(--radius-xs);
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-xs);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.toast-close:hover {
  background: rgba(255, 255, 255, 0.2);
  color: var(--text-primary);
  transform: scale(1.1);
}

/* -------- Modal/Dialog -------- */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(8px);
  z-index: 999;
  display: grid;
  place-items: center;
  padding: var(--space-4);
  animation: backdropFadeIn var(--duration-base) var(--ease-smooth);
}

@keyframes backdropFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-2xl);
  padding: var(--space-8);
  max-width: 600px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
  position: relative;
}

@keyframes modalSlideIn {
  from {
    transform: translateY(40px) scale(0.95);
    opacity: 0;
  }
  to {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-5);
  padding-bottom: var(--space-4);
  border-bottom: 1px solid var(--glass-border);
}

.modal-title {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-close {
  width: 40px;
  height: 40px;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-lg);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.modal-close:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: scale(1.05);
}

.modal-body {
  color: var(--text-secondary);
  line-height: 1.7;
}

.modal-footer {
  display: flex;
  gap: var(--space-3);
  justify-content: flex-end;
  margin-top: var(--space-6);
  padding-top: var(--space-4);
  border-top: 1px solid var(--glass-border);
}

/* -------- Dropdown Menu -------- */
.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-menu {
  position: absolute;
  top: calc(100% + var(--space-2));
  right: 0;
  min-width: 220px;
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xl);
  backdrop-filter: blur(24px) saturate(150%);
  padding: var(--space-2);
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all var(--duration-base) var(--ease-smooth);
}

.dropdown.open .dropdown-menu {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.dropdown-item {
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  cursor: pointer;
  color: var(--text-secondary);
  font-weight: 600;
  font-size: var(--text-sm);
  display: flex;
  align-items: center;
  gap: var(--space-3);
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.dropdown-item:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
}

.dropdown-item.active {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 20%, transparent),
    color-mix(in oklab, var(--accent-secondary) 15%, transparent));
  color: var(--text-primary);
  border-color: color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.dropdown-divider {
  height: 1px;
  background: var(--glass-border);
  margin: var(--space-2) 0;
}

/* -------- Tooltip -------- */
[data-tooltip] {
  position: relative;
  cursor: help;
}

[data-tooltip]::before {
  content: attr(data-tooltip);
  position: absolute;
  bottom: calc(100% + var(--space-2));
  left: 50%;
  transform: translateX(-50%) translateY(-5px);
  padding: var(--space-2) var(--space-3);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-size: var(--text-xs);
  font-weight: 600;
  white-space: nowrap;
  box-shadow: var(--shadow-lg);
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
  pointer-events: none;
  z-index: 200;
  backdrop-filter: blur(12px);
}

[data-tooltip]::after {
  content: '';
  position: absolute;
  bottom: calc(100% + var(--space-1));
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: var(--glass-border-strong);
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
  pointer-events: none;
  z-index: 200;
}

[data-tooltip]:hover::before,
[data-tooltip]:hover::after {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(0);
}

/* -------- Context Menu -------- */
.context-menu {
  position: fixed;
  min-width: 200px;
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-2xl);
  backdrop-filter: blur(24px) saturate(150%);
  padding: var(--space-2);
  z-index: 9999;
  animation: contextMenuAppear var(--duration-fast) var(--ease-smooth);
}

@keyframes contextMenuAppear {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* -------- Progress Indicator -------- */
.progress {
  height: 8px;
  background: var(--glass-bg);
  border-radius: var(--radius-full);
  overflow: hidden;
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-inner);
}

.progress-value {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
  border-radius: inherit;
  transition: width var(--duration-base) var(--ease-smooth);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

/* -------- Accordion -------- */
.accordion-item {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  margin-bottom: var(--space-3);
  transition: all var(--duration-base) var(--ease-smooth);
}

.accordion-item:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
}

.accordion-header {
  padding: var(--space-4) var(--space-5);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 700;
  color: var(--text-primary);
  transition: all var(--duration-base) var(--ease-smooth);
}

.accordion-header:hover {
  background: var(--glass-bg);
}

.accordion-icon {
  transition: transform var(--duration-base) var(--ease-smooth);
}

.accordion-item.open .accordion-icon {
  transform: rotate(180deg);
}

.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height var(--duration-slow) var(--ease-smooth);
}

.accordion-item.open .accordion-content {
  max-height: 1000px;
}

.accordion-body {
  padding: var(--space-4) var(--space-5);
  color: var(--text-secondary);
  line-height: 1.7;
}

/* -------- Pro Feature Lock -------- */
.pro-locked {
  position: relative;
  opacity: 0.65;
  pointer-events: none;
}

.pro-locked::after {
  content: "ðŸ”’ Pro Feature â€” Unlock 8-Beat Studio Pro";
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  font-weight: 600;
  font-size: 1rem;
  text-align: center;
  border-radius: var(--radius-md);
  padding: 1rem;
  pointer-events: all;
  z-index: 50;
}

body.pro .pro-locked {
  opacity: 1;
  pointer-events: auto;
}

body.pro .pro-locked::after {
  display: none;
}

.sidebar-tab.locked {
  opacity: 0.5;
  pointer-events: none;
}

#unlockProBtn {
  padding: var(--space-4) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
  color: #451a03;
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: var(--text-base);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  box-shadow: 
    var(--shadow-md),
    0 0 20px color-mix(in oklab, #f59e0b 40%, transparent);
  margin-top: var(--space-4);
}

#unlockProBtn:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    0 0 30px color-mix(in oklab, #f59e0b 50%, transparent);
}

#unlockProBtn:active {
  transform: translateY(0);
}

.sidebar-tab.locked::after {
  content: 'ðŸ”’';
  margin-left: var(--space-2);
  font-size: var(--text-sm);
}

#unlockModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(8px);
  padding: var(--space-4);
  align-items: center;
  justify-content: center;
}

#unlockModal:not(.hidden) {
  display: flex;
}

#unlockModal .pro-modal-inner {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  padding: var(--space-8);
  max-width: 500px;
  width: 100%;
  box-shadow: var(--shadow-2xl);
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
  height: auto;
  min-height: auto;
  max-height: calc(100vh - 4rem);
  align-self: center;
}

#unlockModal h2 {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  background: linear-gradient(135deg, var(--text-primary), #fbbf24);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#unlockModal p {
  color: var(--text-secondary);
  margin-bottom: var(--space-4);
  line-height: 1.6;
}

#unlockModal input {
  width: 100%;
  padding: var(--space-4);
  font-family: var(--font-mono);
  font-size: var(--text-base);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  transition: all var(--duration-base) var(--ease-smooth);
}

#unlockModal input:focus {
  outline: none;
  border-color: #fbbf24;
  box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
}

#unlockModal .modal-actions {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: var(--space-3);
  margin-top: var(--space-4);
}

#unlockModal .modal-actions > * {
  width: 100%;
}

#unlockModal .modal-actions form {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#unlockModal #confirmLicenseBtn,
#unlockModal #cancelLicenseBtn {
  width: 100%;
  justify-content: center;
}

#unlockModal .status {
  margin-top: var(--space-4);
  padding: var(--space-3);
  border-radius: var(--radius-sm);
  font-size: var(--text-sm);
  font-weight: 600;
  text-align: center;
}

#unlockModal .status:not(:empty) {
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
}

/* -------- Sample Browser -------- */
.sample-item {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
}

.sample-item:hover {
  background: var(--glass-bg-strong);
  border-color: var(--accent-primary);
  transform: translateX(4px);
}

.sample-item.active {
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
  border-color: var(--accent-primary);
}

.sample-icon {
  font-size: var(--text-2xl);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
}

.sample-info {
  flex: 1;
}

.sample-name {
  font-weight: 600;
  margin-bottom: var(--space-1);
}

.sample-meta {
  font-size: var(--text-xs);
  color: var(--text-tertiary);
}

.sample-actions {
  display: flex;
  gap: var(--space-2);
}

.sample-action-btn {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: var(--text-sm);
}

.sample-action-btn:hover {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  transform: scale(1.1);
}

/* ==================== MULTITRACK DAW STYLES ==================== */

.daw-wrapper {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 180px);
  min-height: 600px;
  background: var(--bg-primary);
  position: relative;
  overflow: hidden;
}

.daw-transport-bar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: var(--space-4);
  padding: var(--space-4) var(--space-5);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  margin-bottom: var(--space-4);
  box-shadow: var(--shadow-md);
  flex-shrink: 0;
}

.transport-section {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.transport-btn {
  width: 44px;
  height: 44px;
  border: none;
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  color: var(--text-primary);
  font-size: var(--text-xl);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.transport-btn:hover {
  background: var(--glass-bg-strong);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.transport-btn:active {
  transform: translateY(0);
}

.transport-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-md), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.transport-display {
  padding: var(--space-2) var(--space-4);
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-base);
  color: var(--text-primary);
  min-width: 120px;
  text-align: center;
}

.daw-main-container {
  display: grid;
  grid-template-columns: 280px 1fr 320px;
  grid-template-rows: 1fr auto;
  gap: var(--space-4);
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

.daw-track-list {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  grid-row: 1 / 3;
  min-height: 70vh;
  max-height: 90vh;
}

.daw-section-header {
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  font-weight: 800;
  font-size: var(--text-sm);
  color: var(--text-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.daw-track-list-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-3);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  min-height: 0;
}

.daw-track-strip {
  padding: var(--space-4);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  background: var(--surface);
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  flex-shrink: 0;
}

.daw-track-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.daw-track-strip.selected {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 12%, var(--surface)),
    var(--surface));
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 25%, transparent);
}

.daw-track-strip.recording {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--error) 12%, var(--surface)),
    var(--surface));
  border-color: var(--error);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--error) 30%, transparent);
  animation: recordPulse 1s ease-in-out infinite;
}

@keyframes recordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.track-strip-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-2);
}

.track-strip-name {
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}

.track-strip-controls {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
}

.track-strip-btn {
  width: 32px;
  height: 32px;
  min-width: 32px;
  min-height: 32px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  font-size: var(--text-xs);
  font-weight: 800;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.track-strip-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: scale(1.05);
}

.track-strip-btn.active {
  background: var(--error);
  color: white;
  box-shadow: var(--shadow-sm);
}

.track-strip-btn.solo.active {
  background: var(--warning);
}

.track-strip-meters {
  display: flex;
  gap: var(--space-1);
  height: 40px;
  margin: var(--space-2) 0;
}

.track-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-xs);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.track-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 50ms linear;
  will-change: height;
}

.track-strip-fader {
  width: 100%;
  height: 80px;
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

.daw-timeline-container {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  min-height: 0;
  grid-row: 1;
}

.daw-timeline-container:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-timeline-toolbar {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
}

.tool-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  flex-shrink: 0;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-lg);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.tool-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.tool-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-sm);
}

.daw-ruler {
  position: relative;
  height: 48px;
  background: linear-gradient(180deg, var(--bg-secondary), var(--bg-tertiary));
  border-bottom: 2px solid var(--glass-border-strong);
  overflow: hidden;
  flex-shrink: 0;
}

.daw-ruler-markers {
  position: relative;
  height: 100%;
  width: var(--timeline-width, 100%);
  min-width: var(--timeline-width, 100%);
}

.daw-ruler-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 1px;
  background: rgba(255, 255, 255, 0.15);
}

.daw-ruler-marker.bar {
  width: 2px;
  background: rgba(255, 255, 255, 0.3);
}

.daw-ruler-label {
  position: absolute;
  top: 4px;
  left: 4px;
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  pointer-events: none;
}

.daw-playhead {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--error);
  pointer-events: none;
  z-index: 100;
  box-shadow: 0 0 12px var(--error);
}

.daw-playhead::before {
  content: '';
  position: absolute;
  top: -6px;
  left: -5px;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 8px solid var(--error);
}

.daw-loop-region {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(124, 131, 255, 0.12);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 50;
  box-shadow: inset 0 0 20px rgba(124, 131, 255, 0.15);
}

.loop-region-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 12px;
  cursor: ew-resize;
  z-index: 60;
  pointer-events: auto;
  background: rgba(124, 131, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.loop-region-handle:hover {
  background: rgba(124, 131, 255, 0.3);
}

.loop-region-handle.left {
  left: -6px;
}

.loop-region-handle.right {
  right: -6px;
}

.daw-arrangement-scroll {
  flex: 1;
  overflow: auto;
  background: var(--bg-primary);
  position: relative;
  scrollbar-width: thin;
  min-height: 0;
  cursor: grab;
}

.daw-arrangement-scroll.drag-scroll-active {
  cursor: grabbing;
}

.daw-arrangement-scroll::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

.daw-arrangement-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
}

.daw-arrangement-scroll::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 85%, #fff), 
    color-mix(in oklab, var(--accent-secondary) 85%, #fff));
  border-radius: var(--radius-xs);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.daw-arrangement-grid {
  position: relative;
  width: var(--timeline-width, 3200px);
  min-width: var(--timeline-width, 3200px);
  min-height: 100%;
  background-image: 
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      transparent 1px,
      transparent 100px),
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.08) 0px,
      rgba(255, 255, 255, 0.08) 2px,
      transparent 2px,
      transparent 400px);
}

.loop-region-highlight {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(124, 131, 255, 0.08);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 5;
  display: none;
}

.loop-region-highlight.active {
  display: block;
}

.daw-track-lane {
  position: relative;
  height: 80px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.daw-track-lane:hover {
  background: rgba(255, 255, 255, 0.02);
}

.daw-track-lane.selected {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--accent-primary) 8%, transparent),
    transparent);
}

.daw-track-lane.recording {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--error) 8%, transparent),
    transparent);
  animation: laneRecordPulse 1s ease-in-out infinite;
}

@keyframes laneRecordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

.daw-clip {
  position: absolute;
  top: 8px;
  bottom: 8px;
  border-radius: var(--radius-md);
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 60%, transparent),
    color-mix(in oklab, var(--accent-secondary) 50%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 70%, transparent);
  cursor: move;
  overflow: hidden;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
  display: flex;
  flex-direction: column;
}

.daw-clip:hover {
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-md), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  transform: translateY(-1px);
  z-index: 10;
}

.daw-clip.selected {
  border-color: var(--warning);
  box-shadow: var(--shadow-md), 0 0 16px color-mix(in oklab, var(--warning) 40%, transparent);
  z-index: 15;
}

.daw-clip.dragging {
  opacity: 0.7;
  cursor: grabbing;
  z-index: 100;
}

.clip-header {
  padding: var(--space-2) var(--space-3);
  background: rgba(0, 0, 0, 0.4);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  backdrop-filter: blur(8px);
}

.clip-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.clip-waveform {
  flex: 1;
  position: relative;
  overflow: hidden;
  padding: var(--space-1);
  background: rgba(0, 0, 0, 0.2);
}

.clip-waveform canvas {
  width: 100%;
  height: 100%;
  display: block;
  image-rendering: crisp-edges;
}

.clip-resize-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 10px;
  cursor: ew-resize;
  background: rgba(255, 255, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
  z-index: 20;
}

.clip-resize-handle.left {
  left: 0;
}

.clip-resize-handle.right {
  right: 0;
}

.clip-resize-handle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.audio-region {
  position: absolute;
  height: 64px;
  top: 8px;
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 40%, transparent),
    color-mix(in oklab, var(--accent-secondary) 30%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 60%, transparent);
  border-radius: var(--radius-md);
  cursor: move;
  overflow: visible;
  display: flex;
  flex-direction: column;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-md);
  user-select: none;
}

.audio-region:hover {
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  transform: translateY(-1px);
}

.audio-region.selected {
  border-color: var(--warning);
  box-shadow: var(--shadow-lg), 0 0 16px color-mix(in oklab, var(--warning) 40%, transparent);
}

.region-header {
  position: sticky;
  top: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-2) var(--space-3);
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(12px);
  z-index: 200;
  border-radius: var(--radius-md) var(--radius-md) 0 0;
  gap: var(--space-2);
  min-height: 32px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.region-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.region-actions {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
  z-index: 201;
}

.region-action-btn {
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  border: none;
  border-radius: var(--radius-xs);
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  cursor: pointer;
  font-size: 14px;
  display: grid;
  place-items: center;
  transition: all var(--duration-fast) var(--ease-smooth);
  padding: 0;
  backdrop-filter: blur(4px);
}

.region-action-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.15);
}

.audio-region.dragging .region-action-btn {
  pointer-events: none;
}

.audio-region:not(.dragging) .region-action-btn {
  pointer-events: auto;
}

.region-context-menu {
  position: fixed;
  min-width: 220px;
  max-width: 260px;
  padding: 4px 0;
  background: var(--surface-elevated);
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border-strong);
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7), 0 0 0 1px rgba(255, 255, 255, 0.02);
  z-index: 10000;
  backdrop-filter: blur(16px);
  font-size: var(--text-sm);
  color: var(--text-primary);
  animation: contextMenuFadeIn 0.12s var(--ease-smooth);
}

.region-context-item {
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  transition: background var(--duration-fast) var(--ease-smooth);
}

.region-context-item:hover {
  background: color-mix(in oklab, var(--accent-primary) 12%, transparent);
}

.region-context-item.danger {
  color: #fecaca;
}

.region-context-item.danger:hover {
  background: color-mix(in oklab, #ef4444 18%, transparent);
  color: #fee2e2;
}

@keyframes contextMenuFadeIn {
  from {
    opacity: 0;
    transform: translateY(-4px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.daw-inspector {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  min-height: 0;
  grid-row: 1 / 3;
}

.daw-inspector:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-inspector-tabs {
  display: flex;
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  padding: var(--space-2);
  gap: var(--space-2);
  overflow-x: auto;
  scrollbar-width: thin;
}

.inspector-tab {
  flex: 1;
  padding: var(--space-3);
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  background: transparent;
  color: var(--text-tertiary);
  font-weight: 700;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  white-space: nowrap;
}

.inspector-tab:hover {
  color: var(--text-primary);
  background: var(--glass-bg-strong);
  border-color: var(--glass-border);
}

.inspector-tab.active {
  color: var(--bg-primary);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  border-color: transparent;
  box-shadow: var(--shadow-sm);
}

.daw-inspector-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-5);
  min-height: 0;
}

.inspector-section {
  margin-bottom: var(--space-6);
  padding: var(--space-4);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
}

.inspector-section:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
}

.inspector-section-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 2px solid var(--glass-border);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.inspector-param {
  margin-bottom: var(--space-3);
}

.inspector-param-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  font-weight: 600;
}

.inspector-param-value {
  font-family: var(--font-mono);
  font-weight: 700;
  color: var(--text-primary);
}

.inspector-param input[type="range"] {
  width: 100%;
}

.inspector-param select,
.inspector-param input[type="text"],
.inspector-param input[type="number"] {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-size: var(--text-sm);
}

.daw-master-strip {
  padding: var(--space-4);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: var(--space-4);
  align-items: center;
  grid-row: 2;
}

.daw-master-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
  box-shadow: var(--shadow-lg);
}

.master-strip-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.daw-meters {
  display: flex;
  gap: var(--space-2);
  height: 100px;
}

.daw-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.6);
  border-radius: var(--radius-sm);
  position: relative;
  overflow: hidden;
  border: 1px solid var(--glass-border);
  min-width: 24px;
}

.daw-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 30ms linear;
  box-shadow: 0 0 10px currentColor;
  will-change: height;
}

#masterFader {
  width: 100%;
  height: 100px;
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

.daw-fader-label {
  text-align: center;
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
}

.track-fx-panel {
  margin-top: var(--space-2);
  padding: var(--space-3);
  border-radius: var(--radius-md);
  border: 1px dashed var(--glass-border);
  background: color-mix(in oklab, var(--surface) 70%, rgba(148, 163, 184, 0.12));
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.track-fx-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: var(--text-xs);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-secondary);
}

.fx-chain-mini {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  flex-wrap: wrap;
}

.fx-slots-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.fx-chip {
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.5);
  background: rgba(15, 23, 42, 0.9);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--text-primary);
}

.fx-chip.disabled {
  opacity: 0.5;
}

.fx-chain-panel {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-height: 50vh;
  background: #2b2b2b;
  border-top: 2px solid #3a3a3a;
  box-shadow: var(--shadow-2xl);
  backdrop-filter: none;
  z-index: 9500;
  display: none;
  flex-direction: column;
  overflow: visible;
  color: #f0f0f0;
}

.fx-chain-panel.open {
  display: flex;
}

.fx-chain-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-4) var(--space-5);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  position: relative;
}

.fx-add-menu {
  position: absolute;
  top: 100%;
  right: var(--space-4);
  margin-top: var(--space-2);
  bottom: auto;
  z-index: 10;
  
  min-width: 220px;
  max-height: 260px;
  overflow-y: auto;
  
  background: var(--surface-elevated);
  border-radius: var(--radius-lg);
  border: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-xl);
  padding: var(--space-3);
}

.fx-add-menu h4 {
  font-size: var(--text-xs);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-tertiary);
  margin-bottom: var(--space-2);
}

.fx-add-menu button {
  width: 100%;
  text-align: left;
  margin-bottom: var(--space-1);
}
.fx-add-menu button:last-child {
  margin-bottom: 0;
}

.fx-chain-body {
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.fx-add-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  flex-wrap: wrap;
  padding: var(--space-3);
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
}

.fx-add-label {
  font-size: var(--text-sm);
  font-weight: 600;
  color: var(--text-secondary);
}

.fx-add-list {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.fx-pill {
  padding: var(--space-1) var(--space-3);
  border-radius: var(--radius-full);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg-strong);
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: var(--space-1);
  transition: all var(--duration-fast) var(--ease-smooth);
}

.fx-pill:hover,
.fx-pill:focus-visible {
  border-color: var(--accent-primary);
  color: var(--text-primary);
  background: color-mix(in oklab, var(--accent-primary) 12%, var(--glass-bg-strong));
  box-shadow: var(--shadow-sm);
}

.fx-chain-slots {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-height: 220px;
  overflow-y: auto;
}

.track-meters {
  display: flex;
  align-items: center;
  gap: 4px;
  height: 24px;
}

.track-meter {
  position: relative;
  flex: 1;
  height: 100%;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.9);
  overflow: hidden;
  border: 1px solid rgba(30, 64, 175, 0.7);
}

.track-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 0;
  background: linear-gradient(180deg, #22c55e, #f97316 60%, #ef4444 100%);
  transform-origin: bottom;
  transition: height 0.06s linear;
}

.daw-fab {
  position: fixed;
  bottom: calc(1.5rem + env(safe-area-inset-bottom));
  right: calc(1.5rem + env(safe-area-inset-right));
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  font-size: var(--text-2xl);
  border: none;
  box-shadow: var(--shadow-lg), var(--glow-md) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  z-index: 999;
  cursor: pointer;
  display: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

.daw-fab:hover {
  transform: scale(1.05) rotate(90deg);
  box-shadow: var(--shadow-xl), var(--glow-lg) color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

.daw-fab:active {
  transform: scale(0.95);
}

.song-builder-status {
  margin-top: 4px;
  font-size: 0.8rem;
  min-height: 1em;
  color: var(--text-muted);
}

.song-builder-status.active {
  color: var(--accent, #7dd3fc);
}

.song-builder-status .dot {
  display: inline-block;
  width: 0.4em;
  height: 0.4em;
  border-radius: 999px;
  margin-right: 0.4em;
  background: currentColor;
  animation: sb-pulse 0.9s ease-in-out infinite;
}

@keyframes sb-pulse {
  0%   { transform: scale(0.9); opacity: 0.4; }
  50%  { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(0.9); opacity: 0.4; }
}

/* ==================== RESPONSIVE BREAKPOINTS ==================== */

/* TABLET: 1024px - 768px */
@media (max-width: 1024px) {
  :root {
    --space-4: 0.875rem;
    --space-5: 1rem;
    --space-6: 1.25rem;
    --space-8: 1.5rem;
  }
  
  body {
    padding: var(--space-3);
  }
  
  .app {
    padding: clamp(var(--space-3), 1.5vw, var(--space-6));
    gap: var(--space-4);
  }
  
  header {
    grid-template-columns: auto 1fr;
    gap: var(--space-3);
    padding: var(--space-3) var(--space-4);
  }
  
  .header-actions {
    grid-column: 1 / -1;
    justify-content: center;
  }
  
  h1 {
    font-size: var(--text-xl);
  }
  
  .tagline {
    font-size: var(--text-xs);
  }
  
  .logo {
    width: 44px;
    height: 44px;
  }
  
  .genre-selector {
    justify-content: flex-start;
  }
  
  .genre-btn {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .sidebar-nav {
    width: min(90vw, 340px);
  }
  
  .sidebar-toggle {
    width: 52px;
    height: 52px;
    font-size: var(--text-xl);
  }
  
  .transport {
    grid-template-columns: 1fr;
    gap: var(--space-4);
    padding: var(--space-4);
  }
  
  .transport-controls {
    justify-content: center;
  }
  
  .transport-params {
    grid-auto-flow: row;
    gap: var(--space-3);
  }
  
  .panel {
    padding: var(--space-4);
  }
  
  .panel-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .grid-2 {
    grid-template-columns: 1fr;
  }
  
  .grid-3 {
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  }
  
  .grid-4 {
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  }
  
  .grid-5 {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  }
  
  .preset-grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: var(--space-3);
  }
  
  .seq-grid {
    min-width: 800px;
  }
  
  .seq-row {
    grid-template-columns: 150px repeat(16, 1fr);
    gap: var(--space-1);
  }
  
  .step {
    min-height: 40px;
  }
  
  #mixerGrid {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--space-3);
  }
  
  .mixer-channel {
    padding: var(--space-3);
  }
  
  #fxGrid {
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: var(--space-3);
  }
  
  .fx-unit {
    padding: var(--space-4);
  }
  
  .visualizer {
    height: clamp(140px, 18vh, 180px);
  }
  
  .sample-item {
    padding: var(--space-2);
    gap: var(--space-2);
  }
  
  .sample-icon {
    width: 40px;
    height: 40px;
    font-size: var(--text-xl);
  }
  
  .daw-main-container {
    grid-template-columns: 240px 1fr 280px;
    gap: var(--space-3);
  }
}

/* MOBILE LANDSCAPE: 900px - 768px */
@media (max-width: 900px) {
  :root {
    --space-4: 0.75rem;
    --space-5: 0.875rem;
    --space-6: 1rem;
    --space-8: 1.25rem;
  }
  
  body {
    padding: var(--space-2);
  }
  
  .app {
    padding: var(--space-3);
    gap: var(--space-3);
    border-radius: var(--radius-xl);
  }
  
  header {
    position: relative;
    top: 0;
    grid-template-columns: 1fr;
    gap: var(--space-2);
    padding: var(--space-3);
    min-height: auto;
  }
  
  .logo-section {
    justify-content: center;
  }
  
  .logo {
    width: 40px;
    height: 40px;
    font-size: var(--text-xl);
  }
  
  h1 {
    font-size: var(--text-lg);
  }
  
  .tagline {
    display: none;
  }
  
  .genre-selector {
    order: 3;
    width: 100%;
    justify-content: center;
  }
  
  .genre-btn {
    padding: var(--space-1) var(--space-3);
    font-size: 11px;
  }
  
  .header-actions {
    order: 2;
    justify-content: center;
    width: 100%;
  }
  
  .sidebar-toggle {
    top: var(--space-3);
    left: var(--space-3);
    width: 48px;
    height: 48px;
    font-size: var(--text-lg);
  }
  
  .sidebar-nav {
    padding-top: calc(var(--space-16) + var(--inset-top));
  }
  
  .sidebar-presets {
    grid-template-columns: 1fr;
  }
  
  .transport {
    position: relative;
    top: 0;
    grid-template-columns: 1fr;
    padding: var(--space-3);
    gap: var(--space-3);
  }
  
  .transport-controls {
    justify-content: center;
    order: 1;
  }
  
  .progress-area {
    order: 2;
  }
  
  .transport-params {
    order: 3;
    grid-auto-flow: row;
    justify-items: stretch;
  }
  
  .btn {
    padding: var(--space-2) var(--space-4);
  }
  
  .btn-sm {
    padding: var(--space-1) var(--space-3);
  }
  
  .section.active {
    gap: var(--space-3);
  }
  
  .panel {
    padding: var(--space-3);
  }
  
  .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-2);
  }
  
  .panel-title {
    font-size: var(--text-base);
  }
  
  .grid,
  .grid-2,
  .grid-3,
  .grid-4,
  .grid-5 {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .preset-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-2);
  }
  
  .preset {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  .preset-icon {
    font-size: var(--text-2xl);
  }
  
  .preset-name {
    font-size: var(--text-xs);
  }
  
  .sequencer {
    padding-bottom: var(--space-1);
  }
  
  .seq-grid {
    min-width: 700px;
    gap: var(--space-2);
  }
  
  .seq-row {
    grid-template-columns: 120px repeat(16, 1fr);
  }
  
  .seq-label {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .seq-icon {
    width: 28px;
    height: 28px;
    font-size: 10px;
  }
  
  .step {
    min-height: 36px;
  }
  
  .step-prob,
  .step-vel {
    display: none;
  }
  
  #mixerGrid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-3);
  }
  
  .mixer-channel {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  #fxGrid {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .fx-unit {
    padding: var(--space-4);
  }

  .fx-add-menu {
    left: var(--space-3);
    right: var(--space-3);
    min-width: auto;
  }
  
  .visualizer {
    height: 120px;
  }
  
  .viz-bar {
    width: 4px;
  }
  
  .sample-item {
    flex-direction: row;
  }
  
  .sample-icon {
    width: 36px;
    height: 36px;
  }
  
  .sample-action-btn {
    width: 28px;
    height: 28px;
  }
  
  .chips {
    gap: var(--space-1);
  }
  
  .chip {
    padding: var(--space-1) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .modal {
    padding: var(--space-6);
    max-width: 90vw;
  }
  
  .modal-title {
    font-size: var(--text-xl);
  }
  
  .toast-container {
    width: min(360px, 85vw);
  }
  
  .footer {
    padding: var(--space-4);
    font-size: var(--text-xs);
  }
  
  /* DAW Responsive */
  .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto;
    gap: var(--space-3);
  }
  
  .daw-track-list,
  .daw-timeline-container,
  .daw-inspector {
    grid-row: auto;
    grid-column: 1;
  }

  .daw-track-list {
    min-height: 60vh;
    max-height: 80vh;
  }
  
  .daw-track-list-scroll {
    max-height: 200px;
  }
  
  .daw-timeline-container {
    min-height: 300px;
  }
  
  .daw-transport-bar {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .transport-section {
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .daw-master-strip {
    grid-template-columns: 1fr;
    gap: var(--space-3);
    text-align: center;
  }

    /* --- Center layout for mobile buttons & text --- */

  header {
    grid-template-columns: 1fr;
    text-align: center;
    justify-items: center;
  }

  .logo-section {
    justify-content: center;
  }

  .header-actions {
    justify-content: center;
  }

  .genre-selector {
    justify-content: center;
  }

  .transport {
    grid-template-columns: 1fr;
    text-align: center;
  }

  .transport-controls,
  .transport-params {
    justify-content: center;
  }

  .panel-header {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .panel-title,
  .chips,
  .preset-grid,
  .footer {
    text-align: center;
    justify-content: center;
  }

  .btn {
    justify-content: center;
  }
}

/* MOBILE PORTRAIT: 768px and below */
@media (max-width: 768px) {
  :root {
    --text-base: 0.875rem;
    --text-lg: 1rem;
    --text-xl: 1.125rem;
    --text-2xl: 1.25rem;
    --text-3xl: 1.5rem;
    
    --space-3: 0.625rem;
    --space-4: 0.75rem;
    --space-5: 0.875rem;
    --space-6: 1rem;
  }
  
  body {
    padding: var(--space-2);
  }
  
  .app {
    padding: var(--space-3);
    gap: var(--space-3);
    border-radius: var(--radius-lg);
  }
  
  header {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-2);
  }
  
  .logo {
    width: 36px;
    height: 36px;
    font-size: var(--text-lg);
  }
  
  h1 {
    font-size: var(--text-base);
  }
  
  .genre-selector {
    gap: var(--space-1);
  }
  
  .genre-btn {
    padding: 4px 8px;
    font-size: 10px;
    border-radius: var(--radius-sm);
  }
  
  .btn {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .btn-sm {
    padding: 4px 8px;
    font-size: 10px;
  }
  
  .sidebar-toggle {
    width: 44px;
    height: 44px;
    top: var(--space-2);
    left: var(--space-2);
  }
  
  .sidebar-nav {
    width: min(85vw, 320px);
    padding: calc(var(--space-12) + var(--inset-top)) var(--space-3) calc(var(--space-3) + var(--inset-bottom)) var(--space-3);
  }
  
  .sidebar-section {
    margin-bottom: var(--space-6);
  }
  
  .sidebar-section-title {
    font-size: var(--text-base);
    margin-bottom: var(--space-3);
  }
  
  .sidebar-tab {
    padding: var(--space-3) var(--space-4);
    font-size: var(--text-sm);
  }
  
  .sidebar-presets {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .sidebar-preset {
    padding: var(--space-3);
  }
  
  .transport {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  .transport-controls {
    gap: var(--space-1);
  }
  
  .transport-controls .btn {
    width: auto;
    height: auto;
    padding: var(--space-2) var(--space-4);
    border-radius: var(--radius-full);
  }
  
  .time-info {
    font-size: var(--text-xs);
  }
  
  .progress-bar {
    height: 10px;
  }
  
  .transport-params {
    gap: var(--space-2);
  }
  
  .param-control {
    gap: var(--space-1);
  }
  
  .param-label {
    font-size: var(--text-xs);
  }
  
  .param-value {
    font-size: var(--text-xs);
    padding: 2px var(--space-1);
  }
  
  input[type="range"] {
    height: 10px;
  }
  
  input[type="range"]::-webkit-slider-thumb {
    width: 18px;
    height: 18px;
  }
  
  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
  }
  
  .section.active {
    gap: var(--space-2);
    margin-top: var(--space-1);
  }
  
  .panel {
    padding: var(--space-3);
    border-radius: var(--radius-md);
  }
  
  .panel-header {
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
  }
  
  .panel-title {
    font-size: var(--text-sm);
    gap: var(--space-2);
  }
  
  .grid,
  .grid-2,
  .grid-3,
  .grid-4,
  .grid-5 {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .preset-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-2);
  }
  
  .preset {
    padding: var(--space-3);
  }
  
  .preset-icon {
    font-size: var(--text-2xl);
  }
  
  .preset-name {
    font-size: 10px;
  }
  
  .seq-grid {
    min-width: 600px;
  }
  
  .seq-row {
    grid-template-columns: 100px repeat(16, 1fr);
    gap: 4px;
  }
  
  .seq-label {
    padding: var(--space-2);
    font-size: 10px;
  }
  
  .seq-icon {
    width: 24px;
    height: 24px;
    font-size: 9px;
  }
  
  .step {
    min-height: 32px;
    border-radius: var(--radius-sm);
  }
  
  .step-prob,
  .step-vel {
    display: none;
  }
  
  #mixerGrid {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .mixer-channel {
    padding: var(--space-3);
  }
  
  .channel-header {
    padding-bottom: var(--space-1);
  }
  
  .channel-name {
    font-size: var(--text-xs);
  }
  
  .channel-btn {
    width: 30px;
    height: 30px;
    font-size: 10px;
  }
  
  #fxGrid {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .fx-unit {
    padding: var(--space-3);
  }
  
  .fx-header {
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
  }
  
  .fx-name {
    font-size: var(--text-sm);
  }
  
  .fx-toggle {
    width: 52px;
    height: 28px;
  }
  
  .fx-toggle::after {
    width: 20px;
    height: 20px;
  }
  
  .visualizer {
    height: 100px;
    border-radius: var(--radius-md);
  }
  
  .viz-bar {
    width: 3px;
  }
  
  .viz-overlay {
    font-size: var(--text-base);
  }
  
  .sample-item {
    padding: var(--space-2);
    gap: var(--space-2);
  }
  
  .sample-icon {
    width: 32px;
    height: 32px;
    font-size: var(--text-lg);
  }
  
  .sample-name {
    font-size: var(--text-xs);
  }
  
  .sample-meta {
    font-size: 10px;
  }
  
  .sample-action-btn {
    width: 28px;
    height: 28px;
    font-size: var(--text-xs);
  }
  
  .chip {
    padding: 4px 8px;
    font-size: 10px;
  }
  
  input[type="text"],
  input[type="email"],
  input[type="number"],
  select {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-sm);
  }
  
  .modal {
    padding: var(--space-4);
    border-radius: var(--radius-lg);
  }
  
  .modal-header {
    margin-bottom: var(--space-4);
    padding-bottom: var(--space-3);
  }
  
  .modal-title {
    font-size: var(--text-lg);
  }
  
  .modal-close {
    width: 36px;
    height: 36px;
  }
  
  .modal-footer {
    margin-top: var(--space-4);
    padding-top: var(--space-3);
    gap: var(--space-2);
    flex-direction: column;
  }
  
  .modal-footer .btn {
    width: 100%;
  }
  
  .dropdown-menu {
    min-width: 180px;
  }
  
  .dropdown-item {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .toast-container {
    width: min(320px, 90vw);
    bottom: calc(var(--space-3) + var(--inset-bottom));
  }
  
  .toast {
    padding: var(--space-2) var(--space-3);
    font-size: 11px;
  }
  
  .toast-icon {
    font-size: var(--text-sm);
  }
  
  .footer {
    padding: var(--space-3);
    font-size: 11px;
    line-height: 1.6;
  }
  
  kbd {
    padding: 2px 4px;
    font-size: 10px;
  }
  
  .badge {
    padding: 2px 6px;
    font-size: 9px;
  }
  
  .accordion-item {
    margin-bottom: var(--space-2);
  }
  
  .accordion-header {
    padding: var(--space-3);
    font-size: var(--text-sm);
  }
  
  .accordion-body {
    padding: var(--space-3);
    font-size: var(--text-xs);
  }
  
  #unlockModal .pro-modal-inner {
    padding: var(--space-6);
    max-width: 90vw;
  }
  
  #unlockModal h2 {
    font-size: var(--text-xl);
    margin-bottom: var(--space-3);
  }
  
  #unlockModal p {
    font-size: var(--text-sm);
    margin-bottom: var(--space-3);
  }
  
  #unlockModal input {
    padding: var(--space-3);
    font-size: var(--text-sm);
  }
  
  #unlockProBtn {
    padding: var(--space-3) var(--space-4);
    font-size: var(--text-sm);
  }
  
  .transport-btn {
    width: 48px;
    height: 48px;
    font-size: var(--text-xl);
    border-radius: var(--radius-full);
  }
  
    /* === Toolbar button fixes for mobile/tablet === */
  .tool-btn {
    width: 36px;
    height: 36px;
    min-width: 36px;
    flex-shrink: 0;
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border: 1px solid var(--bg-secondary);
    transition: background 0.2s ease, transform 0.1s ease;
  }

  .tool-btn:active {
    transform: scale(0.95);
  }

  .tool-btn svg {
    width: 18px;
    height: 18px;
  }

  .multitrack-toolbar {
    flex-wrap: wrap;
    justify-content: center;
  }

  /* === Prevent horizontal overflow on smaller screens === */
  .multitrack-wrapper {
    overflow-x: auto;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch;
  }

  /* === Responsive zoom controls === */
  .zoom-controls {
    display: flex;
    gap: var(--space-1);
    justify-content: center;
    align-items: center;
  }

  .zoom-controls button {
    flex: 0 0 36px;
    height: 36px;
    border-radius: var(--radius-sm);
  }

} /* closes @media (max-width: 768px) */

/* ==================== DAW TRANSPORT INPUT POLISH ==================== */

.daw-transport-bar input[type="number"],
.daw-transport-bar select {
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--bg-tertiary);
  color: var(--text-primary);
  font-size: var(--text-xs);
  padding: var(--space-1) var(--space-2);
  line-height: 1.2;
  min-width: 64px;
}

.daw-transport-bar input[type="number"]:focus,
.daw-transport-bar select:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-primary) 45%, transparent);
}

/* === MULTITRACK: TRACK HEADER & CONTROLS === */

/* Main track header container (left column + inline version) */
.track-header {
  padding: var(--space-3) var(--space-3);
  border-bottom: 1px solid var(--glass-border);
  background: color-mix(in oklab, var(--surface) 80%, var(--bg-secondary));
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  border-radius: var(--radius-md);
}

/* Recording / armed state tint */
.track-header.recording {
  box-shadow: var(--shadow-md),
    0 0 0 1px color-mix(in oklab, var(--error) 40%, transparent);
}

.track-header.armed:not(.recording) {
  box-shadow: var(--shadow-sm),
    0 0 0 1px color-mix(in oklab, var(--accent-secondary) 40%, transparent);
}

/* Top row: icon + editable name */
.track-header-top {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.track-icon {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-md);
  background: var(--glass-bg-strong);
  display: grid;
  place-items: center;
  font-size: var(--text-lg);
  box-shadow: var(--shadow-sm);
  flex-shrink: 0;
}

.track-name {
  flex: 1;
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  outline: none;
  border-radius: var(--radius-sm);
  padding: 2px 6px;
  border: 1px solid transparent;
  background: transparent;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.track-name:focus {
  border-color: var(--accent-primary);
  background: color-mix(in oklab, var(--surface) 85%, var(--accent-primary) 15%);
  box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

/* Track meters in header (re-use existing meter fill) */
.track-meters {
  display: flex;
  gap: var(--space-1);
  height: 28px;
  margin-top: var(--space-1);
}

.track-meter {
  flex: 1;
  background: rgba(0, 0, 0, 0.45);
  border-radius: var(--radius-xs);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

/* We already have .track-meter-fill defined, so this just uses it */

/* === Track header button grid (REC / ARM / M / S / FX / ðŸ—‘) === */

.track-controls-grid {
  margin-top: var(--space-2);
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: var(--space-2);
}

.track-mini-btn {
  width: 100%;
  min-height: 32px;
  padding: 4px 6px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.track-mini-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.track-mini-btn:active {
  transform: translateY(0) scale(0.97);
}

/* Generic "on" state */
.track-mini-btn.active {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 60%, var(--accent-secondary)),
    var(--accent-secondary));
  color: var(--bg-primary);
  border-color: color-mix(in oklab, var(--accent-primary) 60%, var(--accent-secondary));
  box-shadow: var(--shadow-sm);
}

/* Special cases so you can read state at a glance */
.track-mini-btn.rec.active {
  background: linear-gradient(135deg, var(--error), color-mix(in oklab, var(--error) 70%, #ffb0b0));
  border-color: var(--error);
}

.track-mini-btn.arm.active {
  background: linear-gradient(135deg, var(--warning), var(--accent-secondary));
  border-color: var(--warning);
}

.track-mini-btn.mute.active {
  background: color-mix(in oklab, var(--bg-tertiary) 70%, #000);
  color: color-mix(in oklab, var(--text-secondary) 60%, #aaa);
  border-color: rgba(255, 255, 255, 0.08);
}

.track-mini-btn.solo.active {
  background: linear-gradient(135deg, var(--success), var(--warning));
  color: #02040a;
}

/* FX + Delete â€“ keep them a bit more icon-y */
.track-mini-btn[data-action="fx"] {
  font-size: var(--text-sm);
}

.track-mini-btn[data-action="delete"] {
  background: rgba(255, 76, 76, 0.12);
  border-color: rgba(255, 76, 76, 0.35);
  color: color-mix(in oklab, var(--error) 70%, #fff);
}

.track-mini-btn[data-action="delete"]:hover {
  background: rgba(255, 76, 76, 0.2);
}

/* Volume / pan block under header */

.track-volume-control {
  margin-top: var(--space-2);
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.track-volume-control label {
  font-size: var(--text-xs);
  color: var(--text-tertiary);
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

.track-volume-control input[type="range"] {
  width: 100%;
}

.track-volume-value,
.track-pan-value {
  font-family: var(--font-mono);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  opacity: 0.9;
}

/* Canvas area: keep the timeline lane visually focused */
.track-canvas-area {
  background: radial-gradient(circle at top left,
      color-mix(in oklab, var(--accent-primary) 12%, transparent),
      transparent 55%);
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
  padding: var(--space-2) 0 var(--space-2) var(--space-1);
}

.track-canvas {
  position: relative;
}

/* === TIMELINE TOOLBAR: FORCE HORIZONTAL LAYOUT === */

/* Desktop + mobile: tools stay on one line, scroll if needed */
.daw-timeline-toolbar {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  flex-wrap: nowrap;        /* key: no wrapping */
  overflow-x: auto;         /* scroll instead */
  scrollbar-width: thin;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding-right: var(--space-3);
  border-right: 1px solid var(--glass-border);
  flex: 0 0 auto;           /* keep groups inline, don't squeeze */
}

.toolbar-group:last-child {
  border-right: none;
}

/* Tools themselves: nice touch targets + consistent shape */
.tool-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  min-height: 40px;
  flex-shrink: 0;
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-lg);
  display: grid;
  place-items: center;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.tool-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.tool-btn:active {
  transform: translateY(0) scale(0.96);
}

.tool-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-sm);
}

@media (max-width: 768px) {
  /* Timeline is the star on mobile */
  .daw-timeline-container {
    order: 2;
    min-height: 280px;
    border-width: 2px;
    border-color: color-mix(in oklab, var(--accent-primary) 50%, var(--glass-border));
    box-shadow:
      var(--shadow-lg),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  }

  /* Slightly tighter header to save vertical space */
  .track-header {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-1);
  }

  .track-controls-grid {
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: var(--space-1);
  }

  .track-mini-btn {
    min-height: 32px;
    font-size: 10px;
    padding: 3px 4px;
  }

  /* Toolbar: even more clearly a single row you can swipe */
  .daw-timeline-toolbar {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-1);
    justify-content: flex-start;
  }
}

/* ==========================================================================
   MULTITRACK: ACCESSIBLE MOBILE LAYOUT + INSPECTOR STYLES
   Paste this near the end of your <style> block so it overrides earlier rules
   ========================================================================== */

/* 1) Friendlier mobile layout for the multitrack tab */
@media (max-width: 900px) {
  #tab-multitrack .daw-wrapper {
    height: auto;
    min-height: 0;
  }

  #tab-multitrack .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto minmax(280px, 1fr);
    gap: var(--space-3);
  }

  #tab-multitrack .daw-track-list {
    order: 1;
    min-height: auto;
    max-height: 220px;
  }

  #tab-multitrack .daw-track-list-scroll {
    max-height: 180px;
    overflow-y: auto;
  }

  #tab-multitrack .daw-timeline-container {
    order: 2;
    min-height: 280px;
  }

  #tab-multitrack .daw-master-strip {
    order: 3;
  }

  #tab-multitrack .daw-inspector {
    order: 4;
  }
}

@media (max-width: 768px) {
  #tab-multitrack .daw-main-container {
    grid-template-rows: auto minmax(260px, 1fr);
  }

  #tab-multitrack .daw-track-list {
    max-height: 190px;
  }

  #tab-multitrack .daw-timeline-container {
    min-height: 260px;
  }

  /* Hide the master strip on very small screens â€“
     you can still access master from the mixer tab */
  #tab-multitrack .daw-master-strip {
    display: none;
  }

  /* Turn the inspector into a bottom sheet on phones */
  #tab-multitrack .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    margin: 0;
    max-height: 70vh;
    transform: translateY(100%);
    transition: transform var(--duration-base) var(--ease-smooth);
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    box-shadow: 0 -16px 40px rgba(0,0,0,.6);
    z-index: 9600;
  }

  #tab-multitrack .daw-inspector.inspector-open {
    transform: translateY(0);
  }
}

/* 4) FX chain panel: scroll instead of overlapping the footer */
.fx-chain-panel {
  max-height: min(60vh, calc(100vh - 80px));
  overflow-y: auto;
  padding-bottom: calc(var(--space-4) + var(--inset-bottom));
}

/* 2) Track header selection state (what's currently in the inspector) */
#tab-multitrack .track-header.selected {
  border-color: color-mix(in oklab, var(--accent-primary) 50%, var(--glass-border-strong));
  box-shadow:
    0 0 0 1px color-mix(in oklab, var(--accent-primary) 35%, transparent),
    0 0 0 1px rgba(15,23,42,.9),
    var(--shadow-lg);
  background:
    radial-gradient(circle at top left,
      color-mix(in oklab, var(--accent-primary) 16%, transparent),
      transparent 65%),
    var(--surface-elevated);
}

/* 3) Inspector micro layout tweaks */
.daw-inspector-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
}

#inspectorTitle {
  font-size: var(--text-sm);
  font-weight: 700;
  color: var(--text-secondary);
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.inspector-section-title {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.inspector-param-label span:first-child {
  font-weight: 600;
}

.inspector-toggle-row {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

/* ==================== MULTITRACK MOBILE SIGNATURE LAYOUT ==================== */
/* Replaces generic mobile DAW styles with purpose-built multitrack UI */

@media (max-width: 900px) {
  /* Kill the rigid grid, embrace natural flow */
  #tab-multitrack .daw-wrapper {
    height: auto;
    min-height: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    padding-bottom: calc(var(--space-8) + var(--inset-bottom));
  }

  /* Transport becomes a floating command bar */
  #tab-multitrack .daw-transport-bar {
    position: sticky;
    top: calc(var(--header-h) + var(--space-6));
    z-index: 100;
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--bg-secondary) 95%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 90%, transparent));
    backdrop-filter: blur(20px) saturate(160%);
    border: 1px solid var(--glass-border-strong);
    border-radius: var(--radius-xl);
    padding: var(--space-3) var(--space-4);
    box-shadow: 
      var(--shadow-xl),
      0 0 0 1px rgba(255,255,255,.04);
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: var(--space-3);
    align-items: center;
  }

  /* Main container: track list on top, timeline hero, inspector slides up */
  #tab-multitrack .daw-main-container {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    min-height: 0;
  }

  /* Track list: compact horizontal carousel */
  #tab-multitrack .daw-track-list {
    order: 1;
    max-height: 140px;
    border-radius: var(--radius-xl);
    overflow: hidden;
    background: var(--surface-elevated);
    border: 1px solid var(--glass-border);
  }

  #tab-multitrack .daw-track-list-scroll {
    display: flex;
    flex-direction: row;
    gap: var(--space-3);
    padding: var(--space-4);
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }

  #tab-multitrack .daw-track-list-scroll::-webkit-scrollbar {
    display: none;
  }

  #tab-multitrack .daw-track-strip {
    flex: 0 0 240px;
    scroll-snap-align: start;
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
    padding: var(--space-3);
    background: var(--surface);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    min-width: 240px;
  }

  /* Timeline becomes the visual anchor */
  #tab-multitrack .daw-timeline-container {
    order: 2;
    min-height: 420px;
    border-width: 2px;
    border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
    box-shadow:
      var(--shadow-2xl),
      var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent),
      inset 0 1px 0 rgba(255,255,255,.08);
    border-radius: var(--radius-2xl);
    overflow: hidden;
  }

  /* Master strip: simplified horizontal */
  #tab-multitrack .daw-master-strip {
    order: 3;
    grid-template-columns: 1fr auto;
    padding: var(--space-4);
  }

  /* Inspector: slide-up modal on demand */
  #tab-multitrack .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    order: 4;
    max-height: 75vh;
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
    border-bottom: none;
    box-shadow: 0 -20px 60px rgba(0,0,0,.7);
    z-index: 9600;
    transform: translateY(100%);
    transition: transform var(--duration-slow) cubic-bezier(0.32, 0.72, 0, 1);
  }

  #tab-multitrack .daw-inspector.inspector-open {
    transform: translateY(0);
  }

  /* Add pull handle */
  #tab-multitrack .daw-inspector::before {
    content: '';
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 48px;
    height: 5px;
    border-radius: 999px;
    background: var(--text-muted);
    opacity: 0.4;
  }
}

/* ==================== MOBILE TIMELINE TOOLBAR: SWIPEABLE COMMAND BAR ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-timeline-toolbar {
    position: sticky;
    top: 0;
    z-index: 10;
    padding: var(--space-3);
    background: linear-gradient(180deg,
      color-mix(in oklab, var(--bg-secondary) 96%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 92%, transparent));
    backdrop-filter: blur(16px) saturate(140%);
    border-bottom: 2px solid var(--glass-border-strong);
    display: flex;
    gap: var(--space-2);
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x proximity;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
  }

  .toolbar-group {
    display: flex;
    gap: var(--space-2);
    padding: 0 var(--space-2);
    border-right: 1px solid rgba(255,255,255,.08);
    flex-shrink: 0;
  }

  .toolbar-group:last-child {
    border-right: none;
    padding-right: var(--space-4);
  }

  .tool-btn {
    width: 48px;
    height: 48px;
    min-width: 48px;
    border-radius: var(--radius-md);
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--glass-bg-strong) 90%, transparent),
      var(--glass-bg));
    border: 1px solid var(--glass-border);
    font-size: var(--text-xl);
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
  }

  .tool-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center,
      color-mix(in oklab, var(--accent-primary) 20%, transparent),
      transparent 70%);
    opacity: 0;
    transition: opacity var(--duration-fast) var(--ease-smooth);
  }

  .tool-btn:active::before {
    opacity: 1;
  }

  .tool-btn.active {
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    border-color: transparent;
    box-shadow:
      var(--shadow-md),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    transform: scale(0.95);
  }

  /* Zoom controls: grouped pill design */
  .zoom-controls {
    display: flex;
    background: var(--glass-bg-strong);
    border-radius: var(--radius-full);
    padding: var(--space-1);
    gap: var(--space-1);
    border: 1px solid var(--glass-border);
  }

  .zoom-controls .tool-btn {
    width: 40px;
    height: 40px;
    min-width: 40px;
    border-radius: var(--radius-full);
    font-size: var(--text-lg);
  }
}

/* ==================== MOBILE TRACK CARDS: SWIPEABLE OVERVIEW ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-track-strip {
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--surface) 95%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 90%, transparent));
    border: 1px solid var(--glass-border);
    box-shadow: var(--shadow-md);
    transition: all var(--duration-base) var(--ease-smooth);
  }

  #tab-multitrack .daw-track-strip.selected {
    border-width: 2px;
    border-color: var(--accent-primary);
    box-shadow:
      var(--shadow-lg),
      0 0 0 3px color-mix(in oklab, var(--accent-primary) 20%, transparent);
    transform: scale(1.02);
  }

  #tab-multitrack .daw-track-strip.recording {
    border-color: var(--error);
    box-shadow:
      var(--shadow-lg),
      0 0 0 3px color-mix(in oklab, var(--error) 25%, transparent);
    animation: cardRecordPulse 1.2s ease-in-out infinite;
  }

  @keyframes cardRecordPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.85; }
  }

  .track-strip-header {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding-bottom: var(--space-2);
    border-bottom: 1px solid var(--glass-border);
  }

  .track-strip-name {
    flex: 1;
    font-size: var(--text-sm);
    font-weight: 800;
    color: var(--text-primary);
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .track-strip-controls {
    display: flex;
    gap: 4px;
  }

  .track-strip-btn {
    width: 36px;
    height: 36px;
    border-radius: var(--radius-sm);
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    font-size: var(--text-xs);
    font-weight: 800;
    display: grid;
    place-items: center;
    cursor: pointer;
    transition: all var(--duration-fast) var(--ease-smooth);
  }

  .track-strip-btn:active {
    transform: scale(0.9);
  }

  .track-strip-btn.active {
    background: var(--error);
    color: white;
    border-color: transparent;
    box-shadow: 0 0 12px color-mix(in oklab, var(--error) 40%, transparent);
  }

  .track-strip-btn.solo.active {
    background: var(--warning);
  }

  /* Compact meters */
  .track-strip-meters {
    display: flex;
    gap: 4px;
    height: 32px;
    margin: var(--space-2) 0;
  }

  .track-meter-bar {
    flex: 1;
    background: rgba(0,0,0,.5);
    border-radius: var(--radius-xs);
    border: 1px solid rgba(255,255,255,.06);
  }
}

/* ==================== PHONE PORTRAIT: MINIMAL CHROME, MAXIMUM CONTENT ==================== */

@media (max-width: 768px) {
  #tab-multitrack .daw-wrapper {
    gap: var(--space-3);
  }

  /* Transport: ultra-compact */
  #tab-multitrack .daw-transport-bar {
    padding: var(--space-2) var(--space-3);
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }

  .transport-section {
    justify-content: center;
  }

  .transport-btn {
    width: 52px;
    height: 52px;
    border-radius: var(--radius-full);
    font-size: var(--text-2xl);
    box-shadow: var(--shadow-lg);
  }

  .transport-display {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-sm);
  }

  /* Track list: tighter cards */
  #tab-multitrack .daw-track-list {
    max-height: 120px;
  }

  #tab-multitrack .daw-track-list-scroll {
    padding: var(--space-3);
    gap: var(--space-2);
  }

  #tab-multitrack .daw-track-strip {
    flex: 0 0 200px;
    min-width: 200px;
    padding: var(--space-2);
  }

  .track-strip-name {
    font-size: var(--text-xs);
  }

  .track-strip-btn {
    width: 32px;
    height: 32px;
    font-size: 10px;
  }

  /* Timeline: hero element with breathing room */
  #tab-multitrack .daw-timeline-container {
    min-height: 380px;
    border-radius: var(--radius-xl);
  }

  #tab-multitrack .daw-timeline-toolbar {
    padding: var(--space-2);
    gap: var(--space-1);
  }

  .tool-btn {
    width: 44px;
    height: 44px;
    min-width: 44px;
    font-size: var(--text-lg);
  }

  .zoom-controls .tool-btn {
    width: 36px;
    height: 36px;
    min-width: 36px;
  }

  /* Ruler: readable but compact */
  #tab-multitrack .daw-ruler {
    height: 40px;
  }

  #tab-multitrack .daw-ruler-label {
    font-size: 10px;
  }

  /* Arrangement: prioritize vertical scroll */
  #tab-multitrack .daw-arrangement-scroll {
    min-height: 280px;
  }

  /* Master strip: hide or ultra-minimal */
  #tab-multitrack .daw-master-strip {
    display: none; /* Access via mixer tab instead */
  }

  /* Inspector: full-screen modal feel */
  #tab-multitrack .daw-inspector {
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  #tab-multitrack .daw-inspector-content {
    padding: var(--space-4);
  }

  .inspector-section {
    padding: var(--space-3);
    margin-bottom: var(--space-3);
  }

  .inspector-param {
    margin-bottom: var(--space-2);
  }
}

/* ==================== MOBILE REGION MANIPULATION: FAT FINGERS WELCOME ==================== */

@media (max-width: 900px) {
  .audio-region {
    height: 72px;
    top: 4px;
    border-width: 2px;
    touch-action: none; /* Prevent scroll interference */
  }

  .region-header {
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    background: rgba(0,0,0,.95);
    -webkit-backdrop-filter: blur(20px);
    backdrop-filter: blur(20px);
  }

  .region-name {
    font-size: var(--text-sm);
    font-weight: 800;
  }

  .region-action-btn {
    width: 40px;
    height: 40px;
    min-width: 40px;
    min-height: 40px;
    border-radius: var(--radius-full);
    font-size: var(--text-base);
    background: rgba(255,255,255,.15);
    -webkit-backdrop-filter: blur(8px);
    backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0,0,0,.4);
  }

  .region-action-btn:active {
    transform: scale(0.88);
    box-shadow: 0 1px 4px rgba(0,0,0,.5);
  }

  /* Resize handles: bigger hit targets */
  .clip-resize-handle {
    width: 20px;
    background: linear-gradient(90deg,
      transparent,
      rgba(255,255,255,.1),
      transparent);
  }

  .clip-resize-handle.left {
    left: -10px;
  }

  .clip-resize-handle.right {
    right: -10px;
  }

  .clip-resize-handle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px;
    height: 24px;
    border-radius: 2px;
    background: rgba(255,255,255,.3);
    box-shadow: 0 0 8px rgba(0,0,0,.5);
  }
}

/* ==================== MOBILE FX CHAIN: SLIDE-UP PANEL ==================== */

@media (max-width: 900px) {
  .fx-chain-panel {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    max-height: 70vh;
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
    border-bottom: none;
    box-shadow: 0 -16px 48px rgba(0,0,0,.75);
    background: var(--surface-elevated);
    backdrop-filter: blur(32px) saturate(150%);
    z-index: 9700;
    transform: translateY(100%);
    transition: transform var(--duration-slow) cubic-bezier(0.32, 0.72, 0, 1);
  }

  .fx-chain-panel.open {
    transform: translateY(0);
  }

  /* Pull indicator */
  .fx-chain-panel::before {
    content: '';
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 48px;
    height: 5px;
    border-radius: 999px;
    background: var(--text-muted);
    opacity: 0.5;
  }

  .fx-chain-header {
    padding: var(--space-5) var(--space-4) var(--space-4);
    border-bottom: 1px solid var(--glass-border);
  }

  .fx-chain-body {
    padding: var(--space-4);
    max-height: calc(70vh - 80px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .fx-add-menu {
    position: relative;
    top: auto;
    right: auto;
    margin-top: var(--space-3);
    max-height: none;
    border: 1px solid var(--glass-border);
  }

  .fx-pill {
    padding: var(--space-2) var(--space-4);
    font-size: var(--text-sm);
    min-height: 44px;
    border-radius: var(--radius-md);
  }
}

/* ==================== MOBILE INSPECTOR: FOCUSED EDITING SURFACE ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-inspector-tabs {
    padding: var(--space-3);
    gap: var(--space-2);
    background: linear-gradient(180deg,
      var(--glass-bg-strong),
      var(--glass-bg));
    border-bottom: 2px solid var(--glass-border-strong);
  }

  .inspector-tab {
    flex: 1;
    min-width: 0;
    padding: var(--space-3);
    font-size: var(--text-sm);
    border-radius: var(--radius-md);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .inspector-tab.active {
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    color: var(--bg-primary);
    box-shadow:
      var(--shadow-md),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  }

  #tab-multitrack .daw-inspector-content {
    padding: var(--space-4);
    padding-bottom: calc(var(--space-8) + var(--inset-bottom));
  }

  .inspector-section {
    padding: var(--space-4);
    margin-bottom: var(--space-4);
    border-radius: var(--radius-lg);
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--glass-bg) 90%, transparent),
      var(--glass-bg));
    border: 1px solid var(--glass-border);
  }

  .inspector-section-title {
    font-size: var(--text-sm);
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
    border-bottom: 2px solid var(--glass-border-strong);
  }

  .inspector-param {
    margin-bottom: var(--space-3);
  }

  .inspector-param-label {
    margin-bottom: var(--space-2);
    font-size: var(--text-sm);
  }

  .inspector-param input[type="range"] {
    height: 14px;
  }

  .inspector-param input[type="range"]::-webkit-slider-thumb {
    width: 24px;
    height: 24px;
  }

  .inspector-param select,
  .inspector-param input[type="text"],
  .inspector-param input[type="number"] {
    padding: var(--space-3);
    font-size: var(--text-base);
    border-radius: var(--radius-md);
    min-height: 48px;
  }
}

/* ==================== MOBILE FAB: QUICK ACCESS HUB ==================== */

@media (max-width: 900px) {
  .daw-fab {
    position: fixed;
    bottom: calc(var(--space-5) + var(--inset-bottom));
    left: 50%;
    transform: translateX(-50%);
    width: 64px;
    height: 64px;
    border-radius: var(--radius-full);
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    color: var(--bg-primary);
    font-size: var(--text-3xl);
    font-weight: 300;
    border: none;
    box-shadow:
      var(--shadow-2xl),
      var(--glow-lg) color-mix(in oklab, var(--accent-primary) 45%, transparent);
    z-index: 9001;
    cursor: pointer;
    display: grid;
    place-items: center;
    transition: all var(--duration-base) cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .daw-fab:active {
    transform: translateX(-50%) scale(0.88);
  }

  .daw-fab.open {
    transform: translateX(-50%) rotate(135deg);
    background: linear-gradient(135deg,
      var(--error),
      color-mix(in oklab, var(--error) 80%, #ff6b6b));
  }

  .daw-fab::before {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: inherit;
    background: inherit;
    opacity: 0.3;
    filter: blur(12px);
    animation: fabPulse 2s ease-in-out infinite;
    z-index: -1;
  }

  @keyframes fabPulse {
    0%, 100% { transform: scale(1); opacity: 0.3; }
    50% { transform: scale(1.15); opacity: 0.5; }
  }

  .daw-fab-backdrop {
    position: fixed;
    inset: 0;
    background: transparent;
    backdrop-filter: none;
    z-index: 8900;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--duration-base) var(--ease-smooth),
                visibility 0s var(--duration-base);
    pointer-events: none;
  }

  .daw-fab-backdrop.open {
    opacity: 1;
    visibility: visible;
    transition: opacity var(--duration-base) var(--ease-smooth),
                visibility 0s 0s;
    pointer-events: auto;
  }

  .daw-fab,
  .daw-fab-menu {
    position: fixed;
    isolation: isolate;
    z-index: 10000;
  }

  .daw-fab-backdrop {
    z-index: 9500;
  }

  .daw-fab-menu {
    position: fixed;
    bottom: calc(var(--space-5) + var(--inset-bottom) + 32px);
    left: 50%;
    transform: translateX(-50%);
    z-index: 9002;
    pointer-events: none;
  }

  .daw-fab-menu.open {
    pointer-events: auto;
  }

  .daw-fab-menu-item {
    position: absolute;
    width: 56px;
    height: 56px;
    border-radius: var(--radius-full);
    background: var(--surface-elevated);
    border: 1px solid var(--glass-border-strong);
    color: var(--text-primary);
    font-size: var(--text-2xl);
    box-shadow: var(--shadow-lg);
    display: grid;
    place-items: center;
    cursor: pointer;
    opacity: 0;
    transform: scale(0);
    transform-origin: center center; /* ADD THIS */
    transition: all var(--duration-base) cubic-bezier(0.68, -0.55, 0.265, 1.55);
    backdrop-filter: none;
  }

  /* === Smooth, symmetric half-circle above FAB === */
  .daw-fab-menu.open .daw-fab-menu-item {
    opacity: 1;
  }
  
  /* Clean, symmetric semi-circle above the centered FAB */
  .daw-fab-menu.open .daw-fab-menu-item:nth-child(1) {
    transform: translate(-95px, -60px) scale(1);
    transition-delay: 50ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(2) {
    transform: translate(-55px, -110px) scale(1);
    transition-delay: 100ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(3) {
    transform: translate(0px, -140px) scale(1);
    transition-delay: 150ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(4) {
    transform: translate(55px, -110px) scale(1);
    transition-delay: 200ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(5) {
    transform: translate(95px, -60px) scale(1);
    transition-delay: 250ms;
  }

  .daw-fab-menu-item:active {
    transform: scale(0.9);
    box-shadow: var(--shadow-sm);
  }

  .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: -60vh;
    max-height: 60vh;
    z-index: 9800;
    transition: bottom var(--duration-base) var(--ease-smooth);
  }

  .daw-inspector.inspector-open {
    bottom: 0;
  }
}

@media (min-width: 901px) {
  .daw-fab,
  .daw-fab-menu,
  .daw-fab-backdrop {
    display: none;
  }
}
    
/* === MOBILE: COMPLETELY HIDE MULTITRACK INSPECTOR === */
@media (max-width: 900px) {
  #tab-multitrack .daw-inspector,
  .daw-inspector {
    display: none !important;
  }
}

/* === Mobile keyboard safety mode for inspector === */
@media (max-width: 900px) {
  #tab-multitrack .daw-inspector.inspector-keyboard-open {
    position: static !important;
    transform: none !important;
    max-height: none;
    top: auto;
    bottom: auto;
    margin: 0;
    border-radius: 0;
    box-shadow: none;
    z-index: auto;
  }
}

/* =========================================================
   MULTITRACK LAYOUT FIXES
   - Make track header controls fully accessible
   - Keep bottom panels/menus sitting above footer
========================================================= */

/* 1) Let the track list breathe on tablet/mobile
   (removes the harsh 200px cap so the header buttons aren't cramped) */
@media (max-width: 1024px) {
  #tab-multitrack .daw-track-list {
    /* Still feels like a column, but not overly constrained */
    min-height: 60vh;
    max-height: none;
  }

  #tab-multitrack .daw-track-list-scroll {
    max-height: none;   /* overrides the old 200px cap */
    min-height: 0;
  }
}

/* 2) Make sure "opening" UI (FX panel, menus, etc.) sits above the footer */

.modal-backdrop,
.region-context-menu,
#fxChainPanel,
.daw-fab-menu,
.toast-container {
  z-index: 11000; /* safely above main app content + footer */
}

/* 3) Nudge the FX chain panel up slightly so it feels "above" the footer,
   not like itâ€™s glued directly to the very bottom */
#fxChainPanel {
  bottom: calc(var(--space-4) + var(--inset-bottom));
}

/* (Optional but nice) â€“ if you ever want the region context menu
   to never collide with the footer visually, you can give it a small
   bottom margin via JS or here as a visual hint: */

.region-context-menu {
  /* keep existing styles, just ensure we never visually hug the bottom */
  max-height: calc(100vh - 64px);
}

/* ==================== SONG BUILDER TAB: PREMIUM STYLING ==================== */

#tab-songbuilder {
  /* Special hero gradient background */
  background: 
    radial-gradient(ellipse 800px 600px at 20% 10%, 
      color-mix(in oklab, var(--accent-primary) 18%, transparent), 
      transparent 60%),
    radial-gradient(ellipse 700px 500px at 80% 90%, 
      color-mix(in oklab, var(--accent-secondary) 15%, transparent), 
      transparent 60%),
    linear-gradient(135deg, 
      var(--bg-secondary) 0%, 
      var(--bg-primary) 50%, 
      var(--bg-tertiary) 100%);
  border-radius: var(--radius-2xl);
  padding: var(--space-6);
  position: relative;
  overflow: hidden;
}

#tab-songbuilder::before {
  content: '';
  position: absolute;
  inset: -100%;
  background: 
    radial-gradient(circle at 30% 40%, 
      color-mix(in oklab, var(--accent-tertiary) 12%, transparent), 
      transparent 50%),
    radial-gradient(circle at 70% 60%, 
      color-mix(in oklab, var(--accent-secondary) 10%, transparent), 
      transparent 50%);
  animation: songBuilderAmbient 12s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes songBuilderAmbient {
  0%, 100% { transform: rotate(0deg) scale(1); opacity: 0.5; }
  50% { transform: rotate(10deg) scale(1.15); opacity: 0.3; }
}

#tab-songbuilder > * {
  position: relative;
  z-index: 1;
}

/* Main panel styling */
#tab-songbuilder .panel {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  padding: var(--space-6);
  box-shadow: 
    var(--shadow-xl),
    inset 0 1px 0 rgba(255,255,255,.08),
    inset 0 -1px 0 rgba(0,0,0,.15);
  backdrop-filter: blur(24px) saturate(150%);
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

#tab-songbuilder .panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    var(--accent-primary), 
    var(--accent-secondary), 
    var(--accent-tertiary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

#tab-songbuilder .panel:hover::before {
  opacity: 1;
  box-shadow: var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent);
}

#tab-songbuilder .panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 35%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-2xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent),
    inset 0 1px 0 rgba(255,255,255,.12);
  transform: translateY(-2px);
}

/* Nested panels (steps 1-4) */
#tab-songbuilder .panel .panel {
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--glass-bg-strong) 95%, transparent),
      color-mix(in oklab, var(--glass-bg) 90%, transparent));
  border: 1px solid var(--glass-border);
  padding: var(--space-5);
  box-shadow: var(--shadow-md);
}

#tab-songbuilder .panel .panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  transform: translateY(-1px);
}

/* Panel header with badge */
#tab-songbuilder .panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-5);
  padding-bottom: var(--space-4);
  border-bottom: 2px solid var(--glass-border-strong);
  gap: var(--space-4);
  flex-wrap: wrap;
}

#tab-songbuilder .panel-title {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, 
    var(--text-primary), 
    var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

#tab-songbuilder .panel-subtitle {
  font-size: var(--text-sm);
  color: var(--text-tertiary);
  font-weight: 500;
  line-height: 1.6;
  margin-top: var(--space-1);
}

#tab-songbuilder .badge-ghost {
  background: var(--glass-bg-strong);
  color: var(--text-secondary);
  border: 1px solid var(--glass-border-strong);
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: 800;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  box-shadow: var(--shadow-sm);
}

/* Step headers */
#tab-songbuilder .panel .panel > div:first-child {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-4);
  gap: var(--space-3);
}

#tab-songbuilder .panel .panel > div:first-child > div:first-child > div:first-child {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

#tab-songbuilder .panel .panel > div:first-child > div:first-child > div:first-child::before {
  content: '';
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 0 0 12px color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

/* Template selector styling */
#songTemplateSelect {
  width: 100%;
  max-width: 280px;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-md);
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
}

#songTemplateSelect:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border-strong));
  background: var(--surface);
  box-shadow: var(--shadow-md);
}

#songTemplateSelect:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 
    var(--shadow-md),
    0 0 0 3px color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

/* Sections table styling */
#tab-songbuilder table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  font-size: var(--text-sm);
  background: var(--glass-bg);
  border-radius: var(--radius-md);
  overflow: hidden;
  box-shadow: var(--shadow-inner);
}

#tab-songbuilder thead {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 15%, var(--glass-bg-strong)),
    var(--glass-bg-strong));
}

#tab-songbuilder thead tr {
  border-bottom: 2px solid var(--glass-border-strong);
}

#tab-songbuilder th {
  padding: var(--space-3) var(--space-4);
  text-align: left;
  font-weight: 800;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: var(--text-xs);
}

#tab-songbuilder tbody tr {
  transition: all var(--duration-fast) var(--ease-smooth);
  border-bottom: 1px solid var(--glass-border);
}

#tab-songbuilder tbody tr:last-child {
  border-bottom: none;
}

#tab-songbuilder tbody tr:hover {
  background: color-mix(in oklab, var(--accent-primary) 8%, transparent);
}

#tab-songbuilder tbody td {
  padding: var(--space-3) var(--space-4);
  color: var(--text-secondary);
  font-weight: 600;
}

/* Scroll container for table */
#tab-songbuilder .scroll-x {
  overflow-x: auto;
  margin: 0 calc(-1 * var(--space-1));
  padding: 0 var(--space-1);
  scrollbar-width: thin;
}

/* Fill select styling */
#songFillEverySelect {
  width: 100%;
  max-width: 160px;
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
}

#songFillEverySelect:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
  background: var(--glass-bg-strong);
}

#songFillEverySelect:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

/* Total bars label */
#songTotalBarsLabel {
  font-family: var(--font-mono);
  font-weight: 800;
  color: var(--accent-primary);
  font-size: var(--text-base);
  padding: var(--space-1) var(--space-3);
  background: color-mix(in oklab, var(--accent-primary) 12%, transparent);
  border-radius: var(--radius-sm);
  display: inline-block;
  box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

/* Build button - HERO TREATMENT */
#songBuildBtn {
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-lg);
  background: linear-gradient(135deg, 
    var(--accent-primary), 
    var(--accent-secondary),
    var(--accent-tertiary));
  color: var(--bg-primary);
  font-family: var(--font-sans);
  font-weight: 900;
  font-size: var(--text-base);
  letter-spacing: 0.02em;
  border: none;
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-bounce);
  box-shadow: 
    var(--shadow-xl),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.25);
  position: relative;
  overflow: hidden;
  animation: songBuildPulse 3s ease-in-out infinite;
}

@keyframes songBuildPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

#songBuildBtn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, 
    transparent 30%, 
    rgba(255,255,255,.3) 50%, 
    transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slower) var(--ease-smooth);
}

#songBuildBtn:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: 
    var(--shadow-2xl),
    var(--glow-lg) color-mix(in oklab, var(--accent-primary) 55%, transparent),
    inset 0 1px 0 rgba(255,255,255,.35);
}

#songBuildBtn:hover::before {
  transform: translateX(100%);
}

#songBuildBtn:active {
  transform: translateY(-1px) scale(0.98);
}

/* Send to Multitrack button */
#songBuilderToMultitrackBtn {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-md);
  background: linear-gradient(135deg, 
    var(--success), 
    color-mix(in oklab, var(--success) 75%, #5eead4));
  color: #042f2e;
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: var(--text-sm);
  border: none;
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: 
    var(--shadow-md),
    0 0 20px color-mix(in oklab, var(--success) 35%, transparent);
}

#songBuilderToMultitrackBtn:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    0 0 30px color-mix(in oklab, var(--success) 45%, transparent);
}

#songBuilderToMultitrackBtn:active {
  transform: translateY(0);
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  #tab-songbuilder {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel-title {
    font-size: var(--text-xl);
  }
}

@media (max-width: 768px) {
  #tab-songbuilder {
    padding: var(--space-3);
  }

  #tab-songbuilder .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel .panel {
    padding: var(--space-3);
  }

  #tab-songbuilder .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-2);
  }

  #tab-songbuilder .panel-title {
    font-size: var(--text-lg);
  }

  #tab-songbuilder table {
    font-size: var(--text-xs);
  }

  #tab-songbuilder th,
  #tab-songbuilder td {
    padding: var(--space-2) var(--space-3);
  }

  #songBuildBtn {
    width: 100%;
    padding: var(--space-3) var(--space-5);
  }

  #songBuilderToMultitrackBtn {
    width: 100%;
  }
}
  </style>
</head>
<body>
  <div id="splashOverlay">
    <div class="splash-inner">
      <div class="splash-logo">8-Beat Studio</div>
      <div class="splash-message" id="splashMessage">
        Initializing engineâ€¦
      </div>
      <div class="splash-progress">
        <div class="splash-progress-bar" id="splashBar"></div>
      </div>
      <div class="splash-sub">
        This should only take a moment âœ¨
      </div>
    </div>
  </div>
  <!-- Sidebar Toggle Button -->
  <button class="sidebar-toggle" id="sidebarToggle" aria-label="Menu">
    ðŸ§­
  </button>
  
  <!-- Sidebar Backdrop -->
  <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
  
  <!-- Sidebar Navigation -->
  <nav class="sidebar-nav" id="sidebarNav">
    <div class="sidebar-section">
      <div class="sidebar-section-title">...</div>
      <div class="sidebar-tabs" id="sidebarTabs">
        <button class="sidebar-tab active" data-tab="generate">ðŸŽ² Generate</button>
        <button class="sidebar-tab" data-tab="sequencer">ðŸŽ¹ Sequencer</button>
        <button class="sidebar-tab" data-tab="mixer">ðŸŽšï¸ Mixer</button>
        <button class="sidebar-tab" data-tab="fx">ðŸŽ›ï¸ Effects</button>
        <button class="sidebar-tab" data-tab="harmony">ðŸŽ¼ Harmony</button>
        <button class="sidebar-tab" data-tab="songbuilder">ðŸ§± Song Builder</button>
        <button class="sidebar-tab" data-tab="multitrack">ðŸŽ™ï¸ Multitrack</button>
        <button class="sidebar-tab" data-tab="samples">ðŸ“‚ Samples</button>
        <button id="unlockProBtn">ðŸ”“ Unlock Pro</button>

        <div id="unlockModal" class="hidden">
          <div class="pro-modal-inner">
            <h2>ðŸ”“ Unlock 8-Beat Studio Pro</h2>
            <p>Paste your license key to unlock all features.</p>
            <input id="licenseInput" type="text" inputmode="text" placeholder="8BEAT-XXXX-XXXX-XXXX">
            <div class="modal-actions">
              <div>
                <style>.pp-58FUHY8RYFPP2{text-align:center;border:none;border-radius:0.25rem;min-width:11.625rem;padding:0 2rem;height:2.625rem;font-weight:bold;background-color:#FFD140;color:#000000;font-family:"Helvetica Neue",Arial,sans-serif;font-size:1rem;line-height:1.25rem;cursor:pointer;}</style>
                <form action="https://www.paypal.com/ncp/payment/58FUHY8RYFPP2" method="post" target="_blank" style="display:inline-grid;justify-items:center;align-content:start;gap:0.5rem;">
                  <input class="pp-58FUHY8RYFPP2" type="submit" value="Buy Now" />
                  <img src=https://www.paypalobjects.com/images/Debit_Credit_APM.svg alt="cards" />
                  <section style="font-size: 0.75rem;"> Powered by <img src="https://www.paypalobjects.com/paypal-ui/logos/svg/paypal-wordmark-color.svg" alt="paypal" style="height:0.875rem;vertical-align:middle;"/></section>
                </form>
              </div>
              <button id="confirmLicenseBtn" class="btn btn-primary">Confirm</button>
              <button id="cancelLicenseBtn" class="btn btn-secondary">Cancel</button>
            </div>
            <p id="licenseStatus" class="status"></p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="sidebar-section">
      <div class="sidebar-section-title">ðŸŽ¨ Genre Presets</div>
      <div class="sidebar-presets" id="sidebarPresets">
        <!-- Presets will be rendered here by JS -->
      </div>
    </div>
    <div style="margin-top: auto; padding: 1rem; font-size: 0.7rem; color: #6b7199; text-align: center; line-height: 1.4;">
      Â© 2025 8-Beat Studio. All Rights Reserved.<br>
      Unauthorized copying, distribution, or modification is prohibited.
    </div>
  </nav>
  <div class="app">
    <header>
      <div class="logo-section">
        <div class="logo">ðŸŽ¹</div>
        <div>
          <h1>8-Beat Studio</h1>
          <div class="tagline">Fun With Noise</div>
        </div>
      </div>
      
      <div class="genre-selector" id="genreSelector">
        <button class="genre-btn active" data-genre="lofi">Lo-Fi</button>
        <button class="genre-btn" data-genre="hiphop">Hip-Hop</button>
        <button class="genre-btn" data-genre="postpunk">Post-Punk</button>
        <button class="genre-btn" data-genre="rnb">R&B</button>
        <button class="genre-btn" data-genre="ambient">Ambient</button>
        <button class="genre-btn" data-genre="dazecore">Dazecore</button>
      </div>
      
      <div class="header-actions">
        <button class="btn btn-secondary btn-sm" id="installBtn" hidden>ðŸ“± Install</button>
        <button class="btn btn-secondary btn-sm" id="vibeBtn">ðŸŒˆ Vibe: Moon</button>
      </div>
    </header>
    
    <div class="transport">
      <div class="transport-controls">
        <button class="btn btn-primary" id="playBtn">â–¶ï¸ Play</button>
        <button class="btn btn-secondary" id="stopBtn">â¹ï¸ Stop</button>
        <button class="btn btn-secondary" id="exportBtn">ðŸŽ§ DJ (Live Export)</button>
      </div>
      
      <div class="progress-area">
        <div class="time-info">
          <span class="time-display" id="timeDisplay">00:00</span>
          <span id="durationDisplay">/ 05:00</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      
      <div class="transport-params">
        <div class="param-control">
          <div class="param-label">
            <span>BPM</span>
            <span class="param-value" id="bpmValue">120</span>
          </div>
          <input type="range" id="bpmSlider" min="60" max="200" value="120">
        </div>
        <div class="param-control">
          <div class="param-label">
            <span>Swing</span>
            <span class="param-value" id="swingValue">50%</span>
          </div>
          <input type="range" id="swingSlider" min="0" max="100" value="50">
        </div>
      </div>
      <div class="flex" style="gap: var(--space-2);">
        <button class="btn btn-secondary btn-sm" id="metronomeBtn">
          ðŸ¥ Click: Off
        </button>
        <button class="btn btn-secondary btn-sm" id="countInBtn">
          â±ï¸ Count: 1 bar
        </button>
      </div>
    </div>
    
    <section class="section active" id="tab-generate">
      <div class="panel">
        <div class="visualizer" id="visualizer">
          <div class="viz-overlay" id="vizOverlay">Generate & Press Play</div>
        </div>
      </div>
      
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">âš™ï¸ Project Settings</div>
          </div>
          
          <div class="grid grid-3 mb-3">
            <div class="param-control">
              <div class="param-label">
                <span>Duration</span>
                <span class="param-value" id="durValue">5 min</span>
              </div>
              <input type="range" id="durSlider" min="1" max="20" value="5">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Complexity</span>
                <span class="param-value" id="complexValue">Medium</span>
              </div>
              <input type="range" id="complexSlider" min="1" max="3" value="2">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Humanize</span>
                <span class="param-value" id="humanValue">10ms</span>
              </div>
              <input type="range" id="humanSlider" min="0" max="30" value="10">
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="generateBtn">ðŸŽ² Generate Beat</button>
            <button id="generateSongBtn" class="btn btn-primary btn-sm">ðŸŽµ Generate Song</button>
            <button class="btn btn-primary" id="generateRhythmBtn">ðŸ¥ Generate Rhythm</button>
            <button class="btn btn-secondary" id="randomVelBtn">ðŸŽ¯ Random Velocity</button>
            <button class="btn btn-secondary" id="randomProbBtn">ðŸŽ² Random Prob</button>
            <button class="btn btn-ghost" id="clearBtn">ðŸ§¹ Clear</button>
          </div>
          
          <!-- NEW: AI Generation Section -->
          <div class="panel-header" style="margin-top: var(--space-6);">
            <div class="panel-title">ðŸ¤– AI Beat Generator</div>
          </div>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); margin-bottom: var(--space-3);">
            <div style="font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6;">
              AI analyzes your current pattern and creates intelligent variations using music theory and production techniques.
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="aiVariationBtn">
              ðŸ¤– AI Drum Variation
            </button>
            <button class="btn btn-primary" id="aiMelodicBtn">
              ðŸŽ¹ AI Melodic Variation
            </button>
          </div>
          
          <div class="panel-header" style="margin-top: var(--space-4);">
            <div class="panel-title">Groove Templates</div>
          </div>
          
          <div class="grid grid-4">
            <button class="preset groove-template-btn" data-template="shuffle">
              <div class="preset-icon">ðŸŽµ</div>
              <div class="preset-name">Shuffle</div>
            </button>
            <button class="preset groove-template-btn" data-template="halfTime">
              <div class="preset-icon">ðŸŒ</div>
              <div class="preset-name">Half-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="doubleTime">
              <div class="preset-icon">âš¡</div>
              <div class="preset-name">Double-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="breakbeat">
              <div class="preset-icon">ðŸ’¥</div>
              <div class="preset-name">Breakbeat</div>
            </button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸ’¾ Projects</div>
          </div>
          
          <div class="flex-col">
            <div class="flex">
              <button class="btn btn-success" id="saveBtn">ðŸ’¾ Save Project</button>
              <button class="btn btn-secondary" id="loadBtn">ðŸ“‚ Load Project</button>
            </div>
            <div class="flex">
              <input type="text" id="projectName" placeholder="Project Name" 
                style="flex:1; padding:10px; background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:var(--radius-sm); color:var(--text-primary); font-family:inherit">
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-sequencer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ¹ Pattern Sequencer</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="lenDecBtn">âˆ’ Length</button>
            <button class="btn btn-secondary btn-sm" id="lenIncBtn">+ Length</button>
            <select id="resSelect">
              <option value="16n" selected>1/16</option>
              <option value="8n">1/8</option>
              <option value="32n">1/32</option>
            </select>
            <button class="btn btn-secondary btn-sm" id="euclidBtn">âˆ· Euclidean</button>
            <button class="btn btn-secondary btn-sm" id="ghostBtn">ðŸ‘» Ghost Notes</button>
          </div>
        </div>
        
        <div class="sequencer">
          <div class="seq-grid" id="seqGrid"></div>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-mixer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽšï¸ Channel Mixer</div>
        </div>
        <div class="grid grid-4" id="mixerGrid"></div>
      </div>
      
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ›ï¸ Master Bus</div>
        </div>
        
        <div class="grid grid-3">
          <div class="param-control">
            <div class="param-label">
              <span>Master Volume</span>
              <span class="param-value" id="masterVolValue">0dB</span>
            </div>
            <input type="range" id="masterVolSlider" min="-40" max="10" value="-6">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Tape Saturation</span>
              <span class="param-value" id="tapeValue">25%</span>
            </div>
            <input type="range" id="tapeSlider" min="0" max="100" value="25">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Vinyl Noise</span>
              <span class="param-value" id="vinylValue">15%</span>
            </div>
            <input type="range" id="vinylSlider" min="0" max="100" value="15">
          </div>
        </div>
        
        <div class="grid grid-3 mt-3">
          <div class="param-control">
            <div class="param-label">
              <span>Low Cut</span>
              <span class="param-value" id="lowCutValue">30Hz</span>
            </div>
            <input type="range" id="lowCutSlider" min="20" max="200" value="30">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>High Cut</span>
              <span class="param-value" id="highCutValue">16kHz</span>
            </div>
            <input type="range" id="highCutSlider" min="4000" max="20000" value="16000">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Compressor</span>
              <span class="param-value" id="compValue">-18dB</span>
            </div>
            <input type="range" id="compSlider" min="-40" max="0" value="-18">
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸ¤– AI Mixing & Mastering</div>
          <button class="btn btn-secondary btn-sm" id="toggleAIMixingBtn">
            <span id="aiMixingStatus">Enable AI</span>
          </button>
        </div>
        
        <div class="grid grid-2" style="margin-bottom: var(--space-4);">
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoGainCheckbox" checked>
            <span style="font-weight: 600;">Auto Gain Staging</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoPanCheckbox" checked>
            <span style="font-weight: 600;">Auto Panning</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoEQCheckbox" checked>
            <span style="font-weight: 600;">Auto EQ</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoCompCheckbox" checked>
            <span style="font-weight: 600;">Auto Compression</span>
          </label>
        </div>
        
        <button class="btn btn-primary" id="applyAIMixBtn" disabled>
          ðŸŽšï¸ Apply AI Mix
        </button>
        
        <div class="panel-header" style="margin-top: var(--space-6);">
          <div class="panel-title">Mastering Presets</div>
        </div>
        
        <div class="grid grid-4">
          <button class="preset" data-master-preset="gentle">
            <div class="preset-icon">ðŸŒ™</div>
            <div class="preset-name">Gentle</div>
          </button>
          <button class="preset" data-master-preset="modern">
            <div class="preset-icon">ðŸŽ§</div>
            <div class="preset-name">Modern</div>
          </button>
          <button class="preset" data-master-preset="aggressive">
            <div class="preset-icon">ðŸ”¥</div>
            <div class="preset-name">Aggressive</div>
          </button>
          <button class="preset" data-master-preset="lofi">
            <div class="preset-icon">ðŸ“»</div>
            <div class="preset-name">Lo-Fi</div>
          </button>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-fx">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ›ï¸ Effects Rack</div>
        </div>
        <div class="grid grid-3" id="fxGrid"></div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-harmony">
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸŽ¼ Key & Scale</div>
          </div>
          
          <div class="flex mb-3">
            <label style="display:flex; align-items:center; gap:8px">
              Key: <select id="keySelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Scale: <select id="scaleSelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Octave: <select id="octaveSelect"></select>
            </label>
          </div>
          
          <div class="panel-header">
            <div class="panel-title">Available Chords</div>
            <button class="btn btn-secondary btn-sm" id="genProgBtn">â†» Generate</button>
          </div>
          <div class="chips" id="chordChips"></div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸŽµ Chord Progression</div>
            <button class="btn btn-ghost btn-sm" id="clearProgBtn">Clear</button>
          </div>
          
          <div class="chips mb-3" id="progressionChips"></div>
          
          <div class="panel-header">
            <div class="panel-title">Progression Templates</div>
          </div>
          <div class="grid grid-4">
            <button class="preset" data-prog="ii-v-i">
              <div class="preset-icon">ðŸŽ·</div>
              <div class="preset-name">II-V-I</div>
            </button>
            <button class="preset" data-prog="lofi">
              <div class="preset-icon">ðŸ˜Œ</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-prog="neosoul">
              <div class="preset-icon">ðŸŽ¹</div>
              <div class="preset-name">Neo-Soul</div>
            </button>
            <button class="preset" data-prog="modal">
              <div class="preset-icon">ðŸŒ™</div>
              <div class="preset-name">Modal</div>
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- ==================== SONG BUILDER TAB ==================== -->
    <section class="section pro-locked" id="tab-songbuilder">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="panel-title">ðŸ§± Song Builder</div>
            <div class="panel-subtitle">
              Step-by-step pipeline from empty grid â†’ full, structured song.
            </div>
          </div>
          <div class="badge badge-ghost">Beta Â· v1.7</div>
        </div>
    
        <div class="panel-body" style="display:flex; flex-direction:column; gap:var(--space-4);">
    
          <!-- STEP 1: Pick a template -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">1. Song Form</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Choose a structure: intro, verses, choruses, bridge, outro.
                </div>
              </div>
            </div>
          
            <div style="display:flex; flex-wrap:wrap; gap:var(--space-3); align-items:center;">
              <label style="font-size:var(--text-xs); text-transform:uppercase; letter-spacing:0.08em; color:var(--text-tertiary);">
                Template
              </label>
              <select id="songTemplateSelect" class="input" style="min-width:220px;">
                <option value="intro-verse-chorus">Pop / Rock</option>
                <option value="short-edm-rise-drop">EDM / House</option>
                <option value="hiphop-lofi">Hip-Hop / Lo-Fi</option>
                <option value="metal-hardcore">Metal / Hardcore</option>
                <option value="ambient-flow">Ambient / Downtempo</option>
                <option value="loop-jam">Loop Jam</option>
                <option value="trap-banger">Trap / Modern Hip-Hop</option>
                <option value="progressive-house">Progressive House / Trance</option>
                <option value="funk-groove">Funk / Disco</option>
                <option value="jazz-standard">Jazz / Fusion</option>
                <option value="dubstep-wobble">Dubstep / Bass Music</option>
                <option value="reggae-dub">Reggae / Dub</option>
              </select>
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); margin-left:auto;">
                Powered by your current key, scale & progression (Harmony tab)
              </div>
            </div>
          
            <!-- Randomize now lives here -->
            <div style="
                display:flex;
                justify-content:flex-end;
                margin-top:var(--space-3);
            ">
              <button
                id="songRandomizeSectionsBtn"
                class="btn btn-secondary btn-sm"
                type="button"
              >
                ðŸŽ² Randomize sections
              </button>
            </div>
          </div>
    
          <!-- STEP 2: Edit sections -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">2. Sections & Energy</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Tweak length, energy and instrumentation for each section. MOBILE USERS: Landscape is recommended!
                </div>
              </div>
            </div>
    
            <div class="scroll-x" style="overflow-x:auto;">
              <table style="width:100%; border-collapse:collapse; font-size:var(--text-xs); min-width:560px;">
                <thead>
                  <tr style="text-align:left; border-bottom:1px solid var(--glass-border);">
                    <th style="padding:6px 4px;">Section</th>
                    <th style="padding:6px 4px; width:70px;">Bars</th>
                    <th style="padding:6px 4px; width:160px;">Energy</th>
                    <th style="padding:6px 4px;">Instruments</th>
                  </tr>
                </thead>
                <tbody id="songSectionsTable">
                  <!-- Filled by JS -->
                </tbody>
              </table>
            </div>
          </div>
    
          <!-- STEP 3: Fills & groove -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">3. Fills & Groove</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Light automation for drum fills and intensity.
                </div>
              </div>
            </div>
    
            <div style="display:flex; flex-wrap:wrap; gap:var(--space-4); align-items:center;">
              <div style="display:flex; flex-direction:column; gap:4px;">
                <label for="songFillEverySelect" style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Drum fill everyâ€¦
                </label>
                <select id="songFillEverySelect" class="input" style="min-width:120px;">
                  <option value="0">Never</option>
                  <option value="4" selected>4 bars</option>
                  <option value="8">8 bars</option>
                  <option value="16">16 bars</option>
                </select>
              </div>
    
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); max-width:260px;">
                Fills are only added in higher-energy sections (verses / choruses / drops).
              </div>
            </div>
          </div>
    
          <!-- STEP 4: Build -->
          <div class="panel" style="padding:var(--space-4); display:flex; justify-content:space-between; align-items:center;">
            <div>
              <div style="font-weight:600; margin-bottom:4px;">4. Build full song</div>
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); max-width:360px;">
                Uses your current genre, tempo, and harmony guardrails to generate
                drums, bass, keys and lead for the whole structure.
              </div>
            </div>
    
            <div style="display:flex; flex-direction:column; gap:var(--space-2); align-items:flex-end;">
              <button id="songBuildBtn" class="btn btn-primary">
                ðŸŽ¼ Build structured song
              </button>
              <div id="songBuilderStatus" class="song-builder-status"></div>
              <!--<button id="songBuilderToMultitrackBtn" class="btn btn-success btn-sm">
                â¬‡ï¸ Send to Multitrack
              </button>-->
              <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                Result shows up in the Sequencer / Generate view.
              </div>
            </div>
          </div>
    
        </div>
      </div>
    </section>

    
    <!-- Replace the entire <section class="section pro-locked" id="tab-multitrack"> block with this -->

    <section class="section pro-locked" id="tab-multitrack">
      <div class="panel">
        <!-- Professional DAW Header -->
        <div class="panel-header">
          <div class="panel-title">ðŸŽ™ï¸ Multitrack DAW</div>
          <div class="flex" style="gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" id="newSessionBtn">ðŸ“„ New</button>
            <button class="btn btn-secondary btn-sm" id="saveSessionBtn">ðŸ’¾ Save</button>
            <button class="btn btn-secondary btn-sm" id="loadSessionBtn">ðŸ“‚ Load</button>
        
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
        
            <button class="btn btn-secondary btn-sm" id="undoBtn" disabled>â†¶ Undo</button>
            <button class="btn btn-secondary btn-sm" id="redoBtn" disabled>â†· Redo</button>
        
            <!-- ðŸ”Š Mixdown / housekeeping -->
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
            <button class="btn btn-success btn-sm" id="bounceAllBtn">ðŸ“¦ Bounce</button>
            <button class="btn btn-secondary btn-sm" id="clearAllTracksBtn">ðŸ§¹ Clear</button>
          </div>
        </div>

    
        <!-- Transport Controls Bar -->
        <div class="daw-transport-bar">
          <div class="transport-section">
            <button class="transport-btn" id="dawRewindBtn" title="Rewind">â®ï¸</button>
            <button class="transport-btn" id="dawPlayBtn" title="Play/Pause">â–¶ï¸</button>
            <button class="transport-btn" id="dawStopBtn" title="Stop">â¹ï¸</button>
            <button class="transport-btn" id="dawRecordBtn" title="Record Armed">âºï¸</button>
            <button class="transport-btn" id="dawForwardBtn" title="Fast Forward">â­ï¸</button>
          </div>
    
          <div class="transport-section">
            <div class="transport-display" id="dawTimecode">00:00:00.000</div>
            <div class="transport-display" id="dawBars">1.1.1</div>
          </div>
    
          <div class="transport-section">
            <button class="btn btn-secondary btn-sm" id="dawLoopBtn">ðŸ” Loop</button>
            <button class="btn btn-secondary btn-sm" id="dawClickBtn">ðŸ¥ Click</button>
            <button class="btn btn-secondary btn-sm" id="dawCountInBtn">â±ï¸ Count</button>
          </div>
    
          <div class="transport-section" style="margin-left: auto;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">BPM</label>
            <input type="number" id="dawBpmInput" value="120" min="30" max="300" 
                   style="width: 60px; padding: var(--space-2); text-align: center;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">Time Sig</label>
            <select id="dawTimeSigSelect" style="padding: var(--space-2);">
              <option value="4/4" selected>4/4</option>
              <option value="3/4">3/4</option>
              <option value="6/8">6/8</option>
              <option value="5/4">5/4</option>
              <option value="7/8">7/8</option>
            </select>
          </div>
        </div>
    
        <!-- Main DAW Layout: 3-Column Professional View -->
        <div class="daw-main-container">
          
          <!-- LEFT: Track List / Mixer Column -->
          <div class="daw-track-list">
            <div class="daw-section-header">
              <span>ðŸ“‹ Tracks</span>
              <button class="btn btn-ghost btn-sm" id="addTrackBtnLeft">âž•</button>
            </div>
            
            <div class="daw-track-list-scroll" id="dawTrackList">
              <!-- Track strips will be dynamically inserted here -->
            </div>
          </div>
          
          <div class="daw-master-strip">
            <div class="daw-section-header">Master</div>
            <div class="daw-meters">
              <div class="daw-meter-bar" id="masterMeterL"></div>
              <div class="daw-meter-bar" id="masterMeterR"></div>
            </div>
            <input type="range" orient="vertical" id="masterFader" min="-60" max="6" value="0" step="0.1">
            <div class="daw-fader-label" id="masterFaderLabel">0.0 dB</div>
          </div>
    
          <!-- CENTER: Timeline / Arrangement View -->
          <div class="daw-timeline-container">
            <!-- Toolbar -->
            <div class="daw-timeline-toolbar">
              <div class="toolbar-group">
                <button class="tool-btn active" data-tool="select" title="Select Tool">â†–ï¸</button>
                <button class="tool-btn" data-tool="pencil" title="Pencil Tool">âœï¸</button>
                <button class="tool-btn" data-tool="split" title="Split Tool">âœ‚ï¸</button>
                <button class="tool-btn" data-tool="fade" title="Fade Tool">ðŸ“‰</button>
              </div>

              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="importStemBtn">ðŸ“ Import Audio</button>
              </div>
    
              <div class="toolbar-group">
                <span class="toolbar-label">Snap:</span>
                <select id="dawSnapSelect" style="padding: var(--space-1) var(--space-2);">
                  <option value="off">Off</option>
                  <option value="bar" selected>Bar</option>
                  <option value="beat">Beat</option>
                  <option value="1/8">1/8</option>
                  <option value="1/16">1/16</option>
                  <option value="1/32">1/32</option>
                </select>
              </div>
    
              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="dawZoomInBtn">ðŸ”+</button>
                <span id="dawZoomLevel">100%</span>
                <button class="btn btn-secondary btn-sm" id="dawZoomOutBtn">ðŸ”-</button>
                <button class="btn btn-secondary btn-sm" id="dawZoomFitBtn">âŠ¡ Fit</button>
              </div>
    
              <div class="toolbar-group" style="margin-left: auto;">
                <button class="btn btn-secondary btn-sm" id="dawGridBtn">âŠž Grid</button>
                <button class="btn btn-secondary btn-sm" id="dawAutomationBtn">ðŸ“ˆ Auto</button>
              </div>
            </div>
    
            <!-- Ruler with measures/beats -->
            <div class="daw-ruler" id="dawRuler">
              <div class="daw-ruler-markers" id="dawRulerMarkers"></div>
              <div class="daw-playhead" id="dawPlayhead"></div>
              <div class="daw-loop-region" id="dawLoopRegion" style="display: none;"></div>
            </div>
    
            <!-- Scrollable arrangement view -->
            <div class="daw-arrangement-scroll" id="dawArrangementScroll">
              <div id="loopRegionHighlight" class="loop-region-highlight" style="display:none;"></div>
              <div class="daw-arrangement-grid" id="dawArrangementGrid">
                <!-- Track lanes will be rendered here -->
              </div>
            </div>
          </div>
    
          <!-- RIGHT: Inspector / Properties Panel -->
          <div class="daw-inspector">
            <div class="daw-section-header">
              <span id="inspectorTitle">ðŸŽ›ï¸ Inspector</span>
              <button class="btn btn-ghost btn-sm" id="closeInspectorBtn">âœ•</button>
            </div>
    
            <div class="daw-inspector-content" id="inspectorContent">
              <!-- Content changes based on selection -->
              <div class="inspector-placeholder">
                <div style="text-align: center; padding: var(--space-8); color: var(--text-tertiary);">
                  <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">ðŸŽšï¸</div>
                  <div>Select a track or region</div>
                  <div style="font-size: var(--text-sm); margin-top: var(--space-2);">to view properties</div>
                </div>
              </div>
            </div>
          </div>
    
        </div>
        
        <!-- ðŸŽ› FX Chain Panel -->
        <!-- Bottom FX Chain Panel -->
        <div id="fxChainPanel" class="fx-chain-panel" aria-hidden="true">
          <div class="fx-chain-header">
            <div class="fx-chain-title">
              <span class="fx-chain-icon">âœ¨</span>
              <div>
                <div class="fx-chain-title-main">Track FX Chain</div>
                <div class="fx-chain-title-sub" id="fxChainTrackLabel">
                  No track selected
                </div>
              </div>
            </div>
            <button class="btn btn-ghost btn-xs" id="closeFxPanelBtn" type="button">
              âœ•
            </button>
          </div>

          <div class="fx-chain-body">
            <!-- INLINE ADD FX STRIP (no modal / menu) -->
            <div class="fx-add-row">
              <span class="fx-add-label">Add effect</span>
              <div class="fx-add-list" id="fxAddList">
                <button type="button" class="fx-pill" data-fx="eq">ðŸŽš EQ</button>
                <button type="button" class="fx-pill" data-fx="compressor">ðŸ«§ Comp</button>
                <button type="button" class="fx-pill" data-fx="delay">â± Delay</button>
                <button type="button" class="fx-pill" data-fx="reverb">ðŸŒ« Reverb</button>
                <button type="button" class="fx-pill" data-fx="saturation">ðŸ”¥ Sat</button>
                <button type="button" class="fx-pill" data-fx="filter">ðŸª„ Filter</button>
              </div>
            </div>

            <!-- Where each track's FX chain gets rendered -->
            <div class="fx-chain-slots" id="fxChainSlots">
              <!-- renderFxChain(track) populates this -->
            </div>
          </div>
        </div>
        
        <!-- Bottom: Status Bar -->
        <div class="daw-status-bar">
          <span id="dawStatusMessage">Ready</span>
          <div style="margin-left: auto; display: flex; gap: var(--space-4); font-size: var(--text-xs);">
            <span>Sample Rate: <strong id="dawSampleRate">48000 Hz</strong></span>
            <span>Latency: <strong id="dawLatency">0ms</strong></span>
            <span>CPU: <strong id="dawCpuLoad">0%</strong></span>
            <span>Tracks: <strong id="dawTrackCount">0</strong></span>
          </div>
        </div>
      </div>
      <!-- Mobile quick actions FAB -->
      <!--<button id="dawFab" class="daw-fab" type="button" aria-label="Quick actions">
        <span id="dawFabIcon">+</span>
      </button>
      
      <div id="dawFabMenu" class="daw-fab-menu" aria-label="Multitrack quick actions">
        <button class="daw-fab-menu-item" data-action="add-track" title="Add Track">
          ðŸŽµ
        </button>
        <button class="daw-fab-menu-item" data-action="toggle-inspector" title="Inspector">
          ðŸŽ›ï¸
        </button>
        <button class="daw-fab-menu-item" data-action="toggle-fx" title="FX Chain">
          âœ¨
        </button>
        <button class="daw-fab-menu-item" data-action="record-arm" title="Quick Record">
          âºï¸
        </button>
        <button class="daw-fab-menu-item" data-action="undo" title="Undo">
          â†¶
        </button>
      </div>-->
    </section>

    <section class="section pro-locked" id="tab-samples">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸ“‚ Sample Library</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="refreshSamplesBtn">â†» Refresh</button>
            <button class="btn btn-success btn-sm" id="loadKitBtn">ðŸ“¥ Load Kit to Sequencer</button>
            <button id="defaultKitBtn" class="btn btn-secondary btn-sm">â†º Default</button>
          </div>
        </div>
    
        <!-- Kit Selector -->
        <div style="margin-bottom: var(--space-6);">
          <div style="font-weight: 600; margin-bottom: var(--space-3); color: var(--text-secondary);">
            ðŸŽ›ï¸ Sample Kits
          </div>
          <div class="grid grid-5" id="kitSelector">
            <button class="preset active" data-kit="lofi">
              <div class="preset-icon">ðŸ“»</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-kit="metal">
              <div class="preset-icon">ðŸ¤˜</div>
              <div class="preset-name">Metal</div>
            </button>
            <button class="preset" data-kit="hiphop">
              <div class="preset-icon">ðŸŽ¤</div>
              <div class="preset-name">Hip-Hop</div>
            </button>
            <button class="preset" data-kit="trap">
              <div class="preset-icon">ðŸ”¥</div>
              <div class="preset-name">Trap</div>
            </button>
            <button class="preset" data-kit="house">
              <div class="preset-icon">ðŸ </div>
              <div class="preset-name">House</div>
            </button>
            <button class="preset" data-kit="techno">
              <div class="preset-icon">âš¡</div>
              <div class="preset-name">Techno</div>
            </button>
            <button class="preset" data-kit="dnb">
              <div class="preset-icon">ðŸ¥</div>
              <div class="preset-name">DnB</div>
            </button>
            <button class="preset" data-kit="ambient">
              <div class="preset-icon">ðŸŒ™</div>
              <div class="preset-name">Ambient</div>
            </button>
            <button class="preset" data-kit="rock">
              <div class="preset-icon">ðŸŽ¸</div>
              <div class="preset-name">Rock</div>
            </button>
            <button class="preset" data-kit="jazz">
              <div class="preset-icon">ðŸŽ·</div>
              <div class="preset-name">Jazz</div>
            </button>
            <button class="preset" data-kit="vintage">
              <div class="preset-icon">ðŸ“¼</div>
              <div class="preset-name">Vintage</div>
            </button>
            <!--<button class="preset" data-kit="instruments">
              <div class="preset-icon">ðŸŽ¹</div>
              <div class="preset-name">Instruments</div>
            </button>-->
          </div>
        </div>
    
        <!-- Sample Browser Grid -->
        <div class="grid grid-2" style="gap: var(--space-4);">
          
          <!-- Left: Sample List -->
          <div class="panel">
            <div class="panel-header">
              <div class="panel-title">ðŸŽµ Samples</div>
              <div class="badge badge-primary" id="sampleCount">8 sounds</div>
            </div>
            
            <div id="sampleList" style="display: flex; flex-direction: column; gap: var(--space-2); max-height: 500px; overflow-y: auto;">
              <!-- Sample items will be generated here -->
            </div>
          </div>
    
          <!-- Right: Sample Editor -->
          <div class="panel">
            <div class="panel-header">
              <div class="panel-title">ðŸŽšï¸ Sample Editor</div>
              <button class="btn btn-ghost btn-sm" id="resetSampleBtn">Reset</button>
            </div>
    
            <div id="sampleEditor">
              <!-- Waveform Preview -->
              <div style="margin-bottom: var(--space-4);">
                <div style="font-weight: 600; margin-bottom: var(--space-2); color: var(--text-secondary); font-size: var(--text-sm);">
                  Waveform
                </div>
                <div style="background: var(--bg-secondary); border-radius: var(--radius-md); padding: var(--space-4); height: 80px; display: flex; align-items: center; justify-content: center;">
                  <canvas id="sampleWaveform" width="400" height="60"></canvas>
                </div>
              </div>
    
              <!-- Sample Info -->
              <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
                <div style="font-weight: 600; margin-bottom: var(--space-2);" id="selectedSampleName">Select a sample</div>
                <div style="font-size: var(--text-sm); color: var(--text-tertiary);" id="selectedSampleInfo">Click any sample to edit</div>
              </div>
    
              <!-- Synthesis Parameters -->
              <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŽ›ï¸ Pitch</span>
                    <span class="param-value" id="samplePitchValue">0</span>
                  </div>
                  <input type="range" id="samplePitch" min="-12" max="12" value="0" step="0.1">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ“ Decay</span>
                    <span class="param-value" id="sampleDecayValue">0.2s</span>
                  </div>
                  <input type="range" id="sampleDecay" min="0.05" max="2" value="0.2" step="0.01">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŽšï¸ Tone</span>
                    <span class="param-value" id="sampleToneValue">50%</span>
                  </div>
                  <input type="range" id="sampleTone" min="0" max="100" value="50">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŒŠ Noise</span>
                    <span class="param-value" id="sampleNoiseValue">30%</span>
                  </div>
                  <input type="range" id="sampleNoise" min="0" max="100" value="30">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>âš¡ Attack</span>
                    <span class="param-value" id="sampleAttackValue">0.001s</span>
                  </div>
                  <input type="range" id="sampleAttack" min="0.001" max="0.1" value="0.001" step="0.001">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ”Š Volume</span>
                    <span class="param-value" id="sampleVolumeValue">0dB</span>
                  </div>
                  <input type="range" id="sampleVolume" min="-24" max="6" value="0" step="0.5">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ“» Lo-Fi</span>
                    <span class="param-value" id="sampleLofiValue">0%</span>
                  </div>
                  <input type="range" id="sampleLofi" min="0" max="100" value="0">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>âš¡ Distortion</span>
                    <span class="param-value" id="sampleDistValue">0%</span>
                  </div>
                  <input type="range" id="sampleDist" min="0" max="100" value="0">
                </div>
    
              </div>
    
              <!-- Action Buttons -->
              <div class="flex" style="margin-top: var(--space-4);">
                <button class="btn btn-primary" id="previewSampleBtn">â–¶ï¸ Preview</button>
                <button class="btn btn-secondary" id="saveSampleBtn">ðŸ’¾ Save</button>
                <button class="btn btn-secondary" id="exportSampleBtn">ðŸ“¥ Export WAV</button>
                <button class="btn btn-secondary btn-sm" id="sendSampleToMultitrackBtn">â†— To Multitrack</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    
      <!-- Sample Pack Generator -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ² Sample Pack Generator</div>
        </div>
    
        <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); margin-bottom: var(--space-4);">
          <div style="font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6; margin-bottom: var(--space-3);">
            Generate entire custom sample packs with AI-powered sound design. Choose your style and let the algorithm create unique, cohesive drum sounds.
          </div>
        </div>
    
        <div class="grid grid-3" style="margin-bottom: var(--space-4);">
          <div class="param-control">
            <div class="param-label">
              <span>Character</span>
              <span class="param-value" id="genCharacterValue">Warm</span>
            </div>
            <input type="range" id="genCharacter" min="0" max="100" value="50">
          </div>
    
          <div class="param-control">
            <div class="param-label">
              <span>Variation</span>
              <span class="param-value" id="genVariationValue">Medium</span>
            </div>
            <input type="range" id="genVariation" min="0" max="100" value="50">
          </div>
    
          <div class="param-control">
            <div class="param-label">
              <span>Lo-Fi Amount</span>
              <span class="param-value" id="genLofiValue">25%</span>
            </div>
            <input type="range" id="genLofi" min="0" max="100" value="25">
          </div>
        </div>
    
        <div class="flex">
          <button class="btn btn-success" id="generatePackBtn">ðŸŽ² Generate Pack</button>
          <button class="btn btn-secondary" id="downloadPackBtn">ðŸ“¦ Download Pack (.zip)</button>
        </div>
      </div>
    </section>
    
    <footer class="footer">
      <div style="max-width: 1400px; margin: 0 auto;">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--space-6); margin-bottom: var(--space-4);">
          
          <!-- Transport & Playback -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>â–¶ï¸</span> Transport
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Space</kbd> Play/Pause</div>
              <div><kbd>S</kbd> Stop</div>
              <div><kbd>E</kbd> DJ Export</div>
            </div>
          </div>
          
          <!-- Multitrack DAW -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸŽ™ï¸</span> Multitrack
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Ctrl</kbd>+<kbd>Z</kbd> Undo</div>
              <div><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> Redo</div>
              <div><kbd>X</kbd> Split at Playhead</div>
              <div><kbd>Ctrl</kbd>+<kbd>D</kbd> Duplicate Region</div>
              <div><kbd>Delete</kbd> Delete Region</div>
              <div><kbd>Ctrl</kbd>+<kbd>=</kbd> Zoom In</div>
              <div><kbd>Ctrl</kbd>+<kbd>-</kbd> Zoom Out</div>
            </div>
          </div>
          
          <!-- Sequencer -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸŽ¹</span> Sequencer
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Click</kbd> Toggle Step</div>
              <div><kbd>Alt</kbd>+<kbd>Click</kbd> Accent Velocity</div>
              <div><kbd>Shift</kbd>+<kbd>Click</kbd> Inc. Probability</div>
              <div><kbd>Ctrl</kbd>+<kbd>Click</kbd> Edit Note</div>
            </div>
          </div>
          
          <!-- Navigation -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸ§­</span> Navigation
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Esc</kbd> Close Sidebar</div>
              <div><kbd>Tab</kbd> Next Control</div>
            </div>
          </div>
          
        </div>
        
        <!-- Studio Info Bar -->
        <div style="padding-top: var(--space-4); border-top: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
          <div style="display: flex; align-items: center; gap: var(--space-4);">
            <strong style="background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: var(--text-lg);">8-Beat Studio</strong>
            <span style="color: var(--text-tertiary);">â€¢</span>
            <span style="color: var(--text-secondary);">Hand Crafted Multitrack DAW</span>
          </div>
          
          <div style="display: flex; align-items: center; gap: var(--space-3); font-size: var(--text-sm); color: var(--text-tertiary);">
            <div class="badge badge-ghost">Beta v1.7</div>
            <span>Made with â¤ï¸ for producers</span>
          </div>
        </div>
      </div>
    </footer>
  </div>
  <!-- Add before closing </body> tag -->
  <div id="waveformEditorModal" style="display: none;"></div>
<script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
// ========================================
// 8-Beat Studio - Fully Optimized JS
// Performance: Debounced events, RAF throttling, object pooling
// Memory: Weak references, proper cleanup, no leaks
// Audio: Low-latency graph, stable connections, no crackles
// ========================================

'use strict';

// -------------------- Configuration --------------------
// Detect mobile device once
const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);

// Global config
const CONFIG = {
  MAX_BPM: 200,
  MAX_SEQUENCE_LENGTH: isMobile ? 512 : 1024, // âœ… use colon here
  MIN_SEQUENCE_LENGTH: 8,
  VISUALIZER_BARS: 32,
  VISUALIZER_FPS: 30,
  PROGRESS_UPDATE_MS: 16,
  DEBOUNCE_MS: 80,
  STORAGE_KEY: 'prostudio.vibe'
};

const VIBES = ['moon', 'dawn', 'nebula', 'forest', 'sunset', 'ocean', 'ember', 'aurora', 'cyber', 'sandstorm'];

// -------------------- State Management --------------------
const state = {
  currentGenre: 'lofi',
  currentTab: 'generate',
  isPlaying: false,
  bpm: 120,
  swing: 50,
  duration: 5,
  complexity: 2,
  humanize: 10,
  sequenceLength: 32,  // CHANGED FROM 16
  resolution: '16n',
  currentStep: 0,
  cursorSeconds: 0,
  // ... rest stays the same
  key: 'C',
  scale: 'major',
  octave: 4,
  progression: [],
  masterVolume: 0,
  tapeSaturation: 25,
  vinylNoise: 15,
  lowCut: 30,
  highCut: 16000,
  compressor: -18,
  metronomeEnabled: false,
  metronomeVolume: -6,
  countInBars: 1,
  // AI Mixing
  aiMixing: {
    enabled: false,
    autoGain: true,
    autoPan: true,
    autoEQ: true,
    autoCompression: true,
    referenceLevel: -14, // LUFS target
    lastAnalysis: null
  }
};

// Has the main Tone.Sequence been set up at least once?
let sequencerInitialized = false;
  
// Metronome system
const metronome = {
  synth: null,
  enabled: false,
  loop: null
};
  
async function checkAudioPermissions() {
  try {
    const permissions = await navigator.permissions.query({ name: 'microphone' });
    
    if (permissions.state === 'denied') {
      console.warn('âš ï¸ Microphone permission denied');
      showToast('âš ï¸ Microphone access denied. External audio tracks will not work.', 'warning');
    } else if (permissions.state === 'prompt') {
      console.log('â„¹ï¸ Microphone permission will be requested when adding external audio track');
    } else {
      console.log('âœ… Microphone permission granted');
    }
    
    permissions.addEventListener('change', () => {
      console.log('ðŸ”„ Microphone permission changed:', permissions.state);
    });
    
  } catch (err) {
    // Permissions API not supported or microphone not in query list
    console.log('â„¹ï¸ Cannot query microphone permissions, will request on demand');
  }
}
  
// -------------------- Data Structures --------------------
const instruments = {
  kick: { name: 'Kick', icon: 'ðŸ¥', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  snare: { name: 'Snare', icon: 'ðŸŽ¤', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  hihat: { name: 'Hi-Hat', icon: 'ðŸŽ©', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  clap: { name: 'Clap', icon: 'ðŸ‘', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  rimshot: { name: 'Rimshot', icon: 'ðŸ”Š', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  tom: { name: 'Tom', icon: 'ðŸª˜', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  crash: { name: 'Crash', icon: 'ðŸ’¥', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  ride: { name: 'Ride', icon: 'ðŸŒŠ', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  
  // NEW ATMOSPHERIC INSTRUMENTS
  fx: { name: 'FX', icon: 'âœ¨', mute: false, solo: false, volume: -6, pan: 0, type: 'atmospheric' },
  riser: { name: 'Riser', icon: 'ðŸ“ˆ', mute: false, solo: false, volume: -8, pan: 0, type: 'atmospheric' },
  ambience: { name: 'Ambience', icon: 'ðŸŒ«ï¸', mute: false, solo: false, volume: -10, pan: 0, type: 'atmospheric' },
  
  bass: { name: 'Bass', icon: 'ðŸŽ¸', mute: false, solo: false, volume: -3, pan: 0, type: 'melodic', note: 'C2' },
  guitar: { name: 'Guitar', icon: 'ðŸŽ¸', mute: false, solo: false, volume: -5, pan: 20, type: 'melodic', note: 'C3' },
  keys: { name: 'Keys', icon: 'ðŸŽ¹', mute: false, solo: false, volume: -6, pan: 0, type: 'melodic', note: 'C4' },
  lead: { name: 'Lead', icon: 'ðŸŽº', mute: false, solo: false, volume: -8, pan: 0, type: 'melodic', note: 'C5' }
};

const patterns = {};
const synths = {};
const effects = {};
const master = {};

// Initialize patterns with proper structure
Object.keys(instruments).forEach(inst => {
  patterns[inst] = Array(32).fill(null).map(() => ({  // CHANGED FROM 16
    active: false,
    velocity: 0.8,
    probability: 100,
    note: instruments[inst].note,
    duration: '8n'
  }));
});

// -------------------- Genre Presets --------------------
const genrePresets = {
  lofi: {
    name: 'Lo-Fi Hip-Hop', icon: 'ðŸ˜Œ', bpm: 85, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','G2','G2','C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','A2','A2'],
      guitar: ['C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','G3','D4','F3','G3','C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','C4','D4','F4','G4'],
      keys: ['C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','G3','A#3','D4','F4','C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','C4','D4','F4','G4'],
      lead: ['G4','A#4','D5','C5','A#4','G4','F4','D#4','G4','A#4','D5','C5','A#4','G4','F4','D#4']
    }
  },
  
  hiphop: {
    name: 'Hip-Hop', icon: 'ðŸŽ¤', bpm: 90, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
      hihat:   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      bass:    [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','G2','A1','A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','A1','A1'],
      guitar: ['A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','G3','B2','A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','G3'],
      keys: ['A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','F3','B3','A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','A3'],
      lead: ['E4','G4','A4','C5','B4','A4','G4','E4','E4','G4','A4','C5','D5','C5','B4','A4']
    }
  },
  
  postpunk: {
    name: 'Post-Punk', icon: 'ðŸ–¤', bpm: 100, swing: 0,
    patterns: {
      kick:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0],
      rimshot: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      bass:    [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0],
      guitar:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','D2','D1','E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','E2','E1'],
      guitar: ['E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','F3','A3','D3','E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','E3','G3','B3'],
      keys: ['E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','F3','A3','C4','E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','E3','G3','B3'],
      lead: ['B3','D4','E4','G4','F4','E4','D4','B3','B3','D4','E4','G4','A4','G4','F4','E4']
    }
  },
  
  rnb: {
    name: 'R&B', icon: 'ðŸ’«', bpm: 75, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0]
    },
    notes: {
      bass: ['F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','C3','C3','F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','D3','D3'],
      guitar: ['F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','G3','C3','F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','F3','A3'],
      keys: ['F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','C4','F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','A3'],
      lead: ['C4','E4','F4','A4','G4','F4','E4','C4','C4','E4','F4','A4','G4','A4','C5','E5']
    }
  },
  
  ambient: {
    name: 'Ambient', icon: 'ðŸŒŒ', bpm: 60, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      snare:   [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0],
      bass:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','A#1','A#1','A#1','A#1','C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','G#1','G#1','G#1','G#1'],
      guitar: ['C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','D3','F3','A#3','D3','C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      keys: ['C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','D3','F3','A#3','D4','C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      lead: ['G3','A#3','D4','F4','D#4','D4','A#3','G3','G3','A#3','D4','F4','D#4','D4','C4','A#3']
    }
  },

  dazecore: {
    name: 'Dazecore', icon: 'â˜€ï¸', bpm: 95, swing: 0,
    patterns: {
      // Warm, inviting kick - but the timing is slightly off
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      
      // Soft, jazzy snare - comforting but distant
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1],
      
      // Lounge hi-hats with subtle glitches
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1],
      
      // Intimate claps - inviting you in
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0],
      
      // Dial-up nostalgia - warm but uncanny
      rimshot: [0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,0,1],
      
      // Rare tom fills - something stirring beneath
      tom:     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      
      // Deep, warm bass - comforting rumble with wrong notes
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,0],
      
      // Lush guitar chords - too beautiful, almost sickly sweet
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0],
      
      // Dreamy keys - lounge jazz piano with dissonant undertones
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0],
      
      // Warm melody - beckoning, seductive, slightly wrong
      lead:    [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0],
      
      // Vinyl crackle and tape warble - nostalgic texture
      fx:      [1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1],
      
      // Subtle riser - the room is shifting around you
      riser:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
      
      // Warm ambient pad - the "off" feeling underneath everything
      ambience:[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
    },
    notes: {
      // Warm bass with chromatic "wrong" notes
      bass: ['D2','D2','D2','F2','F2','F2','A2','A2','A2','C3','C3','C3','D3','D3','D#3','D2','D2','D2','F2','F2','F2','A2','A2','C3','C3','C3','D3','D#3','D3','C3','A2','F2'],
      
      // Lush major 7th chords with occasional dissonance
      guitar: ['D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','A3','C#4','E4','A3','D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','B3','D4','F#4','A4'],
      
      // Jazzy extended chords - warm but unsettling
      keys: ['D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','G#4','C#4','E4','G#4','B4','D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','A4','C#4','E4','G#4','C#5'],
      
      // Nostalgic melody - familiar but you can't place it
      lead: ['A4','C#5','D5','F#5','E5','D5','C#5','A4','F#4','A4','C#5','E5','D5','C#5','B4','A4','A4','C#5','D5','F#5','E5','D5','C#5','B4','A4','C#5','E5','F#5','G#5','A5','C#6','D6']
    }
  }
};
  
// -------------------- Music Theory --------------------
const keysArr = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const scales = {
  major: [0,2,4,5,7,9,11],
  minor: [0,2,3,5,7,8,10],
  dorian: [0,2,3,5,7,9,10],
  phrygian: [0,1,3,5,7,8,10],
  lydian: [0,2,4,6,7,9,11],
  mixolydian: [0,2,4,5,7,9,10],
  pentatonic: [0,2,4,7,9]
};

// -------------------- FX Configuration --------------------
const fxConfig = {
  reverb: { name: 'Reverb', active: false, decay: 1, wet: 0.2 },
  delay: { name: 'Delay', active: false, time: '4n', feedback: 0.2 },
  chorus: { name: 'Chorus', active: false, frequency: 1.5, depth: 0.7 },
  flanger: { name: 'Flanger', active: false, frequency: 0.5, depth: 0.5 },
  distortion: { name: 'Distortion', active: false, amount: 0.5 },
  filter: { name: 'Filter', active: false, frequency: 5000, type: 'lowpass' },
  phaser: { name: 'Phaser', active: false, frequency: 0.5, octaves: 3 },
  bitcrusher: { name: 'Bitcrusher', active: false, bits: 8, frequency: 4000 }
};

// -------------------- Utilities --------------------
const debounce = (fn, ms) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), ms);
  };
};

const throttle = (fn, ms) => {
  let lastRun = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastRun >= ms) {
      lastRun = now;
      fn(...args);
    }
  };
};

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

// -------------------- Audio Context Setup --------------------
function initAudioContext() {
  if (Tone.getContext && Tone.getContext().rawContext) return;

  const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
  
  const ctx = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: isMobile ? 'balanced' : 'interactive',
    sampleRate: 48000
  });
  
  Tone.setContext(new Tone.Context(ctx));
  
  // CRITICAL: Desktop needs LESS lookahead to avoid timing issues
  Tone.context.lookAhead = isMobile ? 0.05 : 0.015; // Reduced from 0.02
  Tone.context.updateInterval = isMobile ? 0.03 : 0.008; // Reduced from 0.01
  
  console.log('ðŸŽ§ Device:', isMobile ? 'Mobile' : 'Desktop');
  console.log('ðŸŽµ Lookahead:', Tone.context.lookAhead.toFixed(3) + 's');
  console.log('ðŸŽµ Update:', Tone.context.updateInterval.toFixed(3) + 's');
}
  
function unlockAudioOnce() {
  const unlock = async () => {
    try {
      await Tone.start();
      await Tone.getContext().rawContext.resume();
      console.log('ðŸ”“ Audio unlocked:', Tone.getContext().rawContext.state);
    } catch (e) {
      console.warn('Unlock failed:', e);
    } finally {
      ['pointerdown', 'keydown', 'touchstart'].forEach(evt => {
        window.removeEventListener(evt, unlock);
      });
    }
  };
  
  window.addEventListener('pointerdown', unlock, { once: true });
  window.addEventListener('keydown', unlock, { once: true });
  window.addEventListener('touchstart', unlock, { once: true, passive: true });
}

// -------------------- Audio Graph Initialization --------------------
function initAudio() {
  // CRITICAL: Much lower gain + slower ramps for desktop stability
  master.fxIn = new Tone.Gain(0.25); // Reduced from 0.18
  
  // Master bus filters with SLOWER frequency ramps
  master.lowCutFilter = new Tone.Filter({
    type: 'highpass',
    frequency: state.lowCut,
    rolloff: -12
  });
  
  master.highCutFilter = new Tone.Filter({
    type: 'lowpass',
    frequency: state.highCut,
    rolloff: -12
  });
  
  // Tape saturation (subtle warm distortion)
  master.tapeDistortion = new Tone.Distortion({
    distortion: state.tapeSaturation / 100 * 0.2, // Reduced from 0.3
    wet: state.tapeSaturation / 100 * 0.6 // Reduced wet mix
  });
  
  // Vinyl noise (pink noise layer) - QUIETER
  master.vinylNoise = new Tone.Noise('pink');
  master.vinylNoise.volume.value = -50 + (state.vinylNoise / 100 * 15); // Quieter
  master.vinylNoise.start();
  master.vinylNoise.connect(master.fxIn);
  
  // Effects with MUCH gentler settings for desktop
  effects.filter = new Tone.Filter(fxConfig.filter.frequency, fxConfig.filter.type);
  effects.distortion = new Tone.Distortion(0.01); // Half strength
  effects.chorus = new Tone.Chorus(1.5, 2.5, 0.1).start(); // Reduced depth
  effects.flanger = new Tone.Chorus({
    frequency: 0.5,
    delayTime: 2,
    depth: 0.3, // Reduced from 0.5
    type: 'sine',
    spread: 0
  }).start();
  effects.phaser = new Tone.Phaser({
    frequency: 0.3, // Slower modulation
    octaves: 2, // Reduced from 3
    baseFrequency: 350
  });
  effects.bitcrusher = new Tone.BitCrusher(10); // Less crushing (was 8)
  effects.delay = new Tone.FeedbackDelay(fxConfig.delay.time, 0.08); // Less feedback
  effects.reverb = new Tone.Reverb({ decay: 0.6, wet: 0.1 }); // Drier reverb
  
  master.comp = new Tone.Compressor({
    threshold: state.compressor,
    ratio: 4, // More compression = more consistent volume
    attack: 0.003,
    release: 0.15
  });
  master.limiter = new Tone.Limiter(-2); // Safety limiter catches peaks
  
  // Connect master bus chain
  master.fxIn.chain(
    master.lowCutFilter,
    master.highCutFilter,
    master.tapeDistortion,
    effects.filter,
    effects.distortion,
    effects.bitcrusher,
    effects.chorus,
    effects.flanger,
    effects.phaser,
    effects.delay,
    effects.reverb,
    master.comp,
    master.limiter
  );
  
  master.limiter.toDestination();
  
  // Clip detection meter
  master.meter = new Tone.Meter();
  master.limiter.connect(master.meter);
  
  // Visualizer tap
  master.analyser = new Tone.Analyser('fft', 64);
  master.limiter.connect(master.analyser);
  
  // Recording tap
  const raw = Tone.getContext().rawContext;
  master.mediaDest = raw.createMediaStreamDestination();
  master.limiter.connect(master.mediaDest);
  master.mediaRecorder = null;
  master.recordedChunks = [];
  
  // Start FX states from fxConfig
  Object.keys(fxConfig).forEach(name => {
    applyFxActiveState(name, fxConfig[name].active);
  });
  
  // Create synths and channels
  Object.keys(instruments).forEach(inst => createInstrumentChain(inst));
  
  // Transport setup
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Initialize metronome
  metronome.synth = new Tone.MembraneSynth({
    pitchDecay: 0.008,
    octaves: 2,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
  }).toDestination();
  
  metronome.synth.volume.value = state.metronomeVolume;

  // Optimize instrument levels for better mix
  instruments.kick.volume = 0;
  instruments.snare.volume = -2;
  instruments.hihat.volume = -6;
  instruments.bass.volume = -3;
  
  metronome.loop = new Tone.Loop((time) => {
    const step = Math.floor(Tone.Transport.position.split(':')[1]);
    const isDownbeat = step === 0;
    const pitch = isDownbeat ? 'C5' : 'C4';
    const velocity = isDownbeat ? 1 : 0.6;
    
    if (state.metronomeEnabled) {
      metronome.synth.triggerAttackRelease(pitch, '32n', time, velocity);
    }
  }, '4n');
  
  metronome.loop.start(0);
  
  // CRITICAL: Batch note triggers to reduce message handler load
  const noteQueue = [];
  let batchTimeout = null;
  
  const flushNoteQueue = (time) => {
    if (noteQueue.length === 0) return;
    
    // Sort by time to maintain order
    noteQueue.sort((a, b) => a.time - b.time);
    
    // Trigger all notes at their scheduled times
    noteQueue.forEach(({ inst, step, time: noteTime }) => {
      playStep(inst, step, noteTime);
    });
    
    noteQueue.length = 0;
  };
  
  // Main sequencer loop - DYNAMIC LENGTH
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);
  
    const activeInsts = Object.keys(instruments).filter(inst => 
      patterns[inst][step]?.active
    );
  
    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');
  
    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });
  
    melodicInsts.forEach((inst, idx) => { 
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002;
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });
  
    updateVisualizer();
  }, 
  Array.from({ length: state.sequenceLength }, (_, i) => i), 
  state.resolution);
  
  loop.loop = true;
  loop.loopEnd = state.sequenceLength;
  
  Tone.Transport.loop = true;
  Tone.Transport.loopEnd = state.sequenceLength * Tone.Time(state.resolution).toSeconds();
  
  loop.start(0);
  window.mainLoop = loop; // Store reference for disposal
  
  sequencerInitialized = true;
}

// -------------------- Lightweight Sequencer Rebuild --------------------
function initAudioLight() {
  // Reuse the existing master bus, FX, instruments, metronome, etc.
  // Only rebuild the main sequencer loop + Transport timing.

  // Kill the old loop if it exists
  if (window.mainLoop) {
    try {
      window.mainLoop.stop();
      window.mainLoop.dispose();
    } catch (e) {
      console.warn('Error disposing mainLoop (light):', e);
    }
    window.mainLoop = null;
  }

  // Transport timing based on current state
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Main sequencer loop - DYNAMIC LENGTH (same logic as in initAudio)
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);

    const activeInsts = Object.keys(instruments).filter(inst =>
      patterns[inst][step]?.active
    );

    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');

    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });

    melodicInsts.forEach((inst, idx) => {
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002;
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });

    updateVisualizer();
  },
  Array.from({ length: state.sequenceLength }, (_, i) => i),
  state.resolution);

  loop.loop = true;
  loop.loopEnd = state.sequenceLength;

  Tone.Transport.loop = true;
  Tone.Transport.loopEnd =
    state.sequenceLength * Tone.Time(state.resolution).toSeconds();

  loop.start(0);
  window.mainLoop = loop;

  sequencerInitialized = true;
}

// In createInstrumentChain function (around line ~676), replace with:
function createInstrumentChain(inst) {
  const instData = instruments[inst];
  
  if (instData.type === 'drum') {
    synths[inst] = createDrumSynth(inst);
  } else if (instData.type === 'atmospheric') {
    synths[inst] = createFallbackDrumSynth(inst); // Use synths for atmospheric
    synths[inst].volume = { value: instData.volume };
  } else {
    synths[inst] = createMelodicSynth(inst);
    synths[inst].volume.value = instData.volume;
  }
  
  // Create channel - completely dry, no reverb sends
  const channel = new Tone.Channel({
    pan: 0,
    volume: instData.volume
  }).connect(master.fxIn);
  
  instData.channel = channel;
  synths[inst].connect(channel);
}
  
// ============ DRUM SAMPLE SYSTEM ============
const DRUM_SAMPLES = {
  kick: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/kick.mp3',
  snare: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3',
  hihat: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3',
  tom: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/tom1.mp3',
  
  // FIXED: Using working CR78 samples
  clap: 'https://tonejs.github.io/audio/drum-samples/CR78/clap.mp3',
  rimshot: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3', // Using snare as fallback
  crash: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  ride: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  
  // NEW INSTRUMENTS - using Tone.js built-in sounds since we need synths anyway
  fx: null, // Will use synth
  riser: null, // Will use synth
  ambience: null // Will use synth
};

// Immutable copy of factory drum samples (for "Default" reset)
const DEFAULT_DRUM_SAMPLES = { ...DRUM_SAMPLES };

// ====================================================
// ðŸŽ¹ MUSIC-THEORY AWARE INSTRUMENT VARIATION SYSTEM
// ====================================================

// Use Tonal.js for proper theory (itâ€™s already in your project)
function getScaleNotes(baseKey = 'C', scaleType = 'minor', octave = 3) {
  try {
    const scale = Tonal.Scale.get(`${baseKey} ${scaleType}`);
    return scale.notes.map(n => `${n}${octave}`);
  } catch (err) {
    console.warn('Scale generation failed, falling back to C minor', err);
    return ['C3','D3','Eb3','F3','G3','Ab3','Bb3'];
  }
}

// If your Harmony tab defines a chord progression array like: 
// state.progression = [ ['C', 'E', 'G'], ['A', 'C', 'E'], ... ]
function getChordForBar(barIndex = 0) {
  if (!state.progression || !state.progression.length) return null;
  return state.progression[barIndex % state.progression.length];
}

// Return a note appropriate for instrument & current harmony
function getInstrumentNote(instName, stepIndex = 0, currentChord = null) {
  if (currentChord && Array.isArray(currentChord)) {
    const note = currentChord[Math.floor(Math.random() * currentChord.length)];
    const octave = instName === 'bass' ? state.octave - 2 : state.octave;
    return `${note.replace(/\d/, '')}${octave}`;
  }

  const scaleNotes = Tonal.Scale.get(`${state.key} ${state.scale}`).notes.map(n => `${n}${state.octave}`);
  return scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
}


// Convert note to pitch shift
function getPlaybackRateForNote(note) {
  const semitones = Tone.Frequency(note).toMidi() - Tone.Frequency('C4').toMidi();
  return Math.pow(2, semitones / 12);
}

// Wrapper for triggering a sample with key variation
function triggerSampleWithVariation(instName, time) {
  const player = samplePlayers?.[instName];
  if (!player) return;

  if (INSTRUMENT_VARIATIONS[instName]) {
    const note = getInstrumentNote(instName);
    const rate = getPlaybackRateForNote(note);
    player.playbackRate = rate;
  } else {
    player.playbackRate = 1; // drums stay neutral
  }

  player.start(time);
}

function createDrumSynth(inst) {
  const sampleUrl = DRUM_SAMPLES[inst];

  if (!sampleUrl) {
    console.warn(`No sample for ${inst}, using fallback synth`);
    return createFallbackDrumSynth(inst);
  }

  // Use Tone.Player for single-shot samples
  const player = new Tone.Player({
    url: sampleUrl,
    fadeOut: 0.01,
    onload: () => console.log(`âœ… ${inst} loaded`),
    onerror: (err) => {
      console.error(`âŒ ${inst} failed to load:`, err);
      // Replace with fallback after short delay
      setTimeout(() => {
        if (!player.loaded) {
          synths[inst] = createFallbackDrumSynth(inst);
          console.log(`ðŸ”„ Using fallback synth for ${inst}`);
        }
      }, 3000);
    }
  });

  // Per-player gain
  const BASE_GAIN = 0.6; // ~-4 dB
  const playerGain = new Tone.Gain(BASE_GAIN);
  player.connect(playerGain);

  return {
    // ==========================================================
    // Trigger with pitch variation for instruments
    // ==========================================================
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      if (!player.loaded) return;
    
      player.stop(time);
      const safeVel = Math.min(velocity, 0.9);
      playerGain.gain.setValueAtTime(BASE_GAIN * safeVel, time);
    
      // ðŸŽ¹ Apply music-theory-based pitch variation
      if (['piano','guitar','bass','synth','strings','pad','lead'].includes(inst)) {
        const noteName = getInstrumentNote(inst, 0, state.currentChord || state.progression[0]);
        const rate = getPlaybackRateForNote(noteName);
        player.playbackRate = rate;
      } else {
        player.playbackRate = 1; // keep drums neutral
      }
    
      player.start(time);
    },

    connect: (node) => {
      playerGain.disconnect();
      playerGain.connect(node);
      return playerGain;
    },

    toDestination: () => playerGain.toDestination(),
    dispose: () => {
      player.dispose();
      playerGain.dispose();
    },
    get loaded() {
      return player.loaded;
    },
    player,
    gain: playerGain
  };
}

// Add this new function after createDrumSynth
function createFallbackDrumSynth(inst) {
  let synth;
  
  switch(inst) {
    case 'kick':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
      });
      break;
      
    case 'snare':
      synth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
      });
      break;
      
    case 'hihat':
      synth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'crash':
      synth = new Tone.MetalSynth({
        frequency: 100,
        envelope: { attack: 0.001, decay: 1.4, release: 2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'ride':
      synth = new Tone.MetalSynth({
        frequency: 150,
        envelope: { attack: 0.001, decay: 0.8, release: 0.5 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'clap':
      // Layered noise bursts for clap sound
      const clap = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      const clap2 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.015, decay: 0.03, sustain: 0 }
      });
      const clap3 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.025, decay: 0.02, sustain: 0 }
      });
      
      // Merge into one synth
      const clapGain = new Tone.Gain(1);
      clap.connect(clapGain);
      clap2.connect(clapGain);
      clap3.connect(clapGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          clap.triggerAttackRelease(duration, time, velocity);
          clap2.triggerAttackRelease(duration, time + 0.015, velocity * 0.7);
          clap3.triggerAttackRelease(duration, time + 0.025, velocity * 0.5);
        },
        connect: (node) => clapGain.connect(node),
        toDestination: () => clapGain.toDestination(),
        dispose: () => {
          clap.dispose();
          clap2.dispose();
          clap3.dispose();
          clapGain.dispose();
        },
        loaded: true
      };
      
    case 'rimshot':
      synth = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      break;
      
    case 'tom':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8 }
      });
      break;
      
    // NEW ATMOSPHERIC SYNTHS
    case 'fx':
      // Glitchy stutter effect
      const fxSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
        harmonicity: 12,
        modulationIndex: 50,
        resonance: 2000,
        octaves: 0.5
      });
      const fxGain = new Tone.Gain(0.2);
      fxSynth.connect(fxGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          fxSynth.triggerAttackRelease('32n', time, velocity * 0.3);
        },
        connect: (node) => fxGain.connect(node),
        toDestination: () => fxGain.toDestination(),
        dispose: () => {
          fxSynth.dispose();
          fxGain.dispose();
        },
        loaded: true
      };
      
    case 'riser':
      // Sweeping frequency riser
      synth = new Tone.FMSynth({
        harmonicity: 3,
        modulationIndex: 10,
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 2, decay: 0.1, sustain: 0.1, release: 0.5 },
        modulation: { type: 'square' },
        modulationEnvelope: { attack: 2, decay: 0.2, sustain: 0.5, release: 0.3 }
      });
      break;
      
    case 'ambience':
      // Dark atmospheric pad
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sine' },
        envelope: { attack: 1, decay: 1, sustain: 0.5, release: 2 }
      });
      
      // Add reverb for atmosphere
      const ambReverb = new Tone.Reverb({
        decay: 8,
        wet: 0.7
      });
      ambReverb.generate();
      synth.connect(ambReverb);
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          synth.triggerAttackRelease(note, duration, time, velocity);
        },
        connect: (node) => {
          ambReverb.disconnect();
          ambReverb.connect(node);
          return ambReverb;
        },
        toDestination: () => ambReverb.toDestination(),
        dispose: () => {
          synth.dispose();
          ambReverb.dispose();
        },
        loaded: true
      };
      
    default:
      synth = new Tone.MembraneSynth();
  }
  
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      synth.triggerAttackRelease(note, duration, time, velocity);
    },
    connect: (node) => synth.connect(node),
    toDestination: () => synth.toDestination(),
    dispose: () => synth.dispose(),
    loaded: true
  };
}

function playDrumNote(inst, time, velocity) {
  const synth = synths[inst];
  if (!synth) {
    console.warn(`No synth for ${inst}`);
    return;
  }
  
  // Check if sample is loaded
  if (!synth.loaded) {
    console.warn(`${inst} sample not loaded yet`);
    return;
  }
  
  // All drums trigger at same pitch - sample handles the sound
  synth.triggerAttackRelease('C2', '8n', time, velocity * 0.9);
}

// Melodic instrument samples using Tone.Sampler
const MELODIC_SAMPLES = {
  bass: {
    'C2': 'https://tonejs.github.io/audio/salamander/C2.mp3',
    'D#2': 'https://tonejs.github.io/audio/salamander/Ds2.mp3',
    'F#2': 'https://tonejs.github.io/audio/salamander/Fs2.mp3',
    'A2': 'https://tonejs.github.io/audio/salamander/A2.mp3'
  },
  guitar: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3'
  },
  keys: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3'
  },
  lead: {
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3',
    'D#5': 'https://tonejs.github.io/audio/salamander/Ds5.mp3',
    'F#5': 'https://tonejs.github.io/audio/salamander/Fs5.mp3',
    'A5': 'https://tonejs.github.io/audio/salamander/A5.mp3'
  }
};

function createMelodicSynth(inst) {
  const samples = MELODIC_SAMPLES[inst];
  
  if (!samples) {
    console.warn(`No samples for ${inst}, using fallback synth`);
    return new Tone.PolySynth(Tone.Synth);
  }
  
  const sampler = new Tone.Sampler({
    urls: samples,
    release: 2, // Longer release = more dreamy
    onload: () => {
      console.log(`âœ… ${inst} samples loaded`);
    }
  });

  sampler.volume.value = -6;
  
  switch (inst) {
    case 'bass':
      const bassComp = new Tone.Compressor(-30, 3);
      const bassDist = new Tone.Distortion(0.1);
      sampler.chain(bassDist, bassComp);
      return sampler;
      
    case 'guitar':
      // MORE reverb and chorus for dreamier sound
      const guitarReverb = new Tone.Reverb({
        decay: 3,
        wet: 0.4
      });
      guitarReverb.generate();
      
      const guitarChorus = new Tone.Chorus({
        frequency: 0.5, // Slower = dreamier
        delayTime: 3.5,
        depth: 0.3,
        type: 'sine',
        spread: 180
      }).start();
      
      sampler.chain(guitarChorus, guitarReverb);
      return sampler;
      
    case 'keys':
      // Dark pad sound
      const keysReverb = new Tone.Reverb({
        decay: 4,
        wet: 0.5
      });
      keysReverb.generate();
      
      const keysChorus = new Tone.Chorus(0.3, 4, 0.4).start();
      
      sampler.chain(keysChorus, keysReverb);
      return sampler;
      
    case 'lead':
      // Ethereal lead
      const leadReverb = new Tone.Reverb({
        decay: 5,
        wet: 0.6
      });
      leadReverb.generate();
      
      const leadDelay = new Tone.FeedbackDelay({
        delayTime: '8n',
        feedback: 0.4,
        wet: 0.3
      });
      
      sampler.chain(leadDelay, leadReverb);
      return sampler;
      
    default:
      return sampler;
  }
}

function playStep(inst, step, time) {
  const instPattern = patterns[inst];
  if (!instPattern) return;

  const stepData = instPattern[step];
  if (!stepData || !stepData.active) return;
  
  const instData = instruments[inst];
  if (instData.mute) return;
  
  const anySolo = Object.values(instruments).some(i => i.solo);
  if (anySolo && !instData.solo) return;
  
  if (Math.random() * 100 > stepData.probability) return;
  
  // ðŸ”¥ FIX: Check if sample is loaded before playing
  const synth = synths[inst];
  if (instData.type === 'drum' && synth && !synth.loaded) {
    console.warn(`âš ï¸ ${inst} sample not loaded, skipping step`);
    return;
  }
  
  // Per-instrument humanization scaling
  const humanizeScale = {
    kick: 0.5,
    snare: 0.7,
    hihat: 1.2,
    bass: 0.6,
    guitar: 1.0,
    keys: 0.8,
    lead: 0.9,
    fx: 0.3,
    riser: 0.1,
    ambience: 0.2
  };
  
  const scale = humanizeScale[inst] || 1.0;
  const humanize = (Math.random() - 0.5) * (state.humanize / 1000) * scale;
  
  let velocity = stepData.velocity;
  if (instData.type === 'drum') {
    velocity *= (0.95 + Math.random() * 0.1);
  }
  
  if (instData.type === 'drum') {
    playDrumNote(inst, time + humanize, velocity);
  } else if (instData.type === 'atmospheric') {
    playAtmosphericNote(inst, time + humanize, stepData);
  } else {
    playMelodicNote(inst, time + humanize, stepData);
  }
}

function playMelodicNote(inst, time, stepData) {
  const note = stepData.note || instruments[inst].note || 'C4';
  const duration = stepData.duration || '8n';
  synths[inst].triggerAttackRelease(note, duration, time, stepData.velocity);
}

function playAtmosphericNote(inst, time, stepData) {
  const duration = stepData.duration || '1n'; // Longer by default
  const velocity = stepData.velocity || 0.5;
  
  if (inst === 'fx') {
    // Glitchy FX - random pitch
    const pitch = ['C4', 'D#4', 'F#4', 'A#4'][Math.floor(Math.random() * 4)];
    synths[inst].triggerAttackRelease(pitch, '8n', time, velocity);
  } else if (inst === 'riser') {
    // Rising frequency sweep
    synths[inst].triggerAttackRelease('C2', '2n', time, velocity);
    // Add frequency sweep
    if (synths[inst].frequency) {
      synths[inst].frequency.exponentialRampTo('C6', '2n', time);
    }
  } else if (inst === 'ambience') {
    // Dark ambient chord
    const notes = ['C2', 'D#2', 'G2', 'A#2'];
    synths[inst].triggerAttackRelease(notes, duration, time, velocity * 0.4);
  }
}
  
// -------------------- Vibe System --------------------
function nextVibe() {
  const currentVibe = document.body.getAttribute('data-vibe') || 'moon';
  const currentIndex = VIBES.indexOf(currentVibe);
  const nextIndex = (currentIndex + 1) % VIBES.length;
  return VIBES[nextIndex];
}

function applyVibe(vibe) {
  document.body.setAttribute('data-vibe', vibe);
  try {
    localStorage.setItem(CONFIG.STORAGE_KEY, vibe);
    console.log('ðŸ’¾ Saved vibe:', vibe);
  } catch (e) {
    console.warn('localStorage unavailable:', e);
  }
  
  const label = vibe.charAt(0).toUpperCase() + vibe.slice(1);
  const btn = document.getElementById('vibeBtn');
  if (btn) btn.textContent = `ðŸŒˆ Vibe: ${label}`;
}

function loadSavedVibe() {
  try {
    const savedVibe = localStorage.getItem(CONFIG.STORAGE_KEY);
    if (savedVibe && VIBES.includes(savedVibe)) {
      applyVibe(savedVibe);
      console.log('âœ… Loaded saved vibe:', savedVibe);
    } else {
      applyVibe('moon');
    }
  } catch (e) {
    console.warn('Could not load vibe:', e);
    applyVibe('moon');
  }
}

function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      const next = nextVibe();
      applyVibe(next);
      console.log('ðŸŒˆ Switched to:', next);
    });
  }
}

// ==================== SONG BUILDER ENGINE ====================

// 16 steps per bar (your existing grid resolution)
const STEPS_PER_BAR = 16;

const SONG_TEMPLATES = {
  // --- POP / ROCK ---
  'intro-verse-chorus': [
    { id:'intro', label:'Intro', bars:4, energy:0.3, density:0.4, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.6, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus 1', bars:8, energy:0.9, density:0.8, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'bridge', label:'Bridge', bars:4, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.4, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'sustained', melodyStyle:'scale-run' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.6, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- EDM / HOUSE ---
  'short-edm-rise-drop': [
    { id:'intro', label:'Intro', bars:4, energy:0.4, density:0.5, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'build', label:'Build', bars:8, energy:0.7, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'break', label:'Break', bars:4, energy:0.5, density:0.4, swing:0, filterCutoff:0.8, reverb:0.6, variation:'a', drums:false, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drop2', label:'Drop 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.6, reverb:0.7, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- HIP-HOP / LOFI ---
  'hiphop-lofi': [
    { id:'intro', label:'Intro', bars:4, energy:0.3, density:0.4, swing:30, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:16, energy:0.6, density:0.5, swing:30, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'syncopated', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'hook', label:'Hook', bars:8, energy:0.8, density:0.7, swing:30, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'verse2', label:'Verse 2', bars:16, energy:0.7, density:0.5, swing:30, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'syncopated', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'hook2', label:'Hook 2', bars:8, energy:0.9, density:0.8, swing:30, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:30, filterCutoff:0.7, reverb:0.6, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- METAL / HARDCORE ---
  'metal-hardcore': [
    { id:'intro', label:'Intro Riff', bars:4, energy:0.7, density:0.7, swing:0, filterCutoff:1.0, reverb:0.2, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.2, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus 1', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.9, density:0.8, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'solo', label:'Solo', bars:8, energy:1.0, density:0.8, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'scale-run' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.6, density:0.5, swing:0, filterCutoff:0.8, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- AMBIENT / DOWNTEMPO ---
  'ambient-flow': [
    { id:'drift1', label:'Drift A', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.9, reverb:0.8, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drift2', label:'Drift B', bars:8, energy:0.4, density:0.4, swing:0, filterCutoff:0.95, reverb:0.7, variation:'b', drums:false, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drift3', label:'Drift C', bars:8, energy:0.5, density:0.5, swing:0, filterCutoff:1.0, reverb:0.6, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'fade', label:'Fade', bars:8, energy:0.2, density:0.2, swing:0, filterCutoff:0.7, reverb:0.9, variation:'a', drums:false, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- JAM / IMPROV LOOP ---
  'loop-jam': [
    { id:'a1', label:'A1', bars:8, energy:0.6, density:0.6, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'a2', label:'A2', bars:8, energy:0.7, density:0.7, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'b', label:'B', bars:8, energy:0.9, density:0.8, swing:10, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'a3', label:'A3', bars:8, energy:0.7, density:0.7, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' }
  ],

  // --- TRAP / MODERN HIP-HOP ---
  'trap-banger': [
    { id:'intro', label:'Intro', bars:4, energy:0.5, density:0.5, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'prechorus1', label:'Pre-Chorus', bars:4, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:1.0, density:0.8, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'bridge', label:'Bridge/Half-time', bars:8, energy:0.6, density:0.5, swing:0, filterCutoff:0.9, reverb:0.6, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:true, bass:true, chords:false, lead:false, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- PROGRESSIVE HOUSE / TRANCE ---
  'progressive-house': [
    { id:'intro', label:'Intro', bars:8, energy:0.3, density:0.4, swing:0, filterCutoff:0.8, reverb:0.5, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup1', label:'Build 1', bars:8, energy:0.6, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup2', label:'Build 2', bars:8, energy:0.7, density:0.8, swing:0, filterCutoff:0.95, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'scale-run' },
    { id:'drop2', label:'Drop 2', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.6, reverb:0.8, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- FUNK / DISCO ---
  'funk-groove': [
    { id:'intro', label:'Intro', bars:4, energy:0.5, density:0.6, swing:20, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.7, density:0.7, swing:20, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:0.9, density:0.8, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.7, swing:20, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.6, density:0.5, swing:20, filterCutoff:0.9, reverb:0.5, variation:'c', drums:false, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Vamp Out', bars:8, energy:0.8, density:0.7, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' }
  ],

  // --- JAZZ / FUSION ---
  'jazz-standard': [
    { id:'head-in', label:'Head In', bars:16, energy:0.6, density:0.6, swing:50, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'solo1', label:'Solo Section 1', bars:16, energy:0.7, density:0.7, swing:50, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'scale-run' },
    { id:'solo2', label:'Solo Section 2', bars:16, energy:0.8, density:0.8, swing:50, filterCutoff:1.0, reverb:0.4, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'dense' },
    { id:'head-out', label:'Head Out', bars:16, energy:0.7, density:0.6, swing:50, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'tag', label:'Tag', bars:4, energy:0.5, density:0.4, swing:50, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- DUBSTEP / BASS MUSIC ---
  'dubstep-wobble': [
    { id:'intro', label:'Intro', bars:8, energy:0.4, density:0.4, swing:0, filterCutoff:0.8, reverb:0.5, variation:'a', drums:true, bass:false, chords:true, lead:true, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup', label:'Build Up', bars:8, energy:0.7, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:false, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.6, reverb:0.8, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup2', label:'Build 2', bars:4, energy:0.8, density:0.8, swing:0, filterCutoff:0.95, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'scale-run' },
    { id:'drop2', label:'Drop 2', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:false, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- REGGAE / DUB ---
  'reggae-dub': [
    { id:'intro', label:'Intro Skank', bars:8, energy:0.5, density:0.5, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:16, energy:0.6, density:0.5, swing:10, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:0.8, density:0.7, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'verse2', label:'Verse 2', bars:16, energy:0.6, density:0.5, swing:10, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'dub-section', label:'Dub Drop', bars:16, energy:0.7, density:0.6, swing:10, filterCutoff:0.8, reverb:0.8, variation:'c', drums:true, bass:true, chords:false, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus Out', bars:8, energy:0.8, density:0.7, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' }
  ]
};

  // At the top with other state
let songBuilderState = {
  templateId: 'intro-verse-chorus',
  sections: SONG_TEMPLATES['intro-verse-chorus'].map(s => ({ ...s })),
  fillEvery: 4,
  isActive: false  // ADD THIS FLAG
};
  
// Small helper for safe step activation
function sbSetStep(inst, stepIndex, opts = {}) {
  const arr = patterns[inst];
  if (!arr || stepIndex < 0 || stepIndex >= arr.length) return;
  const step = arr[stepIndex];
  const {
    velocity   = 0.8,
    probability = 100,
    note       = step.note || instruments[inst]?.note,
    duration   = '8n'
  } = opts;

  step.active = true;
  step.velocity = velocity;
  step.probability = probability;
  step.note = note;
  step.duration = duration;
}

function getSongBuilderTotalBars() {
  return songBuilderState.sections.reduce((sum, s) => sum + (s.bars || 0), 0);
}

function randomizeSongBuilderSections() {
  if (!songBuilderState.sections || !songBuilderState.sections.length) return;

  const template = SONG_TEMPLATES[songBuilderState.templateId] || songBuilderState.sections;

  const drumPatterns  = ['four-floor', 'breakbeat', 'trap', 'half-time'];
  const bassPatterns  = ['root-fifth', 'walking', 'syncopated', 'pedal'];
  const chordPatterns = ['sustained', 'arpeggiated', 'rhythmic', 'staccato'];
  const melodyStyles  = ['sparse', 'motif', 'scale-run', 'dense'];

  const randFrom = (arr, prefer) => {
    // 40% chance to keep the current/base value so it still â€œfeelsâ€ like the template,
    // otherwise pick something else
    if (prefer && arr.includes(prefer) && Math.random() < 0.4) return prefer;
    return arr[Math.floor(Math.random() * arr.length)];
  };

  const energyJitter  = 0.18;  // how far we can nudge energy
  const densityJitter = 0.20;  // how far we can nudge density

  songBuilderState.sections = songBuilderState.sections.map((section, idx) => {
    const base = template[idx] || section;

    const baseEnergy  = typeof base.energy  === 'number' ? base.energy  : (section.energy  ?? 0.7);
    const baseDensity = typeof base.density === 'number' ? base.density : (section.density ?? 0.7);

    let energy  = baseEnergy  + ((Math.random() * 2 - 1) * energyJitter);
    let density = baseDensity + ((Math.random() * 2 - 1) * densityJitter);

    energy  = clamp(energy,  0.1, 1.0);
    density = clamp(density, 0.15, 1.0);

    // --- Instrument on/off toggles ---
    let drums  = base.drums;
    let bass   = base.bass;
    let chords = base.chords;
    let lead   = base.lead;

    const id = (base.id || section.id || '').toLowerCase();
    const isIntro = id.includes('intro');
    const isOutro = id.includes('outro') || id.includes('end');
    const isBreak = id.includes('break') || id.includes('dub') || id.includes('drop');

    const flip = (value, prob) => (Math.random() < prob ? !value : value);

    if (isIntro) {
      drums  = flip(drums, 0.25);
      bass   = flip(bass, 0.35);
      chords = flip(chords, 0.15);
      lead   = flip(lead, 0.40);
    } else if (isOutro) {
      drums  = flip(drums, 0.20);
      bass   = flip(bass, 0.25);
      chords = flip(chords, 0.25);
      lead   = flip(lead, 0.50);
    } else if (isBreak) {
      drums  = flip(drums, 0.35);
      bass   = flip(bass, 0.45);
      chords = flip(chords, 0.40);
      lead   = flip(lead, 0.40);
    } else {
      // verses / choruses: subtle variation
      drums  = flip(drums, 0.15);
      bass   = flip(bass, 0.15);
      chords = flip(chords, 0.15);
      lead   = flip(lead, 0.30);
    }

    // Make sure we donâ€™t kill *all* harmonic content
    if (!bass && !chords && !lead) {
      chords = true;
    }

    const drumPattern  = randFrom(drumPatterns,  base.drumPattern  || section.drumPattern);
    const bassPattern  = randFrom(bassPatterns,  base.bassPattern  || section.bassPattern);
    const chordPattern = randFrom(chordPatterns, base.chordPattern || section.chordPattern);
    const melodyStyle  = randFrom(melodyStyles,  base.melodyStyle  || section.melodyStyle);

    return {
      ...section,
      energy,
      density,
      drums,
      bass,
      chords,
      lead,
      drumPattern,
      bassPattern,
      chordPattern,
      melodyStyle
      // bars stay as-is so your total length + 512-step cap stay predictable
    };
  });

  // Re-render the table so sliders / selects / toggles reflect the new values
  renderSongBuilderSections();
}

function applySongTemplate(id) {
  const tpl = SONG_TEMPLATES[id];
  if (!tpl) return;
  songBuilderState.templateId = id;
  songBuilderState.sections = tpl.map(s => ({ ...s }));
  renderSongBuilderSections();
}

// === UI rendering for the table ===
function renderSongBuilderSections() {
  const tbody = document.getElementById('songSectionsTable');
  const totalLabel = document.getElementById('songTotalBarsLabel');
  if (!tbody) return;
  tbody.innerHTML = '';
  
  songBuilderState.sections.forEach((section, index) => {
    const tr = document.createElement('tr');
    tr.dataset.index = index;
    
    tr.innerHTML = `
      <td style="padding:6px 4px;">
        <span>${section.label}</span>
      </td>
      <td style="padding:6px 4px;">
        <input type="number"
               class="input"
               min="2" max="64"
               value="${section.bars}"
               data-field="bars"
               style="width:56px; padding:2px 4px; font-size:10px;">
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="range"
                 min="0" max="100"
                 value="${Math.round((section.energy || 0) * 100)}"
                 data-field="energy"
                 style="flex:1;">
          <span style="width:32px; text-align:right;">
            ${Math.round((section.energy || 0) * 100)}%
          </span>
        </div>
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="range"
                 min="0" max="100"
                 value="${Math.round((section.density || 0.7) * 100)}"
                 data-field="density"
                 style="flex:1;">
          <span style="width:32px; text-align:right;">
            ${Math.round((section.density || 0.7) * 100)}%
          </span>
        </div>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="drumPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="four-floor" ${(section.drumPattern || 'four-floor') === 'four-floor' ? 'selected' : ''}>4-Floor</option>
          <option value="breakbeat" ${section.drumPattern === 'breakbeat' ? 'selected' : ''}>Breakbeat</option>
          <option value="trap" ${section.drumPattern === 'trap' ? 'selected' : ''}>Trap</option>
          <option value="half-time" ${section.drumPattern === 'half-time' ? 'selected' : ''}>Half-time</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="bassPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="root-fifth" ${(section.bassPattern || 'root-fifth') === 'root-fifth' ? 'selected' : ''}>Root-Fifth</option>
          <option value="walking" ${section.bassPattern === 'walking' ? 'selected' : ''}>Walking</option>
          <option value="syncopated" ${section.bassPattern === 'syncopated' ? 'selected' : ''}>Syncopated</option>
          <option value="pedal" ${section.bassPattern === 'pedal' ? 'selected' : ''}>Pedal</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="chordPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="sustained" ${(section.chordPattern || 'sustained') === 'sustained' ? 'selected' : ''}>Sustained</option>
          <option value="staccato" ${section.chordPattern === 'staccato' ? 'selected' : ''}>Staccato</option>
          <option value="arpeggiated" ${section.chordPattern === 'arpeggiated' ? 'selected' : ''}>Arpeggiated</option>
          <option value="rhythmic" ${section.chordPattern === 'rhythmic' ? 'selected' : ''}>Rhythmic</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="melodyStyle" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="motif" ${(section.melodyStyle || 'motif') === 'motif' ? 'selected' : ''}>Motif</option>
          <option value="scale-run" ${section.melodyStyle === 'scale-run' ? 'selected' : ''}>Scale Run</option>
          <option value="sparse" ${section.melodyStyle === 'sparse' ? 'selected' : ''}>Sparse</option>
          <option value="dense" ${section.melodyStyle === 'dense' ? 'selected' : ''}>Dense</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <label><input type="checkbox" data-field="drums"  ${section.drums  ? 'checked' : ''}> Drums</label>
          <label><input type="checkbox" data-field="bass"   ${section.bass   ? 'checked' : ''}> Bass</label>
          <label><input type="checkbox" data-field="chords" ${section.chords ? 'checked' : ''}> Chords</label>
          <label><input type="checkbox" data-field="lead"   ${section.lead   ? 'checked' : ''}> Lead</label>
        </div>
      </td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Wire changes
  tbody.querySelectorAll('input, select').forEach(input => {
    input.addEventListener('change', e => {
      const row = e.target.closest('tr');
      const idx = parseInt(row.dataset.index, 10);
      const field = e.target.dataset.field;
      const section = songBuilderState.sections[idx];
      if (!section) return;
      
      if (field === 'bars') {
        const v = Math.max(2, Math.min(64, parseInt(e.target.value || '0', 10)));
        section.bars = v;
        e.target.value = v;
      } else if (field === 'energy') {
        const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
        section.energy = pct / 100;
        const label = row.querySelector('td:nth-child(3) span:last-child');
        if (label) label.textContent = pct + '%';
      } else if (field === 'density') {
        const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
        section.density = pct / 100;
        const label = row.querySelector('td:nth-child(4) span:last-child');
        if (label) label.textContent = pct + '%';
      } else if (['drumPattern', 'bassPattern', 'chordPattern', 'melodyStyle'].includes(field)) {
        section[field] = e.target.value;
      } else if (['drums','bass','chords','lead'].includes(field)) {
        section[field] = e.target.checked;
      }
      
      if (totalLabel) {
        totalLabel.textContent = getSongBuilderTotalBars();
      }
    });
    
    // For range inputs, also update on 'input' event for live feedback
    if (input.type === 'range') {
      input.addEventListener('input', e => {
        const row = e.target.closest('tr');
        const idx = parseInt(row.dataset.index, 10);
        const field = e.target.dataset.field;
        const section = songBuilderState.sections[idx];
        if (!section) return;
        
        if (field === 'energy') {
          const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
          section.energy = pct / 100;
          const label = row.querySelector('td:nth-child(3) span:last-child');
          if (label) label.textContent = pct + '%';
        } else if (field === 'density') {
          const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
          section.density = pct / 100;
          const label = row.querySelector('td:nth-child(4) span:last-child');
          if (label) label.textContent = pct + '%';
        }
      });
    }
  });
  
  if (totalLabel) {
    totalLabel.textContent = getSongBuilderTotalBars();
  }
}
  
// === Core generation ===

function wipeAllPatterns() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
}

// --- Song Builder randomness helpers ---

function sbClamp01(v) {
  return Math.max(0, Math.min(1, v));
}

function sbEnergyBand(e) {
  if (e <= 0.4) return 'low';
  if (e >= 0.75) return 'high';
  return 'mid';
}

function sbPick(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

// Create a fresh, slightly randomized copy of the current sections
function randomizeSongBuilderSectionsForRun() {
  // Shallow clone each section so we don't mutate the UI state
  const sections = songBuilderState.sections.map(s => ({ ...s }));

  const variations = ['a', 'b', 'c'];

  const DRUM_PATTERN_POOL = {
    low: ['four-floor', 'half-time'],
    mid: ['four-floor', 'breakbeat', 'trap'],
    high: ['breakbeat', 'trap', 'four-floor']
  };

  const BASS_PATTERN_POOL = {
    low: ['root-fifth', 'pedal'],
    mid: ['root-fifth', 'syncopated', 'walking'],
    high: ['syncopated', 'walking', 'root-fifth']
  };

  const CHORD_PATTERN_POOL = {
    low: ['sustained', 'arpeggiated'],
    mid: ['sustained', 'staccato', 'rhythmic'],
    high: ['staccato', 'rhythmic', 'arpeggiated']
  };

  const MELODY_STYLE_POOL = {
    low: ['motif', 'sparse'],
    mid: ['motif', 'scale-run', 'sparse'],
    high: ['motif', 'dense', 'scale-run']
  };

  sections.forEach((section) => {
    const baseEnergy = section.energy ?? 0.6;
    const baseDensity = section.density ?? 0.7;
    const band = sbEnergyBand(baseEnergy);

    // Slight wiggle in density & energy so groove changes feel
    section.density = sbClamp01(baseDensity + (Math.random() - 0.5) * 0.25); // Â±0.125
    section.energy  = sbClamp01(baseEnergy  + (Math.random() - 0.5) * 0.20); // Â±0.10

    // Vary bars a bit (but keep intros/outros mostly stable)
    if (section.bars >= 4 && section.id !== 'intro' && section.id !== 'outro') {
      const deltaOptions = [0, 0, 0, 4, -4]; // mostly same, sometimes Â±4
      const delta = sbPick(deltaOptions);
      const newBars = Math.max(2, Math.min(64, section.bars + delta));
      section.bars = newBars;
    }

    // Random variation tag
    if (Math.random() < 0.8) {
      section.variation = sbPick(variations);
    }

    // Pattern swaps â€“ only if that lane is enabled for the section
    if (section.drums) {
      const pool = DRUM_PATTERN_POOL[band];
      if (pool && pool.length && Math.random() < 0.9) {
        const current = section.drumPattern || 'four-floor';
        const candidates = pool.filter(p => p !== current);
        if (candidates.length) {
          section.drumPattern = sbPick(candidates);
        }
      }
    }

    if (section.bass) {
      const pool = BASS_PATTERN_POOL[band];
      if (pool && pool.length && Math.random() < 0.8) {
        const current = section.bassPattern || 'root-fifth';
        const candidates = pool.filter(p => p !== current);
        if (candidates.length) {
          section.bassPattern = sbPick(candidates);
        }
      }
    }

    if (section.chords) {
      const pool = CHORD_PATTERN_POOL[band];
      if (pool && pool.length && Math.random() < 0.8) {
        const current = section.chordPattern || 'sustained';
        const candidates = pool.filter(p => p !== current);
        if (candidates.length) {
          section.chordPattern = sbPick(candidates);
        }
      }
    }

    if (section.lead) {
      const pool = MELODY_STYLE_POOL[band];
      if (pool && pool.length && Math.random() < 0.9) {
        const current = section.melodyStyle || 'motif';
        const candidates = pool.filter(p => p !== current);
        if (candidates.length) {
          section.melodyStyle = sbPick(candidates);
        }
      }
    }
  });

  return sections;
}


function generateSectionDrums(section, startBar, endBar) {
  if (!section.drums) return;
  
  const drumPattern = section.drumPattern || 'four-floor';
  const density = section.density || 0.7;
  const energy = section.energy || 0.7;
  const fillEvery = songBuilderState.fillEvery || 0;
  
  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    
    switch(drumPattern) {
      case 'four-floor':
        // Kick on every beat
        [0, 4, 8, 12].forEach(s => sbSetStep('kick', offset + s, { velocity: 0.9 }));
        // Snare on 2 & 4
        sbSetStep('snare', offset + 4, { velocity: 0.9 });
        sbSetStep('snare', offset + 12, { velocity: 0.95 });
        // Hi-hats on 8ths
        if (patterns.hihat) {
          for (let i = 0; i < 16; i += 2) {
            if (Math.random() < density) {
              sbSetStep('hihat', offset + i, { velocity: 0.5 + energy * 0.3 });
            }
          }
        }
        break;
        
      case 'breakbeat':
        // Syncopated breakbeat feel
        sbSetStep('kick', offset + 0, { velocity: 0.95 });
        sbSetStep('kick', offset + 6, { velocity: 0.7 });
        sbSetStep('kick', offset + 10, { velocity: 0.75 });
        sbSetStep('snare', offset + 4, { velocity: 0.9 });
        sbSetStep('snare', offset + 12, { velocity: 0.95 });
        if (patterns.hihat && density > 0.5) {
          for (let i = 0; i < 16; i++) {
            if (Math.random() < 0.6 * density) {
              sbSetStep('hihat', offset + i, { velocity: 0.4 + Math.random() * 0.3 });
            }
          }
        }
        break;
        
      case 'trap':
        // Trap hi-hat rolls
        sbSetStep('kick', offset + 0, { velocity: 0.95 });
        sbSetStep('kick', offset + 8, { velocity: 0.85 });
        if (energy > 0.7) sbSetStep('kick', offset + 14, { velocity: 0.75 });
        sbSetStep('snare', offset + 4, { velocity: 0.9 });
        sbSetStep('snare', offset + 12, { velocity: 0.95 });
        // Rapid hi-hat patterns
        if (patterns.hihat) {
          const rollStart = Math.random() < 0.5 ? 6 : 14;
          for (let i = 0; i < 16; i++) {
            const isRoll = i >= rollStart && i < rollStart + 2;
            const prob = isRoll ? 0.9 : (i % 2 === 1 ? 0.7 : 0.3);
            if (Math.random() < prob * density) {
              sbSetStep('hihat', offset + i, { 
                velocity: 0.4 + (isRoll ? 0.4 : 0.2) * energy,
                probability: isRoll ? 95 : 75
              });
            }
          }
        }
        break;
        
      case 'half-time':
        // Half-time feel (slower kick/snare)
        if (bar % 2 === 0) {
          sbSetStep('kick', offset + 0, { velocity: 0.95 });
          sbSetStep('snare', offset + 8, { velocity: 0.9 });
        }
        if (patterns.hihat) {
          for (let i = 0; i < 16; i += 2) {
            if (Math.random() < 0.7 * density) {
              sbSetStep('hihat', offset + i, { velocity: 0.5 });
            }
          }
        }
        break;
    }
    
    // Add fills
    if (fillEvery && ((bar + 1) % fillEvery === 0) && energy > 0.5) {
      const fillLength = Math.floor(4 * density);
      for (let i = STEPS_PER_BAR - fillLength; i < STEPS_PER_BAR; i++) {
        if (Math.random() < 0.7) {
          const inst = Math.random() < 0.5 ? 'snare' : 'kick';
          sbSetStep(inst, offset + i, {
            velocity: 0.6 + 0.3 * Math.random(),
            probability: 75 + Math.floor(20 * Math.random())
          });
        }
      }
    }
  }
}

function generateSectionBass(section, startBar, endBar) {
  if (!section.bass) return;
  if (!patterns.bass) return;
  
  const bassOct = (state.octave || 3) - 2;
  const bassPattern = section.bassPattern || 'root-fifth';
  const density = section.density || 0.7;
  const energy = section.energy || 0.6;
  
  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale);
    const [root, third, fifth] = chord.map(n => n.replace(/\d/, ''));
    
    switch(bassPattern) {
      case 'root-fifth':
        // Classic root-fifth pattern
        sbSetStep('bass', offset + 0, { note: withOct(root, bassOct), velocity: 0.85, duration: '4n' });
        sbSetStep('bass', offset + 8, { note: withOct(fifth, bassOct), velocity: 0.75, duration: '4n' });
        if (energy > 0.7) {
          sbSetStep('bass', offset + 12, { note: withOct(root, bassOct), velocity: 0.7, duration: '8n' });
        }
        break;
        
      case 'walking':
        // Walking bass line
        const walkingNotes = [root, third, fifth, third];
        [0, 4, 8, 12].forEach((step, i) => {
          sbSetStep('bass', offset + step, {
            note: withOct(walkingNotes[i], bassOct),
            velocity: 0.75 - (i * 0.05),
            duration: '4n'
          });
        });
        break;
        
      case 'syncopated':
        // Syncopated funk bass
        sbSetStep('bass', offset + 0, { note: withOct(root, bassOct), velocity: 0.9, duration: '8n' });
        sbSetStep('bass', offset + 3, { note: withOct(root, bassOct), velocity: 0.7, duration: '16n' });
        sbSetStep('bass', offset + 6, { note: withOct(fifth, bassOct), velocity: 0.75, duration: '8n' });
        sbSetStep('bass', offset + 10, { note: withOct(third, bassOct), velocity: 0.7, duration: '8n' });
        if (density > 0.6) {
          sbSetStep('bass', offset + 14, { note: withOct(root, bassOct), velocity: 0.65, duration: '16n' });
        }
        break;
        
      case 'pedal':
        // Pedal tone (root held throughout)
        sbSetStep('bass', offset + 0, { note: withOct(root, bassOct), velocity: 0.8, duration: '1n' });
        break;
    }
  }
}

function generateSectionChords(section, startBar, endBar) {
  if (!section.chords) return;
  if (!patterns.keys) return;
  
  const keysOct = state.octave || 3;
  const chordPattern = section.chordPattern || 'sustained';
  const energy = section.energy || 0.5;
  const density = section.density || 0.7;
  
  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale);
    const [root, third, fifth] = chord.map(n => n.replace(/\d/, ''));
    
    switch(chordPattern) {
      case 'sustained':
        // Long pad chords
        sbSetStep('keys', offset + 0, { 
          note: withOct(root, keysOct), 
          velocity: 0.5 + 0.2 * energy, 
          duration: '1n' 
        });
        sbSetStep('keys', offset + 0, { 
          note: withOct(third, keysOct), 
          velocity: 0.45 + 0.2 * energy, 
          duration: '1n' 
        });
        sbSetStep('keys', offset + 0, { 
          note: withOct(fifth, keysOct), 
          velocity: 0.45 + 0.2 * energy, 
          duration: '1n' 
        });
        break;
        
      case 'staccato':
        // Short, punchy chords
        [0, 4, 8, 12].forEach(step => {
          if (Math.random() < density) {
            [root, third, fifth].forEach((note, i) => {
              sbSetStep('keys', offset + step, {
                note: withOct(note, keysOct),
                velocity: 0.7 + 0.2 * energy,
                duration: '16n'
              });
            });
          }
        });
        break;
        
      case 'arpeggiated':
        // Arpeggiated chords
        const arpNotes = [root, third, fifth, third];
        arpNotes.forEach((note, i) => {
          const step = i * 4;
          sbSetStep('keys', offset + step, {
            note: withOct(note, keysOct),
            velocity: 0.6 + 0.15 * energy,
            duration: '8n'
          });
        });
        break;
        
      case 'rhythmic':
        // Rhythmic stabs on specific beats
        const stabSteps = [0, 6, 8, 14];
        stabSteps.forEach(step => {
          if (Math.random() < 0.8 * density) {
            [root, third, fifth].forEach(note => {
              sbSetStep('keys', offset + step, {
                note: withOct(note, keysOct),
                velocity: 0.65 + 0.25 * energy,
                duration: '8n'
              });
            });
          }
        });
        break;
    }
  }
}

function generateSectionMelody(section, startBar, endBar) {
  if (!section.lead) return;
  if (!patterns.lead) return;
  
  const leadOct = (state.octave || 3) + 1;
  const melodyStyle = section.melodyStyle || 'motif';
  const density = section.density || 0.6;
  const energy = section.energy || 0.5;
  
  let motif = []; // Store motif for repetition
  
  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale);
    const pcs = chord.map(n => n.replace(/\d/, ''));
    
    // Add scale tones for passing notes
    const scaleNotes = getScaleNotes(state.key, state.scale);
    const allNotes = [...new Set([...pcs, ...scaleNotes])];
    
    switch(melodyStyle) {
      case 'motif':
        // Repeating melodic motif
        if (motif.length === 0 || bar % 4 === 0) {
          // Create new motif every 4 bars
          const motifLength = Math.floor(3 + Math.random() * 3);
          motif = [];
          for (let i = 0; i < motifLength; i++) {
            motif.push({
              step: i * 4,
              note: pcs[Math.floor(Math.random() * pcs.length)],
              velocity: 0.7 + Math.random() * 0.2
            });
          }
        }
        // Apply motif
        motif.forEach(m => {
          if (m.step < STEPS_PER_BAR) {
            sbSetStep('lead', offset + m.step, {
              note: withOct(m.note, leadOct),
              velocity: m.velocity * energy,
              duration: '8n',
              probability: 85
            });
          }
        });
        break;
        
      case 'scale-run':
        // Ascending/descending scale runs
        const runLength = Math.floor(4 + Math.random() * 4);
        const ascending = Math.random() < 0.5;
        for (let i = 0; i < runLength; i++) {
          const noteIdx = ascending ? i % allNotes.length : (allNotes.length - 1 - i) % allNotes.length;
          sbSetStep('lead', offset + i * 2, {
            note: withOct(allNotes[noteIdx], leadOct),
            velocity: 0.6 + (i / runLength) * 0.3,
            duration: '16n'
          });
        }
        break;
        
      case 'sparse':
        // Minimal, space-filled melody
        const sparseSteps = [4, 12];
        sparseSteps.forEach(step => {
          if (Math.random() < 0.6 * density) {
            sbSetStep('lead', offset + step, {
              note: withOct(pcs[Math.floor(Math.random() * pcs.length)], leadOct),
              velocity: 0.7 + 0.2 * energy,
              duration: '4n',
              probability: 90
            });
          }
        });
        break;
        
      case 'dense':
        // Busy, note-heavy melody
        for (let step = 0; step < STEPS_PER_BAR; step += 2) {
          if (Math.random() < density) {
            const note = allNotes[Math.floor(Math.random() * allNotes.length)];
            sbSetStep('lead', offset + step, {
              note: withOct(note, leadOct),
              velocity: 0.6 + 0.3 * energy,
              duration: Math.random() < 0.3 ? '16n' : '8n',
              probability: 75 + Math.floor(15 * energy)
            });
          }
        }
        break;
    }
  }
}

// Helper: Get scale notes
function getScaleNotes(key, scale) {
  const scales = {
    'major': [0, 2, 4, 5, 7, 9, 11],
    'minor': [0, 2, 3, 5, 7, 8, 10],
    'dorian': [0, 2, 3, 5, 7, 9, 10],
    'mixolydian': [0, 2, 4, 5, 7, 9, 10]
  };
  const intervals = scales[scale] || scales['major'];
  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const rootIdx = notes.indexOf(key);
  return intervals.map(interval => notes[(rootIdx + interval) % 12]);
}
  
function applyTransitionEffects(section, nextSection, endBar) {
  if (!nextSection) return;
  
  const transitionBar = endBar - 1;
  const offset = transitionBar * STEPS_PER_BAR;
  
  // Detect transition type
  const energyJump = (nextSection.energy || 0.5) - (section.energy || 0.5);
  
  if (energyJump > 0.3) {
    // BIG DROP/CHORUS INCOMING - add riser
    for (let step = 12; step < 16; step++) {
      if (patterns.hihat) {
        sbSetStep('hihat', offset + step, {
          velocity: 0.4 + (step - 12) * 0.15,
          probability: 100
        });
      }
    }
    // Snare roll
    for (let step = 8; step < 16; step++) {
      if (step % 2 === 0 && patterns.snare) {
        sbSetStep('snare', offset + step, {
          velocity: 0.5 + (step - 8) * 0.05,
          probability: 90
        });
      }
    }
  } else if (energyJump < -0.3) {
    // BREAKDOWN/CHILL - reduce drums
    const lastBarOffset = offset;
    for (let step = 8; step < 16; step++) {
      // Gradually reduce hits
      if (patterns.kick && step % 4 === 0) {
        const kickStep = patterns.kick[lastBarOffset + step];
        if (kickStep) kickStep.velocity *= 0.5;
      }
    }
  }
}

function setSongBuilderBusy(isBusy, label = '') {
  state.isSongBuilding = isBusy;

  const buildBtn  = document.getElementById('songBuildBtn');
  const statusEl  = document.getElementById('songBuilderStatus');

  if (buildBtn) {
    buildBtn.disabled = isBusy;
  }

  // OPTIONAL: if you know your play button id, you can also gate that:
  const playBtn = document.getElementById('playBtn');
  if (playBtn) playBtn.disabled = isBusy;

  if (!statusEl) return;

  if (isBusy) {
    songBuilderBusyStartedAt = performance.now();
    statusEl.classList.add('active');
    statusEl.innerHTML = `<span class="dot"></span>${label || 'Building songâ€¦'}`;
  } else {
    statusEl.classList.remove('active');
    statusEl.textContent = '';
  }
}

let songBuilderBusyStartedAt = 0;

function endSongBuilderBusy() {
  const MIN_BUSY_MS = 1500; // change to 250â€“300ms if you want more visible time
  const elapsed = performance.now() - songBuilderBusyStartedAt;

  if (elapsed >= MIN_BUSY_MS) {
    setSongBuilderBusy(false);
  } else {
    setTimeout(() => setSongBuilderBusy(false), MIN_BUSY_MS - elapsed);
  }
}

function generateFullSongFromStructure() {
  if (songBuilderState.isActive) {
    // guard against double-click spamming
    return;
  }

  songBuilderState.isActive = true;
  setSongBuilderBusy(true, 'Building songâ€¦');

  // 1) Pause / stop audio *first* so heavy CPU work can't glitch playback
  const wasPlaying = Tone.Transport.state === 'started';

  if (wasPlaying) {
    // pause instead of hard stop; we'll resume at the same position
    Tone.Transport.pause();
  }

  // Clear any previous scheduled events / main loop
  Tone.Transport.cancel(0);
  if (window.mainLoop) {
    try {
      window.mainLoop.stop();
      window.mainLoop.dispose();
    } catch (e) {
      console.warn('Error disposing mainLoop', e);
    }
    window.mainLoop = null;
  }

  // 2) Harmony prep
  state.progressionNotes = null;
  ensureHarmonyGuardrails();

  // 3) Decide which sections to run
  const runSections = typeof randomizeSongBuilderSectionsForRun === 'function'
    ? randomizeSongBuilderSectionsForRun()
    : songBuilderState.sections.map(s => ({ ...s }));

  const totalBars = Math.max(
    2,
    runSections.reduce((sum, s) => sum + (s.bars || 0), 0)
  );
  const totalSteps = totalBars * STEPS_PER_BAR;

  state.sequenceLength = Math.min(CONFIG.MAX_SEQUENCE_LENGTH, totalSteps);
  ensurePatternLength(state.sequenceLength);
  wipeAllPatterns();

  // 4) Heavy pattern generation (now with audio safely paused)
  let currentBar = 0;
  for (let idx = 0; idx < runSections.length; idx++) {
    const section = runSections[idx];
    const startBar = currentBar;
    const endBar   = currentBar + (section.bars || 0);

    if (endBar <= startBar) continue;

    generateSectionDrums(section, startBar, endBar);
    generateSectionBass(section, startBar, endBar);
    generateSectionChords(section, startBar, endBar);
    generateSectionMelody(section, startBar, endBar);

    const nextSection = runSections[idx + 1];
    if (nextSection) {
      applyTransitionEffects(section, nextSection, endBar);
    }

    currentBar = endBar;
  }

  // 5) Rebuild audio + UI once, after patterns are ready
  //    Small timeout just lets the browser breathe before initAudio
  setTimeout(() => {
    try {
      sequencerInitialized = false;
      initAudioLight();
      renderSequencer();

      if (wasPlaying) {
        // give Tone a tiny look-ahead buffer
        Tone.Transport.start('+0.05');
      }

      showToast('ðŸŽ¼ Structured song generated', 'success');
    } finally {
      songBuilderState.isActive = false;
      endSongBuilderBusy();
    }
  }, 0);
}

// ==================== SONG BUILDER UI WIRING ====================
function setupSongBuilderControls() {
  const templateSelect = document.getElementById('songTemplateSelect');
  const fillSelect     = document.getElementById('songFillEverySelect');
  const buildBtn       = document.getElementById('songBuildBtn');
  const randomBtn      = document.getElementById('songRandomizeSectionsBtn');

  // Safety guard in case the tab isn't rendered yet
  if (!templateSelect || !fillSelect || !buildBtn) return;

  // === INITIAL RENDER ===
  applySongTemplate(songBuilderState.templateId);

  // --- Template dropdown ---
  templateSelect.value = songBuilderState.templateId;
  templateSelect.addEventListener('change', e => {
    applySongTemplate(e.target.value);
  });

  // --- Fill every X bars ---
  fillSelect.value = String(songBuilderState.fillEvery);
  fillSelect.addEventListener('change', e => {
    songBuilderState.fillEvery = parseInt(e.target.value, 10) || 0;
  });

  // --- ðŸŽ² Randomize Sections ---
  if (randomBtn) {
    randomBtn.addEventListener('click', () => {
      randomizeSongBuilderSections();   // reshuffle parameters
      // if you have a helper that updates total bars, call it here too
      // updateSongTotalBarsLabel();
    });
  }

  // --- ðŸŽ¼ Build Song ---
  buildBtn.addEventListener('click', () => {
    generateFullSongFromStructure();

    // Optional: auto-switch to the Sequencer tab when done
    const sequencerTabBtn = document.querySelector(
      '.sidebar-tab[data-tab="sequencer"]'
    );
    if (sequencerTabBtn) sequencerTabBtn.click();
  });

  // --- â¬‡ï¸ Export to Multitrack (disabled for now) ---
  // const exportBtn = document.getElementById('songBuilderToMultitrackBtn');
  // if (exportBtn) {
  //   exportBtn.addEventListener('click', exportSongBuilderToMultitrack);
  // }
}

async function exportSongBuilderToMultitrack() {
  try {
    await Tone.start();
    ensureHarmonyGuardrails();

    // 1) Build the song once in the live context so patterns + sequenceLength are correct
    generateFullSongFromStructure();

    // 2) Compute actual song duration from sequenceLength + resolution
    const secondsPerStep = Tone.Time(state.resolution).toSeconds();
    const durationSec = Math.max(
      4,
      state.sequenceLength * secondsPerStep + 2 // little tail for reverb, etc
    );

    // 3) Offline render the master mix of the Song Builder arrangement
    const offlineBuffer = await Tone.Offline(() => {
      // Rebuild the full arrangement inside the Offline context
      generateFullSongFromStructure();

      // Start playback for the offline render
      Tone.Transport.start();
    }, durationSec);

    if (!offlineBuffer) {
      showToast("âŒ Export failed (empty render)", "error");
      return;
    }

    // 4) Convert to WAV bytes and Blob (so you can download/export later if you want)
    const wavData = bufferToWavImproved(offlineBuffer); // already defined elsewhere
    const blob = new Blob([wavData], { type: "audio/wav" });

    // 5) Find or create a dedicated "Song Builder" stem track
    let targetTrack = multitrack.tracks.find(t => t.name === "Song Builder");
    if (!targetTrack) {
      const id = multitrack.nextTrackId++;
      targetTrack = new AudioTrack(id, "Song Builder", "stem", true);

      // Minimal routing like addExternalAudioTrackFromBuffer
      const gain = new Tone.Gain(1);
      targetTrack.channel = gain;
      gain.connect(master.fxIn);

      multitrack.tracks.push(targetTrack);
    }

    // 6) Create a proper take object (same shape as imported stems)
    const take = {
      id: `take-${Date.now()}-${targetTrack.id}`,
      buffer: offlineBuffer,
      startTime: 0,
      duration: offlineBuffer.duration,
      muted: false,
      source: "song-builder",
      fileName: "Song Builder",
      blob // optional but nice to have
    };

    targetTrack.takes.push(take);
    targetTrack.selectedTakeIndex = targetTrack.takes.length - 1;

    // 7) Update history + UI and jump to Multitrack tab
    if (typeof multitrackHistory?.captureState === "function") {
      multitrackHistory.captureState();
    }

    renderMultitrack();
    showToast("âœ… Song Builder sent to Multitrack", "success");

    document
      .querySelector('.sidebar-tab[data-tab="multitrack"]')
      ?.click();
  } catch (err) {
    console.error("Song Builder export failed:", err);
    showToast(`âŒ Export failed: ${err.message || err}`, "error");
  }
}

// -------------------- Pattern Management --------------------
function ensurePatternLength(length) {
  Object.keys(patterns).forEach(inst => {
    const arr = patterns[inst];
    
    while (arr.length < length) {
      arr.push({
        active: false,
        velocity: 0.8,
        probability: 100,
        note: instruments[inst].note,
        duration: '8n'
      });
    }
    
    if (arr.length > length) arr.length = length;
  });
}

// -------------------- Event Handlers Setup --------------------
function setupEventListeners() {
  setupGenreSelector();
  setupTabs();
  setupTransportControls();
  setupParameterControls();
  setupGeneratorButtons();
  setupSequencerControls();
  setupMixerListeners();
  //setupFXListeners();
  setupHarmonyControls();
  setupProjectManagement();
  setupKeyboardShortcuts();
  setupVibeSelector();
  setupMultitrackListeners();
  setupSongBuilderControls();

  // Sidebar controls
  document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
  document.getElementById('sidebarBackdrop').addEventListener('click', closeSidebar);
  
  // Keyboard shortcut: ESC to close sidebar
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeSidebar();
    }
  });
}

function setupGenreSelector() {
  document.getElementById('genreSelector').addEventListener('click', e => {
    const btn = e.target.closest('.genre-btn');
    if (!btn) return;
    
    document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.currentGenre = btn.dataset.genre;
    updateGenrePresets();
  });
}
  
// -------------------- Sample Browser (no custom uploads) --------------------
function setupSampleUpload() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) {
    console.warn('âš ï¸ setupSampleUpload: #sampleUploadGrid not found');
    return;
  }
  renderSampleUploadGrid();
}

function renderSampleUploadGrid() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) return;

  grid.innerHTML = '';

  // Show all drum / atmospheric instruments as previewable samples
  const uploadableInstruments = Object.keys(instruments).filter(inst =>
    instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric'
  );

  if (uploadableInstruments.length === 0) {
    const msg = document.createElement('div');
    msg.className = 'panel';
    msg.style.padding = 'var(--space-4)';
    msg.textContent = 'No sample-based instruments found. Drums and atmospheric instruments will show here.';
    grid.appendChild(msg);
    return;
  }

  uploadableInstruments.forEach(inst => {
    const data = instruments[inst];

    const card = document.createElement('div');
    card.className = 'panel';
    card.style.padding = 'var(--space-4)';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = 'var(--space-3)';

    card.innerHTML = `
      <div style="text-align: center;">
        <div style="font-size: var(--text-3xl); margin-bottom: var(--space-2);">
          ${data.icon || 'ðŸŽ›ï¸'}
        </div>
        <div style="font-weight: 700; margin-bottom: var(--space-1); color: var(--text-primary);">
          ${data.name || inst}
        </div>
        <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
          Built-in sample
        </div>
      </div>

      <div style="display: flex; flex-direction: column; gap: var(--space-2);">
        <button class="btn btn-primary btn-sm preview-sample-btn" data-inst="${inst}">
          â–¶ï¸ Preview
        </button>
      </div>
    `;

    grid.appendChild(card);
  });

  // Preview listeners
  grid.querySelectorAll('.preview-sample-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const inst = btn.dataset.inst;
      previewInstrument(inst);
    });
  });
}
  
function previewInstrument(inst) {
  const synth = synths[inst];
  if (!synth) {
    showToast('âŒ Instrument not loaded', 'error');
    return;
  }
  
  // Check if it's loaded
  if (!synth.loaded) {
    showToast('â³ Sample still loading...', 'warning');
    return;
  }
  
  const time = Tone.now();
  
  // For drum samples, trigger at standard note
  if (instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric') {
    synth.triggerAttackRelease('C2', '8n', time, 0.8);
  } else {
    // For melodic instruments
    const note = instruments[inst].note || 'C4';
    synth.triggerAttackRelease(note, '8n', time, 0.8);
  }
  
  showToast(`â–¶ï¸ ${instruments[inst].name}`, 'info');
}

// Helper functions for base64 conversion
async function arrayBufferToBase64(buffer) {
  const blob = new Blob([buffer]);
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
  
function setupTabs() {
  const sidebarTabs = document.getElementById('sidebarTabs');
  
  sidebarTabs.addEventListener('click', e => {
    const tab = e.target.closest('.sidebar-tab');
    if (!tab) return;
    
    document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    
    state.currentTab = tab.dataset.tab;

    if (tab.dataset.tab === 'samples') {
      setupSampleUpload();
    }
    
    // Close sidebar after selection
    closeSidebar();
  });
}

// ==================== AI MIXING & MASTERING ====================

function analyzeTrackFrequencies(inst) {
  const synth = synths[inst];
  if (!synth) return null;
  
  const instData = instruments[inst];
  const type = instData.type;
  
  // Frequency profiles for intelligent EQ
  const profiles = {
    kick: { fundamental: 60, lowEnd: 40, midRange: 200, presence: 3000, clarity: 8000 },
    snare: { fundamental: 200, body: 400, snap: 3500, brightness: 8000 },
    hihat: { fundamental: 8000, shimmer: 12000, air: 16000 },
    bass: { fundamental: 80, subBass: 40, warmth: 200, definition: 800 },
    guitar: { body: 300, presence: 2500, clarity: 5000 },
    keys: { warmth: 250, body: 800, presence: 3000, air: 8000 },
    lead: { fundamental: 1000, presence: 3000, brightness: 6000 }
  };
  
  return profiles[inst] || profiles.keys;
}

function calculateOptimalGain(inst) {
  const instData = instruments[inst];
  const type = instData.type;
  
  // Target levels in dB
  const targets = {
    kick: -6,
    snare: -9,
    hihat: -14,
    clap: -12,
    rimshot: -15,
    tom: -10,
    crash: -16,
    ride: -16,
    bass: -8,
    guitar: -12,
    keys: -14,
    lead: -10,
    fx: -18,
    riser: -20,
    ambience: -22
  };
  
  return targets[inst] || -12;
}

function calculateOptimalPan(inst, totalInstruments) {
  const instData = instruments[inst];
  
  // Stereo field strategy
  const panMap = {
    // Center (mono sources)
    kick: 0,
    snare: 0,
    bass: 0,
    lead: 0,
    
    // Slight spread
    hihat: 15,
    rimshot: -10,
    clap: 5,
    
    // Wide stereo
    guitar: 35,
    keys: -25,
    crash: 40,
    ride: -35,
    
    // Atmospheric spread
    fx: 20,
    ambience: -30,
    riser: 0
  };
  
  return panMap[inst] || 0;
}

function analyzePatternDensity(inst) {
  const pattern = patterns[inst];
  const activeSteps = pattern.filter(s => s.active).length;
  const density = activeSteps / state.sequenceLength;
  
  const avgVelocity = activeSteps > 0
    ? pattern.filter(s => s.active).reduce((sum, s) => sum + s.velocity, 0) / activeSteps
    : 0;
  
  return {
    density,
    avgVelocity,
    activeSteps,
    totalSteps: state.sequenceLength,
    importance: density * avgVelocity // Combined metric
  };
}

function calculateIntelligentEQ(inst, freqProfile, density) {
  const eq = { low: 0, mid: 0, high: 0 };
  
  const instData = instruments[inst];
  const type = instData.type;
  
  if (type === 'drum') {
    // Drums: enhance fundamental, reduce mud
    if (inst === 'kick') {
      eq.low = 2; // Boost sub
      eq.mid = -3; // Cut mud
      eq.high = -1; // Slight air reduction
    } else if (inst === 'snare') {
      eq.low = -2; // Reduce rumble
      eq.mid = 1; // Enhance body
      eq.high = 2; // Add crack
    } else if (inst === 'hihat' || inst === 'crash' || inst === 'ride') {
      eq.low = -4; // Cut lows completely
      eq.mid = -2; // Reduce mids
      eq.high = 3; // Boost highs for shimmer
    }
  } else if (type === 'melodic') {
    if (inst === 'bass') {
      eq.low = 3; // Strong bass boost
      eq.mid = -2; // Cut muddiness
      eq.high = -3; // Remove highs
    } else if (inst === 'guitar') {
      eq.low = -1;
      eq.mid = 2; // Presence boost
      eq.high = 1;
    } else if (inst === 'keys') {
      eq.low = 0;
      eq.mid = 1;
      eq.high = 2; // Clarity
    } else if (inst === 'lead') {
      eq.low = -2;
      eq.mid = 3; // Strong presence
      eq.high = 2; // Brightness
    }
  } else if (type === 'atmospheric') {
    eq.low = -3; // Clean lows
    eq.mid = -1;
    eq.high = 4; // Emphasize air
  }
  
  // Adjust based on density - busier instruments get subtle treatment
  if (density.density > 0.5) {
    eq.low *= 0.7;
    eq.mid *= 0.7;
    eq.high *= 0.7;
  }
  
  return eq;
}

// ============================================================================
// ENHANCED applyAIMixing() - Professional Grade
// ============================================================================

async function applyAIMixing() {
  if (!state.aiMixing.enabled) return;
  
  showToast('ðŸ¤– AI analyzing mix...', 'info');
  
  const analysis = {
    instruments: {},
    totalDensity: 0,
    activeInstruments: 0,
    freqMasking: {},
    stereoBalance: 0
  };
  
  // PHASE 1: Deep Analysis
  Object.keys(instruments).forEach(inst => {
    const density = analyzePatternDensity(inst);
    const freqProfile = analyzeTrackFrequenciesAdvanced(inst);
    
    analysis.instruments[inst] = {
      density,
      freqProfile,
      currentGain: instruments[inst].volume,
      currentPan: instruments[inst].pan,
      dynamicRange: calculateDynamicRange(inst),
      peakFrequency: freqProfile.peakFreq,
      spectralCentroid: calculateSpectralCentroid(freqProfile)
    };
    
    if (density.activeSteps > 0) {
      analysis.totalDensity += density.importance;
      analysis.activeInstruments++;
    }
  });
  
  // Calculate frequency masking matrix
  Object.keys(instruments).forEach(inst => {
    analysis.freqMasking[inst] = calculateFrequencyMasking(inst, analysis);
  });
  
  state.aiMixing.lastAnalysis = analysis;
  
  // PHASE 2: Professional Mixing
  let adjustments = 0;
  
  Object.keys(instruments).forEach(inst => {
    const instAnalysis = analysis.instruments[inst];
    const instData = instruments[inst];
    
    if (instAnalysis.density.activeSteps === 0) return;
    
    // 1. PROFESSIONAL GAIN STAGING
    if (state.aiMixing.autoGain) {
      // Calculate optimal gain with advanced algorithm
      const targetGain = calculateProfessionalGain(inst, instAnalysis, analysis);
      
      // Apply with smooth ramping
      instData.volume = Math.round(targetGain * 100);
      if (instData.channel) {
        instData.channel.volume.rampTo(
          20 * Math.log10(targetGain), // Convert to dB
          0.5
        );
      }
      adjustments++;
    }
    
    // 2. INTELLIGENT STEREO PLACEMENT
    if (state.aiMixing.autoPan) {
      const targetPan = calculateIntelligentPan(inst, instAnalysis, analysis);
      instData.pan = targetPan;
      
      if (instData.channel) {
        instData.channel.pan.rampTo(targetPan / 100, 0.5);
      }
      adjustments++;
    }
    
    // 3. SURGICAL EQ
    if (state.aiMixing.autoEQ) {
      const eq = applyProfessionalEQ(inst, instAnalysis, analysis);
      
      // Create or update EQ nodes
      if (!instData.eq) {
        instData.eq = {
          low: new Tone.EQ3(),
          mid: new Tone.Filter(),
          high: new Tone.EQ3()
        };
        instData.channel.chain(instData.eq.low, instData.eq.mid, instData.eq.high);
      }
      
      // Apply EQ settings
      if (instData.eq.low) {
        instData.eq.low.low.value = eq.low;
        instData.eq.low.mid.value = eq.mid;
        instData.eq.low.high.value = eq.high;
      }
      
      console.log(`ðŸŽ›ï¸ ${inst} EQ: L${eq.low > 0 ? '+' : ''}${eq.low.toFixed(1)}dB M${eq.mid > 0 ? '+' : ''}${eq.mid.toFixed(1)}dB H${eq.high > 0 ? '+' : ''}${eq.high.toFixed(1)}dB`);
      adjustments++;
    }
    
    // 4. DYNAMIC COMPRESSION
    if (state.aiMixing.autoCompression) {
      const compSettings = calculateIntelligentCompression(inst, instAnalysis, analysis);
      
      if (compSettings.enabled) {
        if (!instData.compressor) {
          instData.compressor = new Tone.Compressor();
          instData.channel.chain(instData.compressor);
        }
        
        instData.compressor.threshold.rampTo(compSettings.threshold, 0.5);
        instData.compressor.ratio.value = compSettings.ratio;
        instData.compressor.attack.rampTo(compSettings.attack, 0.5);
        instData.compressor.release.rampTo(compSettings.release, 0.5);
        instData.compressor.knee.value = compSettings.knee;
        
        console.log(`ðŸ“Š ${inst} compression: ${compSettings.ratio}:1 @ ${compSettings.threshold}dB`);
        adjustments++;
      }
    }
  });
  
  // PHASE 3: Master Bus Intelligence
  const mixCharacteristics = analyzeMixCharacteristics(analysis);
  
  // Adaptive master compression
  if (mixCharacteristics.density > 0.7) {
    // Dense mix - multiband approach
    master.comp.threshold.rampTo(-18, 0.5);
    master.comp.ratio.value = 4;
    master.comp.attack.rampTo(0.005, 0.5);
    master.comp.release.rampTo(0.12, 0.5);
  } else if (mixCharacteristics.density > 0.4) {
    // Medium density - gentle glue
    master.comp.threshold.rampTo(-22, 0.5);
    master.comp.ratio.value = 3;
    master.comp.attack.rampTo(0.01, 0.5);
    master.comp.release.rampTo(0.15, 0.5);
  } else {
    // Sparse mix - transparent
    master.comp.threshold.rampTo(-26, 0.5);
    master.comp.ratio.value = 2.5;
    master.comp.attack.rampTo(0.02, 0.5);
    master.comp.release.rampTo(0.2, 0.5);
  }
  
  // Adaptive master EQ
  if (mixCharacteristics.lowEndEnergy > 0.4) {
    // Tighten bass
    if (master.lowCutFilter) {
      master.lowCutFilter.frequency.rampTo(35, 0.5);
    }
  }
  
  if (mixCharacteristics.highEndEnergy < 0.15) {
    // Add air
    if (master.highShelf) {
      master.highShelf.gain.rampTo(1.5, 0.5);
    }
  }
  
  renderMixer();
  
  // Detailed reporting
  console.log('ðŸ¤– Professional AI Mixing Complete:');
  console.log(`   âœ“ ${adjustments} intelligent adjustments`);
  console.log(`   âœ“ ${analysis.activeInstruments} instruments balanced`);
  console.log(`   âœ“ Mix density: ${mixCharacteristics.density.toFixed(2)}`);
  console.log(`   âœ“ Frequency balance: ${mixCharacteristics.balance}`);
  console.log(`   âœ“ Stereo width: ${mixCharacteristics.stereoWidth.toFixed(1)}%`);
  console.log(`   âœ“ Dynamic range: ${mixCharacteristics.dynamicRange.toFixed(1)}dB`);
  
  showToast(`âœ… Professional mix: ${analysis.activeInstruments} tracks`, 'success');
}

// Helper: Advanced frequency analysis
function analyzeTrackFrequenciesAdvanced(inst) {
  const profile = {
    subBass: 0,    // 20-60 Hz
    bass: 0,       // 60-250 Hz
    lowMid: 0,     // 250-500 Hz
    mid: 0,        // 500-2k Hz
    highMid: 0,    // 2k-6k Hz
    presence: 0,   // 6k-12k Hz
    brilliance: 0, // 12k-20k Hz
    peakFreq: 0,
    peakEnergy: 0
  };
  
  // Instrument-based frequency profiles (synthesized from typical values)
  const profiles = {
    kick: { subBass: 0.45, bass: 0.35, lowMid: 0.10, mid: 0.05, highMid: 0.03, presence: 0.02, brilliance: 0.00 },
    bass: { subBass: 0.35, bass: 0.40, lowMid: 0.15, mid: 0.07, highMid: 0.02, presence: 0.01, brilliance: 0.00 },
    snare: { subBass: 0.05, bass: 0.15, lowMid: 0.20, mid: 0.25, highMid: 0.20, presence: 0.10, brilliance: 0.05 },
    hihat: { subBass: 0.00, bass: 0.00, lowMid: 0.02, mid: 0.08, highMid: 0.25, presence: 0.35, brilliance: 0.30 },
    clap: { subBass: 0.00, bass: 0.05, lowMid: 0.15, mid: 0.25, highMid: 0.30, presence: 0.20, brilliance: 0.05 },
    perc: { subBass: 0.00, bass: 0.05, lowMid: 0.10, mid: 0.30, highMid: 0.30, presence: 0.20, brilliance: 0.05 },
    synth: { subBass: 0.10, bass: 0.20, lowMid: 0.25, mid: 0.25, highMid: 0.12, presence: 0.06, brilliance: 0.02 },
    lead: { subBass: 0.00, bass: 0.05, lowMid: 0.15, mid: 0.35, highMid: 0.25, presence: 0.15, brilliance: 0.05 }
  };
  
  const instProfile = profiles[inst] || profiles.synth;
  Object.assign(profile, instProfile);
  
  // Find peak frequency
  let maxEnergy = 0;
  const freqRanges = {
    subBass: 40, bass: 150, lowMid: 375, mid: 1250,
    highMid: 4000, presence: 9000, brilliance: 16000
  };
  
  Object.entries(profile).forEach(([band, energy]) => {
    if (freqRanges[band] && energy > maxEnergy) {
      maxEnergy = energy;
      profile.peakFreq = freqRanges[band];
      profile.peakEnergy = energy;
    }
  });
  
  return profile;
}

// Helper: Calculate spectral centroid
function calculateSpectralCentroid(freqProfile) {
  const freqs = [40, 150, 375, 1250, 4000, 9000, 16000];
  const weights = [
    freqProfile.subBass,
    freqProfile.bass,
    freqProfile.lowMid,
    freqProfile.mid,
    freqProfile.highMid,
    freqProfile.presence,
    freqProfile.brilliance
  ];
  
  let weightedSum = 0;
  let totalWeight = 0;
  
  freqs.forEach((freq, i) => {
    weightedSum += freq * weights[i];
    totalWeight += weights[i];
  });
  
  return totalWeight > 0 ? weightedSum / totalWeight : 1000;
}

// Helper: Calculate dynamic range
function calculateDynamicRange(inst) {
  const density = analyzePatternDensity(inst);
  // Estimate based on pattern complexity
  const baseRange = {
    kick: 12, bass: 8, snare: 14, hihat: 10,
    clap: 12, perc: 11, synth: 10, lead: 13
  };
  
  const range = baseRange[inst] || 10;
  const densityReduction = density.density * 4; // Dense patterns = less dynamic range
  
  return Math.max(6, range - densityReduction);
}

// Helper: Frequency masking calculation
function calculateFrequencyMasking(inst, analysis) {
  const instFreq = analysis.instruments[inst].freqProfile;
  let maskingScore = 0;
  let conflicts = 0;
  
  Object.keys(analysis.instruments).forEach(otherInst => {
    if (otherInst === inst) return;
    
    const otherFreq = analysis.instruments[otherInst].freqProfile;
    
    // Weight overlaps by importance (low freq conflicts matter more)
    const overlap = 
      Math.min(instFreq.subBass, otherFreq.subBass) * 3.0 +
      Math.min(instFreq.bass, otherFreq.bass) * 2.5 +
      Math.min(instFreq.lowMid, otherFreq.lowMid) * 2.0 +
      Math.min(instFreq.mid, otherFreq.mid) * 1.5 +
      Math.min(instFreq.highMid, otherFreq.highMid) * 1.2 +
      Math.min(instFreq.presence, otherFreq.presence) * 1.0 +
      Math.min(instFreq.brilliance, otherFreq.brilliance) * 0.8;
    
    if (overlap > 0.15) conflicts++;
    maskingScore += overlap;
  });
  
  return {
    score: Math.min(maskingScore / Math.max(analysis.activeInstruments - 1, 1), 1),
    conflicts
  };
}

// Helper: Professional gain calculation
function calculateProfessionalGain(inst, instAnalysis, mixAnalysis) {
  // LUFS-aware target levels
  const targetLevels = {
    kick: 0.95,   // -0.4 dB
    bass: 0.85,   // -1.4 dB
    snare: 0.75,  // -2.5 dB
    hihat: 0.45,  // -6.9 dB
    clap: 0.65,   // -3.7 dB
    perc: 0.50,   // -6.0 dB
    synth: 0.70,  // -3.1 dB
    lead: 0.80    // -1.9 dB
  };
  
  let targetGain = targetLevels[inst] || 0.65;
  
  // 1. Density compensation (busy patterns quieter)
  const densityFactor = Math.pow(instAnalysis.density.density, 0.5);
  targetGain *= (1 - densityFactor * 0.25);
  
  // 2. Frequency masking compensation (conflicts = quieter)
  const masking = mixAnalysis.freqMasking[inst];
  targetGain *= (1 - masking.score * 0.3);
  
  // 3. Mix crowding compensation
  const crowdingFactor = Math.min(mixAnalysis.activeInstruments / 8, 1);
  targetGain *= (1 - crowdingFactor * 0.2);
  
  // 4. Importance boost
  const importanceRatio = instAnalysis.density.importance / mixAnalysis.totalDensity;
  targetGain *= (1 + importanceRatio * 0.4);
  
  // 5. Dynamic range consideration
  const drFactor = instAnalysis.dynamicRange / 14;
  targetGain *= (0.85 + drFactor * 0.15);
  
  return Math.max(0.1, Math.min(1.0, targetGain));
}

// Helper: Intelligent panning
function calculateIntelligentPan(inst, instAnalysis, mixAnalysis) {
  // Keep low frequencies centered for mono compatibility
  const lowEndEnergy = instAnalysis.freqProfile.subBass + instAnalysis.freqProfile.bass;
  
  if (lowEndEnergy > 0.5 || inst === 'kick' || inst === 'bass') {
    return 0; // Center
  }
  
  // Strategic panning zones
  const panStrategy = {
    snare: 0,     // Center for impact
    clap: 5,      // Slight offset
    hihat: 30,    // Right
    perc: -25,    // Left
    synth: 20,    // Right
    lead: 0       // Center focus
  };
  
  let targetPan = panStrategy[inst] || 0;
  
  // Add spectral-based variation
  const spectralBias = (instAnalysis.spectralCentroid - 1000) / 100;
  targetPan += spectralBias * 0.5;
  
  // Avoid crowding
  const existingPans = Object.values(mixAnalysis.instruments)
    .map(i => i.currentPan)
    .filter(p => p !== undefined);
  
  // Find least crowded zone
  const zones = [-40, -25, -10, 0, 10, 25, 40];
  let bestZone = targetPan;
  let minCrowding = Infinity;
  
  zones.forEach(zone => {
    const crowding = existingPans.reduce((sum, pan) => {
      return sum + Math.max(0, 30 - Math.abs(zone - pan));
    }, 0);
    
    if (crowding < minCrowding) {
      minCrowding = crowding;
      bestZone = zone;
    }
  });
  
  return Math.max(-50, Math.min(50, bestZone));
}

// Helper: Professional EQ
function applyProfessionalEQ(inst, instAnalysis, mixAnalysis) {
  // Instrument-specific EQ templates
  const eqTemplates = {
    kick: { low: 3, mid: -4, high: 0 },
    bass: { low: 2, mid: -2, high: -6 },
    snare: { low: -8, mid: -1, high: 3 },
    hihat: { low: -18, mid: -3, high: 2 },
    clap: { low: -12, mid: 1, high: 2 },
    perc: { low: -10, mid: 2, high: 1 },
    synth: { low: 0, mid: 1, high: 0 },
    lead: { low: -4, mid: 2, high: 1 }
  };
  
  const eq = { ...(eqTemplates[inst] || { low: 0, mid: 0, high: 0 }) };
  
  // Dynamic adjustments based on masking
  const masking = mixAnalysis.freqMasking[inst];
  if (masking.score > 0.5) {
    // Heavy masking - carve space
    if (instAnalysis.freqProfile.bass > 0.3) {
      eq.low += 1; // Boost strength
    }
    eq.mid -= 2; // Cut mids to reduce conflicts
  }
  
  // Density adjustments
  if (instAnalysis.density.density > 0.6) {
    eq.low -= 1; // Reduce mud in busy sections
  }
  
  // Spectral balance
  const mixBalance = analyzeMixCharacteristics(mixAnalysis);
  if (mixBalance.lowEndEnergy > 0.5) {
    eq.low -= 1; // Reduce if mix is bass-heavy
  }
  if (mixBalance.highEndEnergy < 0.2) {
    eq.high += 1.5; // Add air if mix is dull
  }
  
  return eq;
}

// Helper: Intelligent compression
function calculateIntelligentCompression(inst, instAnalysis, mixAnalysis) {
  const settings = {
    enabled: false,
    threshold: -20,
    ratio: 3,
    attack: 0.01,
    release: 0.1,
    knee: 4
  };
  
  // Only compress if needed
  if (instAnalysis.dynamicRange > 10 || instAnalysis.density.density > 0.5) {
    settings.enabled = true;
    
    // Instrument-specific settings
    const compProfiles = {
      kick: { threshold: -12, ratio: 4, attack: 0.003, release: 0.08, knee: 2 },
      bass: { threshold: -15, ratio: 5, attack: 0.01, release: 0.15, knee: 4 },
      snare: { threshold: -10, ratio: 4, attack: 0.001, release: 0.05, knee: 2 },
      hihat: { threshold: -18, ratio: 3, attack: 0.001, release: 0.04, knee: 3 },
      clap: { threshold: -14, ratio: 4, attack: 0.002, release: 0.06, knee: 3 },
      synth: { threshold: -16, ratio: 3.5, attack: 0.01, release: 0.12, knee: 5 },
      lead: { threshold: -14, ratio: 4, attack: 0.005, release: 0.1, knee: 4 }
    };
    
    Object.assign(settings, compProfiles[inst] || {});
    
    // Dynamic adjustments
    if (instAnalysis.density.density > 0.7) {
      settings.ratio += 1; // More compression for dense patterns
      settings.threshold -= 2;
    }
  }
  
  return settings;
}

// Helper: Analyze overall mix characteristics
function analyzeMixCharacteristics(analysis) {
  let lowEndEnergy = 0;
  let midEnergy = 0;
  let highEndEnergy = 0;
  let totalEnergy = 0;
  let stereoSpread = 0;
  let avgDynamicRange = 0;
  
  Object.values(analysis.instruments).forEach(inst => {
    const weight = inst.density.importance;
    
    lowEndEnergy += (inst.freqProfile.subBass + inst.freqProfile.bass) * weight;
    midEnergy += (inst.freqProfile.lowMid + inst.freqProfile.mid) * weight;
    highEndEnergy += (inst.freqProfile.highMid + inst.freqProfile.presence + inst.freqProfile.brilliance) * weight;
    totalEnergy += weight;
    
    stereoSpread += Math.abs(inst.currentPan || 0);
    avgDynamicRange += inst.dynamicRange;
  });
  
  const count = analysis.activeInstruments || 1;
  
  return {
    density: analysis.totalDensity / Math.max(count, 1),
    lowEndEnergy: lowEndEnergy / totalEnergy,
    midEnergy: midEnergy / totalEnergy,
    highEndEnergy: highEndEnergy / totalEnergy,
    balance: lowEndEnergy > 0.4 ? 'bass-heavy' : highEndEnergy > 0.4 ? 'bright' : 'balanced',
    stereoWidth: (stereoSpread / count) * 2,
    dynamicRange: avgDynamicRange / count
  };
}

// ============================================================================
// ENHANCED applyMasteringPreset() - Professional Grade
// ============================================================================

function applyMasteringPreset(preset) {
  const presets = {
    gentle: {
      name: "Gentle Dynamics",
      comp: { threshold: -20, ratio: 2.5, attack: 0.02, release: 0.3, knee: 8 },
      limiter: -2.0,
      tape: 12,
      highCut: 18000,
      lowCut: 22,
      stereoWidth: 1.0,
      targetLUFS: -18
    },
    modern: {
      name: "Modern Streaming",
      comp: { threshold: -16, ratio: 4, attack: 0.005, release: 0.15, knee: 6 },
      limiter: -0.8,
      tape: 25,
      highCut: 17000,
      lowCut: 28,
      stereoWidth: 1.08,
      targetLUFS: -14
    },
    aggressive: {
      name: "Aggressive/Club",
      comp: { threshold: -12, ratio: 6, attack: 0.002, release: 0.1, knee: 4 },
      limiter: -0.3,
      tape: 38,
      highCut: 16000,
      lowCut: 32,
      stereoWidth: 1.15,
      targetLUFS: -11
    },
    lofi: {
      name: "Lo-Fi/Vintage",
      comp: { threshold: -22, ratio: 3, attack: 0.03, release: 0.35, knee: 10 },
      limiter: -3.0,
      tape: 55,
      highCut: 10000,
      lowCut: 45,
      stereoWidth: 0.9,
      targetLUFS: -16
    },
    broadcast: {
      name: "Broadcast Ready",
      comp: { threshold: -14, ratio: 5, attack: 0.003, release: 0.12, knee: 5 },
      limiter: -0.5,
      tape: 20,
      highCut: 15000,
      lowCut: 40,
      stereoWidth: 1.0,
      targetLUFS: -16
    },
    vinyl: {
      name: "Vinyl Master",
      comp: { threshold: -18, ratio: 3, attack: 0.01, release: 0.25, knee: 8 },
      limiter: -2.5,
      tape: 48,
      highCut: 12000,
      lowCut: 30,
      stereoWidth: 0.95,
      targetLUFS: -16
    }
  };
  
  const config = presets[preset];
  if (!config) {
    console.warn(`Unknown preset: ${preset}`);
    return;
  }
  
  showToast(`ðŸŽšï¸ Applying ${config.name}...`, 'info');
  
  // 1. Master Compression with advanced settings
  master.comp.threshold.rampTo(config.comp.threshold, 0.5);
  master.comp.ratio.value = config.comp.ratio;
  master.comp.attack.rampTo(config.comp.attack, 0.5);
  master.comp.release.rampTo(config.comp.release, 0.5);
  
  if (master.comp.knee) {
    master.comp.knee.value = config.comp.knee;
  }
  
  // 2. Filtering with precise control
  state.lowCut = config.lowCut;
  state.highCut = config.highCut;
  
  if (master.lowCutFilter) {
    master.lowCutFilter.frequency.rampTo(config.lowCut, 0.5);
    master.lowCutFilter.Q.value = 0.707; // Butterworth response
  }
  
  if (master.highCutFilter) {
    master.highCutFilter.frequency.rampTo(config.highCut, 0.5);
    master.highCutFilter.Q.value = 0.707;
  }
  
  // 3. Tape Saturation with harmonic enhancement
  state.tapeSaturation = config.tape;
  if (master.tapeDistortion) {
    const saturation = config.tape / 100;
    master.tapeDistortion.distortion = saturation * 0.25;
    master.tapeDistortion.wet.rampTo(saturation * 0.65, 0.5);
    
    // Add subtle odd harmonics for warmth
    if (master.tapeDistortion.oversample) {
      master.tapeDistortion.oversample = saturation > 0.4 ? '4x' : '2x';
    }
  }
  
  // 4. Stereo Width Enhancement
  if (master.stereoWidth) {
    master.stereoWidth.wet.rampTo(config.stereoWidth - 1, 0.5);
  }
  
  // 5. Peak Limiter (brickwall)
  if (master.limiter) {
    master.limiter.threshold.rampTo(config.limiter, 0.5);
    // Fast attack, medium release for transparency
    if (master.limiter.attack) master.limiter.attack.value = 0.001;
    if (master.limiter.release) master.limiter.release.rampTo(0.05, 0.5);
  }
  
  // 6. Update UI elements
  const uiUpdates = {
    'compSlider': config.comp.threshold,
    'compValue': config.comp.threshold + 'dB',
    'ratioValue': config.comp.ratio + ':1',
    'lowCutSlider': config.lowCut,
    'lowCutValue': config.lowCut + 'Hz',
    'highCutSlider': config.highCut,
    'highCutValue': (config.highCut / 1000).toFixed(1) + 'kHz',
    'tapeSlider': config.tape,
    'tapeValue': config.tape + '%',
    'widthValue': Math.round(config.stereoWidth * 100) + '%'
  };
  
  Object.entries(uiUpdates).forEach(([id, value]) => {
    const element = document.getElementById(id);
    if (element) {
      if (id.includes('Slider')) {
        element.value = value;
      } else {
        element.textContent = value;
      }
    }
  });
  
  // 7. Detailed console logging
  console.log(`ðŸŽšï¸ Professional Mastering Applied: ${config.name}`);
  console.log(`   Target Loudness: ${config.targetLUFS} LUFS`);
  console.log(`   Compression: ${config.comp.ratio}:1 @ ${config.comp.threshold}dB`);
  console.log(`   Attack/Release: ${(config.comp.attack * 1000).toFixed(1)}ms / ${(config.comp.release * 1000).toFixed(0)}ms`);
  console.log(`   Tape Saturation: ${config.tape}% (${config.tape > 40 ? 'Heavy' : config.tape > 25 ? 'Medium' : 'Light'})`);
  console.log(`   Frequency Range: ${config.lowCut}Hz - ${(config.highCut / 1000).toFixed(1)}kHz`);
  console.log(`   Stereo Width: ${Math.round(config.stereoWidth * 100)}%`);
  console.log(`   Peak Limiter: ${config.limiter}dB ceiling`);
  
  // 8. Show professional feedback
  const characteristics = [];
  
  if (config.comp.ratio >= 5) characteristics.push('punchy');
  if (config.tape > 40) characteristics.push('warm');
  if (config.stereoWidth > 1.1) characteristics.push('wide');
  if (config.targetLUFS <= -16) characteristics.push('dynamic');
  if (config.targetLUFS >= -12) characteristics.push('loud');
  if (config.highCut < 14000) characteristics.push('vintage');
  
  const charText = characteristics.length > 0 ? ` (${characteristics.join(', ')})` : '';
  
  showToast(`âœ… ${config.name} mastering applied${charText}`, 'success');
}

// ============================================================================
// ADDITIONAL PROFESSIONAL UTILITIES
// ============================================================================

// Calculate LUFS (simplified integrated loudness)
function calculateLUFS() {
  if (!master || !master.meter) return -18;
  
  // This would need actual audio analysis in production
  // Simplified estimation based on current meter reading
  const currentLevel = master.meter.getValue();
  const estimatedLUFS = currentLevel + 6; // Rough conversion
  
  return Math.max(-40, Math.min(0, estimatedLUFS));
}

// Real-time mix analysis for display
function getMixAnalysisReport() {
  if (!state.aiMixing || !state.aiMixing.lastAnalysis) {
    return null;
  }
  
  const analysis = state.aiMixing.lastAnalysis;
  const mixChar = analyzeMixCharacteristics(analysis);
  
  return {
    activeInstruments: analysis.activeInstruments,
    totalDensity: analysis.totalDensity.toFixed(2),
    frequencyBalance: mixChar.balance,
    stereoWidth: mixChar.stereoWidth.toFixed(1) + '%',
    dynamicRange: mixChar.dynamicRange.toFixed(1) + 'dB',
    estimatedLUFS: calculateLUFS().toFixed(1),
    recommendations: generateMixRecommendations(analysis, mixChar)
  };
}

// Generate intelligent recommendations
function generateMixRecommendations(analysis, mixChar) {
  const recommendations = [];
  
  // Check frequency balance
  if (mixChar.lowEndEnergy > 0.5) {
    recommendations.push('âš ï¸ Mix is bass-heavy - consider high-pass filtering or reducing low-end');
  }
  
  if (mixChar.highEndEnergy < 0.15) {
    recommendations.push('ðŸ’¡ Add brightness - boost high shelf or add more high-frequency content');
  }
  
  // Check density
  if (mixChar.density > 0.8) {
    recommendations.push('ðŸ“Š Very dense mix - ensure clarity with EQ carving');
  } else if (mixChar.density < 0.3) {
    recommendations.push('ðŸŽµ Sparse mix - good dynamics, consider adding texture');
  }
  
  // Check stereo field
  if (mixChar.stereoWidth < 15) {
    recommendations.push('â†”ï¸ Narrow stereo image - pan elements for wider mix');
  } else if (mixChar.stereoWidth > 45) {
    recommendations.push('âš ï¸ Very wide - check mono compatibility');
  }
  
  // Check dynamic range
  if (mixChar.dynamicRange < 6) {
    recommendations.push('ðŸ“ˆ Low dynamic range - reduce compression or limiting');
  } else if (mixChar.dynamicRange > 14) {
    recommendations.push('ðŸ“‰ High dynamic range - consider compression for consistency');
  }
  
  // Check for frequency masking conflicts
  let highMaskingCount = 0;
  Object.values(analysis.freqMasking || {}).forEach(masking => {
    if (masking.score > 0.6) highMaskingCount++;
  });
  
  if (highMaskingCount > 2) {
    recommendations.push('ðŸŽšï¸ Heavy frequency masking detected - use EQ to separate instruments');
  }
  
  if (recommendations.length === 0) {
    recommendations.push('âœ… Mix balance looks good!');
  }
  
  return recommendations;
}

// Automatic loudness normalization
function normalizeMixLoudness(targetLUFS = -14) {
  const currentLUFS = calculateLUFS();
  const difference = targetLUFS - currentLUFS;
  
  if (Math.abs(difference) > 0.5) {
    const gainAdjust = Math.pow(10, difference / 20);
    
    if (master.gain) {
      const currentGain = master.gain.gain.value;
      master.gain.gain.rampTo(currentGain * gainAdjust, 1.0);
    }
    
    console.log(`ðŸ“Š Loudness normalized: ${currentLUFS.toFixed(1)} â†’ ${targetLUFS} LUFS`);
    showToast(`Normalized to ${targetLUFS} LUFS`, 'success');
  }
}

// Export professional mix analysis
function exportMixAnalysis() {
  const report = getMixAnalysisReport();
  if (!report) return null;
  
  const analysis = state.aiMixing.lastAnalysis;
  
  const detailedReport = {
    timestamp: new Date().toISOString(),
    summary: report,
    instruments: {}
  };
  
  // Add per-instrument details
  Object.entries(analysis.instruments).forEach(([inst, data]) => {
    detailedReport.instruments[inst] = {
      active: data.density.activeSteps > 0,
      density: data.density.density.toFixed(2),
      importance: data.density.importance.toFixed(2),
      gain: data.currentGain,
      pan: data.currentPan,
      peakFrequency: data.peakFrequency ? data.peakFrequency.toFixed(0) + 'Hz' : 'N/A',
      spectralCentroid: data.spectralCentroid ? data.spectralCentroid.toFixed(0) + 'Hz' : 'N/A',
      dynamicRange: data.dynamicRange ? data.dynamicRange.toFixed(1) + 'dB' : 'N/A',
      frequencyProfile: {
        low: ((data.freqProfile.subBass + data.freqProfile.bass) * 100).toFixed(0) + '%',
        mid: ((data.freqProfile.lowMid + data.freqProfile.mid) * 100).toFixed(0) + '%',
        high: ((data.freqProfile.highMid + data.freqProfile.presence + data.freqProfile.brilliance) * 100).toFixed(0) + '%'
      }
    };
  });
  
  return detailedReport;
}

// Preset comparison tool
function comparePresets() {
  const presetNames = Object.keys({
    gentle: true,
    modern: true,
    aggressive: true,
    lofi: true,
    broadcast: true,
    vinyl: true
  });
  
  console.log('ðŸŽšï¸ MASTERING PRESET COMPARISON');
  console.log('â•'.repeat(60));
  
  presetNames.forEach(preset => {
    const presets = {
      gentle: { targetLUFS: -18, ratio: 2.5, tape: 12, character: 'Natural & Dynamic' },
      modern: { targetLUFS: -14, ratio: 4, tape: 25, character: 'Streaming Ready' },
      aggressive: { targetLUFS: -11, ratio: 6, tape: 38, character: 'Loud & Punchy' },
      lofi: { targetLUFS: -16, ratio: 3, tape: 55, character: 'Vintage Warmth' },
      broadcast: { targetLUFS: -16, ratio: 5, tape: 20, character: 'Broadcast Safe' },
      vinyl: { targetLUFS: -16, ratio: 3, tape: 48, character: 'Analog Style' }
    };
    
    const config = presets[preset];
    console.log(`${preset.toUpperCase()}: ${config.character}`);
    console.log(`  Loudness: ${config.targetLUFS} LUFS | Ratio: ${config.ratio}:1 | Tape: ${config.tape}%`);
    console.log('â”€'.repeat(60));
  });
}

// ============================================================================
// INTEGRATION HELPERS
// ============================================================================

// Call this to apply AI mixing with current settings
function autoMixNow() {
  if (state.aiMixing && state.aiMixing.enabled) {
    applyAIMixing();
  } else {
    showToast('Enable AI Mixing first', 'warning');
  }
}

// Quick preset switcher
function quickMaster(style) {
  const styleMap = {
    soft: 'gentle',
    balanced: 'modern',
    loud: 'aggressive',
    vintage: 'lofi',
    radio: 'broadcast',
    analog: 'vinyl'
  };
  
  const preset = styleMap[style] || style;
  applyMasteringPreset(preset);
}

// Get current mix health score (0-100)
function getMixHealthScore() {
  const report = getMixAnalysisReport();
  if (!report) return 50;
  
  let score = 100;
  
  // Deduct for issues
  const mixChar = analyzeMixCharacteristics(state.aiMixing.lastAnalysis);
  
  if (mixChar.lowEndEnergy > 0.5) score -= 10;
  if (mixChar.highEndEnergy < 0.15) score -= 10;
  if (mixChar.density > 0.8) score -= 8;
  if (mixChar.dynamicRange < 6) score -= 15;
  if (mixChar.dynamicRange > 14) score -= 8;
  
  Object.values(state.aiMixing.lastAnalysis.freqMasking || {}).forEach(masking => {
    if (masking.score > 0.6) score -= 5;
  });
  
  return Math.max(0, Math.min(100, score));
}

console.log('ðŸŽ›ï¸ Professional AI Mixing & Mastering System Loaded');
console.log('ðŸ“Š Features: Advanced gain staging, surgical EQ, intelligent compression');
console.log('ðŸŽšï¸ Mastering presets: gentle, modern, aggressive, lofi, broadcast, vinyl');
console.log('ðŸ’¡ Type comparePresets() to see all preset details');
  
function setupTransportControls() {
  document.getElementById('playBtn').addEventListener('click', togglePlay);
  document.getElementById('stopBtn').addEventListener('click', stop);
  document.getElementById('exportBtn').addEventListener('click', exportAudio);
  
  // Metronome controls
  document.getElementById('metronomeBtn')?.addEventListener('click', () => {
    state.metronomeEnabled = !state.metronomeEnabled;
    const btn = document.getElementById('metronomeBtn');
    btn.textContent = state.metronomeEnabled ? 'ðŸ¥ Click: On' : 'ðŸ¥ Click: Off';
  });
  
  document.getElementById('countInBtn')?.addEventListener('click', () => {
    state.countInBars = state.countInBars === 1 ? 2 : state.countInBars === 2 ? 0 : 1;
    const btn = document.getElementById('countInBtn');
    const labels = ['â±ï¸ Count: Off', 'â±ï¸ Count: 1 bar', 'â±ï¸ Count: 2 bars'];
    btn.textContent = labels[state.countInBars];
  });
}

function setupParameterControls() {
  // BPM with debounce
  const bpmHandler = debounce(value => {
    state.bpm = clamp(value, 60, CONFIG.MAX_BPM);
    Tone.Transport.bpm.value = state.bpm;
  }, CONFIG.DEBOUNCE_MS);
  
  document.getElementById('bpmSlider').addEventListener('input', e => {
    const value = parseInt(e.target.value, 10);
    document.getElementById('bpmValue').textContent = value;
    bpmHandler(value);
  });
  
  // Swing
  document.getElementById('swingSlider').addEventListener('input', e => {
    state.swing = parseInt(e.target.value, 10);
    document.getElementById('swingValue').textContent = state.swing + '%';
    Tone.Transport.swing = state.swing / 100;
    Tone.Transport.swingSubdivision = '8n';
  });
  
  // Duration
  document.getElementById('durSlider').addEventListener('input', e => {
    state.duration = parseInt(e.target.value, 10);
    document.getElementById('durValue').textContent = state.duration + ' min';
    document.getElementById('durationDisplay').textContent = 
      '/ ' + String(state.duration).padStart(2, '0') + ':00';
  });
  
  // Complexity
  document.getElementById('complexSlider').addEventListener('input', e => {
    state.complexity = parseInt(e.target.value, 10);
    const labels = ['Simple', 'Medium', 'Complex'];
    document.getElementById('complexValue').textContent = labels[state.complexity - 1];
  });
  
  // Humanize
  document.getElementById('humanSlider').addEventListener('input', e => {
    state.humanize = parseInt(e.target.value, 10);
    document.getElementById('humanValue').textContent = state.humanize + 'ms';
  });
  
  // Master controls
  setupMasterControls();
}

function setupMasterControls() {
  const masterVolSlider  = document.getElementById('masterVolSlider');
  const masterVolValue   = document.getElementById('masterVolValue');
  const masterFader      = document.getElementById('masterFader');
  const masterFaderLabel = document.getElementById('masterFaderLabel');

  // ---- MASTER VOLUME SYNC (Mixer slider <-> Master strip fader) ----
  function applyMasterVolume(db, source) {
    // Persist in state
    state.masterVolume = db;

    // Mixer tab label
    if (masterVolValue) {
      masterVolValue.textContent = db.toFixed(0) + 'dB';
    }

    // Master strip label
    if (masterFaderLabel) {
      masterFaderLabel.textContent = db.toFixed(1) + ' dB';
    }

    // Keep controls in sync, but avoid loops
    if (masterVolSlider && source !== 'slider') {
      masterVolSlider.value = db;
    }
    if (masterFader && source !== 'fader') {
      masterFader.value = db;
    }

    // Actually apply to audio
    // (this is what you already had for the mixer slider)
    Tone.Destination.volume.rampTo(db, 0.1);
  }

  // Initial volume (default 0 dB)
  const initialDb =
    typeof state.masterVolume === 'number' ? state.masterVolume : 0;
  applyMasterVolume(initialDb);

  // Mixer Master Volume slider (horizontal, existing control)
  if (masterVolSlider) {
    masterVolSlider.addEventListener(
      'input',
      debounce((e) => {
        const db = parseInt(e.target.value, 10);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'slider');
      }, 100)
    );
  }

  // NEW: Master Strip fader (vertical, in multitrack column)
  if (masterFader) {
    masterFader.addEventListener(
      'input',
      debounce((e) => {
        const db = parseFloat(e.target.value);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'fader');
      }, 50)
    );
  }

  // ---- EXISTING MASTER FX CONTROLS (unchanged, just moved under here) ----

  const tapeSlider = document.getElementById('tapeSlider');
  if (tapeSlider) {
    tapeSlider.addEventListener(
      'input',
      debounce((e) => {
        state.tapeSaturation = parseInt(e.target.value, 10);
        document.getElementById('tapeValue').textContent =
          state.tapeSaturation + '%';
        if (master.tapeDistortion) {
          master.tapeDistortion.distortion =
            (state.tapeSaturation / 100) * 0.2; // Reduced
          master.tapeDistortion.wet.rampTo(
            (state.tapeSaturation / 100) * 0.6,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const vinylSlider = document.getElementById('vinylSlider');
  if (vinylSlider) {
    vinylSlider.addEventListener(
      'input',
      debounce((e) => {
        state.vinylNoise = parseInt(e.target.value, 10);
        document.getElementById('vinylValue').textContent =
          state.vinylNoise + '%';
        if (master.vinylNoise) {
          master.vinylNoise.volume.rampTo(
            -50 + (state.vinylNoise / 100) * 15,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const lowCutSlider = document.getElementById('lowCutSlider');
  if (lowCutSlider) {
    lowCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.lowCut = parseInt(e.target.value, 10);
        document.getElementById('lowCutValue').textContent =
          state.lowCut + 'Hz';
        if (master.lowCutFilter) {
          master.lowCutFilter.frequency.rampTo(state.lowCut, 0.15); // Slower ramp
        }
      }, 100)
    );
  }

  const highCutSlider = document.getElementById('highCutSlider');
  if (highCutSlider) {
    highCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.highCut = parseInt(e.target.value, 10);
        document.getElementById('highCutValue').textContent =
          state.highCut + 'Hz';
        if (master.highCutFilter) {
          master.highCutFilter.frequency.rampTo(state.highCut, 0.15);
        }
      }, 100)
    );
  }

  const compSlider = document.getElementById('compressorSlider');
  if (compSlider) {
    compSlider.addEventListener(
      'input',
      debounce((e) => {
        state.compressor = parseInt(e.target.value, 10);
        document.getElementById('compressorValue').textContent =
          state.compressor + 'dB';
        if (master.comp) {
          master.comp.threshold.rampTo(state.compressor, 0.15);
        }
      }, 100)
    );
  }

  // Finally: wire up the master meters
  setupMasterMeters();
}

function setupMasterMeters() {
  if (!master || !master.meter) return;

  const meterL = document.getElementById('masterMeterL');
  const meterR = document.getElementById('masterMeterR');
  if (!meterL || !meterR) return;

  // Ensure inner fill elements exist
  function ensureFill(el) {
    let fill = el.querySelector('.daw-meter-fill');
    if (!fill) {
      fill = document.createElement('div');
      fill.className = 'daw-meter-fill';
      el.appendChild(fill);
    }
    return fill;
  }

  const fillL = ensureFill(meterL);
  const fillR = ensureFill(meterR);

  function dbToNorm(db) {
    if (db === -Infinity) return 0;
    const minDb = -60;
    if (db < minDb) db = minDb;
    const norm = (db - minDb) / -minDb; // map [-60,0] â†’ [0,1]
    return Math.max(0, Math.min(norm, 1));
  }

  function update() {
    // Tone.Meter returns either a single value or an array for stereo
    const value = master.meter.getValue();
    let left, right;

    if (Array.isArray(value)) {
      left = value[0];
      right = value[1] != null ? value[1] : value[0];
    } else {
      left = right = value;
    }

    const lNorm = dbToNorm(left);
    const rNorm = dbToNorm(right);

    fillL.style.height = (lNorm * 100).toFixed(1) + '%';
    fillR.style.height = (rNorm * 100).toFixed(1) + '%';

    requestAnimationFrame(update);
  }

  requestAnimationFrame(update);
}

function setupGeneratorButtons() {
  document.getElementById('generateBtn').addEventListener('click', () => {
    generateBeat();
    ensureHarmonyGuardrails();
    
    if (state.complexity >= 2) {
      addRhythmicVariety();
    }
  });

  // === Combined Beat + Rhythm generator ===
  document.getElementById('generateSongBtn')?.addEventListener('click', async () => {
    showToast('ðŸŽ¶ Generating full song...', 'info');
  
    // 1ï¸âƒ£  Beat + drums
    generateBeat();
  
    // 2ï¸âƒ£  Harmony lock (progression + key)
    ensureHarmonyGuardrails();
  
    // 3ï¸âƒ£  Melodic structure
    generateMelodicPatterns();
  
    // 4ï¸âƒ£  Optional polish
    if (state.complexity >= 2) addRhythmicVariety();
    addDrumFills();
    addSwingVariations();
  
    showToast('âœ… Song ready!', 'success');
  });

  document.getElementById('generateRhythmBtn').addEventListener('click', () => {
    generateMelodicPatterns();
    addDrumFills();
    addSwingVariations();
  });

  document.getElementById('aiVariationBtn')?.addEventListener('click', generateAIVariation);
  document.getElementById('aiMelodicBtn')?.addEventListener('click', generateMelodicAIVariation);
  
  document.querySelectorAll('.groove-template-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const template = e.currentTarget.dataset.template;
      applyGrooveTemplate(template);
    });
  });
  
  document.getElementById('randomVelBtn').addEventListener('click', randomizeVelocity);
  document.getElementById('randomProbBtn').addEventListener('click', randomizeProbability);
  document.getElementById('clearBtn').addEventListener('click', clearPattern);
}

function setupSequencerControls() {
  document.getElementById('lenDecBtn').addEventListener('click', () => {
    state.sequenceLength = Math.max(CONFIG.MIN_SEQUENCE_LENGTH, state.sequenceLength - 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('lenIncBtn').addEventListener('click', () => {
    state.sequenceLength = Math.min(CONFIG.MAX_SEQUENCE_LENGTH, state.sequenceLength + 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('resSelect').addEventListener('change', e => {
    state.resolution = e.target.value;
  });
  
  document.getElementById('euclidBtn').addEventListener('click', applyEuclidean);
  document.getElementById('ghostBtn').addEventListener('click', addGhostNotes);
  
  // Delegated sequencer events
  const seqGrid = document.getElementById('seqGrid');
  seqGrid.addEventListener('click', handleSequencerClick);
}

function handleSequencerClick(e) {
  songBuilderState.isActive = false;
  const stepEl = e.target.closest('.step');
  if (stepEl) {
    const inst = stepEl.dataset.inst;
    const step = parseInt(stepEl.dataset.step, 10);
    toggleStep(inst, step, e);
    return;
  }
  
  const icon = e.target.closest('.seq-icon');
  if (icon) {
    const inst = icon.dataset.inst;
    const action = icon.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    } else if (action === 'note') {
      if (!isPro()) {
        showToast('ðŸ”’ Changing note pitch is available in 8-Beat Pro.', 'info');
        return;
      }
      openNoteEditor(inst);
    }
    
    renderSequencer();
  }
}

function setupMixerListeners() {
  const mixerGrid = document.getElementById('mixerGrid');
  
  mixerGrid.addEventListener('click', e => {
    const btn = e.target.closest('.channel-btn');
    if (!btn) return;
    
    const inst = btn.dataset.inst;
    const action = btn.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    }
    
    renderMixer();
    renderSequencer();
  });
  
  mixerGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;
    
    const inst = e.target.dataset.inst;
    const param = e.target.dataset.param;
    const value = parseFloat(e.target.value);
    
    instruments[inst][param] = value;
    
    if (param === 'volume' && instruments[inst].channel) {
      instruments[inst].channel.volume.value = value;
    } else if (param === 'pan' && instruments[inst].channel) {
      instruments[inst].channel.pan.value = value / 100;
    }
    
    const parent = e.target.closest('.param-control');
    const valEl = parent.querySelector('.param-value');
    
    if (param === 'volume') {
      valEl.textContent = value + 'dB';
    } else if (param === 'pan') {
      const label = value > 0 ? 'R' : value < 0 ? 'L' : 'C';
      valEl.textContent = label + Math.abs(value);
    }
  });

  // AI Mixing controls
  const toggleAIBtn = document.getElementById('toggleAIMixingBtn');
  const applyAIMixBtn = document.getElementById('applyAIMixBtn');
  const aiStatus = document.getElementById('aiMixingStatus');
  
  if (toggleAIBtn) {
    toggleAIBtn.addEventListener('click', () => {
      state.aiMixing.enabled = !state.aiMixing.enabled;
      aiStatus.textContent = state.aiMixing.enabled ? 'Disable AI' : 'Enable AI';
      toggleAIBtn.classList.toggle('btn-success', state.aiMixing.enabled);
      applyAIMixBtn.disabled = !state.aiMixing.enabled;
      
      if (state.aiMixing.enabled) {
        showToast('âœ… AI Mixing enabled', 'success');
      }
    });
  }
  
  if (applyAIMixBtn) {
    applyAIMixBtn.addEventListener('click', () => applyAIMixing());
  }
  
  ['autoGain', 'autoPan', 'autoEQ', 'autoComp'].forEach(feature => {
    const checkbox = document.getElementById(feature + 'Checkbox');
    if (checkbox) {
      checkbox.addEventListener('change', (e) => {
        const key = feature === 'autoComp' ? 'autoCompression' : feature;
        state.aiMixing[key] = e.target.checked;
      });
    }
  });
  
  // Mastering presets
  document.querySelectorAll('[data-master-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      const preset = btn.dataset.masterPreset;
      applyMasteringPreset(preset);
    });
  });
}

function invalidateHarmonyCache() {
  state.progressionNotes = null;
}

function setupHarmonyControls() {
  document.getElementById('keySelect').addEventListener('change', e => {
    state.key = e.target.value;
    invalidateHarmonyCache();      // ðŸ§¹
    updateChords();
  });
  
  document.getElementById('scaleSelect').addEventListener('change', e => {
    state.scale = e.target.value;
    invalidateHarmonyCache();      // ðŸ§¹
    updateChords();
  });
  
  document.getElementById('octaveSelect').addEventListener('change', e => {
    state.octave = parseInt(e.target.value, 10);
    // (no need to invalidate here unless you use octave in chords)
  });
  
  document.getElementById('genProgBtn').addEventListener('click', () => {
    generateProgression();
    invalidateHarmonyCache();      // ðŸ§¹
  });

  document.getElementById('clearProgBtn').addEventListener('click', () => {
    state.progression = [];
    invalidateHarmonyCache();      // ðŸ§¹
    renderProgression();
  });

  document.querySelectorAll('[data-prog]').forEach(btn => {
    btn.addEventListener('click', e => {
      loadProgressionTemplate(e.currentTarget.dataset.prog);
      invalidateHarmonyCache();    // ðŸ§¹
    });
  });
}

function setupProjectManagement() {
  document.getElementById('saveBtn').addEventListener('click', saveProject);
  document.getElementById('loadBtn').addEventListener('click', loadProject);
}

function setupKeyboardShortcuts() {
  // Detect if device is mobile/tablet
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);
  
  // Don't enable keyboard shortcuts on mobile devices
  if (isMobile) {
    console.log('ðŸ“± Mobile device detected - keyboard shortcuts disabled');
    return;
  }

  document.addEventListener('keydown', e => {
    // Also check if user is typing in an input field
    const isTyping = e.target.tagName === 'INPUT' || 
                     e.target.tagName === 'TEXTAREA' || 
                     e.target.isContentEditable;
    
    if (isTyping) return; // Don't trigger shortcuts while typing

    // Basic transport shortcuts
    if (e.code === 'Space') {
      e.preventDefault();
      togglePlay();
    } else if (e.code === 'KeyS') {
      e.preventDefault();
      stop();
    } else if (e.code === 'KeyE') {
      e.preventDefault();
      exportAudio();
    }

    // === NEW MULTITRACK SHORTCUTS ===
    if (e.code === 'KeyX' && !e.ctrlKey && !e.metaKey) {
      // Split at playhead
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'split'
        );
      }
    }

    if (e.code === 'KeyD' && (e.ctrlKey || e.metaKey)) {
      // Duplicate region
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'duplicate'
        );
      }
    }

    if ((e.code === 'Delete' || e.code === 'Backspace') && !isTyping) {
      // Delete selected region
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        e.preventDefault();
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        const track = multitrack.tracks.find(t => t.id === trackId);
        if (track && confirm('Delete selected region?')) {
          track.deleteTake(takeIndex);
          renderMultitrack();
        }
      }
    }

    // Zoom shortcuts
    if (e.code === 'Equal' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomInBtn')?.click();
    }
    
    if (e.code === 'Minus' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomOutBtn')?.click();
    }
    
    // === UNDO/REDO ===
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && !e.shiftKey) {
      e.preventDefault();
      multitrackHistory.undo();
    }
      
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'KeyZ') {
      e.preventDefault();
      multitrackHistory.redo();
    }
      
    // Alternative: Ctrl+Y for redo
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {
      e.preventDefault();
      multitrackHistory.redo();
    }
  });
}


function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      applyVibe(nextVibe());
    });
  }
}

// -------------------- FX Parameter Mapping --------------------
function mapFxParam(param, raw) {
  switch (param) {
    case 'decay':
      return raw / 20;
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return raw / 100;
    case 'time':
      return ['16n', '8n', '4n', '2n'][Math.min(3, Math.floor(raw / 25))];
    case 'frequency':
      return 100 + raw * 79;
    case 'octaves':
      return Math.floor(raw / 20) + 1;
    default:
      return raw / 50;
  }
}

function applyFxParam(fx, param, value) {
  const node = effects[fx];
  if (!node) return;
  
  if (param === 'decay' && node.decay !== undefined) {
    node.decay = value;
  } else if (param === 'wet' && node.wet) {
    node.wet.value = value;
  } else if (param === 'time' && node.delayTime) {
    node.delayTime.value = Tone.Time(value);
  } else if (param === 'feedback' && node.feedback) {
    node.feedback.value = value;
  } else if (param === 'frequency') {
    // Safe frequency updates with ramp to avoid clicks
    if (node.frequency) {
      node.frequency.rampTo(value, 0.1);
    }
  } else if (param === 'depth') {
    if (node.depth !== undefined) {
      node.depth = value;
    }
  } else if (param === 'amount' && node.distortion !== undefined) {
    node.distortion = value;
  } else if (param === 'octaves' && node.octaves !== undefined) {
    node.octaves = value;
  }
}

function formatFxDisplay(param, value) {
  switch (param) {
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return Math.round(value * 100) + '%';
    case 'decay':
      return value.toFixed(2) + 's';
    case 'time':
      return String(value);
    case 'frequency':
      return Math.round(value) + 'Hz';
    case 'octaves':
      return value + ' oct';
    default:
      return String(value);
  }
}

// -------------------- Sequencer Rendering --------------------
let renderSequencerVersion = 0;

function renderSequencer() {
  const grid = document.getElementById('seqGrid');
  if (!grid) return;

  const instrumentKeys = Object.keys(instruments);
  if (!instrumentKeys.length) {
    grid.innerHTML = '';
    return;
  }

  // Bump version so any in-flight render knows it's stale
  const myVersion = ++renderSequencerVersion;

  // Clear old grid immediately so we don't layout around stale content
  grid.innerHTML = '';

  const fragment = document.createDocumentFragment();
  const totalInstruments = instrumentKeys.length;
  const ROWS_PER_FRAME = 2; // tweak: 1 = safest, 3â€“4 = faster but heavier

  function buildRow(inst) {
    const instData = instruments[inst];
    const row = document.createElement('div');
    row.className = 'seq-row';

    // --- Label ---
    const label = document.createElement('div');
    label.className = 'seq-label';

    const span = document.createElement('span');
    span.textContent = `${instData.icon} ${instData.name}`;
    label.appendChild(span);

    const iconsWrap = document.createElement('div');
    iconsWrap.className = 'seq-icons';

    const muteBtn = document.createElement('button');
    muteBtn.className = `seq-icon ${instData.mute ? 'active' : ''}`;
    muteBtn.dataset.inst = inst;
    muteBtn.dataset.action = 'mute';
    muteBtn.textContent = 'M';
    iconsWrap.appendChild(muteBtn);

    const soloBtn = document.createElement('button');
    soloBtn.className = `seq-icon ${instData.solo ? 'active' : ''}`;
    soloBtn.dataset.inst = inst;
    soloBtn.dataset.action = 'solo';
    soloBtn.textContent = 'S';
    iconsWrap.appendChild(soloBtn);

    if (instData.type === 'melodic') {
      const noteBtn = document.createElement('button');
      noteBtn.className = 'seq-icon';
      noteBtn.dataset.inst = inst;
      noteBtn.dataset.action = 'note';
      noteBtn.textContent = 'ðŸŽµ';
      iconsWrap.appendChild(noteBtn);
    }

    label.appendChild(iconsWrap);
    row.appendChild(label);

    // --- Steps ---
    const seqLen = state.sequenceLength;
    const instPatterns = patterns[inst];

    for (let i = 0; i < seqLen; i++) {
      const step = instPatterns[i];
      const cell = document.createElement('div');
      cell.className = 'step';
      cell.dataset.inst = inst;
      cell.dataset.step = i;

      if (step.active) {
        cell.classList.add('active');

        // Prob / note label
        const probLabel = document.createElement('div');
        probLabel.className = 'step-prob';

        if (instData.type === 'melodic' && step.note) {
          probLabel.textContent = step.note;
          probLabel.style.fontSize = '0.6rem';
        } else {
          probLabel.textContent = (step.probability ?? 100) + '%';
        }
        cell.appendChild(probLabel);

        // Velocity bar
        const velBar = document.createElement('div');
        velBar.className = 'step-vel';

        const fill = document.createElement('div');
        fill.className = 'step-vel-fill';
        fill.style.width = `${Math.round((step.velocity || 0) * 100)}%`;

        velBar.appendChild(fill);
        cell.appendChild(velBar);
      }

      row.appendChild(cell);
    }

    return row;
  }

  let nextIndex = 0;

  function renderChunk() {
    // If a newer render started, abort this one
    if (myVersion !== renderSequencerVersion) return;

    const end = Math.min(nextIndex + ROWS_PER_FRAME, totalInstruments);

    for (let idx = nextIndex; idx < end; idx++) {
      const inst = instrumentKeys[idx];
      const row = buildRow(inst);
      fragment.appendChild(row);
    }

    nextIndex = end;

    if (nextIndex < totalInstruments) {
      // More rows to do; yield to browser, then continue
      requestAnimationFrame(renderChunk);
    } else {
      // Finished building all rows; attach once
      if (myVersion !== renderSequencerVersion) return; // safety

      grid.appendChild(fragment);

      // Ensure playhead exists once grid is ready
      let playhead = document.getElementById('playhead');
      if (!playhead) {
        const seqWrapper = document.querySelector('.sequencer');
        if (seqWrapper) {
          playhead = document.createElement('div');
          playhead.id = 'playhead';
          playhead.className = 'playhead';
          seqWrapper.appendChild(playhead);
        }
      }
    }
  }

  // Kick off chunked render
  requestAnimationFrame(renderChunk);
}


function toggleStep(inst, stepIndex, e) {
  songBuilderState.isActive = false;
  const pattern = patterns[inst][stepIndex];
  const instData = instruments[inst];
  
  if (e.altKey) {
    if (pattern.active) {
      pattern.velocity = Math.min(1, (pattern.velocity || 0.8) + 0.2);
      if (pattern.velocity > 1) pattern.velocity = 0.4;
    }
  } else if (e.shiftKey) {
    if (pattern.active) {
      if (instData.type === 'melodic') {
        cycleNote(inst, stepIndex);
      } else {
        pattern.probability = Math.min(100, pattern.probability + 25);
        if (pattern.probability > 100) pattern.probability = 50;
      }
    }
  } else if (e.ctrlKey || e.metaKey) {
    if (instData.type === 'melodic' && pattern.active) {
      const newNote = prompt(
        `Enter note (e.g., C4, D#3):`,
        pattern.note || instData.note
      );
      if (newNote && /^[A-G]#?[1-6]$/.test(newNote)) {
        pattern.note = newNote;
      }
    }
  } else {
    pattern.active = !pattern.active;
    if (pattern.active) {
      pattern.velocity = 0.8;
      pattern.probability = 100;
      if (instData.type === 'melodic') {
        pattern.note = instData.note;
        pattern.duration = '8n';
      }
    }
  }
  
  renderSequencer();
}

function cycleNote(inst, stepIndex) {
  const pattern = patterns[inst][stepIndex];
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const currentNote = pattern.note || instruments[inst].note;
  const match = currentNote.match(/^([A-G]#?)(\d+)$/);
  if (!match) return;
  
  const [, noteName, octave] = match;
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12]);
  const index = scaleNotes.indexOf(noteName);
  const nextNote = scaleNotes[(index + 1 + scaleNotes.length) % scaleNotes.length] + octave;
  
  pattern.note = nextNote;
}

function updateStepVisuals(step) {
  const widthPerStep = 100 / state.sequenceLength;
  const playhead = document.getElementById('playhead');
  if (playhead) {
    playhead.style.transform = `translateX(${(step + 0.5) * widthPerStep}%)`;
  }
}

function openNoteEditor(inst) {
  // Create modal backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  // Get current note
  const currentNote = instruments[inst].note || 'C4';
  
  // Generate all possible notes (C1 to C6)
  const allNotes = [];
  for (let octave = 1; octave <= 6; octave++) {
    keysArr.forEach(note => {
      allNotes.push(note + octave);
    });
  }
  
  modal.innerHTML = `
    <div class="pro-locked">
      <div class="modal-header">
        <div class="modal-title">ðŸŽµ ${instruments[inst].icon} ${instruments[inst].name} - Select Note</div>
        <button class="modal-close" id="closeNoteModal">âœ•</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: var(--space-4); color: var(--text-secondary);">
          Choose the default note for <strong>${instruments[inst].name}</strong>. 
          This will apply to all active steps that don't have a custom note set.
        </p>
        
        <div style="display: grid; gap: var(--space-3);">
          <label style="display: flex; flex-direction: column; gap: var(--space-2);">
            <span style="font-weight: 700; color: var(--text-primary);">Note</span>
            <select id="noteSelect" style="font-size: var(--text-base); padding: var(--space-4);">
              ${allNotes.map(note => 
                `<option value="${note}" ${note === currentNote ? 'selected' : ''}>${note}</option>`
              ).join('')}
            </select>
          </label>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border);">
            <div style="font-weight: 700; margin-bottom: var(--space-2); color: var(--text-primary);">Current: ${currentNote}</div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              Lower octaves (1-2) = Bass range<br>
              Mid octaves (3-4) = Chord/melody range<br>
              High octaves (5-6) = Lead range
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelNoteBtn">Cancel</button>
        <button class="btn btn-primary" id="applyNoteBtn">Apply Note</button>
      </div>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  // Focus the select
  setTimeout(() => document.getElementById('noteSelect').focus(), 100);
  
  // Event handlers
  const close = () => backdrop.remove();
  
  document.getElementById('closeNoteModal').onclick = close;
  document.getElementById('cancelNoteBtn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  document.getElementById('applyNoteBtn').onclick = () => {
    const newNote = document.getElementById('noteSelect').value;
    instruments[inst].note = newNote;
    
    // Update all active steps without custom notes
    patterns[inst].forEach(step => {
      if (step.active && !step.note) {
        step.note = newNote;
      }
    });
    
    renderSequencer();
    close();
    
    // Show confirmation toast
    showToast(`ðŸŽµ ${instruments[inst].name} note set to ${newNote}`, 'success');
  };
  
  // Keyboard support
  modal.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
    if (e.key === 'Enter' && e.target.tagName !== 'SELECT') {
      document.getElementById('applyNoteBtn').click();
    }
  });
}

function showToast(message, type = 'info') {
  let container = document.querySelector('.toast-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'toast-container';
    document.body.appendChild(container);
  }
  
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: 'âœ“',
    error: 'âœ•',
    warning: 'âš ',
    info: 'â„¹'
  };
  
  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || icons.info}</span>
    <span>${message}</span>
    <button class="toast-close">âœ•</button>
  `;
  
  container.appendChild(toast);
  
  toast.querySelector('.toast-close').onclick = () => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => toast.remove(), 200);
  };
  
  // Auto-dismiss faster based on message length
  const baseTime = 1500; // 1.5s base
  const charTime = message.length * 30; // 30ms per character
  const dismissTime = Math.min(baseTime + charTime, 2000); // Max 2s
  
  setTimeout(() => {
    if (toast.parentElement) {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      setTimeout(() => toast.remove(), 200);
    }
  }, dismissTime);
  
  // Limit to 3 toasts at once
  const toasts = container.querySelectorAll('.toast');
  if (toasts.length > 3) {
    toasts[0].remove();
  }
}
  
// -------------------- Pattern Generators --------------------
function generateBeat() {
  songBuilderState.isActive = false;
  const genre = state.currentGenre;
  
  // Clear all patterns first
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
    });
  });
  
  // Generate rhythms based on genre theory
  if (genre === 'lofi') {
    generateLoFiBeat();
  } else if (genre === 'hiphop') {
    generateHipHopBeat();
  } else if (genre === 'postpunk') {
    generatePostPunkBeat();
  } else if (genre === 'rnb') {
    generateRnBBeat();
  } else if (genre === 'ambient') {
    generateAmbientBeat();
  } else if (genre === 'dazecore') {
    generateDazecoreBeat();
  }
  
  renderSequencer();
  
  // Auto-apply AI mixing if enabled
  if (state.aiMixing.enabled) {
    setTimeout(() => applyAIMixing(), 500);
  }
  
  console.log(`âœ… Generated ${genre} beat with ${state.complexity} complexity at ${state.bpm} BPM`);
}
  
// AI-powered beat generation
function generateAIVariation() {
  songBuilderState.isActive = false;
  const activeInsts = Object.keys(patterns).filter(inst =>
    patterns[inst].some(s => s.active)
  );
  
  if (activeInsts.length === 0) {
    showToast('âŒ Generate a beat first', 'error');
    return;
  }
  
  showToast('ðŸ¤– AI generating variation...', 'info');
  
  // Analyze current pattern
  const analysis = analyzePattern();
  
  // Generate variation based on style
  const variationType = Math.random();
  
  if (variationType < 0.25) {
    generateRhythmicDisplacement(analysis);
    showToast('ðŸŽ² Applied: Rhythmic Displacement', 'success');
  } else if (variationType < 0.5) {
    generateDensityVariation(analysis);
    showToast('ðŸŽ² Applied: Density Variation', 'success');
  } else if (variationType < 0.75) {
    generatePolyrhythmicLayer(analysis);
    showToast('ðŸŽ² Applied: Polyrhythmic Layer', 'success');
  } else {
    generateSyncopation(analysis);
    showToast('ðŸŽ² Applied: Syncopation', 'success');
  }
  
  renderSequencer();
}

function analyzePattern() {
  const analysis = {
    density: {},
    complexity: 0,
    activeSteps: 0,
    totalSteps: state.sequenceLength,
    instruments: {}
  };
  
  Object.keys(instruments).forEach(inst => {
    const steps = patterns[inst];
    const active = steps.filter(s => s.active).length;
    
    analysis.instruments[inst] = {
      density: active / state.sequenceLength,
      avgVelocity: active > 0 
        ? steps.filter(s => s.active).reduce((sum, s) => sum + s.velocity, 0) / active
        : 0,
      pattern: steps.map(s => s.active ? 1 : 0)
    };
    
    analysis.activeSteps += active;
  });
  
  analysis.complexity = analysis.activeSteps / (state.sequenceLength * Object.keys(instruments).length);
  
  return analysis;
}

function generateRhythmicDisplacement(analysis) {
  songBuilderState.isActive = false;
  // Shift patterns by random amounts to create variation
  const shiftAmount = Math.floor(Math.random() * 4) + 1;
  
  Object.keys(instruments).forEach(inst => {
    if (Math.random() > 0.6) return; // Only shift 40% of instruments
    
    const oldPattern = [...patterns[inst]];
    
    for (let i = 0; i < state.sequenceLength; i++) {
      const newIndex = (i + shiftAmount) % state.sequenceLength;
      patterns[inst][newIndex] = { ...oldPattern[i] };
    }
  });
}

function generateDensityVariation(analysis) {
  songBuilderState.isActive = false;
  // Add or remove notes to change groove density
  const shouldAdd = Math.random() > 0.5;
  
  Object.keys(instruments).forEach(inst => {
    const currentDensity = analysis.instruments[inst].density;
    
    if (shouldAdd && currentDensity < 0.6) {
      // Add ghost notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (!patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = true;
          patterns[inst][i].velocity = 0.3 + Math.random() * 0.2;
          patterns[inst][i].probability = 60 + Math.random() * 30;
        }
      }
    } else if (!shouldAdd && currentDensity > 0.3) {
      // Remove some notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = false;
        }
      }
    }
  });
}

function generatePolyrhythmicLayer(analysis) {
  songBuilderState.isActive = false;
  // Add polyrhythmic patterns (e.g., 3-over-4, 5-over-4)
  const polyrhythms = [3, 5, 7];
  const poly = polyrhythms[Math.floor(Math.random() * polyrhythms.length)];
  
  // Choose a percussive instrument
  const percInsts = Object.keys(instruments).filter(k => 
    instruments[k].type === 'drum' || instruments[k].type === 'atmospheric'
  );
  
  if (percInsts.length === 0) return;
  
  const inst = percInsts[Math.floor(Math.random() * percInsts.length)];
  
  // Clear existing pattern
  patterns[inst].forEach(s => s.active = false);
  
  // Apply polyrhythm
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % Math.floor(state.sequenceLength / poly) === 0) {
      patterns[inst][i].active = true;
      patterns[inst][i].velocity = 0.6 + Math.random() * 0.2;
      patterns[inst][i].probability = 90 + Math.random() * 10;
    }
  }
}

function generateSyncopation(analysis) {
  songBuilderState.isActive = false;
  // Add off-beat accents
  Object.keys(instruments).forEach(inst => {
    const instData = instruments[inst];
    if (instData.type !== 'drum') return;
    
    for (let i = 0; i < state.sequenceLength; i++) {
      // Target off-beats (odd steps)
      if (i % 2 === 1 && !patterns[inst][i].active && Math.random() > 0.6) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.5 + Math.random() * 0.3;
        patterns[inst][i].probability = 70 + Math.random() * 25;
      }
      
      // Occasionally accent existing off-beats
      if (i % 2 === 1 && patterns[inst][i].active && Math.random() > 0.7) {
        patterns[inst][i].velocity = Math.min(1, patterns[inst][i].velocity * 1.3);
      }
    }
  });
}

// Melodic AI variations
function generateMelodicAIVariation() {
  songBuilderState.isActive = false;
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  if (!melodicInsts.some(inst => patterns[inst].some(s => s.active))) {
    showToast('âŒ Generate melodies first', 'error');
    return;
  }
  
  showToast('ðŸŽ¹ AI generating melodic variation...', 'info');
  
  const variationType = Math.random();
  
  if (variationType < 0.33) {
    generateMelodicInversion();
    showToast('ðŸŽ² Applied: Melodic Inversion', 'success');
  } else if (variationType < 0.66) {
    generateArpeggiation();
    showToast('ðŸŽ² Applied: Arpeggiation', 'success');
  } else {
    generateHarmonicVariation();
    showToast('ðŸŽ² Applied: Harmonic Variation', 'success');
  }
  
  renderSequencer();
}

function generateMelodicInversion() {
  songBuilderState.isActive = false;
  // Invert melodic contours
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  melodicInsts.forEach(inst => {
    const notes = patterns[inst]
      .filter(s => s.active && s.note)
      .map(s => s.note);
    
    if (notes.length === 0) return;
    
    // Find pivot point (median note)
    const midiNotes = notes.map(n => Tone.Frequency(n).toMidi());
    const pivot = midiNotes.reduce((a, b) => a + b, 0) / midiNotes.length;
    
    // Invert around pivot
    patterns[inst].forEach(step => {
      if (step.active && step.note) {
        const midi = Tone.Frequency(step.note).toMidi();
        const distance = midi - pivot;
        const newMidi = Math.round(pivot - distance);
        step.note = Tone.Frequency(newMidi, 'midi').toNote();
      }
    });
  });
}

function generateArpeggiation() {
  songBuilderState.isActive = false;
  // Convert chords to arpeggios
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = state.octave;
  
  // Target keys instrument
  patterns.keys.forEach(step => step.active = false);
  
  // Create ascending arpeggio
  const arpPattern = [0, 2, 4, 2]; // I - III - V - III
  const arpSpeed = 2; // Every 2 steps
  
  for (let i = 0; i < state.sequenceLength; i += arpSpeed) {
    const degree = arpPattern[(i / arpSpeed) % arpPattern.length];
    const note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + octave;
    
    if (i < state.sequenceLength) {
      patterns.keys[i].active = true;
      patterns.keys[i].note = note;
      patterns.keys[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.keys[i].duration = '8n';
    }
  }
}

function generateHarmonicVariation() {
  songBuilderState.isActive = false;
  // Change chord voicings/extensions on melodic instruments
  const scaleIntervals = scales[state.scale];

  // Instruments we want to treat harmonically
  const chordInsts = ['keys', 'guitar', 'lead'];

  chordInsts.forEach(inst => {
    const pattern = patterns[inst];
    if (!pattern) return;

    pattern.forEach(step => {
      if (!step.active || !step.note) return;

      const baseNote = Array.isArray(step.note) ? step.note[0] : step.note;
      const match = baseNote.match(/^([A-G]#?)(\d+)$/);
      if (!match) return;

      const [, noteName, oct] = match;
      const noteIndex = keysArr.indexOf(noteName);
      if (noteIndex < 0) return;

      const extensions = [];

      // 9th
      if (Math.random() > 0.3) {
        const ninthName = keysArr[(noteIndex + scaleIntervals[1]) % 12];
        const ninth = ninthName + (parseInt(oct, 10) + 1);
        extensions.push(ninth);
      }

      // 11th
      if (Math.random() > 0.5) {
        const eleventhName = keysArr[(noteIndex + scaleIntervals[3]) % 12];
        const eleventh = eleventhName + (parseInt(oct, 10) + 1);
        extensions.push(eleventh);
      }

      if (!extensions.length) return;

      const originalChord = Array.isArray(step.note) ? step.note : [step.note];
      step.note = [...originalChord, ...extensions];
    });
  });
}

// Groove template system
function applyGrooveTemplate(template) {
  const templates = {
    shuffle: {
      name: 'Shuffle',
      // swing: 66,  // REMOVED - user controls this
      hihatPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      velocityMap: [0.8, 0.4, 0.7, 0.35, 0.8, 0.4, 0.7, 0.35]
    },
    halfTime: {
      name: 'Half-Time',
      // bpmMultiplier: 0.5,  // REMOVED
      kickPattern: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
    },
    doubleTime: {
      name: 'Double-Time',
      // bpmMultiplier: 2,  // REMOVED
      kickPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      hihatPattern: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    },
    breakbeat: {
      name: 'Breakbeat',
      kickPattern: [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1],
      complexity: 3
    }
  };
  
  const groove = templates[template];
  if (!groove) return;
  
  showToast(`ðŸŽµ Applying ${groove.name} groove...`, 'info');
  
  // NO BPM OR SWING CHANGES - user controls these for recording!
  
  // Apply patterns (extend to 32 steps if needed)
  if (groove.kickPattern) {
    patterns.kick.forEach((step, i) => {
      const patternIndex = i % groove.kickPattern.length;
      step.active = groove.kickPattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.8;
        step.probability = 100;
      }
    });
  }
  
  if (groove.snarePattern) {
    patterns.snare.forEach((step, i) => {
      const patternIndex = i % groove.snarePattern.length;
      step.active = groove.snarePattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.75;
        step.probability = 100;
      }
    });
  }
  
  if (groove.hihatPattern) {
    patterns.hihat.forEach((step, i) => {
      const patternIndex = i % groove.hihatPattern.length;
      step.active = groove.hihatPattern[patternIndex] === 1;
      if (step.active) {
        const velIdx = i % (groove.velocityMap?.length || 8);
        step.velocity = groove.velocityMap ? groove.velocityMap[velIdx] : 0.6;
        step.probability = 100;
      }
    });
  }
  
  renderSequencer();
  showToast(`âœ… ${groove.name} groove applied! (BPM/swing unchanged)`, 'success');
}
  
// Lo-Fi: Laid back, off-grid, jazzy
function generateLoFiBeat() {
  songBuilderState.isActive = false;
  // DON'T set BPM - user controls it
  const len = state.sequenceLength;
  
  // Kick: Sparse, on 1 and 3 throughout entire sequence
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    setStep('kick', offset + 8, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.3) setStep('kick', offset + 6, 0.7, 80);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 10, 0.75, 70);
  }
  
  // Snare: Backbeat on 2 and 4
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) setStep('snare', offset + 14, 0.4, 60);
  }
  
  // Hi-hat: Shuffled 8ths
  for (let i = 0; i < len; i += 2) {
    const vel = i % 4 === 0 ? 0.7 : 0.45;
    setStep('hihat', i, vel, 95);
    if (state.complexity >= 2 && i % 4 === 2) setStep('hihat', i + 1, 0.3, 70);
  }
  
  // Rimshot: Sparse accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.5, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.5, 80);
    }
  }
  
  // Crash: Bar markers
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
    }
  }
}
  
// Hip-Hop: Boom-bap, hard-hitting
function generateHipHopBeat() {
  songBuilderState.isActive = false;
  
  const len = state.sequenceLength;
  
  // Kick: Boom-bap throughout
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.9, 100);
    setStep('kick', offset + 6, 0.85, 100);
    if (state.complexity >= 2) {
      if (Math.random() > 0.5) setStep('kick', offset + 9, 0.8, 90);
      if (Math.random() > 0.6) setStep('kick', offset + 13, 0.75, 85);
    }
  }
  
  // Snare: Hard backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.9, 100);
    setStep('snare', offset + 12, 0.9, 100);
  }
  
  // Clap: Layer with snare
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('clap', offset + 4, 0.7, 100);
    setStep('clap', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Steady 8ths and 16ths
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    for (let i = 3; i < len; i += 4) {
      setStep('hihat', i, 0.4, 85);
    }
  }
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.5) setStep('crash', offset + 6, 0.5, 75);
      if (Math.random() > 0.5) setStep('crash', offset + 14, 0.5, 75);
    }
  }
  
  // Tom fills at end of each bar
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.65, 95);
        setStep('tom', offset + 14, 0.75, 95);
        setStep('tom', offset + 15, 0.85, 95);
      }
    }
  }
}
  
// Post-Punk: Driving, motorik, relentless
function generatePostPunkBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  const fourOnFloor = Math.random() > 0.3;
  
  // Kick: Four-on-floor or driving 8ths
  if (fourOnFloor) {
    for (let i = 0; i < len; i += 4) {
      setStep('kick', i, 0.85, 100);
    }
  } else {
    for (let i = 0; i < len; i += 2) {
      setStep('kick', i, i % 4 === 0 ? 0.85 : 0.75, 100);
    }
  }
  
  // Snare: Backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.8, 100);
    setStep('snare', offset + 12, 0.8, 100);
    if (state.complexity >= 2) setStep('snare', offset + 10, 0.7, 80);
  }
  
  // Rimshot: Driving 16ths
  if (state.complexity >= 2) {
    for (let i = 1; i < len; i += 2) {
      if (Math.random() > 0.4) setStep('rimshot', i, 0.5, 85);
    }
  }
  
  // Hi-hat: Mechanical 16ths
  for (let i = 0; i < len; i++) {
    const vel = i % 4 === 0 ? 0.7 : 0.5;
    setStep('hihat', i, vel, 100);
  }
  
  // Ride: Alternative
  if (state.complexity >= 3 && Math.random() > 0.5) {
    for (let i = 0; i < len; i += 2) {
      if (Math.random() > 0.3) setStep('ride', i, 0.55, 90);
    }
  }
  
  // Tom fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
        setStep('tom', offset + 15, 0.8, 90);
      }
    }
  }
  
  // Crash on downbeat
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.4) setStep('crash', bar * 16, 0.75, 100);
  }
}
  
// R&B: Syncopated, groovy, pocket
function generateRnBBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Syncopated
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.85, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 95);
    setStep('kick', offset + 10, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) setStep('kick', offset + 13, 0.7, 85);
  }
  
  // Snare: Laid back backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) {
      setStep('snare', offset + 11, 0.4, 70);
      setStep('snare', offset + 15, 0.45, 75);
    }
  }
  
  // Rimshot: Syncopated accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.55, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.55, 80);
    }
  }
  
  // Hi-hat: Intricate 16th patterns
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    const offbeats = [1, 3, 5, 9, 11, 13];
    for (let bar = 0; bar < len / 16; bar++) {
      offbeats.forEach(pos => {
        if (Math.random() > 0.3) setStep('hihat', bar * 16 + pos, 0.35, 75);
      });
    }
  }
  
  // Clap: Occasional layers
  if (state.complexity >= 3 && Math.random() > 0.6) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      setStep('clap', offset + 4, 0.5, 85);
      setStep('clap', offset + 12, 0.5, 85);
    }
  }
}
  
// Ambient: Sparse, textural, atmospheric
function generateAmbientBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Minimal bar markers
  for (let bar = 0; bar < len / 16; bar++) {
    setStep('kick', bar * 16, 0.7, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) {
      setStep('kick', bar * 16 + 8, 0.65, 90);
    }
  }
  
  // Snare: Very sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) setStep('snare', bar * 16 + 8, 0.5, 85);
    }
  }
  
  // Hi-hat: Sparse texture
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    if (Math.random() > 0.3) setStep('hihat', offset + 0, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 6, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 10, 0.4, 80);
  }
  
  // Crash: Textural swells
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
      if (Math.random() > 0.4) setStep('crash', bar * 16 + 12, 0.55, 80);
    }
  }
  
  // Ride: Subtle pulse
  if (state.complexity >= 3) {
    for (let i = 0; i < len; i += 4) {
      if (Math.random() > 0.3) setStep('ride', i, 0.35, 70);
    }
  }
  
  // Tom: Occasional atmospheric hits
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.7) {
        const tomStep = [4, 8, 12][Math.floor(Math.random() * 3)];
        setStep('tom', bar * 16 + tomStep, 0.45, 75);
      }
    }
  }
}
  
function generateDazecoreBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Warm and bouncy
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 90);
    setStep('kick', offset + 12, 0.8, 100);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 3, 0.5, 70);
  }
  
  // Snare: Off-grid, nostalgic
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.7, 100);
    if (state.complexity >= 2) setStep('snare', offset + 7, 0.5, 80);
    setStep('snare', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Shimmering, irregular
  const glitchyHats = [0, 2, 3, 5, 6, 8, 10, 11, 13, 14];
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    glitchyHats.forEach((step, idx) => {
      const vel = idx % 3 === 0 ? 0.65 : 0.4;
      const prob = Math.random() > 0.2 ? 90 : 60;
      setStep('hihat', offset + step, vel, prob);
    });
  }
  
  // Rimshot: Dial-up clicks
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [1, 5, 9].forEach(step => {
        if (Math.random() > 0.4) setStep('rimshot', offset + step, 0.45, 75);
      });
    }
  }
  
  // Clap: Sunny handclaps
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.3) setStep('clap', offset + 7, 0.55, 85);
      if (Math.random() > 0.3) setStep('clap', offset + 15, 0.55, 85);
    }
  }
  
  // Tom: Nostalgic fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
      }
    }
  }
  
  // Crash: Sunshine swells
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.5) setStep('crash', bar * 16, 0.65, 95);
  }
}

// Helper to set a step
function setStep(inst, step, velocity, probability) {
  if (step < state.sequenceLength) {
    patterns[inst][step].active = true;
    patterns[inst][step].velocity = velocity;
    patterns[inst][step].probability = probability;
  }
}

// ==================== BEAT VARIETY GENERATORS ====================

// Add rhythmic variations - keep the groove but make it interesting
function addRhythmicVariety() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Add syncopated kicks (occasional off-beat hits)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 30% chance to add syncopated kick
      if (Math.random() > 0.7) {
        const positions = [3, 7, 11, 15]; // Syncopated positions
        const pos = positions[Math.floor(Math.random() * positions.length)];
        setStep('kick', offset + pos, 0.65 + Math.random() * 0.15, 85);
      }
    }
  }
  
  // Add hi-hat variations (open hats, rolls)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // Random hi-hat roll at end of bar
      if (Math.random() > 0.6) {
        for (let i = 13; i < 16; i++) {
          if (Math.random() > 0.3) {
            setStep('hihat', offset + i, 0.4 + Math.random() * 0.2, 90);
          }
        }
      }
    }
  }
  
  // Add snare flams (double hits)
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 20% chance to add flam before main snare
      [4, 12].forEach(mainHit => {
        if (Math.random() > 0.8 && !patterns.snare[offset + mainHit - 1].active) {
          setStep('snare', offset + mainHit - 1, 0.4, 80);
        }
      });
    }
  }
  
  // Add crash accents on sections
  if (state.complexity >= 2) {
    const sectionsCount = Math.floor(len / 16);
    for (let i = 0; i < sectionsCount; i += 4) {
      // Every 4 bars, add emphasis
      if (i > 0) {
        setStep('crash', i * 16, 0.7, 100);
      }
    }
  }
  
  renderSequencer();
}

// Create a fill pattern at the end of 4/8 bar sections
function addDrumFills() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  const barsPerFill = state.complexity === 1 ? 8 : state.complexity === 2 ? 4 : 2;
  
  for (let bar = barsPerFill - 1; bar < len / 16; bar += barsPerFill) {
    const fillStart = bar * 16 + 12; // Last 4 steps of bar
    
    if (fillStart + 4 > len) continue;
    
    // Random fill type
    const fillType = Math.floor(Math.random() * 3);
    
    if (fillType === 0) {
      // Tom roll descending
      for (let i = 0; i < 4; i++) {
        setStep('tom', fillStart + i, 0.6 + (i * 0.1), 95);
      }
    } else if (fillType === 1) {
      // Snare roll
      for (let i = 0; i < 4; i++) {
        if (i % 2 === 0 || state.complexity >= 3) {
          setStep('snare', fillStart + i, 0.5 + (i * 0.1), 90);
        }
      }
    } else {
      // Mixed fill (toms + crash)
      setStep('tom', fillStart + 0, 0.6, 95);
      setStep('tom', fillStart + 1, 0.7, 95);
      setStep('snare', fillStart + 2, 0.75, 95);
      setStep('crash', fillStart + 3, 0.8, 100);
    }
  }
  
  renderSequencer();
}

// Add swing feel variations
function addSwingVariations() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Offset every other hi-hat slightly for swing feel
  for (let i = 1; i < len; i += 4) {
    if (patterns.hihat[i].active) {
      patterns.hihat[i].velocity *= 0.7; // Quieter on off-beats
    }
  }
  
  // Add ghost notes on snare
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      const ghostPositions = [2, 6, 10, 14];
      
      ghostPositions.forEach(pos => {
        if (Math.random() > 0.6 && !patterns.snare[offset + pos].active) {
          setStep('snare', offset + pos, 0.25 + Math.random() * 0.15, 70);
        }
      });
    }
  }
  
  renderSequencer();
}
  
// More subtle variations - don't destroy the groove
function addSubtleVariations() {
  songBuilderState.isActive = false;
  // Only add to hi-hats and rimshots - keep kick/snare solid
  ['hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      // Only 15% chance to add variation on empty steps
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 30;
      }
    }
  });
}

// Add after generateBeat function
function applyGenreFX() {
  songBuilderState.isActive = false;
  if (state.currentGenre === 'postpunk') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 2.0;
    fxConfig.chorus.active = true;
    fxConfig.filter.active = false;
  } else if (state.currentGenre === 'rnb') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.5;
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.3;
    fxConfig.distortion.active = false;
  } else if (state.currentGenre === 'dazecore') {
    // Warm glitchy sunshine sound
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.8; // Nostalgic space
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.5; // Shimmer
    fxConfig.bitcrusher.active = true; // Dial-up glitch texture
    fxConfig.bitcrusher.bits = 6; // Lo-fi crunch
    fxConfig.delay.active = true; // Echo memories
    fxConfig.delay.time = '8n';
    fxConfig.delay.feedback = 0.3;
    fxConfig.filter.active = true; // Warm cut
    fxConfig.filter.frequency = 4000; // Bright but not harsh
  }
  
  // Apply settings
  Object.keys(fxConfig).forEach(fx => {
    const cfg = fxConfig[fx];
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = cfg.active ? 0.25 : 0;
    }
  });
  
  renderFX();
}
  
function addVariations() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.2 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.3;
        patterns[inst][i].probability = 50 + Math.random() * 50;
      }
    }
  });
}

function addGhostNotes() {
  songBuilderState.isActive = false;
  ['snare', 'hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.2 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 40;
      }
    }
  });
  renderSequencer();
}

function randomizeVelocity() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.velocity = 0.5 + Math.random() * 0.5;
      }
    });
  });
  renderSequencer();
}

function randomizeProbability() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.probability = 50 + Math.floor(Math.random() * 51);
      }
    });
  });
  renderSequencer();
}

function clearPattern() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
  renderSequencer();
}

function generateMelodicPatterns() {
  songBuilderState.isActive = false;

  ensureHarmonyGuardrails();
  
  const genre = state.currentGenre;
  
  // Generate based on genre characteristics
  if (genre === 'lofi') {
    generateLoFiMelodies();
  } else if (genre === 'hiphop') {
    generateHipHopMelodies();
  } else if (genre === 'postpunk') {
    generatePostPunkMelodies();
  } else if (genre === 'rnb') {
    generateRnBMelodies();
  } else if (genre === 'ambient') {
    generateAmbientMelodies();
  } else if (genre === 'dazecore') {
    generateDazecoreMelodies();
  }
  
  renderSequencer();
}

// Lo-Fi: chords/bass/lead driven by the active chord progression (phrase-aware)
function generateLoFiMelodies() {
  songBuilderState.isActive = false;
  ensureHarmonyGuardrails();

  const len = state.sequenceLength;
  const bars = Math.max(1, Math.floor(len / 16));
  const keysOct  = state.octave || 3;   // keys/blocks
  const bassOct  = (state.octave || 3) - 2;
  const leadOct  = (state.octave || 3) + 1;

  // Clear any existing melodic notes
  ['bass','keys','lead','guitar'].forEach(inst => {
    if (!patterns[inst]) return;
    for (let i=0;i<len;i++) {
      patterns[inst][i].active = false;
      patterns[inst][i].note = instruments[inst]?.note || patterns[inst][i].note;
      patterns[inst][i].velocity = 0.8;
      patterns[inst][i].duration = '8n';
    }
  });

  // Simple A / A' phrase plan: first half repeats with light variation
  const phraseLenBars = Math.max(2, Math.min(4, bars)); // 2â€“4 bar phrase
  let lastLeadPC = null; // previous pitch-class for smoothing

  for (let bar = 0; bar < bars; bar++) {
    const offset = bar * 16;
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale); // safety
    const [root, third, fifth] = chord;

    // === KEYS (block chords on the grid) ===
    // Downbeats: 0, 4, 8, 12 â€” alternate chord tones
    const keysPlan = [
      withOct(root,  keysOct),
      withOct(third, keysOct),
      withOct(fifth, keysOct),
      withOct(root,  keysOct)
    ];
    [0,4,8,12].forEach((step, i) => {
      const idx = offset + step;
      patterns.keys[idx].active   = true;
      patterns.keys[idx].note     = keysPlan[i % keysPlan.length];
      patterns.keys[idx].velocity = 0.6;
      patterns.keys[idx].duration = '2n';
    });

    // === BASS (root/5th on strong beats, passing on weak) ===
    for (let s = 0; s < 16; s++) {
      const idx = offset + s;
      const n = chooseBassNote(chord, s, bassOct);
      if (s % 2 === 0) { // half the density; feel free to tweak
        patterns.bass[idx].active   = true;
        patterns.bass[idx].note     = n;
        patterns.bass[idx].velocity = (s % 4 === 0) ? 0.9 : 0.7;
        patterns.bass[idx].duration = (s % 4 === 0) ? '8n' : '16n';
      }
    }

    // === LEAD (motif that lightly varies every phrase) ===
    // Place on weak beats inside the bar for a laid-back feel
    const motifSteps = [2, 6, 10, 14];
    motifSteps.forEach((s, i) => {
      const idx = offset + s;
      const n = chooseMelodyNote(chord, s, leadOct, lastLeadPC);
      lastLeadPC = n; // keep string (has octave, okay)
      patterns.lead[idx].active   = true;
      patterns.lead[idx].note     = n;
      patterns.lead[idx].velocity = 0.7;
      patterns.lead[idx].duration = '8n';
    });

    // === Light variation on A' phrases ===
    if (bar >= phraseLenBars && (bar % phraseLenBars === 0)) {
      // Nudge one keys hit and one lead note
      const idxK = offset + 8;
      if (patterns.keys[idxK]?.active) {
        patterns.keys[idxK].note = withOct(third, keysOct); // swap tone
      }
      const idxL = offset + 10;
      if (patterns.lead[idxL]?.active) {
        patterns.lead[idxL].note = withOct(fifth, leadOct); // small lift
      }
    }
  }

  renderSequencer?.();
}

// Hip-Hop: Heavy bass, sparse chords, melodic hooks
function generateHipHopMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root notes, heavy and sparse
  const bassOctave = 1;
  const bassPattern = [0, 0, 4, 0, 0, 3, 0, 5];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassPattern.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.8;
        patterns.bass[offset + step].duration = '4n';
      }
    });
  }
  
  // Keys: Simple triads on downbeats
  const chordOctave = 3;
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach(step => {
      const root = keysArr[keyIndex] + chordOctave;
      const third = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
      const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
      
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = [root, third, fifth];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '1n';
    });
  }
  
  // Lead: Melodic hook
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const hook = [0, 3, 2, 0, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (hook[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[hook[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.6;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 100;
        }
      });
    }
  }
}

// Post-Punk: Dark bass, angular guitars, minimal keys
function generatePostPunkMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Driving 8th notes, root-fifth motion
  const bassOctave = 1;
  
  for (let i = 0; i < len; i += 2) {
    patterns.bass[i].active = true;
    const useFifth = i % 4 === 2;
    const degree = useFifth ? 4 : 0;
    patterns.bass[i].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[i].velocity = 0.75;
    patterns.bass[i].duration = '8n';
  }
  
  // Guitar: Power chords, angular rhythm
  if (state.complexity >= 2) {
    const chordOctave = 2;
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [0, 4, 8, 12].forEach(step => {
        const root = keysArr[keyIndex] + chordOctave;
        const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
        const octave = keysArr[keyIndex] + (chordOctave + 1);
        
        patterns.guitar[offset + step].active = true;
        patterns.guitar[offset + step].note = [root, fifth, octave];
        patterns.guitar[offset + step].velocity = 0.6;
        patterns.guitar[offset + step].duration = '4n';
      });
    }
  }
  
  // Keys: Sparse stabs
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [6, 14].forEach(step => {
        if (Math.random() > 0.3) {
          const chordOctave = 4;
          patterns.keys[offset + step].active = true;
          patterns.keys[offset + step].note = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
          patterns.keys[offset + step].velocity = 0.5;
          patterns.keys[offset + step].duration = '16n';
        }
      });
    }
  }
}

// R&B: Smooth chords, groovy bass, soulful leads
function generateRnBMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Syncopated groove
  const bassOctave = 2;
  const bassGroove = [0, null, 4, null, 3, null, 5, null];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassGroove.forEach((degree, idx) => {
      const step = idx * 2;
      if (degree !== null && step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7;
        patterns.bass[offset + step].duration = '8n';
      }
    });
  }
  
  // Keys: 7th chords with extensions
  const chordOctave = 3;
  const rnbChords = [0, 3, 4, 5].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = rnbChords[idx % rnbChords.length];
      patterns.keys[offset + step].velocity = 0.45;
      patterns.keys[offset + step].duration = '2n';
    });
  }
  
  // Guitar: Rhythm chops
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach(step => {
        if (Math.random() > 0.4) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = rnbChords[Math.floor(step / 4) % rnbChords.length];
          patterns.guitar[offset + step].velocity = 0.35;
          patterns.guitar[offset + step].duration = '16n';
        }
      });
    }
  }
  
  // Lead: Soulful melody
  if (state.complexity >= 3) {
    const leadOctave = 5;
    const soul = [0, 2, 3, 4, 3, 2, 0, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      soul.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.55 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Ambient: Atmospheric pads, sparse melodic elements
function generateAmbientMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Long sustained root notes
  const bassOctave = 2;
  const bassProgression = [0, 4]; // Alternate between root and fifth
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    const degree = bassProgression[bar % bassProgression.length];
    
    patterns.bass[offset].active = true;
    patterns.bass[offset].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[offset].velocity = 0.6;
    patterns.bass[offset].duration = '1n';
    
    if (state.complexity >= 2 && bar % 2 === 1) {
      patterns.bass[offset + 8].active = true;
      patterns.bass[offset + 8].note = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12] + bassOctave;
      patterns.bass[offset + 8].velocity = 0.55;
      patterns.bass[offset + 8].duration = '1n';
    }
  }
  
  // Keys: Wide ambient chords
  const chordOctave = 3;
  const ambientChords = [0, 4, 5, 3].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + (chordOctave - 1), third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = ambientChords[(bar + idx) % ambientChords.length];
        patterns.keys[offset + step].velocity = 0.4;
        patterns.keys[offset + step].duration = '1n';
      }
    });
  }
  
  // Lead: Sparse ethereal notes
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const etherealNotes = [0, 2, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [4, 8, 12].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = etherealNotes[idx % etherealNotes.length];
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.35;
          patterns.lead[offset + step].duration = '2n';
          patterns.lead[offset + step].probability = 70;
        }
      });
    }
  }
}

// Dazecore: Warm, nostalgic melodies with glitchy textures
function generateDazecoreMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.major;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Warm, syncopated bounce
  const bassOctave = 2;
  const sunnyBass = [0, 0, 2, 0, 4, 0, 2, 0];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    sunnyBass.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7 + Math.random() * 0.1;
        patterns.bass[offset + step].duration = '8n';
        patterns.bass[offset + step].probability = 95;
      }
    });
  }
  
  // Keys: Shimmering nostalgic chords with add9s
  const chordOctave = 3;
  const nostalgiaChords = [0, 4, 5, 2].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = nostalgiaChords[idx % nostalgiaChords.length];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '2n';
      patterns.keys[offset + step].probability = 95;
    });
  }
  
  // Guitar: Glitchy arpeggios (dial-up texture)
  if (state.complexity >= 2) {
    const arpSteps = [1, 2, 5, 6, 9, 10, 13, 14];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      arpSteps.forEach((step, idx) => {
        if (Math.random() > 0.3) {
          const chordIdx = Math.floor(step / 4) % nostalgiaChords.length;
          const noteIdx = idx % 4;
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = nostalgiaChords[chordIdx][noteIdx];
          patterns.guitar[offset + step].velocity = 0.35 + Math.random() * 0.15;
          patterns.guitar[offset + step].duration = '16n';
          patterns.guitar[offset + step].probability = 70 + Math.floor(Math.random() * 25);
        }
      });
    }
  }
  
  // Lead: Nostalgic melody fragments (summer memory)
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const memory = [4, 5, 4, 2, 0, 2, 4, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      memory.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16 && Math.random() > 0.2) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 85;
        }
      });
    }
  }
}
// Add after generateMelodicPatterns function
function addDrumFills() {
  songBuilderState.isActive = false;
  // Add crash on bar 1
  patterns.crash[0].active = true;
  patterns.crash[0].velocity = 0.8;
  patterns.crash[0].probability = 100;
  
  // Random tom fills every 2 bars
  if (state.complexity >= 2) {
    for (let bar = 1; bar < state.sequenceLength / 16; bar++) {
      const fillStart = (bar * 16) - 4; // Last 4 steps of bar
      
      if (Math.random() < 0.3) { // 30% chance
        for (let i = 0; i < 4; i++) {
          if (Math.random() < 0.7) {
            patterns.tom[fillStart + i].active = true;
            patterns.tom[fillStart + i].velocity = 0.6 + (i * 0.1);
          }
        }
      }
    }
  }
}

function generateBassLine() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const root = state.key;
  const octave = 2; // Keep bass in low register
  
  // Use darker intervals - root, minor 3rd, 4th, 5th
  const bassNotes = [
    root + octave,
    keysArr[(keyIndex + scaleIntervals[2]) % 12] + octave,  // minor 3rd
    keysArr[(keyIndex + scaleIntervals[3]) % 12] + octave,  // 4th
    keysArr[(keyIndex + scaleIntervals[4]) % 12] + octave   // 5th
  ];
  
  const density = state.complexity === 1 ? 4 : state.complexity === 2 ? 6 : 8;
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % (16 / density) === 0 || (state.complexity >= 3 && Math.random() < 0.2)) {
      patterns.bass[i].active = true;
      patterns.bass[i].note = bassNotes[Math.floor(i / 4) % bassNotes.length];
      patterns.bass[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.bass[i].duration = '4n'; // Longer, sustained notes
      patterns.bass[i].probability = 100;
    }
  }
}

function generateKeyPattern() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 3; // Lower octave - darker
  
  // Build darker, more dissonant chords
  const chords = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 4][i]; // Use 2nd (adds tension), minor 3rd, 4th
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % scaleIntervals.length]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Add 7th for more color/tension
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % scaleIntervals.length]) % 12];
    
    chords.push([
      root + octave, 
      third + octave, 
      fifth + octave,
      seventh + (octave + 1)
    ]);
  }
  
  // Sparse, sustained pads
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % 8 === 0) { // Only every 8 steps = very sparse
      const index = Math.floor(i / 8) % chords.length;
      patterns.keys[i].active = true;
      patterns.keys[i].note = chords[index];
      patterns.keys[i].velocity = 0.5 + Math.random() * 0.15; // Quiet
      patterns.keys[i].duration = '1n'; // Whole note - long sustain
      patterns.keys[i].probability = 100;
    }
  }
}

function generateLeadMelody() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 4; // Medium-low register
  
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12] + octave);
  
  let lastIndex = 0;
  const density = state.complexity === 1 ? 2 : state.complexity === 2 ? 3 : 5; // Very sparse
  
  for (let i = 0; i < state.sequenceLength; i++) {
    // Much sparser - only occasional notes
    if (Math.random() < (density / 32)) { // Half the normal density
      // Prefer downward motion (darker feel)
      const jump = Math.random() < 0.6 ? -1 : (Math.random() < 0.7 ? 1 : 2);
      
      lastIndex = clamp(lastIndex + jump, 0, scaleNotes.length - 1);
      
      patterns.lead[i].active = true;
      patterns.lead[i].note = scaleNotes[lastIndex];
      patterns.lead[i].velocity = 0.4 + Math.random() * 0.2; // Quiet, ghostly
      patterns.lead[i].duration = Math.random() < 0.7 ? '4n' : '2n'; // Longer notes
      patterns.lead[i].probability = Math.random() < 0.6 ? 100 : 70; // Some randomness
    }
  }
}

// Add after line ~1260 (after generateLeadMelody function)
function generateGuitarStrums() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 2; // Lower, darker
  
  // Build power chords and sus chords (no 3rd = ambiguous/dreamy)
  const chordShapes = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 5][i];
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const fourth = keysArr[(keyIndex + scaleIntervals[(degree + 3) % scaleIntervals.length]) % 12]; // sus4
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Sus chords = dreamy, no major/minor
    chordShapes.push([
      root + octave, 
      fourth + octave, 
      fifth + octave,
      root + (octave + 1)
    ]);
  }
  
  // Very sparse strumming
  const strumPattern = [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]; // Only twice per bar
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (strumPattern[i % strumPattern.length]) {
      const chordIndex = Math.floor(i / 8) % chordShapes.length;
      patterns.guitar[i].active = true;
      patterns.guitar[i].note = chordShapes[chordIndex];
      patterns.guitar[i].velocity = 0.4 + Math.random() * 0.15; // Quiet
      patterns.guitar[i].duration = '2n'; // Half note sustain
      patterns.guitar[i].probability = 100;
    }
  }
}

function applyEuclidean() {
  songBuilderState.isActive = false;
  const instrumentKeys = Object.keys(instruments);
  const inst = instrumentKeys[Math.floor(Math.random() * instrumentKeys.length)];
  const hits = Math.floor(Math.random() * 8) + 3;
  const steps = state.sequenceLength;
  
  const pattern = generateEuclidean(hits, steps);
  pattern.forEach((value, i) => {
    patterns[inst][i].active = value === 1;
    if (value === 1) {
      patterns[inst][i].velocity = 0.7 + Math.random() * 0.3;
      patterns[inst][i].probability = 100;
    }
  });
  
  renderSequencer();
}

function generateEuclidean(hits, steps) {
  songBuilderState.isActive = false;
  const result = Array(steps).fill(0);
  const bucket = [];
  
  for (let i = 0; i < steps; i++) {
    bucket.push(Math.floor((i * hits) / steps));
  }
  
  for (let i = 0; i < steps; i++) {
    if (i === 0 || bucket[i] !== bucket[i - 1]) {
      result[i] = 1;
    }
  }
  
  return result;
}

// -------------------- Mixer Rendering --------------------
function renderMixer() {
  const grid = document.getElementById('mixerGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const data = instruments[inst];
    const channel = document.createElement('div');
    channel.className = 'mixer-channel';
    
    channel.innerHTML = `
      <div class="channel-header">
        <div class="channel-name">${data.icon} ${data.name}</div>
        <div class="channel-btns">
          <button class="channel-btn mute ${data.mute ? 'active' : ''}" 
                  data-inst="${inst}" data-action="mute">M</button>
          <button class="channel-btn solo ${data.solo ? 'active' : ''}" 
                  data-inst="${inst}" data-action="solo">S</button>
        </div>
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Volume</span>
          <span class="param-value">${data.volume}dB</span>
        </div>
        <input type="range" min="-40" max="10" value="${data.volume}" 
               data-inst="${inst}" data-param="volume">
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Pan</span>
          <span class="param-value">${data.pan > 0 ? 'R' : data.pan < 0 ? 'L' : 'C'}${Math.abs(data.pan)}</span>
        </div>
        <input type="range" min="-100" max="100" value="${data.pan}" 
               data-inst="${inst}" data-param="pan">
      </div>
    `;
    
    fragment.appendChild(channel);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- FX Rendering --------------------
function renderFX() {
  const grid = document.getElementById('fxGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(fxConfig).forEach(fx => {
    const config = fxConfig[fx];
    const unit = document.createElement('div');
    unit.className = 'fx-unit';
    
    const params = Object.keys(config).filter(k => k !== 'name' && k !== 'active');
    let paramsHTML = '';
    
    params.forEach(param => {
      const value = config[param];
      const display = formatFxDisplay(param, value);
      
      let sliderVal = 50;
      if (param === 'decay') {
        sliderVal = clamp(Math.round(value * 20), 0, 100);
      } else if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
        sliderVal = Math.round(value * 100);
      } else if (param === 'time') {
        const timeMap = { '16n': 0, '8n': 33, '4n': 66, '2n': 100 };
        sliderVal = timeMap[value] ?? 50;
      } else if (param === 'frequency') {
        sliderVal = Math.round((value - 100) / 79);
      } else if (param === 'octaves') {
        sliderVal = (value - 1) * 20;
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value">${display}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx="${fx}" data-param="${param}">
        </div>
      `;
    });
    
    unit.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${config.name}</div>
        <div class="fx-toggle ${config.active ? 'active' : ''}" data-fx="${fx}"></div>
      </div>
      ${paramsHTML}
    `;
    
    fragment.appendChild(unit);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);

  wireGlobalFXControls();
}

function wireGlobalFXControls() {
  const grid = document.getElementById('fxGrid');
  if (!grid) return;

  // Avoid double binding if renderFX runs multiple times
  if (grid.dataset._wired === 'true') return;
  grid.dataset._wired = 'true';

  // --- Slider changes ---
  grid.addEventListener('input', (e) => {
    const target = e.target;
    if (!(target instanceof HTMLInputElement)) return;
    if (target.type !== 'range') return;

    const fxName = target.dataset.fx;
    const param  = target.dataset.param;
    if (!fxName || !param) return;

    const raw = parseFloat(target.value);
    const mapped = sliderToFxValue(fxName, param, raw);

    // Update config
    const cfg = fxConfig[fxName];
    if (cfg) cfg[param] = mapped;

    // Push into Tone node
    applyFxParamToNode(fxName, param, mapped);

    // Update displayed text
    const label = target.closest('.param-control')?.querySelector('.param-value');
    if (label) {
      label.textContent = formatFxDisplay(param, mapped);
    }
  });

  // --- Toggle active on/off ---
  grid.addEventListener('click', (e) => {
    const toggle = e.target.closest('.fx-toggle');
    if (!toggle) return;

    const fxName = toggle.dataset.fx;
    const cfg = fxConfig[fxName];
    if (!cfg) return;

    cfg.active = !cfg.active;
    toggle.classList.toggle('active', cfg.active);

    applyFxActiveState(fxName, cfg.active);
  });
}

// Map 0â€“100 slider â†’ actual useful value
function sliderToFxValue(fxName, param, raw) {
  // Normalized 0â€“1
  if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
    return raw / 100;
  }

  if (param === 'decay') {
    // 0â€“5 seconds
    return raw / 20;
  }

  if (param === 'time') {
    const steps = ['16n', '8n', '4n', '2n'];
    return steps[Math.round(raw / 33)] || '4n';
  }

  if (param === 'frequency') {
    // 100 Hz â†’ 8000 Hz
    return 100 + (raw / 100) * (8000 - 100);
  }

  if (param === 'octaves') {
    // 1 â†’ 6 octaves
    return 1 + (raw / 20);
  }

  if (param === 'bits') {
    // 4 â†’ 16 bits
    return Math.round(4 + (raw / 100) * 12);
  }

  return raw;
}

// Actually update the Tone.js nodes you created in initAudio
function applyFxParamToNode(fxName, param, value) {
  const fx = effects[fxName];
  if (!fx) return;

  const ramp = 0.05;

  try {
    if (fxName === 'reverb') {
      if (param === 'decay' && fx.decay !== undefined) fx.decay = value;
      if (param === 'wet' && fx.wet) fx.wet.rampTo(value, ramp);
    }
    else if (fxName === 'delay') {
      if (param === 'time' && fx.delayTime) fx.delayTime.value = Tone.Time(value);
      if (param === 'feedback' && fx.feedback) fx.feedback.rampTo(value, ramp);
    }
    else if (fxName === 'chorus' || fxName === 'flanger') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'depth' && fx.depth !== undefined) fx.depth = value;
    }
    else if (fxName === 'phaser') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'octaves' && fx.octaves !== undefined) fx.octaves = value;
    }
    else if (fxName === 'distortion') {
      if (param === 'amount' && fx.distortion !== undefined) fx.distortion = value;
    }
    else if (fxName === 'bitcrusher') {
      if (param === 'bits' && fx.bits !== undefined) fx.bits = value;
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
    }
    else if (fxName === 'filter') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'type' && typeof fx.type === 'string') fx.type = value;
    }
  } catch (err) {
    console.warn(`FX param update failed for ${fxName}.${param}`, err);
  }
}

// Turn FX "on/off" based on fxConfig.active
function applyFxActiveState(fxName, active) {
  const fx = effects[fxName];
  if (!fx) return;

  // Most of your effects in initAudio are Tone.Effect subclasses, so they have .wet
  if (fx.wet) {
    const cfg = fxConfig[fxName];
    const wet = cfg && typeof cfg.wet === 'number' ? cfg.wet : (active ? 0.3 : 0);
    fx.wet.value = active ? wet : 0;
    return;
  }

  // Special case: filter has no .wet - "off" = wide open
  if (fxName === 'filter' && fx.frequency) {
    const targetFreq = active ? (fxConfig.filter.frequency || 5000) : 20000;
    fx.frequency.rampTo(targetFreq, 0.05);
  }
}

/* ============================
   HARMONY GUARDRAILS (v1.7)
   - Progression templates (degrees)
   - Triad builder from scale
   - Normalization of state.progression -> state.progressionNotes
   - Chord/phrase helpers
============================ */

const PROGRESSION_TEMPLATES = {
  lofi: [
    // Degrees in current scale (0..6)
    [0, 5, 3, 4],  // I â€“ vi â€“ IV â€“ V
    [1, 4, 0, 5],  // ii â€“ V â€“ I â€“ vi
    [0, 3, 4, 0],  // I â€“ IV â€“ V â€“ I
    [5, 3, 0, 4],  // vi â€“ IV â€“ I â€“ V
  ],
  hiphop: [
    [5, 3, 0, 4],  // vi â€“ IV â€“ I â€“ V
    [0, 0, 3, 4],  // I â€“ I â€“ IV â€“ V
  ],
  default: [[0, 3, 4, 0]]
};

// Build a triad (root, 3rd, 5th) from a scale degree using your keysArr/scales tables
function buildTriadFromDegree(degree, keyRoot = state.key, scaleName = state.scale) {
  const keyIndex = keysArr.indexOf(keyRoot);
  const scaleIntervals = scales[scaleName] || scales.major; // fallback
  const deg = ((degree % scaleIntervals.length) + scaleIntervals.length) % scaleIntervals.length;

  const rootSemis  = scaleIntervals[deg];
  const thirdSemis = scaleIntervals[(deg + 2) % scaleIntervals.length];
  const fifthSemis = scaleIntervals[(deg + 4) % scaleIntervals.length];

  const root  = keysArr[(keyIndex + rootSemis)  % 12];
  const third = keysArr[(keyIndex + thirdSemis) % 12];
  const fifth = keysArr[(keyIndex + fifthSemis) % 12];

  return [root, third, fifth]; // notes WITHOUT octaves
}

// Normalize any existing state.progression into state.progressionNotes = [ ['C','E','G'], ... ]
function ensureHarmonyGuardrails() {
  // Already normalized?
  if (Array.isArray(state.progressionNotes) && state.progressionNotes.length) return;

  // Case A: User/Harmony tab already created a progression we can normalize
  if (Array.isArray(state.progression) && state.progression.length) {
    const normalized = [];
    for (const chord of state.progression) {
      if (Array.isArray(chord)) {
        // ['C','E','G'] or with stray octaves like ['C3','E3','G3']
        normalized.push(chord.map(n => String(n).replace(/\d/g,'')));
      } else if (chord && chord.root) {
        // { root:'C', type:'minor'|'major'|'dim' , ... }
        // Try Tonal first (if available), else derive from the scale degree fallback
        try {
          const typeSuffix = chord.type === 'minor' ? 'm' : (chord.type === 'dim' ? 'dim' : '');
          const tonalNotes = (window.Tonal?.Chord?.get?.(`${chord.root}${typeSuffix}`)?.notes) || [];
          if (tonalNotes.length) {
            normalized.push(tonalNotes.map(n => n.replace(/\d/g,'')));
            continue;
          }
        } catch (e) {}
        // Fallback: build a triad on the root as if it's a scale member (best-effort)
        normalized.push([chord.root, chord.root, chord.root]);
      }
    }
    if (normalized.length) {
      state.progressionNotes = normalized;
      return;
    }
  }

  // Case B: Nothing to normalize â†’ generate from template for the current genre
  const bank = PROGRESSION_TEMPLATES[state.currentGenre] || PROGRESSION_TEMPLATES.lofi || PROGRESSION_TEMPLATES.default;
  const tpl = bank[Math.floor(Math.random() * bank.length)];
  state.progressionNotes = tpl.map(deg => buildTriadFromDegree(deg, state.key, state.scale));
}

// Map a *bar index* to its chord (notes WITHOUT octaves)
function getChordNotesForBar(barIndex) {
  ensureHarmonyGuardrails();
  if (!Array.isArray(state.progressionNotes) || !state.progressionNotes.length) return null;
  return state.progressionNotes[barIndex % state.progressionNotes.length];
}

// Append an octave to a pitch class like "C" -> "C3"
function withOct(note, octave) {
  return `${note.replace(/\d/g,'')}${octave}`;
}

// Pick a bass note for a step in the bar: strong beats = root/5th, weak = passing
function chooseBassNote(chordNotes, stepInBar, baseOct = 2) {
  const strong = (stepInBar % 4 === 0); // steps 0,4,8,12 within a 16-step bar
  if (strong) {
    // Alternate root and fifth to create simple movement
    const pick = (stepInBar === 8) ? 2 : 0; // 0=root, 2=fifth (root,3rd,5th indexing)
    return withOct(chordNotes[Math.min(pick, chordNotes.length-1)], baseOct);
  }
  // Weak beats: neighbor/passing = third or step back to root
  const pick = (stepInBar % 8 < 4) ? 1 : 0;
  return withOct(chordNotes[Math.min(pick, chordNotes.length-1)], baseOct);
}

// Choose a chord-tone melody note; strong beats prefer chord tones, weak beats can use neighbors
function chooseMelodyNote(chordNotes, stepInBar, baseOct = 4, last = null) {
  const strong = (stepInBar % 4 === 0);
  const pool = strong ? chordNotes : [...chordNotes]; // could add scale neighbors if you like
  let pick = pool[Math.floor(Math.random() * pool.length)];
  // Gentle smoothing: avoid repeating the exact same note too often on weak beats
  if (!strong && last && pick === last.replace(/\d/g,'')) {
    pick = pool[(pool.indexOf(pick)+1) % pool.length];
  }
  // Keep melodic contour inside a comfy range
  const oct = strong ? baseOct : (Math.random() < 0.6 ? baseOct : baseOct + 1);
  return withOct(pick, oct);
}

// -------------------- Harmony System --------------------
function renderHarmony() {
  const keySelect = document.getElementById('keySelect');
  keySelect.innerHTML = keysArr.map(k => 
    `<option value="${k}" ${k === state.key ? 'selected' : ''}>${k}</option>`
  ).join('');
  
  const scaleSelect = document.getElementById('scaleSelect');
  scaleSelect.innerHTML = Object.keys(scales).map(s => 
    `<option value="${s}" ${s === state.scale ? 'selected' : ''}>${s}</option>`
  ).join('');
  
  const octaveSelect = document.getElementById('octaveSelect');
  octaveSelect.innerHTML = [2, 3, 4, 5, 6].map(o => 
    `<option value="${o}" ${o === state.octave ? 'selected' : ''}>${o}</option>`
  ).join('');
  
  updateChords();
}

function updateChords() {
  const chordChips = document.getElementById('chordChips');
  const fragment = document.createDocumentFragment();
  
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  
  const chords = [];
  scaleIntervals.forEach((interval, i) => {
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(i + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type =
      thirdInterval === 3 ? 'minor' :
      thirdInterval === 4 ? 'major' :
      'dim';

    chords.push({
      root,
      type,
      roman: ['I','II','III','IV','V','VI','VII'][i]
    });
  });
  
  chords.forEach(chord => {
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent =
      `${chord.roman} - ${chord.root}${
        chord.type === 'minor' ? 'm' :
        chord.type === 'dim'   ? 'Â°' : ''
      }`;
    
    chip.addEventListener('click', () => {
      state.progression.push(chord);
      invalidateHarmonyCache();   // ðŸ§¹ harmony cache reset
      renderProgression();
    });
    
    fragment.appendChild(chip);   // âœ… this was missing
  });

  chordChips.innerHTML = '';
  chordChips.appendChild(fragment);
}

function renderProgression() {
  const wrap = document.getElementById('progressionChips');
  const fragment = document.createDocumentFragment();
  
  if (!state.progression.length) {
    wrap.innerHTML =
      '<div style="color: var(--text-muted); font-size: 0.9rem;">Click chords above to build progression</div>';
    return;
  }
  
  state.progression.forEach((chord, index) => {
    const chip = document.createElement('div');
    chip.className = 'chip active';
    chip.textContent =
      `${chord.roman} - ${chord.root}${
        chord.type === 'minor' ? 'm' :
        chord.type === 'dim'   ? 'Â°' : ''
      }`;
    
    chip.addEventListener('click', () => {
      state.progression.splice(index, 1);
      invalidateHarmonyCache();   // ðŸ§¹ reset *then* re-render
      renderProgression();
    });

    fragment.appendChild(chip);
  });
  
  wrap.innerHTML = '';
  wrap.appendChild(fragment);
}

function generateProgression() {
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  const templates = [
    [0, 3, 4, 0],
    [0, 5, 3, 4],
    [1, 4, 0],
    [0, 4, 5, 3]
  ];
  
  const template = templates[Math.floor(Math.random() * templates.length)];
  state.progression = [];
  
  template.forEach(degree => {
    const interval = scaleIntervals[degree];
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(degree + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    state.progression.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][degree] });
  });
  
  renderProgression();
}

function loadProgressionTemplate(name) {
  const templates = {
    'ii-v-i': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'G', type: 'major', roman: 'V' },
      { root: 'C', type: 'major', roman: 'I' }
    ],
    'lofi': [
      { root: 'C', type: 'major', roman: 'I' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'F', type: 'major', roman: 'IV' },
      { root: 'G', type: 'major', roman: 'V' }
    ],
    'neosoul': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'E', type: 'minor', roman: 'III' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'D', type: 'minor', roman: 'II' }
    ],
    'modal': [
      { root: 'D', type: 'minor', roman: 'I' },
      { root: 'E', type: 'minor', roman: 'II' },
      { root: 'F', type: 'major', roman: 'III' },
      { root: 'G', type: 'major', roman: 'IV' }
    ]
  };
  
  state.progression = templates[name] || [];
  renderProgression();
}

// ==================== MULTITRACK RECORDING SYSTEM ====================

const multitrack = {
  tracks: [],
  nextTrackId: 1,
  recordingTracks: new Set(),
  currentFxTrackId: null,
  globalRecordStartTime: null,
  zoom: 100, // pixels per second
  snapEnabled: true,
  snapInterval: 0.25,
  loopEnabled: false,
  loopStart: null,
  loopEnd: null,
  currentTool: 'select'   // âœï¸ timeline tool state
};

// === UNDO/REDO HISTORY SYSTEM ===
const multitrackHistory = {
  stack: [],
  currentIndex: -1,
  maxSize: 50,
  isRestoring: false, // Prevent recording during undo/redo
  
  captureState() {
    if (this.isRestoring) return; // Don't record during undo/redo
    
    // Serialize current multitrack state (without audio buffers to save memory)
    const state = {
      tracks: multitrack.tracks.map(t => ({
        id: t.id,
        name: t.name,
        instrument: t.instrument,
        isExternalAudio: t.isExternalAudio,
        volume: t.volume,
        pan: t.pan,
        muted: t.muted,
        soloed: t.soloed,
        armed: t.armed,
        selectedTakeIndex: t.selectedTakeIndex,
        takes: t.takes.map(take => ({
          id: take.id,
          duration: take.duration,
          startTime: take.startTime,
          muted: take.muted,
          timestamp: take.timestamp,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd
          // Note: We keep audio buffers in the actual track objects
        }))
      })),
      nextTrackId: multitrack.nextTrackId,
      zoom: multitrack.zoom,
      timestamp: Date.now()
    };
    
    // Remove any states after current index (branching timeline)
    this.stack = this.stack.slice(0, this.currentIndex + 1);
    
    // Add new state
    this.stack.push(state);
    
    // Limit stack size
    if (this.stack.length > this.maxSize) {
      this.stack.shift();
    } else {
      this.currentIndex++;
    }
    
    updateUndoRedoButtons();
  },
  
  undo() {
    if (!this.canUndo()) return;
    
    this.currentIndex--;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('â†¶ Undo', 'info');
  },
  
  redo() {
    if (!this.canRedo()) return;
    
    this.currentIndex++;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('â†· Redo', 'info');
  },
  
  canUndo() {
    return this.currentIndex > 0;
  },
  
  canRedo() {
    return this.currentIndex < this.stack.length - 1;
  },
  
  restoreState(state) {
    this.isRestoring = true;
    
    try {
      // Restore track metadata (preserve existing audio buffers)
      state.tracks.forEach(savedTrack => {
        const liveTrack = multitrack.tracks.find(t => t.id === savedTrack.id);
        
        if (liveTrack) {
          // Update existing track
          liveTrack.name = savedTrack.name;
          liveTrack.volume = savedTrack.volume;
          liveTrack.pan = savedTrack.pan;
          liveTrack.muted = savedTrack.muted;
          liveTrack.soloed = savedTrack.soloed;
          liveTrack.armed = savedTrack.armed;
          liveTrack.selectedTakeIndex = savedTrack.selectedTakeIndex;
          
          // Update audio routing
          if (liveTrack.channel) {
            liveTrack.channel.volume.value = liveTrack.volume;
            liveTrack.channel.pan.value = liveTrack.pan / 100;
          }
          
          // Restore take metadata (keep audio buffers)
          savedTrack.takes.forEach((savedTake, idx) => {
            if (liveTrack.takes[idx]) {
              liveTrack.takes[idx].startTime = savedTake.startTime;
              liveTrack.takes[idx].muted = savedTake.muted;
              liveTrack.takes[idx].trimStart = savedTake.trimStart;
              liveTrack.takes[idx].trimEnd = savedTake.trimEnd;
            }
          });
        }
      });
      
      // Remove tracks that don't exist in saved state
      multitrack.tracks = multitrack.tracks.filter(t => 
        state.tracks.some(st => st.id === t.id)
      );
      
      // Restore other properties
      multitrack.zoom = state.zoom;
      multitrack.nextTrackId = state.nextTrackId;
      
      renderMultitrack();
      
    } finally {
      this.isRestoring = false;
    }
  },
  
  clear() {
    this.stack = [];
    this.currentIndex = -1;
    updateUndoRedoButtons();
  }
};

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn) {
    undoBtn.disabled = !multitrackHistory.canUndo();
  }
  
  if (redoBtn) {
    redoBtn.disabled = !multitrackHistory.canRedo();
  }
}
  
// ==================== ENHANCED MULTITRACK WITH EXTERNAL AUDIO ====================

class AudioTrack {
  constructor(id, name = `Track ${id}`, instrument = null, isExternalAudio = false) {
    this.id = id;
    this.name = name;
    this.instrument = instrument || 'internal';
    this.isExternalAudio = isExternalAudio;
    this.takes = [];
    this.selectedTakeIndex = -1;
    this.armed = false;
    this.recording = false;
    this.muted = false;
    this.soloed = false;
    this.volume = 0;
    this.pan = 0;
    this.inputMonitoring = false;
    this.recordStartTime = null;

    // Audio routing
    this.channel = new Tone.Channel({ volume: 0, pan: 0 }).connect(master.fxIn);
    this.recorder = null;
    this.recordedChunks = [];
    this.fxChain = [];
    
    // Meter for visual feedback
    this.meter = new Tone.Meter();
    this.channel.connect(this.meter);
    
    // External audio setup
    this.mediaStream = null;
    this.mediaStreamSource = null;
    this.externalInput = null;
    
    if (!isExternalAudio && instrument !== 'external') {
      this.routeInstrument();
    }
  }
  
  rename(newName) {
    this.name = newName.trim() || `Track ${this.id}`;
    showToast(`âœï¸ Renamed to "${this.name}"`, 'info');
    renderMultitrack();
  }
  
  async setupExternalAudio() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000
        }
      });
      
      console.log(`ðŸŽ¤ Microphone access granted for track ${this.id}`);
      
      const audioContext = Tone.context.rawContext;
      this.mediaStreamSource = audioContext.createMediaStreamSource(this.mediaStream);
      
      this.externalInput = new Tone.Gain(1);
      this.mediaStreamSource.connect(this.externalInput.input);
      
      this.externalInput.connect(this.channel);
      this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      
      console.log(`âœ… External audio routed for track ${this.id}`);
      
    } catch (err) {
      console.error(`âŒ Failed to access microphone for track ${this.id}:`, err);
      showToast(`âŒ Microphone access denied: ${err.message}`, 'error');
    }
  }

  toggleInputMonitoring() {
    if (!this.mediaStreamSource) return showToast('âš ï¸ No input available', 'warning');

    if (!this.isExternalAudio || !this.externalInput) return;
    
    this.inputMonitoring = !this.inputMonitoring;
    this.externalInput.gain.rampTo(this.inputMonitoring ? 1 : 0, 0.05);
    
    console.log(`ðŸ”Š Input monitoring ${this.inputMonitoring ? 'ON' : 'OFF'} for ${this.name}`);
    renderMultitrack();
  }
  
  routeInstrument() {
    // Internal audio tracks no longer route from a fixed instrument.
    // They simply exist as live audio buses (Tone.Channel â†’ master).
    console.log(`ðŸŽšï¸ ${this.name} ready as internal track`);
  }

  
  addFx(type, params = {}) {
    let fx;
    params = { ...params };
  
    switch (type) {
      case 'reverb': {
        const decay = params.decay ?? 1.5;
        const wet = params.wet ?? 0.3;
        fx = new Tone.Reverb({ decay, wet });
        params.decay = decay;
        params.wet = wet;
        break;
      }
      case 'delay': {
        const time = params.time ?? '8n';
        const feedback = params.feedback ?? 0.3;
        const wet = params.wet ?? 0.3;
        fx = new Tone.FeedbackDelay({ delayTime: time, feedback, wet });
        params.time = time;
        params.feedback = feedback;
        params.wet = wet;
        break;
      }
      case 'chorus': {
        const frequency = params.frequency ?? 1.5;
        const delayTime = params.delayTime ?? 3.5;
        const depth = params.depth ?? 0.7;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Chorus({ frequency, delayTime, depth, wet }).start();
        params.frequency = frequency;
        params.delayTime = delayTime;
        params.depth = depth;
        params.wet = wet;
        break;
      }
      case 'distortion': {
        const amount = params.amount ?? 0.4;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Distortion({ distortion: amount, wet });
        params.amount = amount;
        params.wet = wet;
        break;
      }
      case 'filter': {
        const typeOpt = params.type ?? 'lowpass';
        const frequency = params.frequency ?? 5000;
        const q = params.q ?? 1;
        fx = new Tone.Filter({ type: typeOpt, frequency, Q: q });
        params.type = typeOpt;
        params.frequency = frequency;
        params.q = q;
        break;
      }
      case 'compressor': {
        const threshold = params.threshold ?? -24;
        const ratio = params.ratio ?? 4;
        const attack = params.attack ?? 0.003;
        const release = params.release ?? 0.25;
        fx = new Tone.Compressor({ threshold, ratio, attack, release });
        params.threshold = threshold;
        params.ratio = ratio;
        params.attack = attack;
        params.release = release;
        break;
      }
      case 'eq': {
        const low = params.low ?? 0;
        const mid = params.mid ?? 0;
        const high = params.high ?? 0;
        fx = new Tone.EQ3({ low, mid, high });
        params.low = low;
        params.mid = mid;
        params.high = high;
        break;
      }
      case 'bitcrusher': {
        const bits = params.bits ?? 4;
        fx = new Tone.BitCrusher({ bits });
        params.bits = bits;
        break;
      }
      default:
        return null;
    }
  
    const fxObj = {
      id: Date.now() + Math.random(),
      type,
      node: fx,
      params,
      enabled: true
    };
  
    this.fxChain.push(fxObj);
    this.reconnectFxChain();
  
    return fxObj;
  }
  
  removeFx(fxId) {
    const index = this.fxChain.findIndex(fx => fx.id === fxId);
    if (index === -1) return;
    
    const fx = this.fxChain[index];
    fx.node.disconnect();
    fx.node.dispose();
    
    this.fxChain.splice(index, 1);
    this.reconnectFxChain();
  }
  
  reconnectFxChain() {
    const masterBus = window.master?.fxIn || Tone.Destination;
  
    // 1) Disconnect channel from previous routing
    try {
      this.channel.disconnect();
    } catch (err) {
      console.warn('Channel disconnect failed:', err);
    }
  
    // 2) Keep the meter tapped off the channel (pre-FX)
    if (this.meter) {
      try {
        this.channel.connect(this.meter);
      } catch (err) {
        console.warn('Meter reconnect failed:', err);
      }
    }
  
    // 3) Clear old FX connections
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.disconnect === 'function') {
        try { fx.node.disconnect(); } catch (err) {
          console.warn('FX disconnect failed:', err);
        }
      }
    });
  
    // 4) Only use enabled FX with actual nodes
    const activeFx = this.fxChain.filter(fx => fx.enabled && fx.node);
  
    // No FX? Channel goes straight to master
    if (activeFx.length === 0) {
      this.channel.connect(masterBus);
      return;
    }
  
    // 5) Rebuild: channel -> fx1 -> fx2 -> ... -> master
    let lastNode = this.channel;
    activeFx.forEach(fx => {
      if (!fx.node) return;
      lastNode.connect(fx.node);
      lastNode = fx.node;
    });
  
    lastNode.connect(masterBus);
  }

  updateFxParam(fxId, param, value) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    const node = fx.node;
    fx.params[param] = value;

    const fastRamp = 0.01; 

    try {
      // Generic Tone.Param
      if (node[param] && node[param].rampTo) {
        node[param].rampTo(value, fastRamp);
      }
      // Common FX types
      else if (param === 'wet' && node.wet) node.wet.rampTo(value, fastRamp);
      else if (param === 'decay' && node.decay !== undefined) node.decay = value;
      else if (param === 'time' && node.delayTime) node.delayTime.value = Tone.Time(value);
      else if (param === 'feedback' && node.feedback) node.feedback.rampTo(value, fastRamp);
      else if (param === 'frequency' && node.frequency) node.frequency.rampTo(value, fastRamp);
      else if (param === 'depth' && node.depth !== undefined) node.depth = value;
      else if (param === 'amount' && node.distortion !== undefined) node.distortion = value;
      else if (param === 'bits' && node.bits !== undefined) node.bits = Math.round(value);
      else if (param === 'threshold' && node.threshold) node.threshold.rampTo(value, fastRamp);
      else if (param === 'ratio' && node.ratio) node.ratio.rampTo(value, fastRamp);
      else if (param === 'attack' && node.attack) node.attack.rampTo(value, fastRamp);
      else if (param === 'release' && node.release) node.release.rampTo(value, fastRamp);
      else if (param === 'low' && node.low) node.low.rampTo(value, fastRamp);
      else if (param === 'mid' && node.mid) node.mid.rampTo(value, fastRamp);
      else if (param === 'high' && node.high) node.high.rampTo(value, fastRamp);
      else if (param === 'q' && node.Q) node.Q.rampTo(value, fastRamp);
      else if (param === 'type' && node.type !== undefined) node.type = value;
      else if (node.set) node.set({ [param]: value }); // Fallback for Tone.js node.set()

      console.log(`ðŸŽ›ï¸ Live FX: ${fx.type}.${param} â†’ ${value}`);
    } catch (err) {
      console.warn(`âš ï¸ FX param update failed: ${param}`, err);
    }
  }
  
  toggleFx(fxId) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.enabled = !fx.enabled;
    this.reconnectFxChain();
  }
  
  async startRecording(options = {}) {
    if (this.recording) return;
  
    await Tone.start();
    if (Tone.context.state !== 'running') await Tone.context.resume();
  
    // keep timing logic
    const forcedStart = typeof options.forcedStartTime === 'number' ? options.forcedStartTime : null;
    if (this.recordStartTime == null)
      this.recordStartTime = forcedStart ?? Tone.now();
  
    // external input monitor stays unchanged
    if (this.isExternalAudio) {
      if (!this.mediaStreamSource) await this.setupExternalAudio();
      this.inputMonitoring = true;
      if (this.externalInput) this.externalInput.gain.value = 1;
    }
  
    // ðŸŽ¯ record the *master bus* instead of a per-track stem
    const ctx = Tone.getContext().rawContext;
    let stream;
  
    if (window.master?.mediaDest) {
      stream = master.mediaDest.stream;        // post-limiter master
      this.recordDest = null;
    } else {
      const dest = ctx.createMediaStreamDestination();
      this.recordDest = dest;
      (master?.limiter || master?.fxIn || Tone.getDestination()).connect(dest);
      stream = dest.stream;
    }
  
    this.recordedChunks = [];
    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus'
      : 'audio/webm';
  
    this.recorder = new MediaRecorder(stream, { mimeType });
    this.recorder.ondataavailable = e => e.data?.size && this.recordedChunks.push(e.data);
    this.recorder.onstop = () => this.finishRecording();
    this.recorder.start(100);
    this.recording = true;
  
    showToast(`ðŸŽ§ Recording live master output into ${this.name}`, 'success');
  }

  stopRecording() {
    if (this.recording && this.recorder) {
      this.recorder.stop();
      this.recording = false;
      if (this.isExternalAudio && this.externalInput) {
        // Keep live monitoring on stop for feedback continuity
        this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      }
    }
  }
  
  async finishRecording() {
    if (this.recordedChunks.length === 0) {
      console.warn('âš ï¸ No audio data recorded');
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      showToast('âš ï¸ Recording was empty', 'warning'); 
      return;
    }
  
    const blob = new Blob(this.recordedChunks, {
      type: (this.recorder && this.recorder.mimeType) || 'audio/webm'
    });
  
    console.log(`ðŸ’¾ Processing ${blob.size} bytes`);
  
    if (blob.size < 1000) {
      console.error('âŒ Recording too small, likely corrupted');
      showToast('âŒ Recording failed - file too small', 'error');
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      return;
    }
  
    try {
      const arrayBuffer = await blob.arrayBuffer();
      if (arrayBuffer.byteLength === 0) {
        throw new Error('ArrayBuffer is empty');
      }
  
      const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
      if (!audioBuffer || audioBuffer.length === 0 || audioBuffer.numberOfChannels === 0) {
        throw new Error('Decoded buffer is invalid');
      }
      
      // ðŸ”Š Auto-normalize recorded takes so bounced samples aren't super quiet
      (function normalizeBuffer(buf) {
        let peak = 0;
        const channels = buf.numberOfChannels;
      
        // Find peak
        for (let ch = 0; ch < channels; ch++) {
          const data = buf.getChannelData(ch);
          for (let i = 0; i < data.length; i++) {
            const v = Math.abs(data[i]);
            if (v > peak) peak = v;
          }
        }
      
        if (peak > 0) {
          // Target â‰ˆ -1 dBFS
          const targetLinear = Math.pow(10, -1 / 20); // ~0.891
          const gain = targetLinear / peak;
      
          for (let ch = 0; ch < channels; ch++) {
            const data = buf.getChannelData(ch);
            for (let i = 0; i < data.length; i++) {
              data[i] *= gain;
            }
          }
        }
      })(audioBuffer);
      
      const duration = audioBuffer.duration;

      // ðŸ”¥ Compute timeline start based on global record start
      let startTime = 0;
      if (multitrack.globalRecordStartTime != null && this.recordStartTime != null) {
        startTime = Math.max(
          0,
          this.recordStartTime - multitrack.globalRecordStartTime
        );
      }
  
      const take = {
        id: Date.now(),
        buffer: audioBuffer,
        blob,
        duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime,   // <-- used by preview & bounce for alignment
        recordedAt: Date.now()
      };
  
      this.takes.push(take);
      this.selectedTakeIndex = this.takes.length - 1;
  
      console.log(
        `âœ… Take ${this.takes.length} created: ${take.duration.toFixed(
          3
        )}s (start=${startTime.toFixed(3)}s)`
      );

      multitrackHistory.captureState();
      
      renderMultitrack();
      showToast(`âœ… Recorded ${take.duration.toFixed(1)}s take`, 'success');
    } catch (err) {
      console.error('âŒ Failed to decode audio:', err);
      showToast(`âŒ Recording failed: ${err.message}`, 'error');
    } finally {
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
    }
  }
  
  selectTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.selectedTakeIndex = index;
    renderMultitrack();
  }

  toggleTakeMute(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.takes[index].muted = !this.takes[index].muted;
    renderMultitrack();
  }
  
  deleteTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    this.takes.splice(index, 1);
    
    if (this.selectedTakeIndex >= this.takes.length) {
      this.selectedTakeIndex = this.takes.length - 1;
    }
    
    renderMultitrack();
  }

  async playTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    if (take.muted) {
      showToast('âŒ Take is muted', 'warning');
      return;
    }
    
    if (this.currentPlayer) {
      try {
        if (this.currentPlayer.state === 'started') {
          this.currentPlayer.stop();
        }
        this.currentPlayer.dispose();
      } catch (err) {
        console.warn('Error stopping previous player:', err);
      }
    }
    
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`âŒ ${this.name}: Invalid or empty buffer`);
      showToast(`âŒ ${this.name}: Take corrupted, cannot play`, 'error');
      return;
    }
    
    try {
      this.currentPlayer = new Tone.Player({
        buffer: take.buffer,
        fadeOut: 0.01
      }).connect(this.channel);
      
      await new Promise((resolve, reject) => {
        let attempts = 0;
        const checkReady = setInterval(() => {
          attempts++;
          
          if (this.currentPlayer.loaded) {
            clearInterval(checkReady);
            resolve();
          } else if (attempts > 50) {
            clearInterval(checkReady);
            reject(new Error('Buffer load timeout'));
          }
        }, 100);
        
        this.currentPlayer.onsuccess = () => {
          clearInterval(checkReady);
          resolve();
        };
      });
      
      await Tone.start();
      
      this.currentPlayer.start();
      
      const takeRegions = document.querySelectorAll('.take-region');
      takeRegions.forEach((region, idx) => {
        if (idx === index) {
          region.style.borderColor = 'var(--warning)';
          region.style.boxShadow = '0 0 20px var(--warning)';
        }
      });
      
      showToast(`â–¶ï¸ Playing ${this.name} - Take ${index + 1}`, 'info');
      
      setTimeout(() => {
        if (this.currentPlayer) {
          try {
            if (this.currentPlayer.state === 'started') {
              this.currentPlayer.stop();
            }
            this.currentPlayer.dispose();
          } catch (err) {
            console.warn('Cleanup error:', err);
          }
          this.currentPlayer = null;
        }
        
        takeRegions.forEach(region => {
          region.style.borderColor = '';
          region.style.boxShadow = '';
        });
      }, take.duration * 1000 + 500);
      
    } catch (err) {
      console.error(`âŒ Failed to play ${this.name}:`, err);
      showToast(`âŒ Playback failed: ${err.message}`, 'error');
      
      if (this.currentPlayer) {
        this.currentPlayer.dispose();
        this.currentPlayer = null;
      }
    }
  }
  
  stopTake() {
    if (this.currentPlayer) {
      this.currentPlayer.stop();
      this.currentPlayer.dispose();
      this.currentPlayer = null;
    }
  }
  
  async exportTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    const url = URL.createObjectURL(take.blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.name.replace(/\s+/g, '_')}_take${index + 1}_${Date.now()}.webm`;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }
  
  dispose() {
    console.log('ðŸ—‘ï¸ Disposing track:', this.id);
    
    this.stopTake();
    
    if (this.recorder && this.recording) {
      this.stopRecording();
    }
    
    if (this.isExternalAudio) {
      if (this.mediaStreamSource) {
        this.mediaStreamSource.disconnect();
        this.mediaStreamSource = null;
      }
      
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }
      
      if (this.externalInput) {
        this.externalInput.disconnect();
        this.externalInput.dispose();
        this.externalInput = null;
      }
    } else {
      const instSynth = synths[this.instrument];
      if (instSynth && this.originalChannel) {
        if (typeof instSynth.disconnect === 'function') {
          instSynth.disconnect();
          instSynth.connect(this.originalChannel);
        } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
          instSynth.gain.disconnect();
          instSynth.gain.connect(this.originalChannel);
        }
      }
    }
    
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.dispose === 'function') {
        fx.node.disconnect();
        fx.node.dispose();
      }
    });
    
    if (this.meter && typeof this.meter.dispose === 'function') {
      this.meter.dispose();
    }
    
    if (this.channel && typeof this.channel.dispose === 'function') {
      this.channel.disconnect();
      this.channel.dispose();
    }
    
    console.log('âœ… Track disposed:', this.id);
  }
}

// ==================== EXTERNAL STEM IMPORT ====================

// 1) Decode an uploaded file into an AudioBuffer
async function decodeFileToBuffer(file) {
  const arrayBuffer = await file.arrayBuffer();

  const audioCtx =
    (Tone && Tone.context && Tone.context.rawContext) ||
    (Tone && Tone.getContext && Tone.getContext().rawContext) ||
    (Tone && Tone.context) ||
    null;

  if (!audioCtx || !audioCtx.decodeAudioData) {
    throw new Error('AudioContext not available for decoding');
  }

  return new Promise((resolve, reject) => {
    audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
  });
}

// 2) Create a new multitrack track from an AudioBuffer
function addExternalAudioTrackFromBuffer(audioBuffer, fileName = 'Imported Stem') {
  const id = multitrack.nextTrackId++;
  const niceName = fileName.replace(/\.[^/.]+$/, ''); // strip extension

  // Create track marked as external audio
  const track = new AudioTrack(id, niceName, 'stem', true);

  // Single take covering whole buffer
  const take = {
    id: `take-${Date.now()}-${id}`,
    buffer: audioBuffer,
    startTime: 0,                 // starts at 0 in the session
    duration: audioBuffer.duration,
    muted: false,
    source: 'external',
    fileName
  };

  track.takes.push(take);
  track.selectedTakeIndex = 0;

  // Minimal routing: gain â†’ master.fxIn
  // (Adjust if you already have a per-track channel system)
  const gain = new Tone.Gain(1);
  track.channel = gain;
  gain.connect(master.fxIn);

  multitrack.tracks.push(track);

  return track;
}

// 3) Wire up the "Import Stem" button
function setupStemImport() {
  const importBtn = document.getElementById('importStemBtn');
  if (!importBtn) {
    console.warn('âš ï¸ setupStemImport: #importStemBtn not found');
    return;
  }

  if (importBtn.dataset._wired) return; // avoid double binding
  importBtn.dataset._wired = 'true';

  importBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/webm';

    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      // Optional size guard
      if (file.size > 50 * 1024 * 1024) {
        showToast('âŒ File too large (max 50MB)', 'error');
        return;
      }

      try {
        showToast(`â³ Importing ${file.name}...`, 'info');
        const buffer = await decodeFileToBuffer(file);
        const track = addExternalAudioTrackFromBuffer(buffer, file.name);
        renderMultitrack(); // your existing UI refresh
        showToast(`âœ… Imported stem: ${track.name}`, 'success');
      } catch (err) {
        console.error('Stem import failed:', err);
        showToast(`âŒ Import failed: ${err.message}`, 'error');
      }
    };

    input.click();
  });
}
  
async function createTrack(instrument = null, isExternalAudio = false) {
  const isInternal = !isExternalAudio;
  const baseName = isExternalAudio
    ? `Mic/Ext ${multitrack.tracks.filter(t => t.isExternalAudio).length + 1}`
    : `Track ${multitrack.tracks.filter(t => !t.isExternalAudio).length + 1}`;

  const track = new AudioTrack(multitrack.nextTrackId++, baseName, instrument, isExternalAudio);

  if (isExternalAudio) {
    try {
      await track.setupExternalAudio();
    } catch (err) {
      console.error('âŒ External audio setup failed:', err);
      showToast(`âŒ Microphone access failed: ${err.message}`, 'error');
      return null;
    }
  }

  multitrack.tracks.push(track);
  multitrackHistory.captureState();
  renderMultitrack();
  showToast(`âœ… ${isExternalAudio ? 'External' : 'Internal'} track added`, 'success');
  return track;
}

function removeTrack(trackId) {
  const index = multitrack.tracks.findIndex(t => t.id === trackId);
  if (index === -1) return;
  
  const track = multitrack.tracks[index];
  track.dispose();
  multitrack.tracks.splice(index, 1);
  multitrackHistory.captureState();
  renderMultitrack();
}

function drawTakeWaveform(canvasEl, audioBuffer) {
  const ctx = canvasEl.getContext('2d');
  const width = canvasEl.width;
  const height = canvasEl.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = audioBuffer.getChannelData(0);
  const step = Math.ceil(data.length / width);
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  ctx.beginPath();
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const datum = data[(i * step) + j];
      if (datum < min) min = datum;
      if (datum > max) max = datum;
    }
    
    const x = i;
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(x, yMin, 1, yMax - yMin);
  }
}

function renderTakes(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  let html = '<div style="display: flex; flex-direction: column; gap: var(--space-2); padding: var(--space-2);">';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    html += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}" 
           data-track-id="${track.id}" data-take-index="${idx}"
           style="cursor: pointer; position: relative;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: var(--space-2);">
          <div style="flex: 1;">
            <div style="font-size: var(--text-xs); font-weight: 700;">
              Take ${idx + 1} ${isSelected ? 'â˜…' : ''}
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
              ${take.duration.toFixed(1)}s
            </div>
          </div>
          <div style="display: flex; gap: var(--space-1);">
            <button class="region-action-btn" data-action="play-take" title="Play">â–¶ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-take" title="Mute/Unmute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" 
                    data-track-id="${track.id}" data-take-index="${idx}" title="Edit Waveform">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="delete-take" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  
  return html;
}
  
// Enhanced track strip rendering
function createTrackStrip(track, timelineWidth) {
  const strip = document.createElement('div');
  strip.className = 'track-strip';
  strip.dataset.trackId = track.id;
  if (track.recording) strip.classList.add('recording');
  if (track.armed) strip.classList.add('armed');
  if (track.isExternalAudio) strip.classList.add('external-audio');
  
  const instData = track.isExternalAudio ? 
    { icon: 'ðŸŽ¤', name: 'External' } : 
    instruments[track.instrument];
  
  const takesCount = track.takes.length;
  const duration = track.selectedTakeIndex >= 0 ? 
    track.takes[track.selectedTakeIndex].duration.toFixed(1) + 's' : 
    '0.0s';
  
  // Format pan display
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };
  
  strip.innerHTML = `
    <div class="track-header">
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || 'ðŸŽšï¸'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-action="rec">
          ${track.recording ? 'âºï¸' : 'âšª'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-action="arm">
          ${track.armed ? 'ðŸ”´' : 'âšª'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-action="monitor">
            ${track.inputMonitoring ? 'ðŸ”Š' : 'ðŸ”‡'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-action="fx">
          ðŸŽ›ï¸ FX
        </button>
        <button class="track-mini-btn" data-action="delete">
          ðŸ—‘ï¸
        </button>
      </div>

      <div class="track-fx-panel" style="display:none;">
        <div class="fx-chain-mini">
          <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
          <div class="fx-slots-inline"></div>
        </div>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" 
               class="track-volume-slider" data-param="volume" data-track-id="${track.id}">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" 
               class="track-pan-slider" data-param="pan" data-track-id="${track.id}">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    </div>
    
    <div class="track-canvas-area">
      <div class="track-canvas" style="width: ${timelineWidth}px; min-width: ${timelineWidth}px;">
        ${track.takes.length === 0 && !track.recording ? `
          <div class="track-empty-state">
            <div class="track-empty-state-icon">ðŸŽ™ï¸</div>
            <div>Arm and record to create takes</div>
          </div>
        ` : ''}
        ${track.recording ? `
          <div class="recording-indicator">
            <div class="recording-indicator-dot"></div>
            <span>Recording...</span>
          </div>
        ` : ''}
        ${renderTimelineRegions(track)}
      </div>
    </div>
  `;
  
  // Attach control listeners
  strip.querySelectorAll('.track-mini-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      handleTrackAction(track, action);
    });
  });
  
  // Volume slider
  const volumeSlider = strip.querySelector('.track-volume-slider');
  if (volumeSlider) {
    volumeSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      track.volume = value;
      
      if (track.channel && track.channel.volume) {
        track.channel.volume.rampTo(value, 0.05);
      }
      
      const label = strip.querySelector('.track-volume-value');
      if (label) label.textContent = value.toFixed(1) + 'dB';
    });
  }
  
  // Pan slider - FIXED
  const panSlider = strip.querySelector('.track-pan-slider');
  if (panSlider) {
    panSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      track.pan = value;
      
      if (track.channel && track.channel.pan) {
        track.channel.pan.rampTo(value / 100, 0.05);
      }
      
      const label = strip.querySelector('.track-pan-value');
      if (label) {
        label.textContent = formatPan(value);
      }
    });
  }
  
  setupRegionInteractions(strip, track);
  
  // Start meter animation
  if (track.meter) {
    const updateMeters = () => {
      const fills = strip.querySelectorAll(`[data-meter-track="${track.id}"]`);
      if (fills.length === 0 || !track.meter) return;
      
      const value = track.meter.getValue();
      const channels = Array.isArray(value) ? value : [value, value];
      
      fills.forEach((fill, idx) => {
        const db = channels[idx] || channels[0] || -60;
        const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
        fill.style.height = normalized + '%';
      });
      
      if (strip.isConnected) {
        requestAnimationFrame(updateMeters);
      }
    };
    
    requestAnimationFrame(updateMeters);
  }
  
  // Draw waveforms after DOM is ready
  requestAnimationFrame(() => {
    setTimeout(() => {
      track.takes.forEach((take, idx) => {
        const canvas = strip.querySelector(`canvas[data-take-id="${take.id}"]`);
        if (canvas && take.buffer) {
          if (canvas.width === 0 || canvas.height === 0) {
            canvas.width = Math.max(100, take.duration * (multitrack.zoom || 100));
            canvas.height = 20;
          }
          drawRegionWaveform(canvas, take.buffer);
        }
      });
    }, 100);
  });
  
  return strip;
}
  
function renderTimelineRegions(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  const zoom = multitrack.zoom || 100;
  let html = '';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    const startPos = (take.startTime || 0) * zoom;
    const width = take.duration * zoom;
    
    html += `
      <div class="audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}"
           data-track-id="${track.id}"
           data-take-index="${idx}"
           data-region-id="${take.id}"
           style="position: absolute; left: ${startPos}px; width: ${width}px; height: 80px; top: 0;">
        
        <div class="region-header">
          <div class="region-name">Take ${idx + 1}</div>
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">âœï¸</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      </div>
    `;
  });
  
  return html;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 100);
  return `${mins}:${String(secs).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
}

function setupRegionInteractions(stripEl, track) {
  // ðŸ’¡ Work with either the old .track-canvas or the lane itself
  const canvas = stripEl.querySelector('.track-canvas') || stripEl;
  if (!canvas) return;
  
  let dragState = null;
  let isTouchDevice = 'ontouchstart' in window;
  
  // === CRITICAL: Use event delegation for action buttons ===
  canvas.addEventListener('click', (e) => {
    const btn = e.target.closest('.region-action-btn');
    if (!btn) return;
    
    e.stopPropagation(); // CRITICAL: Prevent drag logic
    e.preventDefault();
    
    const region = btn.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const action = btn.dataset.action;
    
    handleRegionAction(trackId, takeIndex, action, e);
  }, { capture: true }); // Use capture phase

  const startDrag = (e) => {
    if (e.target.closest('.region-action-btn')) return; // Skip buttons
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    
    const region = document.elementFromPoint(clientX, clientY)?.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const handle = e.target.closest('.region-resize-handle')?.dataset.handle || null;
    
    const track = multitrack.tracks.find(t => t.id === trackId);
    if (!track) return;
    
    const take = track.takes[takeIndex];
    if (!take) return;
    
    const zoom = multitrack.zoom || 100;
    
    dragState = {
      mode: handle ? `resize-${handle}` : 'move',
      trackId,
      takeIndex,
      startX: clientX,
      originalStart: take.startTime || 0,
      originalDuration: take.duration,
      minStart: 0,
      maxEnd: multitrack.projectDuration || (state.duration * 60)
    };
    
    region.classList.add('dragging');
  };
  
  const moveDrag = (e) => {
    if (!dragState) return;
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const zoom = multitrack.zoom || 100;
    const deltaX = clientX - dragState.startX;
    const deltaSeconds = deltaX / zoom;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (!track) return;
    
    const take = track.takes[dragState.takeIndex];
    if (!take) return;
    
    if (dragState.mode === 'move') {
      let newStart = dragState.originalStart + deltaSeconds;
      newStart = Math.max(dragState.minStart, Math.min(newStart, dragState.maxEnd - take.duration));
  
      // ðŸ§² Apply snapping
      newStart = applySnap(newStart);
  
      take.startTime = newStart;
  
    } else if (dragState.mode === 'resize-left') {
      let newStart = dragState.originalStart + deltaSeconds;
      const maxStart = dragState.originalStart + dragState.originalDuration - 0.05;
      newStart = Math.max(dragState.minStart, Math.min(newStart, maxStart));
  
      // ðŸ§² Snap left edge if desired
      newStart = applySnap(newStart);
  
      const newDuration = (dragState.originalStart + dragState.originalDuration) - newStart;
      if (newDuration >= 0.05) {
        take.startTime = newStart;
        take.duration = newDuration;
      }
  
    } else if (dragState.mode === 'resize-right') {
      let newDuration = dragState.originalDuration + deltaSeconds;
      const maxDuration = dragState.maxEnd - dragState.originalStart;
      newDuration = Math.max(0.05, Math.min(newDuration, maxDuration));
  
      // ðŸ§² Snap right edge
      const endTime = dragState.originalStart + newDuration;
      const snappedEnd = applySnap(endTime);
      take.duration = Math.max(0.05, snappedEnd - dragState.originalStart);
    }
  
    renderMultitrack();
  };
  
  const endDrag = (e) => {
    if (!dragState) return;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (track) {
      const lane = document.querySelector(`.track-lane[data-track-id="${track.id}"]`);
      if (lane) {
        const regionEls = lane.querySelectorAll('.audio-region');
        regionEls.forEach(r => r.classList.remove('dragging'));
      }
    }
    
    multitrackHistory.captureState();
    dragState = null;
  };
  
  // Mouse + touch bindings
  if (isTouchDevice) {
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        startDrag(e);
      }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
      if (dragState) {
        e.preventDefault();
        moveDrag(e);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', endDrag, { passive: true });
    canvas.addEventListener('touchcancel', endDrag, { passive: true });
  } else {
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      startDrag(e);
    });
    
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
  }
}

  
function handleRegionAction(trackId, takeIndex, action, event) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take) {
    console.error('Take not found:', takeIndex);
    return;
  }
  
  console.log(`âœ… Handling action: ${action}`);
  
  if (action === 'split-region') {
    openSplitDialog(track, takeIndex, event);
  } else if (action === 'toggle-mute-region') {
    take.muted = !take.muted;
    renderMultitrack();
    showToast(take.muted ? 'ðŸ”‡ Region muted' : 'ðŸ”Š Region unmuted', 'info');
  } else if (action === 'edit-waveform') {
    openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete-region') {
    if (confirm('Delete this region?')) {
      track.takes.splice(takeIndex, 1);
      if (track.selectedTakeIndex >= track.takes.length) {
        track.selectedTakeIndex = track.takes.length - 1;
      }
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('ðŸ—‘ï¸ Region deleted', 'success');
    }
  } else {
    console.warn('Unknown action:', action);
  }
}

function openSplitDialog(track, takeIndex, event) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '600px';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Split Region</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="splitPreviewCanvas" width="500" height="150"
                style="width: 100%; height: 150px; background: var(--glass-bg); border-radius: var(--radius-md); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="param-control">
        <div class="param-label">
          <span>Split Point</span>
          <span class="param-value" id="splitPointValue">0.00s</span>
        </div>
        <input type="range" id="splitPointSlider" min="0" max="100" value="50" step="0.1">
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); margin-top: var(--space-3);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          ðŸ’¡ <strong>Tip:</strong> Click on the waveform to set split point
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-split-btn">Cancel</button>
      <button class="btn btn-primary confirm-split-btn">âœ‚ï¸ Split</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('splitPreviewCanvas');
  const slider = document.getElementById('splitPointSlider');
  const valueLabel = document.getElementById('splitPointValue');
  
  let splitPoint = 0.5; // 0-1 normalized
  
  function drawSplitPreview() {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!take.buffer) return;
    
    // Draw waveform
    const data = take.buffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    for (let i = 0; i < width; i++) {
      let min = 1.0, max = -1.0;
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < data.length) {
          const datum = data[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw split line
    const splitX = splitPoint * width;
    ctx.strokeStyle = 'var(--error)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(splitX, 0);
    ctx.lineTo(splitX, height);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Labels
    ctx.fillStyle = 'var(--text-primary)';
    ctx.font = '12px var(--font-mono)';
    ctx.fillText('A', 10, 20);
    ctx.fillText('B', width - 20, 20);
  }
  
  function updateSplitPoint(newPoint) {
    splitPoint = Math.max(0.01, Math.min(0.99, newPoint));
    slider.value = splitPoint * 100;
    const timeInSeconds = splitPoint * take.duration;
    valueLabel.textContent = timeInSeconds.toFixed(2) + 's';
    drawSplitPreview();
  }
  
  slider.addEventListener('input', (e) => {
    updateSplitPoint(parseFloat(e.target.value) / 100);
  });
  
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const normalizedX = x / rect.width;
    updateSplitPoint(normalizedX);
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-split-btn').onclick = close;
  
  modal.querySelector('.confirm-split-btn').onclick = async () => {
    try {
      showToast('â³ Splitting region...', 'info');
      
      const splitTime = splitPoint * take.duration;
      const buffer = take.buffer;
      
      // Create two new buffers
      const sampleRate = buffer.sampleRate;
      const splitSample = Math.floor(splitTime * sampleRate);
      
      const bufferA = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        splitSample,
        sampleRate
      );
      
      const bufferB = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length - splitSample,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const dataA = bufferA.getChannelData(c);
        const dataB = bufferB.getChannelData(c);
        
        for (let i = 0; i < splitSample; i++) {
          dataA[i] = original[i];
        }
        
        for (let i = splitSample; i < buffer.length; i++) {
          dataB[i - splitSample] = original[i];
        }
      }
      
      // Create blobs
      const wavA = bufferToWavImproved(bufferA);
      const wavB = bufferToWavImproved(bufferB);
      const blobA = new Blob([wavA], { type: 'audio/wav' });
      const blobB = new Blob([wavB], { type: 'audio/wav' });
      
      // Create new takes
      const takeA = {
        id: Date.now(),
        buffer: bufferA,
        blob: blobA,
        duration: bufferA.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: take.startTime || 0
      };
      
      const takeB = {
        id: Date.now() + 1,
        buffer: bufferB,
        blob: blobB,
        duration: bufferB.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: (take.startTime || 0) + splitTime
      };
      
      // Replace original take with split takes
      track.takes.splice(takeIndex, 1, takeA, takeB);
      
      if (track.selectedTakeIndex === takeIndex) {
        track.selectedTakeIndex = takeIndex; // Select first part
      } else if (track.selectedTakeIndex > takeIndex) {
        track.selectedTakeIndex++; // Adjust index
      }

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast('âœ… Region split successfully!', 'success');
      
    } catch (err) {
      console.error('Split failed:', err);
      showToast(`âŒ Split failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  updateSplitPoint(0.5);
  drawSplitPreview();
}

function drawRegionWaveform(canvas, buffer) {
  if (!canvas || !buffer) return;
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = buffer.getChannelData(0);
  const step = Math.max(1, Math.ceil(data.length / width));
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.5)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const index = (i * step) + j;
      if (index < data.length) {
        const sample = data[index];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
      }
    }
    
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
  }
}

function setupRegionContextMenu() {
  let contextMenu = null;
  let contextTarget = null;
  
  document.addEventListener('contextmenu', (e) => {
    const region = e.target.closest('.audio-region');
    if (!region) return;
    
    e.preventDefault();
    
    if (contextMenu) contextMenu.remove();
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    
    contextTarget = { trackId, takeIndex };
    
    contextMenu = document.createElement('div');
    contextMenu.className = 'region-context-menu';
    
    contextMenu.innerHTML = `
      <div class="region-context-item" data-action="split">âœ‚ï¸ Split at Playhead</div>
      <div class="region-context-item" data-action="duplicate">ðŸ“‹ Duplicate</div>
      <div class="region-context-item" data-action="reverse">â†©ï¸ Reverse</div>
      <div class="region-context-item" data-action="normalize">ðŸ“Š Normalize</div>
      <div class="region-context-item" data-action="fade-in">ðŸ“ˆ Fade In</div>
      <div class="region-context-item" data-action="fade-out">ðŸ“‰ Fade Out</div>
      <div class="region-context-item" data-action="export">ðŸ’¾ Export Region</div>
      <div style="height: 1px; background: var(--glass-border); margin: var(--space-2) 0;"></div>
      <div class="region-context-item danger" data-action="delete">ðŸ—‘ï¸ Delete</div>
    `;
    
    document.body.appendChild(contextMenu);
    
    // FIXED: Better positioning that accounts for scroll
    requestAnimationFrame(() => {
      const menuRect = contextMenu.getBoundingClientRect();
      const menuWidth = menuRect.width;
      const menuHeight = menuRect.height;
      
      // Start with click position
      let x = e.clientX;
      let y = e.clientY;
      
      // Right edge
      if (x + menuWidth > window.innerWidth) {
        x = window.innerWidth - menuWidth - 10;
      }
      // Bottom edge
      if (y + menuHeight > window.innerHeight) {
        y = window.innerHeight - menuHeight - 10;
      }
      // Left edge
      if (x < 10) x = 10;
      // Top edge
      if (y < 10) y = 10;
      
      contextMenu.style.position = 'fixed';
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.style.zIndex = '10000';
    });
    
    // Handle menu clicks
    contextMenu.addEventListener('click', async (e2) => {
      const item = e2.target.closest('.region-context-item');
      if (!item || !contextTarget) return;
      
      const action = item.dataset.action;
      const track = multitrack.tracks.find(t => t.id === contextTarget.trackId);
      if (!track) return;
      
      const take = track.takes[contextTarget.takeIndex];
      if (!take) return;
      
      contextMenu.remove();
      contextMenu = null;
      
      await handleContextAction(track, contextTarget.takeIndex, action);
    });

    // Close on click outside
    const closeHandler = (e3) => {
      if (contextMenu && !contextMenu.contains(e3.target)) {
        contextMenu.remove();
        contextMenu = null;
        document.removeEventListener('click', closeHandler);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeHandler);
    }, 0);
  }); // ðŸ”š close contextmenu listener


  // === LONG-PRESS SUPPORT (mobile / touch) ===
  let longPressTimer = null;
  let touchStartX = 0;
  let touchStartY = 0;
  const LONG_PRESS_MS = 550;
  const MOVE_TOLERANCE = 10; // px

  // Start tracking on touchstart
  document.addEventListener(
    'touchstart',
    (e) => {
      const region = e.target.closest('.audio-region');
      if (!region) return;

      if (e.touches.length !== 1) return; // ignore multi-touch

      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(() => {
        const fakeEvent = new MouseEvent('contextmenu', {
          bubbles: true,
          cancelable: true,
          clientX: touchStartX,
          clientY: touchStartY,
        });
        region.dispatchEvent(fakeEvent);
      }, LONG_PRESS_MS);
    },
    { passive: true }
  );

  // Cancel if the finger moves too far
  document.addEventListener(
    'touchmove',
    (e) => {
      if (!longPressTimer) return;

      const touch = e.touches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > MOVE_TOLERANCE) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    },
    { passive: true }
  );

  // Cancel on touchend / cancel
  const cancelLongPress = () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  };

  document.addEventListener('touchend', cancelLongPress, { passive: true });
  document.addEventListener('touchcancel', cancelLongPress, { passive: true });
}

async function handleContextAction(track, takeIndex, action) {
  const take = track.takes[takeIndex];
  
  switch(action) {
    case 'split':
      // Split at current playhead position
      const currentTime = Tone.Transport.seconds;
      const relativeTime = currentTime - (take.startTime || 0);
      
      if (relativeTime > 0 && relativeTime < take.duration) {
        const splitPoint = relativeTime / take.duration;
        openSplitDialog(track, takeIndex, { splitPoint });
      } else {
        showToast('âš ï¸ Playhead not within region', 'warning');
      }
      break;
      
    case 'duplicate':
      const duplicate = {
        ...take,
        id: Date.now(),
        startTime: (take.startTime || 0) + take.duration + 0.1
      };
      track.takes.splice(takeIndex + 1, 0, duplicate);
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('âœ… Region duplicated', 'success');
      break;
      
    case 'reverse':
      await reverseRegion(track, takeIndex);
      break;
      
    case 'normalize':
      await normalizeRegion(track, takeIndex);
      break;
      
    case 'fade-in':
      openFadeDialog(track, takeIndex, 'in');
      break;
      
    case 'fade-out':
      openFadeDialog(track, takeIndex, 'out');
      break;
      
    case 'export':
      track.exportTake(takeIndex);
      break;
      
    case 'delete':
      if (confirm('Delete this region?')) {
        track.deleteTake(takeIndex);
        renderMultitrack();
        showToast('ðŸ—‘ï¸ Region deleted', 'success');
      }
      break;
  }
}

async function reverseRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('â³ Reversing region...', 'info');
  
  try {
    const buffer = take.buffer;
    const reversed = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const reversedData = reversed.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        reversedData[i] = original[buffer.length - 1 - i];
      }
    }
    
    const wavData = bufferToWavImproved(reversed);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = reversed;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast('âœ… Region reversed', 'success');
    
  } catch (err) {
    console.error('Reverse failed:', err);
    showToast(`âŒ Reverse failed: ${err.message}`, 'error');
  }
}

async function normalizeRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('â³ Normalizing region...', 'info');
  
  try {
    const buffer = take.buffer;
    
    // Find peak
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('âš ï¸ Region is silent', 'warning');
      return;
    }
    
    const normalized = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    const targetPeak = 0.891; // -1dB
    const gain = targetPeak / peak;
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const normalizedData = normalized.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        normalizedData[i] = original[i] * gain;
      }
    }
    
    const wavData = bufferToWavImproved(normalized);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = normalized;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast(`âœ… Normalized (+${(20 * Math.log10(gain)).toFixed(1)}dB)`, 'success');
    
  } catch (err) {
    console.error('Normalize failed:', err);
    showToast(`âŒ Normalize failed: ${err.message}`, 'error');
  }
}

function openFadeDialog(track, takeIndex, type) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  const fadeType = type === 'in' ? 'Fade In' : 'Fade Out';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">ðŸ“ˆ ${fadeType}</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body">
      <div class="param-control">
        <div class="param-label">
          <span>Duration</span>
          <span class="param-value" id="fadeDurationValue">100ms</span>
        </div>
        <input type="range" id="fadeDurationSlider" min="10" max="5000" value="100" step="10">
      </div>
      
      <div class="param-control" style="margin-top: var(--space-4);">
        <div class="param-label">
          <span>Curve Type</span>
        </div>
        <select id="fadeCurveSelect" style="width: 100%;">
          <option value="linear">Linear</option>
          <option value="exponential">Exponential</option>
          <option value="logarithmic">Logarithmic</option>
          <option value="sCurve">S-Curve</option>
        </select>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-fade-btn">Cancel</button>
      <button class="btn btn-primary apply-fade-btn">Apply ${fadeType}</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const slider = document.getElementById('fadeDurationSlider');
  const valueLabel = document.getElementById('fadeDurationValue');
  const curveSelect = document.getElementById('fadeCurveSelect');
  
  slider.addEventListener('input', (e) => {
    const ms = parseInt(e.target.value);
    valueLabel.textContent = ms + 'ms';
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-fade-btn').onclick = close;
  
  modal.querySelector('.apply-fade-btn').onclick = async () => {
    try {
      const duration = parseInt(slider.value) / 1000; // Convert to seconds
      const curve = curveSelect.value;
      
      showToast(`â³ Applying ${fadeType.toLowerCase()}...`, 'info');
      
      const buffer = take.buffer;
      const sampleRate = buffer.sampleRate;
      const fadeSamples = Math.floor(duration * sampleRate);
      
      const processed = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const processedData = processed.getChannelData(c);
        
        for (let i = 0; i < buffer.length; i++) {
          let gain = 1.0;
          
          if (type === 'in' && i < fadeSamples) {
            const progress = i / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          } else if (type === 'out' && i >= buffer.length - fadeSamples) {
            const progress = (buffer.length - i) / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          }
          
          processedData[i] = original[i] * gain;
        }
      }
      
      const wavData = bufferToWavImproved(processed);
      const blob = new Blob([wavData], { type: 'audio/wav' });
      
      take.buffer = processed;
      take.blob = blob;

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast(`âœ… ${fadeType} applied`, 'success');
      
    } catch (err) {
      console.error('Fade failed:', err);
      showToast(`âŒ Fade failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

function applyFadeCurve(progress, curve) {
  switch(curve) {
    case 'exponential':
      return Math.pow(progress, 2);
    case 'logarithmic':
      return Math.sqrt(progress);
    case 'sCurve':
      return 0.5 - 0.5 * Math.cos(progress * Math.PI);
    default: // linear
      return progress;
  }
}

function setupTimelineCursor() {
  const wrapper = document.getElementById('dawArrangementScroll');
  const ruler   = document.getElementById('dawRuler');
  if (!wrapper || !ruler) return;

  ruler.addEventListener('click', (e) => {
    const zoom = multitrack.zoom || 100;

    const rect   = ruler.getBoundingClientRect();
    const clickX = e.clientX - rect.left;

    // account for horizontal scroll
    const timelineX = clickX + wrapper.scrollLeft;

    const projectDurationSeconds =
      multitrack.projectDuration || (state.duration * 60);

    let seconds = timelineX / zoom;
    if (!Number.isFinite(seconds)) seconds = 0;

    // clamp inside project range
    seconds = Math.max(0, Math.min(seconds, projectDurationSeconds));

    state.cursorSeconds = seconds;
    multitrack.playheadSeconds = seconds;

    // this already moves the playhead & updates timestamp
    updatePlayheadAndScroll(seconds);

    console.log('ðŸ•’ Cursor set to', seconds.toFixed(3), 's');
  });
}

  
function updateTimelineRuler() {
  const ruler   = document.getElementById('dawRuler');
  const markers = document.getElementById('dawRulerMarkers');
  if (!markers || !ruler) return;

  markers.innerHTML = '';

  const zoom = multitrack.zoom || 100;
  const durationMinutes = typeof state.duration === 'number' && state.duration > 0
    ? state.duration
    : 1;

  const projectDurationSeconds = durationMinutes * 60;
  const totalWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth   = totalWidth;
  document.documentElement.style.setProperty('--timeline-width', totalWidth + 'px');

  ruler.style.width    = totalWidth + 'px';
  ruler.style.minWidth = totalWidth + 'px';

  markers.style.width    = totalWidth + 'px';
  markers.style.minWidth = totalWidth + 'px';

  let interval = 1;
  if (zoom < 25) interval = 10;
  else if (zoom < 50) interval = 5;
  else if (zoom > 200) interval = 0.5;

  for (let t = 0; t <= projectDurationSeconds; t += interval) {
    const x = t * zoom;
    const isMajor = t % (interval * 4) === 0;

    const marker = document.createElement('div');
    marker.className = 'daw-ruler-marker' + (isMajor ? ' bar' : '');
    marker.style.left = x + 'px';

    if (isMajor) {
      const label = document.createElement('div');
      label.className = 'daw-ruler-label';
      const full = formatTime(t);
      label.textContent = full.split('.')[0]; // drop fractional seconds
      marker.appendChild(label);
    }

    markers.appendChild(marker);
  }
}
  
// Enhanced track action handler
async function handleTrackAction(track, action) {
  if (action === 'arm') {
    track.armed = !track.armed;
    renderMultitrack();
  } else if (action === 'monitor') {
    if (track.isExternalAudio) {
      track.toggleInputMonitoring();
    }
  } else if (action === 'rec') {
    await toggleRecordTrack(track.id);
  } else if (action === 'mute') {
    track.muted = !track.muted;
    track.channel.mute = track.muted;
    renderMultitrack();
  } else if (action === 'solo') {
    track.soloed = !track.soloed;
    
    const anySolo = multitrack.tracks.some(t => t.soloed);
    multitrack.tracks.forEach(t => {
      t.channel.mute = anySolo && !t.soloed;
    });
    
    renderMultitrack();
  } else if (action === 'fx') {
    openFxChainEditor(track.id);
  } else if (action === 'rename') {
    const newName = prompt('Rename track:', track.name);
    if (newName !== null) track.rename(newName);
  } else if (action === 'edit') {
    openTakeEditor(track.id);
  } else if (action === 'edit-waveform') {
  e.stopPropagation();
  openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete') {
    if (confirm(`Delete track "${track.name}"?`)) {
      removeTrack(track.id);
    }
  }
}

// === Mobile keyboard fix for inspector inputs ===
(function setupInspectorKeyboardFix() {
  const inspector = document.querySelector('.daw-inspector');
  if (!inspector) return;

  const focusSelector = 'input[type="text"], input[type="number"], input[type="email"], textarea, select';

  // When any editable control inside the inspector gets focus,
  // put the inspector into "keyboard-safe" mode.
  inspector.addEventListener('focusin', (e) => {
    if (!e.target.matches(focusSelector)) return;

    inspector.classList.add('inspector-keyboard-open');

    // Make sure the field is visible once the keyboard comes up
    setTimeout(() => {
      try {
        e.target.scrollIntoView({ block: 'center', behavior: 'smooth' });
      } catch (_) {
        // scrollIntoView may not exist in some environments; ignore
      }
    }, 50);
  });

  // When focus leaves all fields in the inspector, restore bottom-sheet behavior.
  inspector.addEventListener('focusout', () => {
    setTimeout(() => {
      const active = document.activeElement;
      if (!inspector.contains(active)) {
        inspector.classList.remove('inspector-keyboard-open');
      }
    }, 100);
  });
})();


// ============================================================================
// MULTITRACK INSPECTOR â€” TRACK-FOCUSED DETAIL PANEL
// ============================================================================

// Keep track of what the inspector is currently showing
let inspectorSelection = {
  type: 'none',     // 'none' | 'track'
  trackId: null,
  takeIndex: null
};

const inspectorPlaceholderHTML = `
  <div class="inspector-placeholder">
    <div style="text-align:center; padding: var(--space-8); color: var(--text-tertiary);">
      <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">ðŸŽšï¸</div>
      <div>Select a track or region</div>
      <div style="font-size: var(--text-sm); margin-top: var(--space-2);">
        Tap a track name on the left to open its details here.
      </div>
    </div>
  </div>
`;

function getInspectorEls() {
  return {
    root: document.querySelector('.daw-inspector'),
    titleEl: document.getElementById('inspectorTitle'),
    contentEl: document.getElementById('inspectorContent')
  };
}

function resetInspector() {
  const { root, titleEl, contentEl } = getInspectorEls();
  if (!root || !titleEl || !contentEl) return;
  inspectorSelection = { type: 'none', trackId: null, takeIndex: null };
  titleEl.textContent = 'ðŸŽ›ï¸ Inspector';
  contentEl.innerHTML = inspectorPlaceholderHTML;

  // Remove header highlight
  document.querySelectorAll('#dawTrackList .track-header').forEach(el => {
    el.classList.remove('selected');
  });
}

// Open the inspector focused on a given track
function openTrackInspector(trackId) {
  const { root, titleEl, contentEl } = getInspectorEls();
  if (!root || !titleEl || !contentEl) return;

  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;

  inspectorSelection = { type: 'track', trackId, takeIndex: null };
  multitrack.selectedTrackId = trackId;

  // Highlight the selected header
  document.querySelectorAll('#dawTrackList .track-header').forEach(el => {
    const id = parseInt(el.dataset.trackId || '0', 10);
    el.classList.toggle('selected', id === trackId);
  });

  titleEl.textContent = `Track ${track.id} â€¢ ${track.name}`;

  const formatPanLabel = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };

  const numRegions = (track.takes || []).length;

  contentEl.innerHTML = `
    <div class="inspector-section">
      <div class="inspector-section-title">Overview</div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Name</span>
        </div>
        <input type="text"
               data-inspector-field="name"
               value="${track.name}"
               style="width:100%;">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Source</span>
        </div>
        <div class="inspector-param-value">
          ${track.isExternalAudio ? 'External / Mic' : (track.instrument || 'Internal')}
        </div>
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Regions on track</span>
        </div>
        <div class="inspector-param-value">
          ${numRegions}
        </div>
      </div>
    </div>

    <div class="inspector-section">
      <div class="inspector-section-title">Mix</div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Volume</span>
          <span class="inspector-param-value" data-inspector-value="volume">
            ${track.volume.toFixed(1)} dB
          </span>
        </div>
        <input type="range"
               min="-40" max="10" step="0.1"
               value="${track.volume}"
               data-inspector-control="volume">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Pan</span>
          <span class="inspector-param-value" data-inspector-value="pan">
            ${formatPanLabel(track.pan)}
          </span>
        </div>
        <input type="range"
               min="-100" max="100" step="1"
               value="${track.pan}"
               data-inspector-control="pan">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>States</span>
        </div>
        <div class="inspector-toggle-row">
          <button class="btn btn-xs" data-inspector-toggle="mute"></button>
          <button class="btn btn-xs" data-inspector-toggle="solo"></button>
          <button class="btn btn-xs" data-inspector-toggle="monitor"></button>
        </div>
      </div>
    </div>
  `;

  // --- Wire controls ---

  // Rename
  const nameInput = contentEl.querySelector('[data-inspector-field="name"]');
  if (nameInput) {
    nameInput.addEventListener('change', () => {
      const newName = nameInput.value.trim();
      if (!newName || newName === track.name) return;
      if (typeof track.rename === 'function') {
        track.rename(newName);
      } else {
        track.name = newName;
      }
      // Also update header text
      const headerName = document.querySelector(
        `#dawTrackList .track-header[data-track-id="${track.id}"] .track-name`
      );
      if (headerName) headerName.textContent = newName;
      titleEl.textContent = `Track ${track.id} â€¢ ${newName}`;
    });
  }

  // Volume
  const volSlider = contentEl.querySelector('[data-inspector-control="volume"]');
  const volLabel  = contentEl.querySelector('[data-inspector-value="volume"]');
  if (volSlider) {
    volSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      track.volume = value;
      if (track.channel && track.channel.volume) {
        track.channel.volume.rampTo(value, 0.05);
      }
      if (volLabel) volLabel.textContent = value.toFixed(1) + ' dB';

      // Keep header slider & label in sync
      const headerSlider = document.querySelector(
        `.track-header .track-volume-slider[data-track-id="${track.id}"]`
      );
      if (headerSlider) {
        headerSlider.value = value;
        const label = headerSlider.closest('.track-volume-control')?.querySelector('.track-volume-value');
        if (label) label.textContent = value.toFixed(1) + 'dB';
      }
    });
  }

  // Pan
  const panSlider = contentEl.querySelector('[data-inspector-control="pan"]');
  const panLabel  = contentEl.querySelector('[data-inspector-value="pan"]');
  if (panSlider) {
    panSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value, 10);
      track.pan = value;
      if (track.channel && track.channel.pan) {
        track.channel.pan.rampTo(value / 100, 0.05);
      }
      if (panLabel) panLabel.textContent = formatPanLabel(value);

      const headerSlider = document.querySelector(
        `.track-header .track-pan-slider[data-track-id="${track.id}"]`
      );
      if (headerSlider) {
        headerSlider.value = value;
        const label = headerSlider.closest('.track-volume-control')?.querySelector('.track-pan-value');
        if (label) label.textContent = formatPanLabel(value);
      }
    });
  }

  // State toggles
  const muteBtn = contentEl.querySelector('[data-inspector-toggle="mute"]');
  const soloBtn = contentEl.querySelector('[data-inspector-toggle="solo"]');
  const monBtn  = contentEl.querySelector('[data-inspector-toggle="monitor"]');

  if (muteBtn) {
    const syncMuteBtn = () => {
      muteBtn.textContent = track.muted ? 'Muted' : 'Mute';
      muteBtn.classList.toggle('btn-primary', track.muted);
      muteBtn.classList.toggle('btn-secondary', !track.muted);
    };
    syncMuteBtn();
    muteBtn.addEventListener('click', async () => {
      await handleTrackAction(track, 'mute');
      openTrackInspector(track.id);
    });
  }

  if (soloBtn) {
    const syncSoloBtn = () => {
      soloBtn.textContent = track.soloed ? 'Soloed' : 'Solo';
      soloBtn.classList.toggle('btn-primary', track.soloed);
      soloBtn.classList.toggle('btn-secondary', !track.soloed);
    };
    syncSoloBtn();
    soloBtn.addEventListener('click', async () => {
      await handleTrackAction(track, 'solo');
      openTrackInspector(track.id);
    });
  }

  if (monBtn) {
    if (!track.isExternalAudio) {
      monBtn.style.display = 'none';
    } else {
      const syncMonBtn = () => {
        monBtn.textContent = track.inputMonitoring ? 'Monitor On' : 'Monitor Off';
        monBtn.classList.toggle('btn-primary', track.inputMonitoring);
        monBtn.classList.toggle('btn-secondary', !track.inputMonitoring);
      };
      syncMonBtn();
      monBtn.addEventListener('click', async () => {
        await handleTrackAction(track, 'monitor');
        openTrackInspector(track.id);
      });
    }
  }

  // On mobile, slide the inspector up into view
  if (window.innerWidth <= 768 && root) {
    root.classList.add('inspector-open');
  }
}

// Re-apply inspector selection after a re-render (mute/solo, undo, etc.)
function refreshInspectorSelection() {
  if (inspectorSelection.type === 'track' && inspectorSelection.trackId != null) {
    openTrackInspector(inspectorSelection.trackId);
  } else if (inspectorSelection.type === 'none') {
    resetInspector();
  }
}

// Wire close button + initial placeholder
function setupInspectorUI() {
  const { root } = getInspectorEls();
  if (!root) return;

  // Initial state
  resetInspector();

  const closeBtn = document.getElementById('closeInspectorBtn');
  if (closeBtn && !closeBtn.dataset._wired) {
    closeBtn.dataset._wired = 'true';
    closeBtn.addEventListener('click', () => {
      if (window.innerWidth <= 768) {
        root.classList.remove('inspector-open'); // close bottom sheet
      } else {
        resetInspector(); // desktop: keep panel but clear selection
      }
    });
  }
}

// Run once DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  try {
    setupInspectorUI();
  } catch (err) {
    console.warn('Inspector setup failed:', err);
  }
});

function showAddTrackDialog() {
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âž• Add Track</div>
      <button class="modal-close">âœ•</button>
    </div>

    <div class="modal-body">
      <div style="display:grid; gap:var(--space-4);">

        <!-- ðŸ·ï¸ Track Name -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Name
          </label>
          <input type="text" class="track-name-input"
                 placeholder="e.g., Vocals, Guitar, Drums..."
                 style="width:100%; padding:var(--space-3); font-size:var(--text-base);
                        border-radius:var(--radius-sm); border:1px solid var(--glass-border);
                        background:var(--glass-bg); color:var(--text-primary);">
        </div>

        <!-- ðŸŽšï¸ Track Type -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Type
          </label>
          <select class="track-type-select" style="font-size:var(--text-base); padding:var(--space-3); width:100%;">
            <option value="internal">ðŸŽ§ Internal Audio Track</option>
            <option value="external">ðŸŽ¤ External Audio (Mic / Line In)</option>
          </select>
        </div>

        <!-- ðŸŽ¤ External Info -->
        <div class="external-info" style="display:none; padding:var(--space-4);
             background:var(--glass-bg); border-radius:var(--radius-md);
             border:1px solid var(--glass-border);">
          <div style="font-weight:700; margin-bottom:var(--space-2); color:var(--text-primary);">
            ðŸŽ¤ External Audio Input
          </div>
          <div style="font-size:var(--text-sm); color:var(--text-secondary); line-height:1.6;">
            <p style="margin-bottom:var(--space-2);">
              This will create a track that records from your microphone or audio interface.
            </p>
            <ul style="margin-left:var(--space-5); margin-bottom:var(--space-2);">
              <li>Real-time monitoring with effects</li>
              <li>Record vocals, guitar, or any external source</li>
              <li>Syncs perfectly with other tracks</li>
            </ul>
            <p style="font-size:var(--text-xs); color:var(--text-tertiary);">
              âš ï¸ Your browser will request microphone access
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-secondary cancel-btn">Cancel</button>
      <button class="btn btn-primary confirm-btn">Add Track</button>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-btn').onclick = close;

  const nameInput = modal.querySelector('.track-name-input');
  const trackTypeSelect = modal.querySelector('.track-type-select');
  const externalInfo = modal.querySelector('.external-info');
  const confirmBtn = modal.querySelector('.confirm-btn');

  // Toggle external info panel
  trackTypeSelect.onchange = () => {
    const isExternal = trackTypeSelect.value === 'external';
    externalInfo.style.display = isExternal ? 'block' : 'none';
  };

  confirmBtn.onclick = async () => {
    const isExternal = trackTypeSelect.value === 'external';
    const userName = nameInput.value.trim();

    // ðŸ§  Smart default naming logic
    const countInternal = multitrack.tracks.filter(t => !t.isExternalAudio).length + 1;
    const countExternal = multitrack.tracks.filter(t => t.isExternalAudio).length + 1;
    const defaultName = isExternal ? `Mic ${countExternal}` : `Track ${countInternal}`;
    const name = userName || defaultName;

    confirmBtn.disabled = true;
    confirmBtn.textContent = isExternal ? 'Requesting access...' : 'Adding...';

    try {
      const track = await createTrack(null, isExternal);
      if (track) {
        track.rename(name);
        renderMultitrack();
        showToast(`âœ… ${isExternal ? 'External' : 'Internal'} track "${track.name}" added!`, 'success');
        close();
      } else {
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Add Track';
      }
    } catch (err) {
      console.error('âŒ Failed to add track:', err);
      showToast(`âŒ Failed to add track: ${err.message}`, 'error');
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Add Track';
    }
  };

  backdrop.onclick = e => { if (e.target === backdrop) close(); };
}

// === PLAYHEAD FOLLOW + TIME DISPLAY ===

let playheadFollowActive = true;
let playheadUpdateInterval = null;

// Call this once after your DAW tab is ready
function initPlayheadFollow() {
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const playheadEl = document.getElementById('dawPlayhead');

  if (!playheadEl || !arrangementScroll) return;

  clearInterval(playheadUpdateInterval);

  playheadUpdateInterval = setInterval(() => {
    if (!multitrack.isPlaying) return;

    const ctx = Tone?.Transport || null;
    let seconds = multitrack.playheadSeconds || 0;

    // ðŸŽ› For recording: follow the Transport clock if it's actually running
    if (ctx && ctx.state === 'started') {
      seconds = ctx.seconds;
    }

    updatePlayheadAndScroll(seconds);
  }, 50); // ~20fps is plenty
}


function formatTimecode(sec) {
  const ms = Math.floor((sec % 1) * 1000);
  const s = Math.floor(sec) % 60;
  const m = Math.floor(sec / 60) % 60;
  const h = Math.floor(sec / 3600);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
}

function formatBars(sec) {
  const bpm = parseFloat(document.getElementById('dawBpmInput')?.value) || 120;
  const beatDur = 60 / bpm;
  const beats = sec / beatDur;
  const bar = Math.floor(beats / 4) + 1;
  const beat = Math.floor(beats % 4) + 1;
  return `${bar}.${beat}.1`;
}

// Optionally toggle follow mode
function togglePlayheadFollow() {
  playheadFollowActive = !playheadFollowActive;
  showToast(playheadFollowActive ? 'ðŸŽ¥ Follow Mode ON' : 'ðŸŽ¥ Follow Mode OFF', 'info');
}

// Helper: ensure playhead stays visible when manually scrubbed
function updatePlayheadUI(seconds) {
  const playhead = document.getElementById('dawPlayhead');
  const projDur = multitrack.projectDuration || (state.duration * 60);
  const pct = Math.max(0, Math.min(1, seconds / projDur));
  playhead.style.left = `${pct * 100}%`;
}

function renderMultitrack() {
  // Force container visibility
  const container = document.getElementById('dawMainContainer') || 
                    document.querySelector('.daw-main-container');
  if (container) {
    container.style.display = 'grid';
    container.style.visibility = 'visible';
  }

  const trackHeaders = document.getElementById('dawTrackList');
  const arrangementGrid = document.getElementById('dawArrangementGrid');
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const rulerContainer = document.getElementById('dawRuler');

  if (!trackHeaders || !arrangementGrid) {
    console.warn('renderMultitrack: missing containers');
    return;
  }

  const durationMinutes = typeof state.duration === 'number' && state.duration > 0 ? state.duration : 1;
  const projectDurationSeconds = durationMinutes * 60;
  const zoom = multitrack.zoom || 100;
  const timelineWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth = timelineWidth;

  document.documentElement.style.setProperty('--timeline-width', timelineWidth + 'px');

  trackHeaders.innerHTML = '';
  arrangementGrid.innerHTML = '';

  arrangementGrid.style.width = timelineWidth + 'px';
  const ruler = rulerContainer?.querySelector('.daw-ruler');
  if (ruler) {
    ruler.style.width = timelineWidth + 'px';
  }

  // Format pan display helper
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };

  // Render each track
  multitrack.tracks.forEach(track => {
    const instData = track.isExternalAudio ? 
      { icon: 'ðŸŽ¤', name: 'External' } : 
      instruments[track.instrument];

    // CREATE TRACK HEADER (LEFT SIDE)
    const headerDiv = document.createElement('div');
    headerDiv.className = 'track-header';
    headerDiv.dataset.trackId = track.id;   // ðŸ” link header to specific track
    headerDiv.tabIndex = 0;                  // keyboard focusable for accessibility
    if (track.recording) headerDiv.classList.add('recording');
    if (track.armed) headerDiv.classList.add('armed');
    if (track.isExternalAudio) headerDiv.classList.add('external-audio');

    
    headerDiv.innerHTML = `
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || 'ðŸŽšï¸'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-track-id="${track.id}" data-action="rec">
          ${track.recording ? 'âºï¸' : 'âšª'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-track-id="${track.id}" data-action="arm">
          ${track.armed ? 'ðŸ”´' : 'âšª'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-track-id="${track.id}" data-action="monitor">
            ${track.inputMonitoring ? 'ðŸ”Š' : 'ðŸ”‡'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-track-id="${track.id}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-track-id="${track.id}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="fx">
          ðŸŽ›ï¸ FX
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="delete">
          ðŸ—‘ï¸
        </button>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" step="0.1"
               class="track-volume-slider" data-track-id="${track.id}" data-param="volume">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" step="1"
               class="track-pan-slider" data-track-id="${track.id}" data-param="pan">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    `;
    
    trackHeaders.appendChild(headerDiv);
    
    // CREATE TRACK LANE (RIGHT SIDE)
    // CREATE TRACK LANE (RIGHT SIDE)
    const laneDiv = document.createElement('div');
    laneDiv.className = 'daw-track-lane';
    laneDiv.dataset.trackId = track.id;
    laneDiv.style.width = timelineWidth + 'px';

    
    // Add regions
    track.takes.forEach((take, idx) => {
      const isSelected = idx === track.selectedTakeIndex;
      const isMuted = take.muted;
      
      const startPos = (take.startTime || 0) * zoom;
      const width = take.duration * zoom;
      
      const regionDiv = document.createElement('div');
      regionDiv.className = `audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}`;
      regionDiv.dataset.trackId = track.id;
      regionDiv.dataset.takeIndex = idx;
      regionDiv.dataset.regionId = take.id;
      regionDiv.style.left = startPos + 'px';
      regionDiv.style.width = width + 'px';
      
      regionDiv.innerHTML = `
        <div class="region-header">
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">âœï¸</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">ðŸ—‘ï¸</button>
          </div>
          <div class="region-name">Take ${idx + 1}</div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      `;
      
      laneDiv.appendChild(regionDiv);
    });
    
    // Empty state
    if (track.takes.length === 0 && !track.recording) {
      const emptyDiv = document.createElement('div');
      emptyDiv.className = 'track-empty-state';
      emptyDiv.innerHTML = `
        <div class="track-empty-state-icon">ðŸŽ™ï¸</div>
        <div>Arm and record to create takes</div>
      `;
      laneDiv.appendChild(emptyDiv);
    }
    
    // Recording indicator
    if (track.recording) {
      const recDiv = document.createElement('div');
      recDiv.className = 'recording-indicator';
      recDiv.innerHTML = `
        <div class="recording-indicator-dot"></div>
        <span>Recording...</span>
      `;
      laneDiv.appendChild(recDiv);
    }
    
    arrangementGrid.appendChild(laneDiv);
    
    // Attach control listeners
    headerDiv.querySelectorAll('.track-mini-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const action = btn.dataset.action;
        handleTrackAction(track, action);
      });
    });
    
    // Volume slider
    const volumeSlider = headerDiv.querySelector('.track-volume-slider');
    if (volumeSlider) {
      volumeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        track.volume = value;
        if (track.channel && track.channel.volume) {
          track.channel.volume.rampTo(value, 0.05);
        }
        const label = headerDiv.querySelector('.track-volume-value');
        if (label) label.textContent = value.toFixed(1) + 'dB';
      });
    }
    
    // Pan slider - WORKING VERSION
    const panSlider = headerDiv.querySelector('.track-pan-slider');
    if (panSlider) {
      panSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        track.pan = value;
        
        if (track.channel && track.channel.pan) {
          track.channel.pan.rampTo(value / 100, 0.05);
        }
        
        const label = headerDiv.querySelector('.track-pan-value');
        if (label) {
          label.textContent = formatPan(value);
        }
      });
    }

        // Clicking the header (but not the buttons/sliders) opens the inspector
    headerDiv.addEventListener('click', (e) => {
      if (e.target.closest('.track-mini-btn') || e.target.closest('input[type="range"]')) {
        return; // don't double-handle button/slider clicks
      }
      if (typeof openTrackInspector === 'function') {
        openTrackInspector(track.id);
      }
    });

    // Keyboard: Enter/Space also open inspector when header is focused
    headerDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (typeof openTrackInspector === 'function') {
          openTrackInspector(track.id);
        }
      }
    });

    // Setup region interactions
    setupRegionInteractions(laneDiv, track);
    
    // Start meter animation
    if (track.meter) {
      const updateMeters = () => {
        if (!track.meter) return;

        const fills = headerDiv.querySelectorAll(`[data-meter-track="${track.id}"]`);
        if (fills.length === 0) return;
        
        const value = track.meter.getValue();
        const channels = Array.isArray(value) ? value : [value, value];
        
        fills.forEach((fill, idx) => {
          const db = (idx < channels.length ? channels[idx] : channels[0]) ?? -60;
          const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
          fill.style.height = normalized + '%';
        });

        requestAnimationFrame(updateMeters);
      };

      requestAnimationFrame(updateMeters);
    }
  });

  if (typeof updateTimelineRuler === 'function') {
    updateTimelineRuler();
  }
  
  // If the inspector already had something selected, re-apply it
  if (typeof refreshInspectorSelection === 'function') {
    refreshInspectorSelection();
  }
}

function updatePlayheadAndScroll(currentSeconds) {
  const wrapper = document.getElementById('dawArrangementScroll');
  const playhead = document.getElementById('dawPlayhead');
  const timecodeEl = document.getElementById('dawTimecode');
  const barsEl = document.getElementById('dawBars');

  if (!wrapper || !playhead) return;

  const projDur = multitrack.projectDuration || (state.duration * 60);
  let sec = Number(currentSeconds);

  if (!Number.isFinite(sec) || sec < 0) sec = 0;
  if (projDur > 0) sec = Math.min(sec, projDur);

  // ðŸ”‘ Remember this globally so PAUSE / SKIM can use it
  multitrack.playheadSeconds = sec;
  state.cursorSeconds = sec;

  // Position playhead in pixels
  const zoom = multitrack.zoom || 100;
  const x = sec * zoom;
  playhead.style.left = x + 'px';

  // Auto-scroll to keep playhead visible
  const padding = 80;
  const visibleStart = wrapper.scrollLeft;
  const visibleEnd = visibleStart + wrapper.clientWidth;

  if (x < visibleStart + padding) {
    wrapper.scrollLeft = Math.max(0, x - padding);
  } else if (x > visibleEnd - padding) {
    wrapper.scrollLeft = x - wrapper.clientWidth + padding;
  }

  // â±ï¸ Update transport displays
  if (timecodeEl) timecodeEl.textContent = formatTimecode(sec);
  if (barsEl) barsEl.textContent = formatBars(sec);
}


let playheadAnimationId = null;

function startPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
  }

  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.getElementById('dawArrangementScroll'); // âœ… fixed selector

  if (!playhead || !wrapper) return;

  const animate = () => {
    if (!state.isPlaying) {
      playheadAnimationId = null;
      return;
    }

    const currentTime = Tone.Transport.seconds;
    state.cursorSeconds = currentTime;
    updatePlayheadAndScroll(currentTime);

    playheadAnimationId = requestAnimationFrame(animate);
  };

  playheadAnimationId = requestAnimationFrame(animate);
}

function stopPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
    playheadAnimationId = null;
    console.log('â¹ï¸ Playhead animation stopped');
  }
}
  
let previewPlayheadId = null;
let previewStartTime = 0;

function startPreviewPlayhead(startOffset, duration) {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
  }
  
  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.getElementById('dawArrangementScroll');
  
  if (!playhead || !wrapper) {
    console.error('âŒ Missing playhead or wrapper for preview');
    return;
  }
  
  previewStartTime = performance.now();
  
  const animate = () => {
    const elapsed = (performance.now() - previewStartTime) / 1000;
    
    if (elapsed >= duration) {
      previewPlayheadId = null;
      return;
    }
    
    const currentTime = startOffset + elapsed; // ðŸ”‘ real project time
    state.cursorSeconds = currentTime; 
    updatePlayheadAndScroll(currentTime);
    
    previewPlayheadId = requestAnimationFrame(animate);
  };
  
  previewPlayheadId = requestAnimationFrame(animate);
  console.log('âœ… Preview playhead started at', startOffset, 'for', duration, 'seconds');
}

function stopPreviewPlayhead() {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
    previewPlayheadId = null;
    console.log('â¹ï¸ Preview playhead stopped');
  }
}

function setupPreviewButton() {
  const btn = document.getElementById('previewMultitrackBtn');
  if (!btn) return;

  btn.addEventListener('click', () => {
    // Just call with no args â†’ uses last cursor/playhead position
    previewMultitrack();
  });
}

// --- GLOBAL MASTER BUS SAFETY NET ---
const masterGain = new Tone.Gain(0.8); // master volume ~ -4dB
const limiter = new Tone.Limiter(-1);  // prevents 0dBFS overload
masterGain.connect(limiter).toDestination();

// Attach to both systems
if (!multitrack.masterBus) multitrack.masterBus = masterGain;
window.SEQUENCER_MASTER_BUS = masterGain;

// Normalizes based on measured RMS (~perceived loudness)
function normalizeBufferVolume(audioBuffer) {
  const data = audioBuffer.getChannelData(0);
  let sumSq = 0;
  for (let i = 0; i < data.length; i++) {
    const v = data[i];
    sumSq += v * v;
  }
  const rms = Math.sqrt(sumSq / data.length) || 1e-6;

  // Much more conservative target
  const targetRms = 0.12; // was 0.25

  // Convert gain ratio â†’ dB
  return Tone.gainToDb(targetRms / rms);
}

  
async function previewMultitrack(startAtSeconds) {
  // If no explicit start is passed, use the last playhead/cursor position
  const startFrom =
    typeof startAtSeconds === 'number'
      ? startAtSeconds
      : (typeof state.cursorSeconds === 'number' ? state.cursorSeconds : 0);

  const activeTracks = multitrack.tracks.filter(t =>
    t.selectedTakeIndex >= 0 && !t.muted
  );
  
  if (activeTracks.length === 0) {
    showToast('âŒ No active takes to preview', 'error');
    return;
  }

  // ðŸ§© Stop any existing preview first - CRITICAL for looping
  // ðŸ§  Only fully stop if we're not resuming from pause
  if (!multitrack.isPaused) {
    await stopMultitrackPreview();
  }

  await Tone.start();
  if (Tone.context.state !== 'running') {
    await Tone.context.resume();
  }
  
  multitrack.lastStartTime = Tone.now();
  multitrack.isPaused = false;
  multitrack.previewPlayers = [];

  const projectDurationSeconds = multitrack.projectDuration || (state.duration * 60);
  
  // ðŸ”‘ Clamp start offset to project bounds
  const previewStart = Math.max(0, Math.min(startFrom, projectDurationSeconds));
  let previewEnd = previewStart;

  // Update cursor + visually move playhead to the preview start
  state.cursorSeconds = previewStart;
  updatePlayheadAndScroll(previewStart);

  showToast(`â³ Loading takes (from ${previewStart.toFixed(2)}s)...`, 'info');

  for (const track of activeTracks) {
    const take = track.takes[track.selectedTakeIndex];
    if (!take || take.muted) continue;
  
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`âŒ ${track.name}: Invalid buffer`);
      continue;
    }
  
    const regionStart = take.startTime || 0;
    const regionEnd = regionStart + take.duration;
  
    if (regionEnd <= previewStart) continue;
  
    try {
      const player = new Tone.Player({
        context: Tone.context,
        loop: false,
        fadeOut: 0.01
      }).connect(track.channel);
  
      player.buffer = take.buffer;
  
      const relativeStart = Math.max(0, regionStart - previewStart);
  
      multitrack.previewPlayers.push({
        player,
        track,
        regionStart,     // ðŸ‘ˆ added
        regionEnd,       // ðŸ‘ˆ added (optional but useful)
        relativeStart
      });
  
      if (regionEnd > previewEnd) previewEnd = regionEnd;
  
    } catch (err) {
      console.error(`âŒ ${track.name} failed:`, err);
    }
  }

  if (!multitrack.previewPlayers.length) {
    showToast('âš ï¸ No regions overlap this preview range', 'warning');
    return;
  }

  const totalDuration = Math.max(0.1, previewEnd - previewStart);
  console.log(`â–¶ï¸ Preview from ${previewStart.toFixed(3)}s for ${totalDuration.toFixed(3)}s`);

  const now = Tone.now() + 0.1;

  multitrack.previewPlayers.forEach(({ player, track, relativeStart, regionStart }) => {
    try {
      const offsetInBuffer = Math.max(0, previewStart - regionStart);
      player.start(now + relativeStart, offsetInBuffer);
      console.log(`â–¶ï¸ ${track.name} resume at buffer offset ${offsetInBuffer.toFixed(3)}s`);
    } catch (err) {
      console.error(`âŒ Failed to start ${track.name}:`, err);
    }
  });

  showToast(
    `â–¶ï¸ Previewing ${multitrack.previewPlayers.length} track(s) from ${previewStart.toFixed(2)}s`,
    'success'
  );

  // === ðŸ§­ Activate playhead + follow mode ===
  multitrack.isPlaying = true;
  multitrack.playheadSeconds = previewStart;
  initPlayheadFollow();
  startPreviewPlayhead(previewStart, totalDuration);

  // === ðŸŒ€ LOOP SUPPORT (Selection or Full Project) ===
  multitrack.previewTimeout = setTimeout(async () => {
    // Stop current preview and WAIT for cleanup
    await stopMultitrackPreview();
    
    const btn = document.getElementById('previewMultitrackBtn');

    if (!multitrack.loopEnabled) {
      if (btn) btn.textContent = 'â–¶ï¸ Preview Mix';
      return;
    }

    const hasSelection =
      typeof multitrack.loopStart === 'number' &&
      typeof multitrack.loopEnd === 'number' &&
      multitrack.loopEnd > multitrack.loopStart;

    const restartAt = hasSelection ? multitrack.loopStart : 0;

    console.log(
      hasSelection
        ? `ðŸ” Looping selected region: ${restartAt.toFixed(2)}s â†’ ${multitrack.loopEnd.toFixed(2)}s`
        : 'ðŸ” Looping entire projectâ€¦'
    );

    multitrack.playheadSeconds = restartAt;
    
    // Small buffer to ensure Tone.js is ready
    await new Promise(resolve => setTimeout(resolve, 50));
    
    await previewMultitrack(restartAt);
  }, (totalDuration + 0.25) * 1000);
}

async function stopMultitrackPreview(resetOrOptions) {
  // Allow both: stopMultitrackPreview(true) and stopMultitrackPreview({ resetToZero: true })
  const resetToZero =
    typeof resetOrOptions === 'boolean'
      ? resetOrOptions
      : resetOrOptions && typeof resetOrOptions.resetToZero === 'boolean'
        ? resetOrOptions.resetToZero
        : false;

  if (multitrack.previewPlayers && multitrack.previewPlayers.length > 0) {
    // Stop all players first (synchronous)
    multitrack.previewPlayers.forEach(({ player }) => {
      try {
        if (player.state === 'started') {
          player.stop();
        }
      } catch (err) {
        console.warn('Error stopping preview player:', err);
      }
    });

    // Then dispose all players (async) - wait for all to complete
    await Promise.all(
      multitrack.previewPlayers.map(async ({ player }) => {
        try {
          await player.dispose();
        } catch (err) {
          console.warn('Error disposing preview player:', err);
        }
      })
    );

    multitrack.previewPlayers = [];
    console.log('â¹ï¸ Preview stopped');
  }

  // Stop playhead follow + display updates
  multitrack.isPlaying = false;
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  stopPreviewPlayhead();

  if (multitrack.previewTimeout) {
    clearTimeout(multitrack.previewTimeout);
    multitrack.previewTimeout = null;
  }

  // Remember where we stopped so PAUSE can resume
  let lastSeconds = 0;

  if (resetToZero) {
    lastSeconds = 0;
  } else if (
    typeof state.cursorSeconds === 'number' &&
    !Number.isNaN(state.cursorSeconds)
  ) {
    lastSeconds = state.cursorSeconds;
  } else if (
    typeof multitrack.playheadSeconds === 'number' &&
    !Number.isNaN(multitrack.playheadSeconds)
  ) {
    lastSeconds = multitrack.playheadSeconds;
  }

  multitrack.playheadSeconds = lastSeconds;
  multitrack.lastPreviewCursor = lastSeconds;
  // This updates playhead position, scroll, and timecode/bars
  updatePlayheadAndScroll(lastSeconds);
}

// ðŸ” PURE WEB AUDIO MASTER CHAIN FOR OFFLINE BOUNCE
function createOfflineMasterChain(offlineContext) {
  // Entry point for all tracks
  const input = offlineContext.createGain();
  input.gain.value = 1.0; // ðŸ”Š no pre-attenuation (was 0.25 â‰ˆ -12 dB)

  // High-pass (low cut)
  const lowCut = offlineContext.createBiquadFilter();
  lowCut.type = 'highpass';
  lowCut.frequency.value = typeof state.lowCut === 'number' ? state.lowCut : 20;
  lowCut.Q.value = 0.707;

  // Low-pass (high cut)
  const highCut = offlineContext.createBiquadFilter();
  highCut.type = 'lowpass';
  highCut.frequency.value = typeof state.highCut === 'number' ? state.highCut : 20000;
  highCut.Q.value = 0.707;

  // Tape-style soft clip
  const tape = offlineContext.createWaveShaper();
  const satAmt = ((state.tapeSaturation || 0) / 100) * 0.8; // 0â€“0.8
  const curveLen = 4096;
  const curve = new Float32Array(curveLen);
  for (let i = 0; i < curveLen; i++) {
    const x = (i / (curveLen - 1)) * 2 - 1; // -1..1
    curve[i] = ((1 + satAmt) * x) / (1 + satAmt * Math.abs(x));
  }
  tape.curve = curve;

  // Bus compressor
  const comp = offlineContext.createDynamicsCompressor();
  comp.threshold.value =
    typeof state.compressor === 'number' ? state.compressor : -18; // a bit gentler than -24
  comp.ratio.value = 3;       // 3:1 instead of 4:1
  comp.attack.value = 0.005;
  comp.release.value = 0.2;

  // Limiter approximation
  const limiter = offlineContext.createDynamicsCompressor();
  limiter.threshold.value = -1;  // let it sit closer to 0 dBFS
  limiter.ratio.value = 20;
  limiter.attack.value = 0.001;
  limiter.release.value = 0.1;

  // Final output gain (makeup)
  const outGain = offlineContext.createGain();
  // 1.0 = no change. 1.4 â‰ˆ +3 dB, 2.0 â‰ˆ +6 dB
  outGain.gain.value = 1.6; // tweak to taste

  // Chain: input â†’ lowCut â†’ highCut â†’ tape â†’ comp â†’ limiter â†’ outGain â†’ destination
  input.connect(lowCut);
  lowCut.connect(highCut);
  highCut.connect(tape);
  tape.connect(comp);
  comp.connect(limiter);
  limiter.connect(outGain);
  outGain.connect(offlineContext.destination);

  return input;
}

function createOfflineFxNode(fxDef, offlineContext) {
  const { type, params } = fxDef;
  
  switch (type) {
    case 'reverb':
      return new Tone.Reverb({ 
        decay: params.decay, 
        wet: params.wet,
        context: offlineContext 
      });
    
    case 'delay':
      return new Tone.FeedbackDelay({
        delayTime: params.time,
        feedback: params.feedback,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'chorus':
      return new Tone.Chorus({
        frequency: params.frequency,
        delayTime: params.delayTime,
        depth: params.depth,
        wet: params.wet,
        context: offlineContext
      }).start();
    
    case 'distortion':
      return new Tone.Distortion({
        distortion: params.amount,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'filter':
      return new Tone.Filter({
        type: params.type,
        frequency: params.frequency,
        Q: params.q,
        context: offlineContext
      });
    
    case 'compressor':
      return new Tone.Compressor({
        threshold: params.threshold,
        ratio: params.ratio,
        attack: params.attack,
        release: params.release,
        context: offlineContext
      });
    
    case 'eq':
      return new Tone.EQ3({
        low: params.low,
        mid: params.mid,
        high: params.high,
        context: offlineContext
      });
    
    case 'bitcrusher':
      return new Tone.BitCrusher({
        bits: params.bits,
        context: offlineContext
      });
    
    default:
      return null;
  }
}
  
async function bounceAllTracks() {
  const activeTracks = multitrack.tracks.filter(t => {
    if (t.muted) return false;

    if (t.selectedTakeIndex >= 0 && t.takes[t.selectedTakeIndex]) {
      const sel = t.takes[t.selectedTakeIndex];
      return sel.buffer && sel.buffer.length && !sel.muted;
    }

    if (t.takes && t.takes.length > 0) {
      return t.takes.some(tk => tk && tk.buffer && tk.buffer.length && !tk.muted);
    }

    return false;
  });

  if (activeTracks.length === 0) {
    showToast('âŒ No tracks to bounce!', 'error');
    return;
  }

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">ðŸŽµ Bouncing Mix</div>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <div id="bounceStatus" style="font-weight: 700; margin-bottom: var(--space-2);">
          Preparing...
        </div>
        <div class="progress">
          <div class="progress-value" id="bounceProgress"
               style="width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="bounceDetails"
             style="font-size: var(--text-sm); color: var(--text-tertiary); margin-top: var(--space-2);">
        </div>
      </div>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const updateProgress = (percent, status, details = '') => {
    const prog = document.getElementById('bounceProgress');
    const stat = document.getElementById('bounceStatus');
    const det = document.getElementById('bounceDetails');
    if (prog) prog.style.width = percent + '%';
    if (stat) stat.textContent = status;
    if (det) det.textContent = details;
  };

  try {
    updateProgress(10, 'Analyzing tracks...', `${activeTracks.length} tracks to bounce`);

    // Find actual content boundaries
    let minStart = Infinity;
    let maxEnd = 0;
    
    activeTracks.forEach(track => {
      let take = null;
      if (track.selectedTakeIndex >= 0 && track.takes[track.selectedTakeIndex]) {
        take = track.takes[track.selectedTakeIndex];
      } else if (track.takes && track.takes.length > 0) {
        take = track.takes.find(tk => tk && tk.buffer && !tk.muted) || null;
      }
      
      if (take && take.buffer) {
        const start = take.startTime || 0;
        const end = start + take.duration;
        if (start < minStart) minStart = start;
        if (end > maxEnd) maxEnd = end;
      }
    });
    
    if (minStart === Infinity || maxEnd === 0) {
      backdrop.remove();
      showToast('âŒ No audio content to bounce', 'error');
      return;
    }

    // Use actual content duration, not project duration
    const totalDuration = maxEnd - minStart;
    
    updateProgress(
      20,
      'Setting up renderer...',
      `Duration: ${totalDuration.toFixed(1)}s (trimmed)`
    );

    console.log(`ðŸŽ¬ Bouncing ${totalDuration.toFixed(2)}s (content from ${minStart.toFixed(2)}s to ${maxEnd.toFixed(2)}s)`);

    const sampleRate = Tone.context.sampleRate || 48000;
    const numFrames = Math.ceil(totalDuration * sampleRate);

    const offlineContext = new OfflineAudioContext({
      numberOfChannels: 2,
      length: numFrames,
      sampleRate
    });

    updateProgress(30, 'Creating audio chain...', 'Building master effects');

    const offlineMasterIn = createOfflineMasterChain(offlineContext);

    updateProgress(40, 'Scheduling tracks...', `Processing ${activeTracks.length} tracks`);

    for (const track of activeTracks) {
      let take = null;
      if (track.selectedTakeIndex >= 0 && track.takes[track.selectedTakeIndex]) {
        take = track.takes[track.selectedTakeIndex];
      } else if (track.takes && track.takes.length > 0) {
        take = track.takes.find(tk => tk && tk.buffer && !tk.muted) || null;
      }

      if (!take || !take.buffer || take.buffer.length === 0) continue;

      try {
        const ctx = offlineContext;
        const src = ctx.createBufferSource();
        src.buffer = take.buffer;

        const gainNode = ctx.createGain();
        gainNode.gain.value = Tone.dbToGain(track.volume || 0);

        const panNode = ctx.createStereoPanner();
        panNode.pan.value = (track.pan || 0) / 100;

        src.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(offlineMasterIn);

        const startTime = take.startTime || 0;
        const relStart = startTime - minStart;
        const safeStart = Math.max(0, relStart);

        src.start(safeStart);

        console.log(`âœ… ${track.name}: renders at ${safeStart.toFixed(3)}s`);
      } catch (err) {
        console.error(`âŒ Failed to schedule ${track.name}:`, err);
      }
    }

    updateProgress(50, 'Rendering audio...', 'This may take a moment');

    const progressInterval = setInterval(() => {
      const progEl = document.getElementById('bounceProgress');
      const currentProg = progEl
        ? parseFloat(progEl.style.width) || 50
        : 50;
      if (currentProg < 90) {
        updateProgress(
          currentProg + 2,
          'Rendering audio...',
          `${Math.round(currentProg - 50)}% complete`
        );
      }
    }, 200);

    const renderedBuffer = await offlineContext.startRendering();

    clearInterval(progressInterval);
    updateProgress(95, 'Converting to WAV...', 'Almost done');

    console.log(`âœ… Rendered ${renderedBuffer.duration.toFixed(2)}s (trimmed from ${totalDuration.toFixed(2)}s)`);

    const wavData = bufferToWavImproved(renderedBuffer);
    const blob = new Blob([wavData], { type: 'audio/wav' });

    const projectName = document.getElementById('projectName')?.value || 'mix';
    const filename = `${projectName.replace(/\s+/g, '_')}_bounce_${Date.now()}.wav`;

    updateProgress(100, 'Complete!', `Downloading ${filename}`);

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    console.log(`âœ… Bounce complete: ${filename} (${totalDuration.toFixed(1)}s)`);

    setTimeout(() => {
      backdrop.remove();
      showToast(`âœ… Bounce complete! ${totalDuration.toFixed(1)}s exported (silence trimmed)`, 'success');
    }, 1000);
  } catch (err) {
    console.error('âŒ Bounce failed:', err);
    backdrop.remove();
    showToast(`âŒ Bounce failed: ${err.message}`, 'error');
  }
}
  
// Add this NEW function
async function validateAllArmedTracks() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const errors = [];
  
  for (const track of armedTracks) {
    // Check if drum samples are loaded
    if (!track.isExternalAudio && instruments[track.instrument]?.type === 'drum') {
      const synth = synths[track.instrument];
      if (synth && !synth.loaded) {
        errors.push(`${track.instrument} sample not loaded`);
      }
    }
    
    // Check external audio setup
    if (track.isExternalAudio && !track.mediaStream) {
      errors.push(`${track.name} has no audio input`);
    }
  }
  
  if (errors.length > 0) {
    throw new Error(errors.join('\n'));
  }
}
  
async function toggleRecordAllArmed() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const recordingTracks = multitrack.tracks.filter(t => t.recording);

  if (recordingTracks.length > 0) {
    recordingTracks.forEach(track => track.stopRecording());
    stopPlayheadAnimation(); // Stop scroll during recording
    showToast(`â¹ï¸ Stopped recording ${recordingTracks.length} track(s)`, 'info');
    renderMultitrack();
    return;
  }

  if (armedTracks.length === 0) {
    showToast('âŒ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`âŒ Cannot record:\n${err.message}`, 'error');
    return;
  }

  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();

  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  console.log(`ðŸŽ¬ GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    await track.startRecording({ forcedStartTime: globalStart });
  }

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`ðŸŽ™ï¸ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`ðŸŽ™ï¸ Recording ${armedTracks.length} track(s)`, 'success');
  
  // Start playhead animation for recording
  startPlayheadAnimation();
  
  renderMultitrack();
}
  
// Toggle recording for a single track
async function toggleRecordTrack(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.recording) {
    track.stopRecording();
    showToast(`â¹ï¸ Stopped recording ${track.name}`, 'info');
  } else {
    if (!track.armed) {
      track.armed = true;
    }

    if (!state.isPlaying) {
      await togglePlay();
    }

    await Tone.start();
    const start = Tone.now();
    await track.startRecording({ forcedStartTime: start });

    showToast(`ðŸŽ™ï¸ Recording ${track.name}...`, 'success');
  }
  
  renderMultitrack();
}

// Add these functions after the toggleRecordTrack function (around line 4630):

// Global recording control
async function startGlobalRecording() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  
  if (armedTracks.length === 0) {
    showToast('âŒ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`âŒ Cannot record:\n${err.message}`, 'error');
    return;
  }

  // Start transport if not playing
  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();
  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  multitrack.isPlaying = true;

  console.log(`ðŸŽ¬ GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    track.recordStartTime = globalStart;
    await track.startRecording();
  }

  // Start playhead animation
  initPlayheadFollow();

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`ðŸŽ™ï¸ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`ðŸŽ™ï¸ Recording ${armedTracks.length} track(s)`, 'success');
  
  renderMultitrack();
}

function stopGlobalRecording() {
  const recordingTracks = multitrack.tracks.filter(t => t.recording);
  
  if (recordingTracks.length === 0) return;

  recordingTracks.forEach(track => {
    track.stopRecording();
  });

  multitrack.globalRecordStartTime = null;
  multitrack.isPlaying = false;

  // Stop playhead
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  showToast(`â¹ï¸ Stopped recording ${recordingTracks.length} track(s)`, 'info');
  renderMultitrack();
}

// BPM and time signature controls
function setBPM(newBpm) {
  const bpm = Math.max(30, Math.min(300, parseFloat(newBpm) || 120));
  state.bpm = bpm;
  Tone.Transport.bpm.value = bpm;
  
  const bpmSlider = document.getElementById('bpmSlider');
  const bpmValue = document.getElementById('bpmValue');
  if (bpmSlider) bpmSlider.value = bpm;
  if (bpmValue) bpmValue.textContent = bpm;
  
  console.log(`ðŸŽµ BPM set to ${bpm}`);
}

function setTimeSignature(timeSig) {
  const [beats, noteValue] = timeSig.split('/').map(n => parseInt(n));
  Tone.Transport.timeSignature = [beats, noteValue];
  console.log(`ðŸŽµ Time signature: ${timeSig}`);
  showToast(`â±ï¸ Time signature: ${timeSig}`, 'info');
}

function applySnap(seconds) {
  if (!multitrack.snapEnabled) return seconds;
  const grid = multitrack.snapInterval * (60 / state.bpm); // convert beatsâ†’seconds
  return Math.round(seconds / grid) * grid;
}

// Session management
function newMultitrackSession() {
  if (!confirm('Create new session? Unsaved changes will be lost.')) return;
  
  // Stop everything
  if (state.isPlaying) stop();
  stopMultitrackPreview();
  
  // Clear all tracks
  multitrack.tracks.forEach(t => t.dispose());
  multitrack.tracks = [];
  multitrack.nextTrackId = 1;
  multitrack.globalRecordStartTime = null;
  
  // Reset state
  state.cursorSeconds = 0;
  multitrack.playheadSeconds = 0;

  multitrackHistory.clear();
  
  renderMultitrack();
  showToast('âœ… New session created', 'success');
}

function saveMultitrackSession() {
  // Reuse the full project save
  saveProject();
}

function loadMultitrackSession() {
  // Reuse the full project load
  loadProject();
}

// Grid and automation toggles
function toggleGrid() {
  const gridBtn = document.getElementById('dawGridBtn');
  if (!gridBtn) return;
  
  const isActive = gridBtn.classList.toggle('active');
  
  // Toggle snap grid visibility
  document.querySelectorAll('.snap-grid').forEach(grid => {
    grid.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? 'âŠž Grid: On' : 'âŠž Grid: Off', 'info');
}

function toggleAutomationView() {
  const autoBtn = document.getElementById('dawAutomationBtn');
  if (!autoBtn) return;
  
  const isActive = autoBtn.classList.toggle('active');
  
  // Toggle automation lanes
  document.querySelectorAll('.automation-lane').forEach(lane => {
    lane.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? 'ðŸ“ˆ Automation: On' : 'ðŸ“ˆ Automation: Off', 'info');
}

// CPU and status monitoring
function updateDAWStatus() {
  const cpuEl = document.getElementById('dawCpuLoad');
  const latencyEl = document.getElementById('dawLatency');
  const trackCountEl = document.getElementById('dawTrackCount');
  const statusEl = document.getElementById('dawStatusMessage');
  
  if (cpuEl) {
    // Approximate CPU usage based on active tracks
    const activeTracks = multitrack.tracks.filter(t => !t.muted).length;
    const cpuPercent = Math.min(100, activeTracks * 3 + Math.random() * 5);
    cpuEl.textContent = cpuPercent.toFixed(0) + '%';
  }
  
  if (latencyEl) {
    const ctx = Tone.context.rawContext;
    const latencyMs = (ctx.baseLatency || 0) * 1000;
    latencyEl.textContent = latencyMs.toFixed(1) + 'ms';
  }
  
  if (trackCountEl) {
    trackCountEl.textContent = multitrack.tracks.length.toString();
  }
  
  if (statusEl && multitrack.isPlaying) {
    const recordingCount = multitrack.tracks.filter(t => t.recording).length;
    if (recordingCount > 0) {
      statusEl.textContent = `Recording ${recordingCount} track(s)...`;
    } else {
      statusEl.textContent = 'Playing';
    }
  } else if (statusEl) {
    statusEl.textContent = 'Ready';
  }
}
  
// Replace openFxChainEditor function (around line 3285)
function openFxChainEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;

  // Remember which track we're editing
  multitrack.currentFxTrackId = trackId;

  const panel = document.getElementById('fxChainPanel');
  if (!panel) return;

  // Use the actual label ID from the HTML: fxChainTrackLabel
  const labelEl = document.getElementById('fxChainTrackLabel');
  if (labelEl) {
    labelEl.textContent = track.name;
  }

  // Render that track's FX chain into the panel
  renderFxChain(track);

  // Open the panel
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
}

function renderFxChain(track) {
  const slots = document.getElementById('fxChainSlots');

  if (!slots) return;
  
  slots.innerHTML = '';
  
  if (track.fxChain.length === 0) {
    slots.innerHTML = `
      <div style="padding: var(--space-8); text-align: center; color: var(--text-tertiary);">
        <div style="font-size: var(--text-xl); margin-bottom: var(--space-2);">ðŸŽ›ï¸</div>
        <div>No effects on this track</div>
        <div style="font-size: var(--text-sm); margin-top: var(--space-2);">Click an effect pill above to add</div>
      </div>
    `;
    return;
  }
  
  track.fxChain.forEach((fx, idx) => {
    const fxSlot = document.createElement('div');
    fxSlot.className = 'fx-unit';
    fxSlot.style.opacity = fx.enabled ? '1' : '0.5';
    
    let paramsHTML = '';
    
    // Define parameter ranges for each FX type
    const paramConfig = {
      reverb: {
        decay: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 's' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      delay: {
        time: { min: 0, max: 3, options: ['16n', '8n', '4n', '2n', '1n'], default: '8n', format: (v) => v },
        feedback: { min: 0, max: 0.9, default: 0.3, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      chorus: {
        frequency: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 'Hz' },
        delayTime: { min: 2, max: 20, default: 3.5, format: (v) => v.toFixed(1) + 'ms' },
        depth: { min: 0, max: 1, default: 0.7, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      distortion: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      saturation: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      filter: {
        type: { options: ['lowpass', 'highpass', 'bandpass'], default: 'lowpass', format: (v) => v },
        frequency: { min: 20, max: 20000, default: 5000, format: (v) => Math.round(v) + 'Hz' },
        q: { min: 0.1, max: 10, default: 1, format: (v) => v.toFixed(1) }
      },
      compressor: {
        threshold: { min: -60, max: 0, default: -24, format: (v) => Math.round(v) + 'dB' },
        ratio: { min: 1, max: 20, default: 4, format: (v) => v.toFixed(1) + ':1' },
        attack: { min: 0.001, max: 1, default: 0.003, format: (v) => (v * 1000).toFixed(1) + 'ms' },
        release: { min: 0.01, max: 1, default: 0.25, format: (v) => (v * 1000).toFixed(0) + 'ms' }
      },
      eq: {
        low: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        mid: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        high: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' }
      },
      bitcrusher: {
        bits: { min: 1, max: 16, default: 4, format: (v) => Math.round(v) + ' bits' }
      }
    };
    
    const typeConfig = paramConfig[fx.type] || {};
    
    Object.entries(fx.params).forEach(([param, value]) => {
      const config = typeConfig[param] || { min: 0, max: 100, default: 50, format: (v) => v };
      
      let sliderVal = 50;
      let displayVal = value;
      
      // Handle special cases
      if (config.options) {
        // Discrete options (like delay time or filter type)
        const optIndex = config.options.indexOf(value);
        sliderVal = optIndex >= 0 ? (optIndex / (config.options.length - 1)) * 100 : 50;
      } else {
        // Continuous values
        sliderVal = ((value - config.min) / (config.max - config.min)) * 100;
        sliderVal = Math.max(0, Math.min(100, sliderVal));
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value" data-fx-id="${fx.id}" data-param="${param}">${config.format(value)}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx-id="${fx.id}" 
                 data-param="${param}"
                 data-fx-type="${fx.type}"
                 class="fx-param-slider">
        </div>
      `;
    });
    
    fxSlot.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${fx.type.toUpperCase()}</div>
        <div style="display: flex; gap: var(--space-2); align-items: center;">
          <div class="fx-toggle ${fx.enabled ? 'active' : ''}" data-fx-id="${fx.id}"></div>
          <button class="btn btn-ghost btn-sm" data-action="remove-fx" data-fx-id="${fx.id}">âœ•</button>
        </div>
      </div>
      ${paramsHTML}
    `;
    
    slots.appendChild(fxSlot);
  });
  
  // Attach listeners AFTER all DOM is ready
  setTimeout(() => {
    // Toggle switches
    slots.querySelectorAll('.fx-toggle').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const fxId = parseFloat(toggle.dataset.fxId);
        track.toggleFx(fxId);
        renderFxChain(track);
      });
    });
    
    // Remove buttons
    slots.querySelectorAll('[data-action="remove-fx"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const fxId = parseFloat(btn.dataset.fxId);
        if (confirm('Remove this effect?')) {
          track.removeFx(fxId);
          renderFxChain(track);
        }
      });
    });
    
    // Parameter sliders with proper mapping
    slots.querySelectorAll('.fx-param-slider').forEach(slider => {
      slider.addEventListener('input', (e) => {
        const fxId = parseFloat(e.target.dataset.fxId);
        const param = e.target.dataset.param;
        const fxType = e.target.dataset.fxType;
        const sliderPercent = parseInt(e.target.value, 10);
        
        const fx = track.fxChain.find(f => f.id === fxId);
        if (!fx) return;
        
        const typeConfig = {
          reverb: {
            decay: { min: 0.1, max: 10 },
            wet: { min: 0, max: 1 }
          },
          delay: {
            time: { options: ['16n', '8n', '4n', '2n', '1n'] },
            feedback: { min: 0, max: 0.9 },
            wet: { min: 0, max: 1 }
          },
          chorus: {
            frequency: { min: 0.1, max: 10 },
            delayTime: { min: 2, max: 20 },
            depth: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          distortion: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          saturation: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          filter: {
            type: { options: ['lowpass', 'highpass', 'bandpass'] },
            frequency: { min: 20, max: 20000 },
            q: { min: 0.1, max: 10 }
          },
          compressor: {
            threshold: { min: -60, max: 0 },
            ratio: { min: 1, max: 20 },
            attack: { min: 0.001, max: 1 },
            release: { min: 0.01, max: 1 }
          },
          eq: {
            low: { min: -24, max: 24 },
            mid: { min: -24, max: 24 },
            high: { min: -24, max: 24 }
          },
          bitcrusher: {
            bits: { min: 1, max: 16 }
          }
        };
        
        const config = typeConfig[fxType]?.[param];
        if (!config) return;
        
        let value;
        
        if (config.options) {
          // Discrete options
          const index = Math.round((sliderPercent / 100) * (config.options.length - 1));
          value = config.options[index];
        } else {
          // Continuous value
          value = config.min + (sliderPercent / 100) * (config.max - config.min);
        }
        
        track.updateFxParam(fxId, param, value);
        
        // Update display
        const label = e.target.closest('.param-control').querySelector('.param-value');
        if (label) {
          if (param === 'decay' || param === 'frequency' || param === 'delayTime') {
            label.textContent = typeof value === 'number' ? value.toFixed(1) : value;
            if (param === 'decay') label.textContent += 's';
            if (param === 'frequency') label.textContent += 'Hz';
            if (param === 'delayTime') label.textContent += 'ms';
          } else if (param === 'wet' || param === 'feedback' || param === 'depth' || param === 'amount') {
            label.textContent = Math.round(value * 100) + '%';
          } else if (param === 'threshold' || param === 'low' || param === 'mid' || param === 'high') {
            label.textContent = (value > 0 ? '+' : '') + Math.round(value) + 'dB';
          } else if (param === 'ratio') {
            label.textContent = value.toFixed(1) + ':1';
          } else if (param === 'attack' || param === 'release') {
            label.textContent = (value * 1000).toFixed(param === 'attack' ? 1 : 0) + 'ms';
          } else if (param === 'bits') {
            label.textContent = Math.round(value) + ' bits';
          } else if (param === 'q') {
            label.textContent = value.toFixed(1);
          } else {
            label.textContent = value.toString();
          }
        }
      });
    });
  }, 0);
}

// Open take editor for a track
function openTakeEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.takes.length === 0) {
    showToast('âŒ No takes to edit', 'error');
    return;
  }
  
  // Create modal
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '700px';
  
  let takesHTML = '';
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    takesHTML += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${take.muted ? 'muted' : ''}" 
           style="margin-bottom: var(--space-3); padding: var(--space-4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="flex: 1;">
            <div style="font-weight: 800; font-size: var(--text-base); margin-bottom: var(--space-2);">
              Take ${idx + 1} ${isSelected ? '(Active)' : ''}
            </div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              ${take.duration.toFixed(2)}s â€¢ ${new Date(take.timestamp).toLocaleString()}
            </div>
          </div>
          <div style="display: flex; gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" data-action="play-take" data-index="${idx}">
              â–¶ï¸ Play
            </button>
            <button class="btn btn-secondary btn-sm" data-action="select-take" data-index="${idx}">
              ${isSelected ? 'âœ“ Active' : 'Set Active'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="toggle-mute-take" data-index="${idx}">
              ${take.muted ? 'ðŸ”‡ Unmute' : 'ðŸ”Š Mute'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="export-take" data-index="${idx}">
              ðŸ’¾
            </button>
            <button class="btn btn-ghost btn-sm" data-action="delete-take" data-index="${idx}">
              ðŸ—‘ï¸
            </button>
          </div>
        </div>
      </div>
    `;
  });
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Edit Takes: ${track.name}</div>
      <button class="modal-close">âœ•</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          <strong>${track.takes.length}</strong> take${track.takes.length !== 1 ? 's' : ''} recorded
        </div>
      </div>
      ${takesHTML}
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary close-btn">Close</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const close = () => {
    backdrop.remove();
    renderMultitrack();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.close-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  // Handle take actions
  modal.querySelectorAll('[data-action]').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      const index = parseInt(btn.dataset.index);
      
      if (action === 'play-take') {
        track.playTake(index);
      } else if (action === 'select-take') {
        track.selectTake(index);
        close();
      } else if (action === 'toggle-mute-take') {
        track.toggleTakeMute(index);
        close();
      } else if (action === 'export-take') {
        track.exportTake(index);
      } else if (action === 'delete-take') {
        if (confirm('Delete this take?')) {
          track.deleteTake(index);
          if (track.takes.length === 0) {
            close();
          } else {
            close();
          }
        }
      }
    });
  });
}

function openWaveformEditor(trackId, takeIndex) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) {
    console.error('Take or buffer not found');
    showToast('âŒ Cannot edit: invalid take', 'error');
    return;
  }
  
  // Remove any existing modal
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '900px';
  modal.style.maxHeight = '90vh';
  
  const buffer = take.buffer;
  const duration = buffer.duration;
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Waveform Editor: ${track.name} - Take ${takeIndex + 1}</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body" style="overflow: visible;">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="waveformCanvas" 
                width="800" 
                height="200" 
                style="width: 100%; height: 200px; background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="grid grid-2" style="margin-bottom: var(--space-4);">
        <div class="param-control">
          <div class="param-label">
            <span>Trim Start</span>
            <span class="param-value" id="trimStartValue">0.00s</span>
          </div>
          <input type="range" id="trimStartSlider" min="0" max="100" value="0" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Trim End</span>
            <span class="param-value" id="trimEndValue">${duration.toFixed(2)}s</span>
          </div>
          <input type="range" id="trimEndSlider" min="0" max="100" value="100" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade In</span>
            <span class="param-value" id="fadeInValue">0ms</span>
          </div>
          <input type="range" id="fadeInSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade Out</span>
            <span class="param-value" id="fadeOutValue">0ms</span>
          </div>
          <input type="range" id="fadeOutSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Gain</span>
            <span class="param-value" id="gainValue">0dB</span>
          </div>
          <input type="range" id="gainSlider" min="-24" max="24" value="0" step="0.5">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Reverse</span>
            <span class="param-value"></span>
          </div>
          <label style="display: flex; align-items: center; gap: var(--space-2);">
            <input type="checkbox" id="reverseCheckbox">
            <span style="font-size: var(--text-sm);">Reverse audio</span>
          </label>
        </div>
      </div>
      
      <div style="display: flex; gap: var(--space-3); margin-bottom: var(--space-4); flex-wrap: wrap;">
        <button class="btn btn-secondary" id="previewEditBtn">â–¶ï¸ Preview</button>
        <button class="btn btn-secondary" id="normalizeBtn">ðŸ“Š Normalize</button>
        <button class="btn btn-ghost" id="resetEditsBtn">â†» Reset</button>
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); font-size: var(--text-sm); color: var(--text-tertiary);">
        <strong>Original:</strong> ${duration.toFixed(2)}s â€¢ 
        <strong>After edits:</strong> <span id="editedDurationLabel">${duration.toFixed(2)}s</span>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-edit-btn">Cancel</button>
      <button class="btn btn-success apply-edit-btn">âœ… Apply Changes</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');
  
  // Editor state
  const editorState = {
    trimStart: 0,
    trimEnd: duration,
    fadeIn: 0,
    fadeOut: 0,
    gain: 0,
    reverse: false
  };
  
  // Draw waveform function
  function drawWaveform() {
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const channelData = buffer.getChannelData(0);
    const step = Math.ceil(channelData.length / width);
    const amp = height / 2;
    
    // Draw waveform
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    ctx.strokeStyle = 'rgb(124, 131, 255)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;
      
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < channelData.length) {
          const datum = channelData[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const x = i;
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      
      ctx.fillRect(x, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw trim markers
    const startX = (editorState.trimStart / duration) * width;
    const endX = (editorState.trimEnd / duration) * width;
    
    // Grayed out regions
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    if (startX > 0) ctx.fillRect(0, 0, startX, height);
    if (endX < width) ctx.fillRect(endX, 0, width - endX, height);
    
    // Trim lines
    ctx.strokeStyle = 'var(--warning)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, 0);
    ctx.lineTo(startX, height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(endX, 0);
    ctx.lineTo(endX, height);
    ctx.stroke();
    
    // Fade curves
    if (editorState.fadeIn > 0) {
      const fadeInDuration = editorState.fadeIn / 1000;
      const fadeInX = startX + (fadeInDuration / duration) * width;
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX, height);
      ctx.lineTo(Math.min(fadeInX, endX), 0);
      ctx.stroke();
    }
    
    if (editorState.fadeOut > 0) {
      const fadeOutDuration = editorState.fadeOut / 1000;
      const fadeOutX = endX - (fadeOutDuration / duration) * width;
      ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(Math.max(fadeOutX, startX), 0);
      ctx.lineTo(endX, height);
      ctx.stroke();
    }
  }
  
  // Initial draw
  setTimeout(() => drawWaveform(), 0);
  
  // Get controls
  const trimStartSlider = document.getElementById('trimStartSlider');
  const trimEndSlider = document.getElementById('trimEndSlider');
  const fadeInSlider = document.getElementById('fadeInSlider');
  const fadeOutSlider = document.getElementById('fadeOutSlider');
  const gainSlider = document.getElementById('gainSlider');
  const reverseCheckbox = document.getElementById('reverseCheckbox');
  
  function updateEditedDuration() {
    const newDuration = Math.max(0, editorState.trimEnd - editorState.trimStart);
    document.getElementById('editedDurationLabel').textContent = newDuration.toFixed(2) + 's';
  }
  
  // Trim start
  trimStartSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimStart = percent * duration;
    editorState.trimStart = Math.min(editorState.trimStart, editorState.trimEnd - 0.01);
    document.getElementById('trimStartValue').textContent = editorState.trimStart.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Trim end
  trimEndSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimEnd = percent * duration;
    editorState.trimEnd = Math.max(editorState.trimEnd, editorState.trimStart + 0.01);
    document.getElementById('trimEndValue').textContent = editorState.trimEnd.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Fade in
  fadeInSlider.addEventListener('input', (e) => {
    editorState.fadeIn = parseInt(e.target.value);
    document.getElementById('fadeInValue').textContent = editorState.fadeIn + 'ms';
    drawWaveform();
  });
  
  // Fade out
  fadeOutSlider.addEventListener('input', (e) => {
    editorState.fadeOut = parseInt(e.target.value);
    document.getElementById('fadeOutValue').textContent = editorState.fadeOut + 'ms';
    drawWaveform();
  });
  
  // Gain
  gainSlider.addEventListener('input', (e) => {
    editorState.gain = parseFloat(e.target.value);
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
  });
  
  // Reverse
  reverseCheckbox.addEventListener('change', (e) => {
    editorState.reverse = e.target.checked;
  });
  
  // Preview button
  let previewPlayer = null;
  document.getElementById('previewEditBtn').addEventListener('click', async () => {
    try {
      if (previewPlayer) {
        previewPlayer.stop();
        previewPlayer.dispose();
      }
      
      showToast('â³ Rendering preview...', 'info');
      const editedBuffer = await applyEdits(buffer, editorState);
      
      previewPlayer = new Tone.Player(editedBuffer).toDestination();
      await Tone.start();
      previewPlayer.start();
      
      showToast('â–¶ï¸ Previewing edits', 'info');
      
      setTimeout(() => {
        if (previewPlayer) {
          previewPlayer.stop();
          previewPlayer.dispose();
          previewPlayer = null;
        }
      }, editedBuffer.duration * 1000 + 100);
      
    } catch (err) {
      console.error('Preview failed:', err);
      showToast(`âŒ Preview failed: ${err.message}`, 'error');
    }
  });
  
  // Normalize button
  document.getElementById('normalizeBtn').addEventListener('click', () => {
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('âš ï¸ Audio is silent, cannot normalize', 'warning');
      return;
    }
    
    const targetPeak = 0.891; // -1dB
    const gainDb = 20 * Math.log10(targetPeak / peak);
    
    gainSlider.value = gainDb.toFixed(1);
    editorState.gain = parseFloat(gainDb.toFixed(1));
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
    
    showToast(`âœ… Normalized: ${gainDb.toFixed(1)}dB gain`, 'success');
  });
  
  // Reset button
  document.getElementById('resetEditsBtn').addEventListener('click', () => {
    editorState.trimStart = 0;
    editorState.trimEnd = duration;
    editorState.fadeIn = 0;
    editorState.fadeOut = 0;
    editorState.gain = 0;
    editorState.reverse = false;
    
    trimStartSlider.value = 0;
    trimEndSlider.value = 100;
    fadeInSlider.value = 0;
    fadeOutSlider.value = 0;
    gainSlider.value = 0;
    reverseCheckbox.checked = false;
    
    document.getElementById('trimStartValue').textContent = '0.00s';
    document.getElementById('trimEndValue').textContent = duration.toFixed(2) + 's';
    document.getElementById('fadeInValue').textContent = '0ms';
    document.getElementById('fadeOutValue').textContent = '0ms';
    document.getElementById('gainValue').textContent = '0dB';
    
    updateEditedDuration();
    drawWaveform();
    
    showToast('â†» Edits reset', 'info');
  });
  
  // Apply button
  document.querySelector('.apply-edit-btn').addEventListener('click', async () => {
    try {
      showToast('â³ Processing audio...', 'info');
      
      const editedBuffer = await applyEdits(buffer, editorState);
      
      // Create new blob
      const offlineCtx = new OfflineAudioContext(
        editedBuffer.numberOfChannels,
        editedBuffer.length,
        editedBuffer.sampleRate
      );
      
      const source = offlineCtx.createBufferSource();
      source.buffer = editedBuffer;
      source.connect(offlineCtx.destination);
      source.start(0);
      
      const renderedBuffer = await offlineCtx.startRendering();
      const wavData = bufferToWavImproved(renderedBuffer);
      const newBlob = new Blob([wavData], { type: 'audio/wav' });
      
      // Update take
      take.buffer = editedBuffer;
      take.duration = editedBuffer.duration;
      take.blob = newBlob;
      
      backdrop.remove();
      renderMultitrack();
      showToast('âœ… Waveform edited successfully!', 'success');
      
      console.log(`âœ… Edited take ${takeIndex}: ${take.duration.toFixed(2)}s`);
      
    } catch (err) {
      console.error('Edit failed:', err);
      showToast(`âŒ Edit failed: ${err.message}`, 'error');
    }
  });
  
  // Close handlers
  const close = () => {
    if (previewPlayer) {
      previewPlayer.stop();
      previewPlayer.dispose();
    }
    backdrop.remove();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-edit-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

async function applyEdits(buffer, edits) {
  const { trimStart, trimEnd, fadeIn, fadeOut, gain, reverse } = edits;
  
  const sampleRate = buffer.sampleRate;
  const numChannels = buffer.numberOfChannels;
  
  const startSample = Math.floor(trimStart * sampleRate);
  const endSample = Math.floor(trimEnd * sampleRate);
  const newLength = endSample - startSample;
  
  const newBuffer = Tone.context.rawContext.createBuffer(
    numChannels,
    newLength,
    sampleRate
  );
  
  const gainLinear = Tone.dbToGain(gain);
  const fadeInSamples = Math.floor((fadeIn / 1000) * sampleRate);
  const fadeOutSamples = Math.floor((fadeOut / 1000) * sampleRate);
  
  for (let c = 0; c < numChannels; c++) {
    const oldData = buffer.getChannelData(c);
    const newData = newBuffer.getChannelData(c);
    
    for (let i = 0; i < newLength; i++) {
      const oldIndex = reverse ? (endSample - 1 - i) : (startSample + i);
      let sample = oldData[oldIndex] || 0;
      
      // Apply gain
      sample *= gainLinear;
      
      // Apply fade in
      if (i < fadeInSamples) {
        sample *= (i / fadeInSamples);
      }
      
      // Apply fade out
      if (i > newLength - fadeOutSamples) {
        sample *= ((newLength - i) / fadeOutSamples);
      }
      
      newData[i] = sample;
    }
  }
  
  return newBuffer;
}

function setupArrangementDragScroll() {
  const scroll = document.getElementById('dawArrangementScroll');
  if (!scroll || scroll.dataset._dragScrollWired) return;
  scroll.dataset._dragScrollWired = 'true';

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let startScrollLeft = 0;
  let startScrollTop = 0;

  const onMouseDown = (e) => {
    // Only left button
    if (e.button !== 0) return;

    // Don't steal drags from regions / resize handles
    if (e.target.closest('.audio-region') || e.target.closest('.region-resize-handle')) {
      return;
    }

    isDragging = true;
    scroll.classList.add('drag-scroll-active');
    startX = e.clientX;
    startY = e.clientY;
    startScrollLeft = scroll.scrollLeft;
    startScrollTop = scroll.scrollTop;
  };

  const onMouseMove = (e) => {
    if (!isDragging) return;
    e.preventDefault(); // so you don't select text
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    scroll.scrollLeft = startScrollLeft - dx;
    scroll.scrollTop = startScrollTop - dy;
  };

  const endDrag = () => {
    if (!isDragging) return;
    isDragging = false;
    scroll.classList.remove('drag-scroll-active');
  };

  scroll.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', endDrag);
}

// === Sync the timeline ruler with horizontal scroll ===
function syncTimelineRulerToScroll() {
  const arrangementScrollEl = document.getElementById('dawArrangementScroll');
  const ruler = document.getElementById('dawRuler');
  if (!arrangementScrollEl || !ruler) return;

  const offset = arrangementScrollEl.scrollLeft || 0;
  // Slide the ruler to match the arrangementâ€™s horizontal scroll
  ruler.style.transform = `translateX(${-offset}px)`;
}

  
async function setupMultitrackListeners() {
  // Drag-scroll in the arrangement view
  setupArrangementDragScroll();

  // NEW: keep timeline ruler in sync with any horizontal scroll
  const arrangementScrollEl = document.getElementById('dawArrangementScroll');
  if (arrangementScrollEl && !arrangementScrollEl.dataset._rulerSyncWired) {
    arrangementScrollEl.dataset._rulerSyncWired = 'true';
    syncTimelineRulerToScroll();
    arrangementScrollEl.addEventListener('scroll', () => {
      syncTimelineRulerToScroll();
    });
  }

  // === ADD TRACK BUTTON (DESKTOP) ===
  const addTrackBtn = document.getElementById('addTrackBtn');
  if (addTrackBtn && !addTrackBtn.dataset._wired) {
    addTrackBtn.dataset._wired = 'true';
    addTrackBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('ðŸŽšï¸ Add track clicked');
      showAddTrackDialog();
    });
  }

  // === ADD TRACK BUTTON (LEFT PANEL - MOBILE/DESKTOP) ===
  const addTrackBtnLeft = document.getElementById('addTrackBtnLeft');
  if (addTrackBtnLeft && !addTrackBtnLeft.dataset._wired) {
    addTrackBtnLeft.dataset._wired = 'true';
    addTrackBtnLeft.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('ðŸŽšï¸ Add track (left) clicked');
      showAddTrackDialog();
    });
  }

  // === IMPORT STEM BUTTON ===
  // Uses the helper you added earlier; it has its own _wired guard.
  if (typeof setupStemImport === 'function') {
    setupStemImport();
  }

  // === UNDO / REDO ===
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  if (undoBtn && !undoBtn.dataset._wired) {
    undoBtn.dataset._wired = 'true';
    undoBtn.addEventListener('click', () => multitrackHistory.undo());
  }

  if (redoBtn && !redoBtn.dataset._wired) {
    redoBtn.dataset._wired = 'true';
    redoBtn.addEventListener('click', () => multitrackHistory.redo());
  }

  // === LEGACY PREVIEW BUTTON (if still present) ===
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn && !previewBtn.dataset._wired) {
    previewBtn.dataset._wired = 'true';
    previewBtn.onclick = async () => {
      if (previewBtn.textContent.includes('Stop')) {
        stopMultitrackPreview();
        previewBtn.textContent = 'â–¶ï¸ Preview Mix';
      } else {
        await previewMultitrack(multitrack.playheadSeconds || 0);
        previewBtn.textContent = 'â¹ï¸ Stop Preview';
      }
    };
  }

  // === RECORD-ARM ALL ===
  const recordArmedBtn = document.getElementById('recordArmedBtn');
  if (recordArmedBtn && !recordArmedBtn.dataset._wired) {
    recordArmedBtn.dataset._wired = 'true';
    recordArmedBtn.onclick = async () => await toggleRecordAllArmed();
  }

  // === DAW TRANSPORT CONTROLS ===
  const playBtn    = document.getElementById('dawPlayBtn');
  const stopBtn    = document.getElementById('dawStopBtn');
  const rewindBtn  = document.getElementById('dawRewindBtn');
  const forwardBtn = document.getElementById('dawForwardBtn');
  const recordBtn  = document.getElementById('dawRecordBtn');

  if (playBtn && !playBtn.dataset._wired) {
    playBtn.dataset._wired = 'true';
    playBtn.onclick = async () => {
      if (playBtn.textContent.trim() === 'â–¶ï¸') {
        // â–¶ï¸ PLAY â†’ start / resume from current playhead
        playBtn.textContent = 'â¸ï¸';
        await previewMultitrack(multitrack.playheadSeconds || 0);
      } else {
        // â¸ï¸ PAUSE â†’ stop audio but keep position for resume
        playBtn.textContent = 'â–¶ï¸';
  
        // Use Tone.now() since we're not using Tone.Transport
        const elapsed = Tone.now() - (multitrack.lastStartTime || 0);
  
        // Update playhead to the new paused position
        multitrack.playheadSeconds = (multitrack.playheadSeconds || 0) + elapsed;
        multitrack.isPaused = true;
  
        // Stop playback but do NOT reset to start
        stopMultitrackPreview(false);
  
        // Store for resume consistency
        multitrack.lastPauseTime = multitrack.playheadSeconds;
      }
    };
  }

  if (stopBtn && !stopBtn.dataset._wired) {
    stopBtn.dataset._wired = 'true';
    stopBtn.onclick = () => {
      // STOP â†’ full reset to 0
      if (playBtn) playBtn.textContent = 'â–¶ï¸';
      stopMultitrackPreview(true); // resetToZero = true
      updatePlayheadAndScroll(0);  // visually + timecode reset
    };
  }

  if (rewindBtn && !rewindBtn.dataset._wired) {
    rewindBtn.dataset._wired = 'true';
    rewindBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target  = Math.max(0, current - 5);
      updatePlayheadAndScroll(target);
    };
  }

  if (forwardBtn && !forwardBtn.dataset._wired) {
    forwardBtn.dataset._wired = 'true';
    forwardBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target  = Math.min(projDur, current + 5);
      updatePlayheadAndScroll(target);
    };
  }

  if (recordBtn && !recordBtn.dataset._wired) {
    recordBtn.dataset._wired = 'true';
    recordBtn.onclick = () => {
      recordBtn.classList.toggle('active');
      if (recordBtn.classList.contains('active')) {
        startGlobalRecording();
      } else {
        stopGlobalRecording();
      }
    };
  }

  // === LOOP / CLICK / COUNT-IN ===
  const loopBtn    = document.getElementById('dawLoopBtn');
  const clickBtn   = document.getElementById('dawClickBtn');
  const countInBtn = document.getElementById('dawCountInBtn');

  if (typeof multitrack.loopEnabled === 'undefined') {
    multitrack.loopEnabled = false;
  }

  if (loopBtn && !loopBtn.dataset._wired) {
    loopBtn.dataset._wired = 'true';
    loopBtn.classList.toggle('active', !!multitrack.loopEnabled);
    loopBtn.onclick = () => {
      multitrack.loopEnabled = !multitrack.loopEnabled;
      loopBtn.classList.toggle('active', multitrack.loopEnabled);
      showToast(
        multitrack.loopEnabled
          ? 'ðŸ” Loop Enabled (multitrack preview)'
          : 'â¹ï¸ Loop Disabled',
        'info'
      );
    };
  }

  if (clickBtn && !clickBtn.dataset._wired) {
    clickBtn.dataset._wired = 'true';
    clickBtn.onclick = () => {
      state.metronomeEnabled = !state.metronomeEnabled;
      clickBtn.classList.toggle('active', state.metronomeEnabled);
      showToast(
        state.metronomeEnabled ? 'ðŸ¥ Click: On' : 'ðŸ¥ Click: Off',
        'info'
      );
    };
  }

  if (countInBtn && !countInBtn.dataset._wired) {
    countInBtn.dataset._wired = 'true';

    const labels = [
      'â±ï¸ Count: Off',
      'â±ï¸ Count: 1 bar',
      'â±ï¸ Count: 2 bars'
    ];

    const updateCountLabel = () => {
      const idx = Math.max(0, Math.min(2, state.countInBars || 0));
      countInBtn.textContent = labels[idx];
      countInBtn.classList.toggle('active', state.countInBars > 0);
      showToast(
        state.countInBars === 0
          ? 'â±ï¸ Count-in OFF'
          : `â±ï¸ Count-in: ${state.countInBars} bar(s)`,
        'info'
      );
    };

    countInBtn.onclick = () => {
      // 0 â†’ 1 â†’ 2 â†’ 0
      if (!state.countInBars) state.countInBars = 0;
      state.countInBars = state.countInBars === 0 ? 1 :
                          state.countInBars === 1 ? 2 : 0;
      updateCountLabel();
    };

    updateCountLabel();
  }

  // === LOOP REGION SELECTION (drag in empty timeline) ===
  const scrollEl      = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');

  if (scrollEl && loopHighlight && !scrollEl.dataset._loopWired) {
    scrollEl.dataset._loopWired = 'true';

    let dragStartX = null;

    scrollEl.addEventListener('scroll', () => {
      updateLoopRegionHighlight && updateLoopRegionHighlight();
    });

    scrollEl.addEventListener('mousedown', (e) => {
      // Only left-click + Select tool
      if (e.button !== 0) return;
      if (multitrack.currentTool !== 'select') return;

      // Ignore dragging on a region/clip
      if (e.target.closest('.audio-region') || e.target.closest('.daw-clip')) return;

      const rect = scrollEl.getBoundingClientRect();
      dragStartX = e.clientX - rect.left + scrollEl.scrollLeft;

      loopHighlight.style.display = 'block';
      loopHighlight.style.left = dragStartX + 'px';
      loopHighlight.style.width = '0px';
    });

    scrollEl.addEventListener('mousemove', (e) => {
      if (dragStartX === null) return;

      const rect = scrollEl.getBoundingClientRect();
      const currentX = e.clientX - rect.left + scrollEl.scrollLeft;
      const width    = currentX - dragStartX;

      loopHighlight.style.width = Math.abs(width) + 'px';
      loopHighlight.style.left  = (width < 0 ? currentX : dragStartX) + 'px';
    });

    const finishLoopDrag = (e) => {
      if (dragStartX === null) return;

      const rect     = scrollEl.getBoundingClientRect();
      const dragEndX = e.clientX - rect.left + scrollEl.scrollLeft;
      const zoom     = multitrack.zoom || 100;

      const startPx   = Math.min(dragStartX, dragEndX);
      const endPx     = Math.max(dragStartX, dragEndX);
      const startSec  = startPx / zoom;
      const endSec    = endPx / zoom;
      const dragLen   = endSec - startSec;

      loopHighlight.style.display = 'none';
      dragStartX = null;

      if (dragLen > 0.25) {
        setLoopRegion(startSec, endSec);
      } else {
        clearLoopRegion();
      }
    };

    scrollEl.addEventListener('mouseup', finishLoopDrag);
    scrollEl.addEventListener('mouseleave', (e) => {
      if (dragStartX !== null) finishLoopDrag(e);
    });
  }

  // === BPM + TIME SIG ===
  const bpmInput      = document.getElementById('dawBpmInput');
  const timeSigSelect = document.getElementById('dawTimeSigSelect');

  if (bpmInput && !bpmInput.dataset._wired) {
    bpmInput.dataset._wired = 'true';
    bpmInput.onchange = (e) => setBPM(parseFloat(e.target.value));
  }

  if (timeSigSelect && !timeSigSelect.dataset._wired) {
    timeSigSelect.dataset._wired = 'true';
    timeSigSelect.onchange = (e) => setTimeSignature(e.target.value);
  }

  // === ZOOM CONTROLS ===
  const zoomInBtn   = document.getElementById('dawZoomInBtn')  || document.getElementById('zoomInBtn');
  const zoomOutBtn  = document.getElementById('dawZoomOutBtn') || document.getElementById('zoomOutBtn');
  const zoomFitBtn  = document.getElementById('dawZoomFitBtn') || document.getElementById('zoomFitBtn');
  const zoomLabelEl = document.getElementById('dawZoomLevel');

  const updateZoomLabel = () => {
    if (zoomLabelEl) {
      // Rough % based on 100px/s baseline
      const pct = Math.round((multitrack.zoom || 100) / 100 * 100);
      zoomLabelEl.textContent = pct + '%';
    }
  };

  const applyZoom = (factor) => {
    multitrack.zoom = Math.max(20, Math.min(500, (multitrack.zoom || 100) * factor));
    renderMultitrack();
    updateZoomLabel();
    showToast(`ðŸ” Zoom: ${Math.round(multitrack.zoom)}px/s`, 'info');
  };

  if (zoomInBtn && !zoomInBtn.dataset._wired) {
    zoomInBtn.dataset._wired = 'true';
    zoomInBtn.onclick = () => applyZoom(1.5);
  }

  if (zoomOutBtn && !zoomOutBtn.dataset._wired) {
    zoomOutBtn.dataset._wired = 'true';
    zoomOutBtn.onclick = () => applyZoom(1 / 1.5);
  }

  if (zoomFitBtn && !zoomFitBtn.dataset._wired) {
    zoomFitBtn.dataset._wired = 'true';
    zoomFitBtn.onclick = () => {
      let maxDuration = 0;
      multitrack.tracks.forEach(t => {
        t.takes.forEach(take => {
          const end = (take.startTime || 0) + take.duration;
          if (end > maxDuration) maxDuration = end;
        });
      });
      if (maxDuration > 0) {
        const canvasWidth = 800; // simple baseline
        multitrack.zoom = canvasWidth / maxDuration;
        renderMultitrack();
        updateZoomLabel();
        showToast('âœ… Zoom to fit', 'success');
      }
    };
  }

  updateZoomLabel();

  // === TOOL BUTTONS (Select / Pencil / Split / Fade) ===
  const toolButtons = document.querySelectorAll('.tool-btn');
  if (toolButtons.length) {
    toolButtons.forEach(btn => {
      if (btn.dataset._wired) return;
      btn.dataset._wired = 'true';

      btn.addEventListener('click', () => {
        const tool = btn.dataset.tool || 'select';
        multitrack.currentTool = tool;

        toolButtons.forEach(b =>
          b.classList.toggle('active', b === btn)
        );

        showToast(`âœï¸ Tool: ${tool}`, 'info');
      });
    });
  }

  // === SNAP ===
  const snapSelect = document.getElementById('dawSnapSelect');
  if (snapSelect && !snapSelect.dataset._wired) {
    snapSelect.dataset._wired = 'true';

    const snapMapping = {
      bar: 4,      // 4 beats per bar (4/4)
      beat: 1,     // quarter-note
      '1/8': 0.5,  // eighth-note
      '1/16': 0.25,
      '1/32': 0.125
    };

    snapSelect.addEventListener('change', (e) => {
      const value = e.target.value;

      if (value === 'off') {
        multitrack.snapEnabled = false;
        showToast('ðŸ§² Snap OFF', 'info');
      } else {
        multitrack.snapEnabled = true;
        multitrack.snapMode    = value;
        multitrack.snapInterval = snapMapping[value] ?? 1;
        showToast(`ðŸ§² Snap: ${value}`, 'info');
      }
    });

    // Default: bar snap
    if (!snapSelect.value || snapSelect.value === 'off') {
      snapSelect.value = 'bar';
    }
    // Initialize immediately
    snapSelect.dispatchEvent(new Event('change'));
  }

  // === SESSION MANAGEMENT ===
  const newBtn  = document.getElementById('newSessionBtn');
  const saveBtn = document.getElementById('saveSessionBtn');
  const loadBtn = document.getElementById('loadSessionBtn');

  if (newBtn && !newBtn.dataset._wired) {
    newBtn.dataset._wired = 'true';
    newBtn.onclick = () => newMultitrackSession();
  }

  if (saveBtn && !saveBtn.dataset._wired) {
    saveBtn.dataset._wired = 'true';
    saveBtn.onclick = () => saveMultitrackSession();
  }

  if (loadBtn && !loadBtn.dataset._wired) {
    loadBtn.dataset._wired = 'true';
    loadBtn.onclick = () => loadMultitrackSession();
  }

  // === GRID / AUTOMATION ===
  const gridBtn = document.getElementById('dawGridBtn');
  const autoBtn = document.getElementById('dawAutomationBtn');

  if (gridBtn && !gridBtn.dataset._wired) {
    gridBtn.dataset._wired = 'true';
    gridBtn.onclick = () => toggleGrid();
  }

  if (autoBtn && !autoBtn.dataset._wired) {
    autoBtn.dataset._wired = 'true';
    autoBtn.onclick = () => toggleAutomationView();
  }

  // === BOUNCE / CLEAR ===
  const bounceBtn = document.getElementById('bounceAllBtn');
  if (bounceBtn && !bounceBtn.dataset._wired) {
    bounceBtn.dataset._wired = 'true';
    bounceBtn.onclick = () => bounceAllTracks();
  }

  const clearBtn = document.getElementById('clearAllTracksBtn');
  if (clearBtn && !clearBtn.dataset._wired) {
    clearBtn.dataset._wired = 'true';
    clearBtn.onclick = () => {
      if (confirm('Delete all tracks? This cannot be undone.')) {
        multitrack.tracks.forEach(t => t.dispose());
        multitrack.tracks = [];
        multitrack.nextTrackId = 1;
        renderMultitrack();
      }
    };
  }

  // === FX CHAIN EDITOR (inline version) ===
  const fxPanel    = document.getElementById('fxChainPanel');
  const fxAddList  = document.getElementById('fxAddList');
  const closeFxBtn = document.getElementById('closeFxPanelBtn');
  if (fxAddList && !fxAddList.dataset._wired) {
    fxAddList.dataset._wired = 'true';
    fxAddList.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-fx]');
      if (!btn) return;
      const fxType = btn.dataset.fx;
      const trackId = multitrack.currentFxTrackId;
      const track = multitrack.tracks.find(t => t.id === trackId);
      if (!track) {
        showToast('âš ï¸ Click a track\'s FX button first', 'warning');
        return;
      }
      try {
        track.addFx(fxType);
        renderFxChain(track);
        showToast(`âœ¨ Added ${fxType} to ${track.name}`, 'success');  // â† FIXED THIS LINE
      } catch (err) {
        console.error('Error adding FX:', err);
        showToast('âŒ Could not add effect', 'error');
      }
    });
  }
  if (closeFxBtn && !closeFxBtn.dataset._wired) {
    closeFxBtn.dataset._wired = 'true';
    closeFxBtn.onclick = () => {
      if (fxPanel) {
        fxPanel.classList.remove('open');
        fxPanel.setAttribute('aria-hidden', 'true');
      }
    };
  }

  initFAB();
}
  
function addTrackFX(trackIndex, fxType) {
  const trackStrip = document.querySelectorAll('.track-strip')[trackIndex];
  let fxPanel = trackStrip.querySelector('.track-fx-panel');
  
  if (!fxPanel) {
    fxPanel = document.createElement('div');
    fxPanel.className = 'track-fx-panel';
    fxPanel.innerHTML = `
      <div class="fx-chain-mini">
        <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
        <div class="fx-slots-inline"></div>
      </div>
    `;
    trackStrip.appendChild(fxPanel);
  }
  
  fxPanel.style.display = 'block';
  
  const fxSlots = fxPanel.querySelector('.fx-slots-inline');
  const fxUnit = document.createElement('div');
  fxUnit.className = 'fx-unit-mini';
  fxUnit.innerHTML = `
    <span>${fxType}</span>
    <div class="fx-toggle" onclick="this.classList.toggle('active')"></div>
    <button class="fx-remove-btn" onclick="this.parentElement.remove()">Ã—</button>
  `;
  
  fxSlots.appendChild(fxUnit);
}
  
// Utility
function updatePlayheadUI(seconds) {
  const el = document.getElementById('dawPlayhead');
  if (!el) return;
  const dur = multitrack.projectDuration || (state.duration * 60);
  el.style.left = `${(seconds / dur) * 100}%`;
}
  
// -------------------- Preset System --------------------
function renderPresets() {
  const grid = document.getElementById('sidebarPresets');
  const fragment = document.createDocumentFragment();
  
  Object.keys(genrePresets).forEach(genre => {
    const preset = genrePresets[genre];
    const div = document.createElement('div');
    div.className = 'sidebar-preset';
    div.innerHTML = `
      <div class="sidebar-preset-icon">${preset.icon}</div>
      <div class="sidebar-preset-name">${preset.name}</div>
    `;
    div.addEventListener('click', () => {
      loadPreset(genre);
      closeSidebar();
    });
    fragment.appendChild(div);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

function loadPreset(genre) {
  state.currentGenre = genre;
  document.querySelectorAll('.genre-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.genre === genre);
  });
  generateBeat();
}

function updateGenrePresets() {
  songBuilderState.isActive = false;
  renderPresets();
}

// -------------------- Transport Controls --------------------

// keep this near top of file so it's globally available
let harmonyCycle = null;

function startHarmonyCycle() {
  if (harmonyCycle) return; // already running
  let barIndex = 0;

  harmonyCycle = Tone.Transport.scheduleRepeat((time) => {
    if (state.progression && state.progression.length > 0) {
      state.currentChord = state.progression[barIndex % state.progression.length];
      barIndex++;
    }
  }, `${state.timeSignature || 4}m`); // one chord per bar
}

function stopHarmonyCycle() {
  if (harmonyCycle) {
    Tone.Transport.clear(harmonyCycle);
    harmonyCycle = null;
  }
}

async function togglePlay() {
  try {
    await Tone.start();
    const raw = Tone.getContext().rawContext;
    if (raw.state !== 'running') await raw.resume();
  } catch (e) {
    console.error('Could not start audio:', e);
    alert('Could not start audio. Click anywhere on the page, then press Play again.');
    return;
  }

  if (state.isPlaying) {
    // ðŸŸ¡ Pause
    Tone.Transport.pause();
    state.pausedAt = Tone.Transport.seconds;
    state.isPlaying = false;
    document.getElementById('playBtn').innerHTML = 'â–¶ï¸ Play';
    stopTimer();
    stopVisualizer();
    stopPlayheadAnimation();
    stopHarmonyCycle();              // â¹ï¸ stop chord cycling
    return;
  }

  // ðŸŸ¢ Check for active steps
  const hasActive = Object.keys(patterns).some(inst =>
    patterns[inst].some(s => s.active)
  );
  if (!hasActive) {
    alert('No active notes â€” click "Generate Beat" or add steps.');
    return;
  }

  // ðŸŸ¢ Resume playback
  const resumeTime = state.pausedAt || 0;
  Tone.Transport.seconds = resumeTime;
  Tone.Transport.start();

  startHarmonyCycle();               // ðŸŽ¼ begin chord progression cycling

  state.isPlaying = true;
  state.startTime = performance.now() - (resumeTime * 1000);
  document.getElementById('playBtn').innerHTML = 'â¸ï¸ Pause';
  startTimer();
  startPlayheadAnimation();
  document.getElementById('vizOverlay').style.display = 'none';
  updateVisualizer();
}

function stop() {
  // ðŸ”´ Full stop
  Tone.Transport.stop();
  state.isPlaying = false;
  state.pausedAt = 0;
  state.currentStep = 0;
  document.getElementById('playBtn').innerHTML = 'â–¶ï¸ Play';
  document.getElementById('timeDisplay').textContent = '00:00';
  document.getElementById('progressFill').style.width = '0%';
  document.querySelectorAll('.step').forEach(el => el.classList.remove('playing'));
  stopTimer();
  stopVisualizer();
  stopPlayheadAnimation();

  const playhead = document.getElementById('dawPlayhead');
  if (playhead) playhead.style.left = '0px';

  stopHarmonyCycle();                // â¹ï¸ ensure progression stops

  stopMultitrackPreview();
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) previewBtn.textContent = 'â–¶ï¸ Preview Mix';
}

// -------------------- Timer System --------------------
let progressRAF = 0;

function startTimer() {
  cancelAnimationFrame(progressRAF);
  
  const totalSeconds = state.duration * 60;
  const updateProgress = throttle(() => {
    const seconds = Tone.Transport.seconds;
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    
    document.getElementById('timeDisplay').textContent = 
      String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    
    document.getElementById('progressFill').style.width = 
      Math.min(100, (seconds / totalSeconds) * 100) + '%';
  }, CONFIG.PROGRESS_UPDATE_MS);
  
  const tick = () => {
    updateProgress();
    progressRAF = requestAnimationFrame(tick);
  };
  
  progressRAF = requestAnimationFrame(tick);
}

function stopTimer() {
  cancelAnimationFrame(progressRAF);
  progressRAF = 0;
}

// -------------------- Visualizer System --------------------
let visualizerRAF = 0;
let lastVisualizerUpdate = 0;

function initVisualizerOnce() {
  const viz = document.getElementById('visualizer');
  if (viz.dataset.ready) return;
  
  viz.dataset.ready = '1';
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < CONFIG.VISUALIZER_BARS; i++) {
    const bar = document.createElement('div');
    bar.className = 'viz-bar';
    bar.style.left = (i * 100 / CONFIG.VISUALIZER_BARS) + '%';
    bar.style.height = '10%';
    fragment.appendChild(bar);
  }
  
  viz.appendChild(fragment);
}

function updateVisualizer() {
  if (state.isSongBuilding) return;
  if (visualizerRAF) return;
  
  const viz = document.getElementById('visualizer');
  const bars = viz ? viz.querySelectorAll('.viz-bar') : [];
  const barCount = bars.length || 0;
  
  const updateInterval = 1000 / CONFIG.VISUALIZER_FPS;
  
  const loop = (timestamp) => {
    visualizerRAF = requestAnimationFrame(loop);
    
    if (!lastVisualizerUpdate || (timestamp - lastVisualizerUpdate) >= updateInterval) {
      lastVisualizerUpdate = timestamp;
      
      let heights;
      if (master.analyser) {
        const values = master.analyser.getValue();
        heights = new Array(barCount).fill(0).map((_, i) => {
          const index = Math.floor((i / barCount) * values.length);
          const value = values[clamp(index, 0, values.length - 1)];
          
          if (master.analyser.type === 'fft') {
            const db = clamp(value, -100, 0);
            const normalized = (db + 100) / 100;
            return (5 + normalized * 90).toFixed(1) + '%';
          } else {
            const normalized = (value + 1) / 2;
            return (5 + normalized * 90).toFixed(1) + '%';
          }
        });
      } else {
        heights = Array.from({ length: barCount }, () => 
          (Math.random() * 60 + 10).toFixed(1) + '%'
        );
      }
      
      bars.forEach((bar, i) => {
        bar.style.height = heights[i];
        bar.style.transform = '';
      });
    }
  };
  
  visualizerRAF = requestAnimationFrame(loop);
}

function stopVisualizer() {
  cancelAnimationFrame(visualizerRAF);
  visualizerRAF = 0;
}

// -------------------- Project Management --------------------
function getSerializableInstruments() {
  const keep = ['name', 'icon', 'mute', 'solo', 'volume', 'pan', 'type', 'note'];
  const cleaned = {};
  
  Object.keys(instruments).forEach(key => {
    cleaned[key] = {};
    keep.forEach(field => {
      cleaned[key][field] = instruments[key][field];
    });
  });
  
  return cleaned;
}

async function saveProject() {
  const projectName = document.getElementById('projectName').value || 'Untitled';
  
  showToast('ðŸ’¾ Saving project (with all audio)...', 'info');
  
  // Serialize patterns
  const plainPatterns = {};
  Object.keys(patterns).forEach(inst => {
    plainPatterns[inst] = patterns[inst].map(step => ({
      active: !!step.active,
      velocity: step.velocity ?? 0.8,
      probability: step.probability ?? 100,
      note: step.note ?? instruments[inst].note ?? null,
      duration: step.duration ?? '8n'
    }));
  });
  
  // Serialize FX config
  const fxState = {};
  Object.keys(fxConfig).forEach(fx => {
    fxState[fx] = { ...fxConfig[fx] };
  });
  
  // Serialize multitrack WITH AUDIO
  const multitrackData = {
    tracks: [],
    nextTrackId: multitrack.nextTrackId,
    zoom: multitrack.zoom,
    snapEnabled: multitrack.snapEnabled,
    snapInterval: multitrack.snapInterval
  };
  
  // Convert audio blobs to base64 for each track
  for (const track of multitrack.tracks) {
    const trackData = {
      id: track.id,
      name: track.name,
      instrument: track.instrument,
      isExternalAudio: track.isExternalAudio,
      volume: track.volume,
      pan: track.pan,
      muted: track.muted,
      soloed: track.soloed,
      armed: track.armed,
      inputMonitoring: track.inputMonitoring,
      selectedTakeIndex: track.selectedTakeIndex,
      fxChain: track.fxChain.map(fx => ({
        type: fx.type,
        params: fx.params,
        enabled: fx.enabled
      })),
      takes: []
    };
    
    // Convert each take's audio blob to base64
    for (const take of track.takes) {
      try {
        const base64Audio = await blobToBase64(take.blob);
        
        trackData.takes.push({
          id: take.id,
          duration: take.duration,
          timestamp: take.timestamp,
          muted: take.muted,
          startTime: take.startTime,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd,
          recordedAt: take.recordedAt,
          audioData: base64Audio,
          mimeType: take.blob.type
        });
      } catch (err) {
        console.error(`Failed to encode take ${take.id}:`, err);
      }
    }
    
    multitrackData.tracks.push(trackData);
  }
  
  const project = {
    version: '2.1', // Increment for complete state save
    name: projectName,
    state: {
      bpm: state.bpm,
      swing: state.swing,
      duration: state.duration,
      complexity: state.complexity,
      humanize: state.humanize,
      sequenceLength: state.sequenceLength,
      resolution: state.resolution,
      currentGenre: state.currentGenre,
      key: state.key,
      scale: state.scale,
      octave: state.octave,
      progression: state.progression,
      masterVolume: state.masterVolume,
      tapeSaturation: state.tapeSaturation,
      vinylNoise: state.vinylNoise,
      lowCut: state.lowCut,
      highCut: state.highCut,
      compressor: state.compressor,
      metronomeEnabled: state.metronomeEnabled,
      metronomeVolume: state.metronomeVolume,
      countInBars: state.countInBars,
      aiMixing: state.aiMixing
    },
    patterns: plainPatterns,
    instruments: getSerializableInstruments(),
    fxConfig: fxState,
    multitrack: multitrackData,
    timestamp: Date.now(),
    savedVibe: document.body.getAttribute('data-vibe')
  };
  
  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  
  const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${projectName.replace(/\s+/g, '_')}_${Date.now()}.8beat.json`;
  link.click();
  
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  console.log(`ðŸ’¾ Full project saved: ${projectName} (${sizeMB}MB)`);
  showToast(`âœ… Complete project saved! (${sizeMB}MB with ${multitrackData.tracks.length} tracks)`, 'success');
}

// Helper function to convert Blob to Base64
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // Remove the data URL prefix (e.g., "data:audio/webm;base64,")
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert Base64 back to Blob
function base64ToBlob(base64, mimeType) {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function applyLoadedInstruments(loaded) {
  Object.keys(loaded).forEach(inst => {
    const source = loaded[inst];
    if (!instruments[inst]) return;
    
    instruments[inst].mute = !!source.mute;
    instruments[inst].solo = !!source.solo;
    instruments[inst].volume = source.volume ?? instruments[inst].volume;
    instruments[inst].pan = source.pan ?? instruments[inst].pan;
    instruments[inst].note = source.note ?? instruments[inst].note;
    
    if (instruments[inst].channel) {
      instruments[inst].channel.volume.value = instruments[inst].volume;
      instruments[inst].channel.pan.value = (instruments[inst].pan || 0) / 100;
    }
  });
}

function loadProject() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.8beat.json';
  
  input.onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async ev => {
      try {
        const project = JSON.parse(ev.target.result);
        
        console.log('ðŸ“‚ Loading project:', project.name, 'version:', project.version);
        showToast('â³ Loading complete project...', 'info');
        
        // Stop playback
        if (state.isPlaying) {
          stop();
        }
        
        // Load ALL state
        Object.assign(state, {
          ...state,
          ...project.state,
          isPlaying: false,
          currentStep: 0
        });
        
        // Load patterns
        Object.keys(patterns).forEach(k => delete patterns[k]);
        Object.assign(patterns, project.patterns || {});
        
        // Load instruments
        if (project.instruments) {
          applyLoadedInstruments(project.instruments);
        }
        
        // Load FX config
        if (project.fxConfig) {
          Object.assign(fxConfig, project.fxConfig);
        }
        
        // Load vibe/theme
        if (project.savedVibe) {
          applyVibe(project.savedVibe);
        }
        
        // Load multitrack
        if (project.multitrack) {
          multitrack.tracks.forEach(t => t.dispose());
          multitrack.tracks = [];
          
          multitrack.zoom = project.multitrack.zoom || 100;
          multitrack.snapEnabled = project.multitrack.snapEnabled ?? true;
          multitrack.snapInterval = project.multitrack.snapInterval || 0.25;
          
          for (const trackData of project.multitrack.tracks) {
            const track = new AudioTrack(
              trackData.id,
              trackData.name,
              trackData.instrument,
              trackData.isExternalAudio
            );
            
            track.volume = trackData.volume;
            track.pan = trackData.pan;
            track.muted = trackData.muted;
            track.soloed = trackData.soloed;
            track.armed = trackData.armed;
            track.inputMonitoring = trackData.inputMonitoring || false;
            track.selectedTakeIndex = trackData.selectedTakeIndex;
            
            track.channel.volume.value = track.volume;
            track.channel.pan.value = track.pan / 100;
            
            // Restore FX chain
            if (trackData.fxChain && trackData.fxChain.length > 0) {
              trackData.fxChain.forEach(fxData => {
                track.addFx(fxData.type, fxData.params);
                const fx = track.fxChain[track.fxChain.length - 1];
                if (fx) {
                  fx.enabled = fxData.enabled;
                }
              });
            }
            
            // Restore takes with audio
            if (trackData.takes && trackData.takes.length > 0) {
              showToast(`ðŸŽµ Restoring ${trackData.takes.length} take(s) for ${track.name}...`, 'info');
              
              for (const takeData of trackData.takes) {
                try {
                  const blob = base64ToBlob(takeData.audioData, takeData.mimeType);
                  const arrayBuffer = await blob.arrayBuffer();
                  const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
                  
                  const take = {
                    id: takeData.id,
                    buffer: audioBuffer,
                    blob: blob,
                    duration: takeData.duration,
                    timestamp: takeData.timestamp,
                    muted: takeData.muted,
                    startTime: takeData.startTime,
                    trimStart: takeData.trimStart,
                    trimEnd: takeData.trimEnd,
                    recordedAt: takeData.recordedAt
                  };
                  
                  track.takes.push(take);
                  console.log(`âœ… Restored take ${take.id} (${take.duration.toFixed(2)}s)`);
                  
                } catch (err) {
                  console.error(`Failed to restore take ${takeData.id}:`, err);
                }
              }
            }
            
            multitrack.tracks.push(track);
          }
          
          multitrack.nextTrackId = project.multitrack.nextTrackId;
        }
        
        // Update ALL displays
        updateAllDisplays();
        ensurePatternLength(state.sequenceLength);
        
        // Set genre selector
        if (state.currentGenre) {
          document.querySelectorAll('.genre-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.genre === state.currentGenre);
          });
        }
        
        // Update BPM in transport
        Tone.Transport.bpm.value = state.bpm;
        Tone.Transport.swing = state.swing / 100;
        
        renderSequencer();
        renderMixer();
        renderFX();
        renderHarmony();
        renderMultitrack();
        
        document.getElementById('projectName').value = project.name || 'Untitled';
        
        const totalTakes = multitrack.tracks.reduce((sum, t) => sum + t.takes.length, 0);
        console.log('âœ… Complete project loaded successfully');
        showToast(`âœ… Project loaded: ${totalTakes} recording(s), ${multitrack.tracks.length} tracks!`, 'success');
        
      } catch (err) {
        console.error('âŒ Load project error:', err);
        showToast('âŒ Error loading project: ' + err.message, 'error');
      }
    };
    
    reader.readAsText(file);
  };
  
  input.click();
}
  
function updateAllDisplays() {
  state.bpm = Math.min(CONFIG.MAX_BPM, state.bpm);
  
  document.getElementById('bpmSlider').value = state.bpm;
  document.getElementById('bpmValue').textContent = state.bpm;
  document.getElementById('swingSlider').value = state.swing;
  document.getElementById('swingValue').textContent = state.swing + '%';
  document.getElementById('durSlider').value = state.duration;
  document.getElementById('durValue').textContent = state.duration + ' min';
  document.getElementById('durationDisplay').textContent = 
    '/ ' + String(state.duration).padStart(2, '0') + ':00';
  document.getElementById('complexSlider').value = state.complexity;
  document.getElementById('complexValue').textContent = 
    ['Simple', 'Medium', 'Complex'][state.complexity - 1];
  document.getElementById('humanSlider').value = state.humanize;
  document.getElementById('humanValue').textContent = state.humanize + 'ms';
  
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';
}

// -------------------- Audio Export --------------------
function bufferToWav(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = clamp(channels[c][i], -1, 1);
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

async function exportAudio() {
  // Live recording only - captures real-time output
  await exportLiveRecording();
}

// Improved WAV converter with peak normalization
function bufferToWavImproved(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  
  // Find peak for normalization
  let peak = 0;
  for (let c = 0; c < numChannels; c++) {
    const channelData = audioBuffer.getChannelData(c);
    for (let i = 0; i < numFrames; i++) {
      const abs = Math.abs(channelData[i]);
      if (abs > peak) peak = abs;
    }
  }
  
  // Calculate normalization factor (leave 1dB headroom)
  const targetPeak = 0.891; // -1dB
  const normFactor = peak > 0 ? Math.min(targetPeak / peak, 1) : 1;
  
  console.log(`ðŸŽšï¸ Normalizing: peak=${peak.toFixed(3)}, factor=${normFactor.toFixed(3)}`);
  
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples with normalization
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = channels[c][i] * normFactor;
      sample = Math.max(-1, Math.min(1, sample)); // Hard clip
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

// Live recording - captures what you hear in real-time
async function exportLiveRecording() {
  // if we're already recording, this call means "stop & download"
  if (master.mediaRecorder && master.mediaRecorder.state === 'recording') {
    master.mediaRecorder.stop();
    return;
  }

  await Tone.start();

  const stream = master.mediaDest?.stream;
  if (!stream) {
    alert('âŒ No recording stream available.');
    return;
  }

  let mimeType = '';
  if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
    mimeType = 'audio/webm;codecs=opus';
  } else if (MediaRecorder.isTypeSupported('audio/webm')) {
    mimeType = 'audio/webm';
  }

  master.recordedChunks = [];
  const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
  master.mediaRecorder = rec;

  rec.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) {
      master.recordedChunks.push(e.data);
    }
  };

  rec.onstop = () => {
    const blob = new Blob(master.recordedChunks, {
      type: rec.mimeType || 'audio/webm'
    });

    const name = (document.getElementById('projectName')?.value || 'live_mix')
      .replace(/\s+/g, '_') + `_${Date.now()}`;

    let ext = 'webm';
    if ((rec.mimeType || '').includes('ogg')) ext = 'ogg';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.${ext}`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    const btn = document.getElementById('exportBtn');
    if (btn) btn.textContent = 'ðŸŽ§ DJ Export';
    
    showToast('âœ… Live mix exported!', 'success');
  };

  rec.start();

  const btn = document.getElementById('exportBtn');
  if (btn) btn.textContent = 'â¹ï¸ Stop Recording';
  
  showToast('ðŸŽ™ï¸ Recording live output...', 'info');
}

function updateLoopRegionHighlight() {
  const scroll = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');
  if (!scroll || !loopHighlight) return;

  const zoom = multitrack.zoom || 100;
  const { loopStart, loopEnd } = multitrack;

  const hasRegion =
    typeof loopStart === 'number' &&
    typeof loopEnd === 'number' &&
    loopEnd > loopStart;

  if (!hasRegion) {
    loopHighlight.style.display = 'none';
    return;
  }

  const startPx = loopStart * zoom;
  const widthPx = (loopEnd - loopStart) * zoom;

  loopHighlight.style.display = 'block';
  // because loopHighlight lives inside the scroll container,
  // we compensate for scrollLeft so it lines up with content
  loopHighlight.style.left = (startPx - scroll.scrollLeft) + 'px';
  loopHighlight.style.width = widthPx + 'px';
}

function setLoopRegion(startSeconds, endSeconds) {
  if (typeof startSeconds !== 'number' || typeof endSeconds !== 'number') {
    showToast('âš ï¸ Invalid loop region.', 'warning');
    return;
  }
  if (endSeconds <= startSeconds) {
    showToast('âš ï¸ Loop end must be after start.', 'warning');
    return;
  }
  multitrack.loopStart = startSeconds;
  multitrack.loopEnd = endSeconds;
  updateLoopRegionHighlight();
  showToast(`ðŸ” Loop set: ${startSeconds.toFixed(2)}s â†’ ${endSeconds.toFixed(2)}s`, 'info');
}

function clearLoopRegion() {
  multitrack.loopStart = null;
  multitrack.loopEnd = null;
  updateLoopRegionHighlight();
  showToast('â¹ï¸ Loop region cleared.', 'info');
}

// -------------------- PWA Installation --------------------
let deferredPrompt;

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').hidden = false;
});

document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  
  if (outcome === 'accepted') {
    document.getElementById('installBtn').hidden = true;
  }
  
  deferredPrompt = null;
});

function checkSamplesLoaded() {
  const drumInsts = Object.keys(instruments).filter(k => instruments[k].type === 'drum');
  const totalDrums = drumInsts.length;
  let loadedCount = 0;
  let lastLoggedCount = -1;
  
  const checkInterval = setInterval(() => {
    loadedCount = 0;
    const statusList = [];
    
    drumInsts.forEach(inst => {
      const synth = synths[inst];
      if (synth && synth.loaded) {
        loadedCount++;
        statusList.push(`âœ… ${inst}`);
      } else {
        statusList.push(`â³ ${inst}`);
      }
    });
    
    // Only log when count changes
    if (loadedCount !== lastLoggedCount) {
      console.log(`ðŸ“¦ Drum samples: ${loadedCount}/${totalDrums}`);
      console.log(statusList.join(', '));
      lastLoggedCount = loadedCount;
    }
    
    if (loadedCount === totalDrums) {
      clearInterval(checkInterval);
      console.log('âœ… All drum samples ready!');
      document.getElementById('vizOverlay').textContent = 'All Samples Loaded - Generate & Press Play';
    }
  }, 500);
  
  // Stop checking after 15 seconds
  setTimeout(() => {
    clearInterval(checkInterval);
    if (loadedCount < totalDrums) {
      console.warn(`âš ï¸ Only ${loadedCount}/${totalDrums} samples loaded after timeout`);
      console.warn('Missing samples:', drumInsts.filter(inst => !synths[inst]?.loaded));
    }
  }, 15000);
}

// -------------------- Sidebar Controls --------------------
function openSidebar() {
  document.getElementById('sidebarNav').classList.add('open');
  document.getElementById('sidebarBackdrop').classList.add('open');
  document.body.style.overflow = 'hidden';
}

function closeSidebar() {
  document.getElementById('sidebarNav').classList.remove('open');
  document.getElementById('sidebarBackdrop').classList.remove('open');
  document.body.style.overflow = '';
}

function toggleSidebar() {
  const nav = document.getElementById('sidebarNav');
  if (nav.classList.contains('open')) {
    closeSidebar();
  } else {
    openSidebar();
  }
}

const LICENSE_API_URL = 'https://script.google.com/macros/s/AKfycbxvYwLDd0frF6GraU1RSX6q6xnxtVU3FwcVoeTVTsNNtf1C2zEm-DeAeVgCm1c4TbLh/exec'; // no query string

function isPro() {
  return localStorage.getItem('8beat.pro') === 'true';
}

function getSavedLicenseKey() {
  return localStorage.getItem('8beat.licenseKey') || '';
}

async function validateLicenseKey(key) {
  const adminKeys = [
    '8BEAT-ADMIN-BKEY',  // <-- your admin key(s)
    '8BEAT-ADMIN-TEST'
  ];

  // If it's one of your admin keys, instant unlock
  if (adminKeys.includes(key.trim())) {
    console.log('ðŸ› ï¸ Admin key accepted');
    return true;
  }
  const url = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(key.trim())}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Network error');
  const data = await res.json();
  return data.valid === true;
}

function enableProFeatures() {
  document.body.classList.add('pro');

  // Unlock sidebar tabs
  document.querySelectorAll('.sidebar-tab.locked').forEach(btn => {
    btn.classList.remove('locked');
  });

  // Remove "pro-locked" overlays on content panels
  document.querySelectorAll('.pro-locked').forEach(el => {
    el.classList.remove('pro-locked');
  });
}

function initLicenseUI() {
  const unlockBtn = document.getElementById('unlockProBtn');
  const modal = document.getElementById('unlockModal');
  const input = document.getElementById('licenseInput');
  const status = document.getElementById('licenseStatus');
  const confirmBtn = document.getElementById('confirmLicenseBtn');
  const cancelBtn = document.getElementById('cancelLicenseBtn');

  if (!unlockBtn || !modal) return;

  function openModal() {
    modal.classList.remove('hidden');
    status.textContent = '';
    const savedKey = getSavedLicenseKey();
    if (savedKey) input.value = savedKey;
    input.focus();
  }

  function closeModal() {
    modal.classList.add('hidden');
  }

  unlockBtn.addEventListener('click', openModal);
  cancelBtn.addEventListener('click', closeModal);

  confirmBtn.addEventListener('click', async () => {
    const key = input.value.trim();
    if (!key) {
      status.textContent = 'Please paste your license key.';
      return;
    }
    status.textContent = 'Checking keyâ€¦';

    try {
      const valid = await validateLicenseKey(key);
      if (valid) {
        localStorage.setItem('8beat.licenseKey', key);
        localStorage.setItem('8beat.pro', 'true');
        enableProFeatures();
        status.textContent = 'âœ… Pro unlocked! Enjoy.';
        setTimeout(closeModal, 800);
      } else {
        status.textContent = 'âŒ Invalid or inactive license key.';
      }
    } catch (err) {
      console.error(err);
      status.textContent = 'âŒ Error contacting license server.';
    }
  });

  // On load, auto-unlock if already Pro
  if (isPro()) {
    enableProFeatures();
  }
}

function gateTabsForFreeUsers() {
  // Tabs free for all users
  const freeTabs = ['generate', 'sequencer'];

  if (!isPro()) {
    document.querySelectorAll('.sidebar-tab').forEach(btn => {
      const tab = btn.getAttribute('data-tab');
      if (!freeTabs.includes(tab)) {
        btn.classList.add('locked');
      } else {
        btn.classList.remove('locked');
      }
    });
  } else {
    // Pro users get everything unlocked
    document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.remove('locked'));
  }
}

// Simple in-place normaliser with headroom
function normalizeBufferInPlace(buffer, targetDb = -6) {
  if (!buffer) return;
  const ch = buffer.getChannelData(0);
  if (!ch || !ch.length) return;

  // Find peak
  let peak = 0;
  for (let i = 0; i < ch.length; i++) {
    const v = Math.abs(ch[i]);
    if (v > peak) peak = v;
  }
  if (peak === 0) return;

  const targetLinear = Math.pow(10, targetDb / 20); // dB â†’ linear
  const gain = targetLinear / peak;

  for (let i = 0; i < ch.length; i++) {
    ch[i] *= gain;
  }
}

// High-quality sample synthesis engine (more natural, less buzzy)
class SampleSynthesizer {
  constructor() {
    // Prefer Tone's context so buffers are compatible with the DAW
    const toneCtx =
      (window.Tone && Tone.context && Tone.context.rawContext) ||
      (window.Tone && Tone.context) ||
      null;

    this.audioContext =
      toneCtx || new (window.AudioContext || window.webkitAudioContext)();

    this.currentSource = null;
  }

  // --- small helpers ------------------------------------

  envAD(t, attack, decay) {
    const a = attack > 0 ? Math.min(1, t / attack) : 1;
    const d = Math.exp(-t / Math.max(0.000001, decay));
    return a * d;
  }

  fastSmooth(last, sample, amt) {
    return last + amt * (sample - last);
  }

  applyLoFi(sample, lofi) {
    if (!lofi || lofi <= 0) return sample;
    const depth = 16 - (lofi / 100) * 12; // 16 â†’ 4 bits
    const bitDepth = Math.max(4, depth);
    const steps = Math.pow(2, bitDepth);
    return Math.round(sample * steps) / steps;
  }

  applyDist(sample, dist, driveFactor) {
    if (!dist || dist <= 0) return sample;
    const norm = Math.pow(dist / 100, 1.3);
    const drive = 1 + driveFactor * norm;
    return Math.tanh(sample * drive) / (1 + norm * 1.5);
  }

  // --- DRUMS --------------------------------------------

  // Kick: authentic 808/909-style with proper phase modeling
  generateKick(params = {}) {
    const {
      pitch = 0,
      decay = 0.25,
      tone = 60,
      noise = 10,
      attack = 0.003,
      lofi = 0,
      dist = 5
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.06, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const base = 55 * Math.pow(2, pitch / 12);
    let phase = 0;
    let last = 0;
    const SMOOTH = 0.08;

    const noiseNorm = Math.pow(noise / 100, 2);

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);
      
      // Multi-stage pitch envelope for realistic thump
      const pitchEnv1 = Math.exp(-t * 80);
      const pitchEnv2 = Math.exp(-t * 15);
      const f = base * (1 + 4.5 * pitchEnv1 + 1.2 * pitchEnv2);
      
      // Phase accumulation for cleaner sine generation
      phase += (2 * Math.PI * f) / sr;
      
      const body = Math.sin(phase) * (tone / 100);
      const sub = Math.sin(phase * 0.5) * 0.45;
      
      // Click transient for attack
      const click = Math.sin(phase * 8) * Math.exp(-t * 200) * 0.15;

      // Shaped noise burst
      const nSample = (Math.random() * 2 - 1) * noiseNorm * Math.exp(-t * 120);

      let s = (body * 0.55 + sub * 0.35 + click + nSample * 0.1) * env;

      s = this.applyDist(s, dist, 4);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // Snare: layered approach with realistic shell resonance
  generateSnare(params = {}) {
    const {
      pitch  = 0,
      decay  = 0.15,
      tone   = 50,
      noise  = 70,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.05, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const basePitch = 200 * Math.pow(2, pitch / 12);
  
    // Multi-pole filter for noise (more realistic snare wire sound)
    let noiseHP1 = 0, noiseHP2 = 0;
    let noiseBP = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Shell resonance - multiple partials
      const shell1 = Math.sin(2 * Math.PI * basePitch * t);
      const shell2 = Math.sin(2 * Math.PI * basePitch * 1.47 * t);
      const shell3 = Math.sin(2 * Math.PI * basePitch * 1.89 * t);
      const toneComponent = (shell1 * 0.5 + shell2 * 0.3 + shell3 * 0.2) * (tone / 100);
  
      // Snare wire simulation with bandpass filtering
      const rawNoise = Math.random() * 2 - 1;
      
      // High-pass filter cascade
      noiseHP1 = noiseHP1 + 0.7 * (rawNoise - noiseHP1);
      noiseHP2 = noiseHP2 + 0.7 * (noiseHP1 - noiseHP2);
      
      // Band-emphasis around 3-5kHz
      const hpOut = rawNoise - noiseHP2;
      noiseBP = noiseBP + 0.15 * (hpOut - noiseBP);
      
      const noiseAmount = (noise / 100) * 0.8;
      const noiseComponent = noiseBP * noiseAmount;
  
      // Mix with emphasis on noise body
      let sample = (toneComponent * 0.35 + noiseComponent * 0.65) * envelope;
      
      // Transient click
      sample += Math.sin(2 * Math.PI * basePitch * 4 * t) * Math.exp(-t * 150) * 0.2;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 3)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.9;
    }
  
    return buffer;
  }

  // Hi-hat: metallic resonator model (more realistic cymbal sound)
  generateHihat(params = {}, closed = true) {
    const {
      pitch  = 0,
      decay  = closed ? 0.05 : 0.2,
      tone   = 50,
      noise  = 90,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.02, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const pitchMult = Math.pow(2, pitch / 12);
  
    // Resonator banks for metallic character
    let res1 = 0, res2 = 0, res3 = 0, res4 = 0;
    let noiseState = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Inharmonic metallic partials (909-style ratios)
      const freqs = [
        5500 * pitchMult,
        7234 * pitchMult,
        9891 * pitchMult,
        12456 * pitchMult
      ];
      
      const excitation = (Math.random() * 2 - 1) * (noise / 100);
      
      // Resonator simulation
      res1 = res1 * 0.996 + Math.sin(2 * Math.PI * freqs[0] / sampleRate) * excitation * 0.3;
      res2 = res2 * 0.994 + Math.sin(2 * Math.PI * freqs[1] / sampleRate) * excitation * 0.25;
      res3 = res3 * 0.992 + Math.sin(2 * Math.PI * freqs[2] / sampleRate) * excitation * 0.2;
      res4 = res4 * 0.990 + Math.sin(2 * Math.PI * freqs[3] / sampleRate) * excitation * 0.15;
      
      const metallic = (res1 + res2 + res3 + res4) * (tone / 100);
      
      // High-passed noise
      const rawNoise = Math.random() * 2 - 1;
      noiseState = noiseState + 0.25 * (rawNoise - noiseState);
      const noiseHP = rawNoise - noiseState;
      
      let sample = (metallic * 0.6 + noiseHP * 0.4) * envelope;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 2)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.65;
    }
  
    return buffer;
  }

  // Clap: realistic hand clap with proper layering
  generateClap(params = {}) {
    const {
      pitch  = 0,
      decay  = 0.12,
      tone   = 30,
      noise  = 90,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.05, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    // More realistic clap timing (slightly randomized)
    const clapTimes = [0, 0.008, 0.019, 0.027, 0.035];
  
    let noiseBP = 0;
  
    for (let i = 0; i < samples; i++) {
      const t      = i / sampleRate;
      const mainEnv = Math.exp(-t / decay);
  
      let sample = 0;
  
      // Individual clap transients
      clapTimes.forEach((clapTime, idx) => {
        if (t >= clapTime) {
          const localT   = t - clapTime;
          const localEnv = Math.exp(-localT * (60 + idx * 10));
          
          // Each clap has slightly different frequency content
          const burst = (Math.random() * 2 - 1) * localEnv * (0.18 + idx * 0.02);
          sample += burst;
        }
      });
  
      // Body noise with bandpass character
      const rawNoise  = Math.random() * 2 - 1;
      noiseBP = noiseBP + 0.3 * (rawNoise - noiseBP);
      const bodyNoise = noiseBP * (noise / 100) * 0.5 * mainEnv;
  
      sample = sample + bodyNoise;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 3)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.8;
    }
  
    return buffer;
  }
  
  // Tom: acoustic drum modeling with realistic overtones
  generateTom(params = {}, kitPitch = 0) {
    const {
      pitch = 0,
      decay = 0.3,
      tone  = 60,
      noise = 20,
      attack = 0.001,
      lofi  = 0,
      dist  = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.1, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const semitoneOffset = (kitPitch || 0) + (pitch || 0);
    const basePitch = 110 * Math.pow(2, semitoneOffset / 12);
  
    let phase1 = 0, phase2 = 0, phase3 = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Pitch drop on attack (realistic tom behavior)
      const pitchEnv = 1 + 0.15 * Math.exp(-t * 40);
      const f = basePitch * pitchEnv;
  
      // Multiple modes of drum head
      phase1 += (2 * Math.PI * f) / sampleRate;
      phase2 += (2 * Math.PI * f * 1.5) / sampleRate;
      phase3 += (2 * Math.PI * f * 2.0) / sampleRate;
      
      const mode1 = Math.sin(phase1);
      const mode2 = Math.sin(phase2) * 0.3;
      const mode3 = Math.sin(phase3) * 0.15;
      
      const toneComponent = (mode1 + mode2 + mode3) * (tone / 100);
  
      // Attack transient
      const clickEnv = Math.exp(-t * 80);
      const click = (Math.random() * 2 - 1) * (noise / 100) * clickEnv * 0.4;
  
      let sample = (toneComponent * 0.85 + click * 0.15) * envelope;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 4)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.85;
    }
  
    return buffer;
  }

  // --- INSTRUMENTS --------------------------------------

  // Bass: analog-style with proper filter modeling
  generateBass(params = {}) {
    const {
      pitch = -12,
      decay = 0.9,
      tone = 55,
      attack = 0.004,
      lofi = 0,
      dist = 8
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.25, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const fBase = 55 * Math.pow(2, pitch / 12);
    let phase = 0;
    let filterState = 0;
    let last = 0;
    const SMOOTH = 0.1;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);
      
      // Slight pitch drop (analog VCO behavior)
      const f = fBase * (1 + 0.25 * Math.exp(-t * 35));
      phase += (2 * Math.PI * f) / sr;

      // Sawtooth-ish wave (richer harmonics)
      const sawPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      const saw = 2 * sawPhase - 1;
      
      // Add sine fundamental for warmth
      const sine = Math.sin(phase);
      
      const toneNorm = tone / 100;
      let s = saw * toneNorm + sine * (1 - toneNorm * 0.5);
      
      // Low-pass filter envelope
      const cutoffEnv = 0.3 + 0.7 * env;
      filterState = filterState + cutoffEnv * 0.15 * (s - filterState);
      s = filterState;
      
      s = s * env;
      s = this.applyDist(s, dist, 3);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // Guitar: improved Karplus-Strong with realistic damping
  generateGuitar(params = {}) {
    const {
      pitch = 0,
      decay = 1.1,
      tone = 60,
      attack = 0.001,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 110 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.35, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const L = Math.max(2, Math.floor(sr / f0));
    const delay = new Float32Array(L);
    
    // Richer initial excitation
    for (let i = 0; i < L; i++) {
      delay[i] = (Math.random() * 2 - 1) * 0.5 * (1 - i / L);
    }

    let idx = 0;
    const toneNorm = tone / 100;
    const DAMP = 0.495 + (1 - toneNorm) * 0.1;
    
    // Allpass for tuning
    let allpassState = 0;

    for (let i = 0; i < n; i++) {
      // Improved averaging for warmer tone
      const y0 = delay[idx];
      const y1 = delay[(idx + 1) % L];
      let y = (y0 + y1) * 0.5 * DAMP;
      
      // Allpass tuning adjustment
      allpassState = allpassState * 0.5 + y * 0.5;
      y = y + (allpassState - y) * 0.3;
      
      delay[idx] = y;
      idx = (idx + 1) % L;

      const t = i / sr;
      const env = this.envAD(t, attack, decay * 1.5);

      let s = y * env;
      s = this.applyLoFi(s, lofi);

      data[i] = s * 0.95;
    }

    return buffer;
  }

  // Keys: FM Rhodes-style with authentic character
  generateKeys(params = {}) {
    const {
      pitch = 0,
      decay = 1.2,
      tone = 55,
      attack = 0.006,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 220 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.4, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const tremHz = 5.5;
    const toneNorm = tone / 100;
    
    let modPhase = 0;
    let carPhase = 0;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      // FM synthesis for bell-like tone
      const modIndex = 2.5 * env;
      modPhase += (2 * Math.PI * f0) / sr;
      const mod = Math.sin(modPhase) * modIndex;
      
      carPhase += (2 * Math.PI * f0 * (1 + mod)) / sr;
      let s = Math.sin(carPhase);
      
      // Add slight detuned harmonic
      const detune = Math.sin(carPhase * 2.01) * 0.3 * toneNorm;
      s = s * (1 - toneNorm * 0.3) + detune;
      
      s = s * env;

      // Tremolo
      const trem = 1 + 0.25 * Math.sin(2 * Math.PI * tremHz * t);
      s *= trem;

      s = this.applyLoFi(s, lofi);
      data[i] = s * 0.9;
    }

    return buffer;
  }

  // Lead: improved wavetable-style synthesis
  generateLead(params = {}) {
    const {
      pitch = 0,
      decay = 0.85,
      tone = 65,
      attack = 0.01,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 440 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.3, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const toneNorm = tone / 100;
    const vibHz = 6;
    const vibDepth = 0.015;
    
    let phase = 0;
    let pwmPhase = 0;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      const vib = 1 + vibDepth * Math.sin(2 * Math.PI * vibHz * t);
      const f = f0 * vib;
      
      phase += (2 * Math.PI * f) / sr;
      
      // PWM-style wave morphing
      pwmPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      const pulseWidth = 0.5 + 0.3 * toneNorm;
      const pulse = pwmPhase < pulseWidth ? 1 : -1;
      
      // Mix with sine for smoothness
      const sine = Math.sin(phase);
      let s = pulse * toneNorm + sine * (1 - toneNorm * 0.5);
      
      s = s * env;
      s = this.applyLoFi(s, lofi);

      data[i] = s * 0.95;
    }

    return buffer;
  }

  // Riser: formant-filtered sweep for realistic buildup
  generateRiser(params = {}) {
    const {
      pitch = 0,
      decay = 2.5,
      tone = 60,
      attack = 0.02,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.9, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const fStart = 120 * Math.pow(2, pitch / 12);
    const fEnd = 4200 * Math.pow(2, pitch / 12);
    
    let filterLP = 0;
    let filterBP = 0;
    let last = 0;
    const SMOOTH = 0.08;
    const toneNorm = tone / 100;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const frac = t / dur;
      const env = this.envAD(t, attack, decay) * Math.min(1, frac * 1.2);

      const f = fStart * Math.pow(fEnd / fStart, frac);

      // Sawtooth oscillator
      const sawPhase = (2 * Math.PI * f * t) % (2 * Math.PI);
      const saw = 2 * (sawPhase / (2 * Math.PI)) - 1;
      
      // Resonant filter sweep
      const cutoff = 0.1 + 0.3 * frac;
      filterLP = filterLP + cutoff * (saw - filterLP);
      filterBP = filterBP + cutoff * 0.5 * (filterLP - filterBP);
      
      const filtered = filterBP * toneNorm + saw * (1 - toneNorm);
      
      let s = filtered * env;
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // FX: cinematic impact with layered textures
  generateFX(params = {}) {
    const {
      pitch = -12,
      decay = 1.4,
      tone = 45,
      attack = 0.001,
      lofi = 0,
      dist = 10
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.5, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const f0 = 80 * Math.pow(2, pitch / 12);
    let phase = 0;
    let noiseHP = 0;
    let last = 0;
    const SMOOTH = 0.1;
    const toneNorm = tone / 100;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      // Downward pitch sweep
      const sweep = f0 * (1 - 0.7 * Math.min(1, t / decay));
      phase += (2 * Math.PI * sweep) / sr;
      
      const boom = Math.sin(phase);
      const subBoom = Math.sin(phase * 0.5) * 0.4;
      
      // Filtered noise crack
      const rawNoise = Math.random() * 2 - 1;
      noiseHP = noiseHP + 0.4 * (rawNoise - noiseHP);
      const crack = (rawNoise - noiseHP) * Math.exp(-t * 100) * (0.5 + toneNorm * 0.5);

      let s = (boom * 0.6 + subBoom * 0.25 + crack * 0.15) * env;

      s = this.applyDist(s, dist, 4);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // --- playback / export / drawing ----------------------

  // Play sample with volume in dB
  play(buffer, volume = 0) {
    if (this.currentSource) {
      try {
        this.currentSource.stop();
      } catch (e) {}
      this.currentSource = null;
    }

    const source = this.audioContext.createBufferSource();
    const gainNode = this.audioContext.createGain();

    source.buffer = buffer;
    gainNode.gain.value = Math.pow(10, volume / 20); // dB â†’ linear

    source.connect(gainNode);
    gainNode.connect(this.audioContext.destination);

    source.start();
    this.currentSource = source;

    source.onended = () => {
      if (this.currentSource === source) {
        this.currentSource = null;
      }
    };
  }

  // Export buffer as WAV file
  exportWAV(buffer, filename) {
    const wav = this.bufferToWav(buffer);
    const blob = new Blob([wav], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
  }

  bufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;

    const data = buffer.getChannelData(0);
    const dataLength = data.length * bytesPerSample;
    const headerLength = 44;
    const totalLength = headerLength + dataLength;

    const arrayBuffer = new ArrayBuffer(totalLength);
    const view = new DataView(arrayBuffer);

    // Write WAV header
    this.writeString(view, 0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    this.writeString(view, 8, 'WAVE');
    this.writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    this.writeString(view, 36, 'data');
    view.setUint32(40, dataLength, true);

    // Write audio data
    let offset = 44;
    for (let i = 0; i < data.length; i++) {
      const sample = Math.max(-1, Math.min(1, data[i]));
      view.setInt16(
        offset,
        sample < 0 ? sample * 0x8000 : sample * 0x7fff,
        true
      );
      offset += 2;
    }

    return arrayBuffer;
  }

  writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  // Draw waveform to canvas
  drawWaveform(buffer, canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const data = buffer.getChannelData(0);

    ctx.clearRect(0, 0, width, height);

    ctx.beginPath();
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;

    const step = Math.ceil(data.length / width);
    const amp = height / 2;

    for (let i = 0; i < width; i++) {
      const start = i * step;
      let min = 1, max = -1;
      for (let j = 0; j < step && start + j < data.length; j++) {
        const v = data[start + j];
        if (v < min) min = v;
        if (v > max) max = v;
      }

      const y = amp - max * amp;
      if (i === 0) ctx.moveTo(i, y);
      else ctx.lineTo(i, y);
    }

    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    ctx.moveTo(0, amp);
    ctx.lineTo(width, amp);
    ctx.stroke();
  }
}

async function bufferToWavBlob(audioBuffer) {
  const numOfChan = audioBuffer.numberOfChannels;
  const length = audioBuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels = [];
  let offset = 0;
  let pos = 0;

  // write WAVE header
  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"

  setUint32(0x20746d66); // "fmt "
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(audioBuffer.sampleRate);
  setUint32(audioBuffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16);

  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4);

  // interleave channels
  for (let i = 0; i < audioBuffer.numberOfChannels; i++)
    channels.push(audioBuffer.getChannelData(i));

  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      const sample = Math.max(-1, Math.min(1, channels[i][offset]));
      view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      pos += 2;
    }
    offset++;
  }

  return new Blob([buffer], { type: 'audio/wav' });

  function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
  function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
}

// Initialize sample library
const synth = new SampleSynthesizer();

// Sample kits database
const sampleKits = {
  lofi: {
    kick: { type: 'kick', pitch: -3, decay: 0.28, tone: 38, noise: 22, lofi: 45, dist: 18 },
    snare: { type: 'snare', pitch: -2, decay: 0.16, tone: 42, noise: 72, lofi: 40, dist: 12 },
    hihatClosed: { type: 'hihat', pitch: -1, decay: 0.045, tone: 38, noise: 83, lofi: 35, closed: true },
    hihatOpen: { type: 'hihat', pitch: -1, decay: 0.18, tone: 42, noise: 78, lofi: 35, closed: false },
    clap: { type: 'clap', pitch: -1, decay: 0.13, tone: 28, noise: 88, lofi: 30, dist: 8 },
    rimshot: { type: 'snare', pitch: 6, decay: 0.055, tone: 58, noise: 42, lofi: 25 },
    tomLow: { type: 'tom', pitch: -5, decay: 0.38, tone: 62, noise: 16, lofi: 30 },
    tomHigh: { type: 'tom', pitch: 1, decay: 0.28, tone: 58, noise: 18, lofi: 30 },
    // lofi instruments - warm, dusty
    bass: { type: 'bass', pitch: -1, decay: 0.72, tone: 46, attack: 0.009, lofi: 38, dist: 16 },
    keys: { type: 'keys', pitch: 2, decay: 0.88, tone: 43, attack: 0.013, lofi: 42 },
    guitar: { type: 'guitar', pitch: -2, decay: 0.82, tone: 49, attack: 0.007, lofi: 36 }
  },
  metal: {
    // Drums - tight, punchy, aggressive
    kick: { type: 'kick', pitch: -12, decay: 0.12, tone: 72, noise: 8, lofi: 0, dist: 62 },
    snare: { type: 'snare', pitch: 8, decay: 0.11, tone: 84, noise: 88, lofi: 0, dist: 52 },
    hihatClosed: { type: 'hihat', pitch: 9, decay: 0.018, tone: 92, noise: 96, lofi: 0, closed: true },
    hihatOpen: { type: 'hihat', pitch: 8, decay: 0.09, tone: 90, noise: 94, lofi: 0, closed: false },
    clap: { type: 'clap', pitch: 4, decay: 0.08, tone: 48, noise: 94, lofi: 0, dist: 38 },
    rimshot: { type: 'snare', pitch: 16, decay: 0.035, tone: 88, noise: 24, lofi: 0 },
    tomLow: { type: 'tom', pitch: -8, decay: 0.28, tone: 68, noise: 8, lofi: 0 },
    tomHigh: { type: 'tom', pitch: 0, decay: 0.24, tone: 66, noise: 10, lofi: 0 },
  
    // Djent instruments - ultra-tight, heavily processed
    bass: { type: 'bass', pitch: -14, decay: 0.32, tone: 62, attack: 0.0004, lofi: 0, dist: 68 },
    guitar: { type: 'guitar', pitch: -14, decay: 0.28, tone: 58, attack: 0.0006, lofi: 0, dist: 78 },
    lead: { type: 'lead', pitch: -2, decay: 0.42, tone: 72, attack: 0.0048, lofi: 0, dist: 58 }
  },
  hiphop: {
    kick: { type: 'kick', pitch: -4, decay: 0.45, tone: 52, noise: 16, lofi: 18, dist: 28 },
    snare: { type: 'snare', pitch: 0, decay: 0.19, tone: 48, noise: 78, lofi: 12, dist: 22 },
    hihatClosed: { type: 'hihat', pitch: 1, decay: 0.05, tone: 46, noise: 88, lofi: 15, closed: true },
    hihatOpen: { type: 'hihat', pitch: 1, decay: 0.22, tone: 50, noise: 84, lofi: 15, closed: false },
    clap: { type: 'clap', pitch: 0, decay: 0.16, tone: 34, noise: 94, lofi: 8, dist: 18 },
    rimshot: { type: 'snare', pitch: 9, decay: 0.06, tone: 68, noise: 36, lofi: 12 },
    tomLow: { type: 'tom', pitch: -3, decay: 0.32, tone: 68, noise: 13, lofi: 15 },
    tomHigh: { type: 'tom', pitch: 3, decay: 0.24, tone: 64, noise: 15, lofi: 15 },
    // hip-hop instruments - punchy, groovy
    bass: { type: 'bass', pitch: -3, decay: 1.05, tone: 56, attack: 0.0065, lofi: 14, dist: 27 },
    keys: { type: 'keys', pitch: 14, decay: 1.18, tone: 51, attack: 0.0082, lofi: 16 },
    lead: { type: 'lead', pitch: -1, decay: 0.68, tone: 64, attack: 0.016, lofi: 11 }
  },
  trap: {
    kick: { type: 'kick', pitch: -11, decay: 1.2, tone: 48, noise: 4, lofi: 0, dist: 22 }, // Deep 808-style
    snare: { type: 'snare', pitch: 6, decay: 0.08, tone: 38, noise: 92, lofi: 0, dist: 48 }, // Sharp, snappy
    hihatClosed: { type: 'hihat', pitch: 8, decay: 0.018, tone: 72, noise: 98, lofi: 0, closed: true }, // Razor sharp
    hihatOpen: { type: 'hihat', pitch: 7, decay: 0.35, tone: 68, noise: 96, lofi: 0, closed: false }, // Long tail
    clap: { type: 'clap', pitch: 4, decay: 0.11, tone: 22, noise: 97, lofi: 0, dist: 42 }, // Bright, layered
    rimshot: { type: 'snare', pitch: 15, decay: 0.028, tone: 86, noise: 22, lofi: 0 },
    tomLow: { type: 'tom', pitch: -6, decay: 0.65, tone: 82, noise: 6, lofi: 0 }, // Melodic toms
    tomHigh: { type: 'tom', pitch: 2, decay: 0.48, tone: 78, noise: 8, lofi: 0 },
  
    bass: { type: 'bass', pitch: -16, decay: 1.8, tone: 52, attack: 0.0015, lofi: 0, dist: 28 }, // Sliding 808
    lead: { type: 'lead', pitch: 17, decay: 0.42, tone: 82, attack: 0.008, lofi: 0 }, // Bell/pluck leads
    keys: { type: 'keys', pitch: 0, decay: 0.95, tone: 65, attack: 0.004, lofi: 0 }
  },
  house: {
    kick: { type: 'kick', pitch: -1, decay: 0.38, tone: 68, noise: 7, lofi: 3, dist: 12 },
    snare: { type: 'snare', pitch: 1, decay: 0.15, tone: 56, noise: 74, lofi: 5, dist: 8 },
    hihatClosed: { type: 'hihat', pitch: 2, decay: 0.042, tone: 62, noise: 86, lofi: 4, closed: true },
    hihatOpen: { type: 'hihat', pitch: 2, decay: 0.19, tone: 66, noise: 81, lofi: 4, closed: false },
    clap: { type: 'clap', pitch: 0, decay: 0.14, tone: 41, noise: 89, lofi: 2, dist: 13 },
    rimshot: { type: 'snare', pitch: 9, decay: 0.052, tone: 76, noise: 31, lofi: 4 },
    tomLow: { type: 'tom', pitch: -1, decay: 0.34, tone: 74, noise: 10, lofi: 4 },
    tomHigh: { type: 'tom', pitch: 5, decay: 0.26, tone: 70, noise: 11, lofi: 4 },
    // house instruments - smooth, driving
    bass: { type: 'bass', pitch: 1, decay: 0.78, tone: 66, attack: 0.0048, lofi: 0, dist: 9 },
    keys: { type: 'keys', pitch: -3, decay: 1.02, tone: 61, attack: 0.0052, lofi: 0 },
    lead: { type: 'lead', pitch: 11, decay: 0.92, tone: 67, attack: 0.011, lofi: 0 }
  },
  techno: {
    kick: { type: 'kick', pitch: 1, decay: 0.26, tone: 78, noise: 3, lofi: 0, dist: 32 }, // 909-style punch
    snare: { type: 'snare', pitch: 6, decay: 0.075, tone: 46, noise: 84, lofi: 0, dist: 28 }, // Dry snap
    hihatClosed: { type: 'hihat', pitch: 7, decay: 0.022, tone: 74, noise: 95, lofi: 0, closed: true }, // Metallic
    hihatOpen: { type: 'hihat', pitch: 6, decay: 0.11, tone: 76, noise: 92, lofi: 0, closed: false }, // Short open
    clap: { type: 'clap', pitch: 4, decay: 0.09, tone: 28, noise: 94, lofi: 0, dist: 32 },
    rimshot: { type: 'snare', pitch: 14, decay: 0.032, tone: 88, noise: 22, lofi: 0 },
    tomLow: { type: 'tom', pitch: 1, decay: 0.28, tone: 84, noise: 6, lofi: 0 },
    tomHigh: { type: 'tom', pitch: 8, decay: 0.21, tone: 82, noise: 7, lofi: 0 },
  
    bass: { type: 'bass', pitch: 0, decay: 0.42, tone: 76, attack: 0.0012, lofi: 0, dist: 26 }, // Driving pulse
    lead: { type: 'lead', pitch: 0, decay: 0.48, tone: 82, attack: 0.0032, lofi: 0 }, // Acid-style
    fx: { type: 'fx', pitch: 5, decay: 1.2, tone: 52, attack: 0.0008, lofi: 0, dist: 22 } // Industrial
  },
  dnb: {
    kick: { type: 'kick', pitch: -1, decay: 0.15, tone: 68, noise: 14, lofi: 0, dist: 52 }, // Tight, punchy
    snare: { type: 'snare', pitch: 7, decay: 0.09, tone: 38, noise: 94, lofi: 0, dist: 46 }, // Amen snap
    hihatClosed: { type: 'hihat', pitch: 8, decay: 0.016, tone: 76, noise: 97, lofi: 0, closed: true }, // Frantic
    hihatOpen: { type: 'hihat', pitch: 7, decay: 0.08, tone: 72, noise: 93, lofi: 0, closed: false }, // Quick splash
    clap: { type: 'clap', pitch: 4, decay: 0.07, tone: 26, noise: 96, lofi: 0, dist: 38 },
    rimshot: { type: 'snare', pitch: 16, decay: 0.025, tone: 89, noise: 20, lofi: 0 },
    tomLow: { type: 'tom', pitch: 2, decay: 0.22, tone: 78, noise: 8, lofi: 0 },
    tomHigh: { type: 'tom', pitch: 9, decay: 0.16, tone: 76, noise: 9, lofi: 0 },
  
    bass: { type: 'bass', pitch: -11, decay: 0.52, tone: 44, attack: 0.0008, lofi: 0, dist: 64 }, // Reese wobble
    lead: { type: 'lead', pitch: 16, decay: 0.38, tone: 84, attack: 0.0028, lofi: 0 }, // Bright stabs
    fx: { type: 'fx', pitch: -2, decay: 0.88, tone: 62, attack: 0.0006, lofi: 0, dist: 34 } // Atmospheric
  },
  ambient: {
    kick: { type: 'kick', pitch: -8, decay: 1.4, tone: 28, noise: 35, lofi: 62, dist: 2 }, // Distant thump
    snare: { type: 'snare', pitch: -5, decay: 0.72, tone: 32, noise: 64, lofi: 58, dist: 3 },
    hihatClosed: { type: 'hihat', pitch: -4, decay: 0.14, tone: 30, noise: 72, lofi: 52, closed: true },
    hihatOpen: { type: 'hihat', pitch: -4, decay: 0.68, tone: 34, noise: 68, lofi: 52, closed: false }, // Long wash
    clap: { type: 'clap', pitch: -4, decay: 0.38, tone: 26, noise: 78, lofi: 48, dist: 2 },
    rimshot: { type: 'snare', pitch: 3, decay: 0.16, tone: 48, noise: 52, lofi: 42 },
    tomLow: { type: 'tom', pitch: -9, decay: 1.1, tone: 46, noise: 28, lofi: 48 },
    tomHigh: { type: 'tom', pitch: -3, decay: 0.82, tone: 44, noise: 30, lofi: 48 },
  
    keys: { type: 'keys', pitch: 5, decay: 3.8, tone: 36, attack: 0.24, lofi: 28 }, // Pad-like
    lead: { type: 'lead', pitch: 17, decay: 3.2, tone: 42, attack: 0.38, lofi: 24 }, // Glacial
    riser: { type: 'riser', pitch: -6, decay: 5.2, tone: 48, attack: 1.2, lofi: 18 } // Cinematic
  },
  rock: {
    kick: { type: 'kick', pitch: -2, decay: 0.32, tone: 56, noise: 19, lofi: 8, dist: 18 },
    snare: { type: 'snare', pitch: 0, decay: 0.17, tone: 54, noise: 76, lofi: 6, dist: 16 },
    hihatClosed: { type: 'hihat', pitch: 0, decay: 0.048, tone: 50, noise: 85, lofi: 8, closed: true },
    hihatOpen: { type: 'hihat', pitch: 0, decay: 0.24, tone: 54, noise: 81, lofi: 8, closed: false },
    clap: { type: 'clap', pitch: 0, decay: 0.15, tone: 39, noise: 87, lofi: 6, dist: 10 },
    rimshot: { type: 'snare', pitch: 8, decay: 0.058, tone: 70, noise: 39, lofi: 7 },
    tomLow: { type: 'tom', pitch: -4, decay: 0.42, tone: 70, noise: 15, lofi: 8 },
    tomHigh: { type: 'tom', pitch: 3, decay: 0.32, tone: 67, noise: 17, lofi: 8 },
    // rock instruments - raw, powerful
    bass: { type: 'bass', pitch: -2, decay: 0.84, tone: 63, attack: 0.0038, lofi: 9, dist: 24 },
    guitar: { type: 'guitar', pitch: 1, decay: 1.36, tone: 69, attack: 0.0022, lofi: 6, dist: 26 },
    keys: { type: 'keys', pitch: -4, decay: 1.08, tone: 57, attack: 0.0062, lofi: 7 }
  },
  jazz: {
    kick: { type: 'kick', pitch: -3, decay: 0.4, tone: 46, noise: 24, lofi: 22, dist: 8 },
    snare: { type: 'snare', pitch: -1, decay: 0.22, tone: 50, noise: 70, lofi: 20, dist: 6 },
    hihatClosed: { type: 'hihat', pitch: 0, decay: 0.055, tone: 44, noise: 82, lofi: 18, closed: true },
    hihatOpen: { type: 'hihat', pitch: 0, decay: 0.32, tone: 50, noise: 78, lofi: 18, closed: false },
    clap: { type: 'clap', pitch: -1, decay: 0.17, tone: 36, noise: 84, lofi: 16, dist: 5 },
    rimshot: { type: 'snare', pitch: 7, decay: 0.065, tone: 67, noise: 44, lofi: 14 },
    tomLow: { type: 'tom', pitch: -5, decay: 0.48, tone: 64, noise: 17, lofi: 20 },
    tomHigh: { type: 'tom', pitch: 2, decay: 0.36, tone: 62, noise: 19, lofi: 20 },
    // jazz instruments - warm, natural
    bass: { type: 'bass', pitch: 1, decay: 0.64, tone: 51, attack: 0.012, lofi: 17, dist: 6 },
    keys: { type: 'keys', pitch: -5, decay: 1.28, tone: 49, attack: 0.0088, lofi: 19 },
    guitar: { type: 'guitar', pitch: 3, decay: 0.96, tone: 59, attack: 0.0054, lofi: 18 }
  },
  vintage: {
    kick: { type: 'kick', pitch: -4, decay: 0.3, tone: 36, noise: 30, lofi: 60, dist: 28 },
    snare: { type: 'snare', pitch: -2, decay: 0.18, tone: 40, noise: 73, lofi: 55, dist: 22 },
    hihatClosed: { type: 'hihat', pitch: -3, decay: 0.06, tone: 36, noise: 80, lofi: 50, closed: true },
    hihatOpen: { type: 'hihat', pitch: -3, decay: 0.26, tone: 40, noise: 76, lofi: 50, closed: false },
    clap: { type: 'clap', pitch: -2, decay: 0.16, tone: 31, noise: 86, lofi: 45, dist: 16 },
    rimshot: { type: 'snare', pitch: 5, decay: 0.07, tone: 56, noise: 50, lofi: 40 },
    tomLow: { type: 'tom', pitch: -6, decay: 0.45, tone: 53, noise: 22, lofi: 45 },
    tomHigh: { type: 'tom', pitch: 0, decay: 0.34, tone: 50, noise: 24, lofi: 45 },
    // vintage instruments - nostalgic, character-rich
    bass: { type: 'bass', pitch: -4, decay: 0.68, tone: 47, attack: 0.014, lofi: 52, dist: 21 },
    keys: { type: 'keys', pitch: 4, decay: 0.94, tone: 44, attack: 0.017, lofi: 56 },
    guitar: { type: 'guitar', pitch: -1, decay: 0.88, tone: 55, attack: 0.0092, lofi: 49 }
  }
};

// Keep an immutable copy of the original kits so we can randomize around them
const baseSampleKits = JSON.parse(JSON.stringify(sampleKits));

const sampleInfo = {
  kick: { icon: 'ðŸ¥', name: 'Kick', category: 'drums' },
  snare: { icon: 'ðŸŽ¯', name: 'Snare', category: 'drums' },
  hihatClosed: { icon: 'ðŸ”’', name: 'Hi-Hat (Closed)', category: 'cymbals' },
  hihatOpen: { icon: 'ðŸ”“', name: 'Hi-Hat (Open)', category: 'cymbals' },
  clap: { icon: 'ðŸ‘', name: 'Clap', category: 'percussion' },
  rimshot: { icon: 'ðŸŽª', name: 'Rimshot', category: 'percussion' },
  tomLow: { icon: 'ðŸ¥', name: 'Tom (Low)', category: 'drums' },
  tomHigh: { icon: 'ðŸ¥', name: 'Tom (High)', category: 'drums' },
  bass:   { icon: 'ðŸ§¿', name: 'Bass',   category: 'instrument' },
  guitar: { icon: 'ðŸŽ¸', name: 'Guitar', category: 'instrument' },
  keys:   { icon: 'ðŸŽ¹', name: 'Keys',   category: 'instrument' },
  lead:   { icon: 'ðŸŽº', name: 'Lead',   category: 'instrument' },
  riser:  { icon: 'ðŸ“ˆ', name: 'Riser',  category: 'sfx' },
  fx:     { icon: 'âœ¨', name: 'FX',     category: 'sfx' }
};
  
let currentKit = 'lofi';
let currentSample = null;
let currentBuffer = null;
let sampleParams = {};

// Initialize UI
function initSampleLibrary() {
  renderSampleList();
  attachEventListeners();
  updateSampleCount();
}

function renderSampleList() {
  const kit = sampleKits[currentKit];
  const sampleList = document.getElementById('sampleList');
  
  sampleList.innerHTML = '';
  
  Object.keys(kit).forEach(sampleKey => {
    const info = sampleInfo[sampleKey];
    const params = kit[sampleKey];
    
    const item = document.createElement('div');
    item.className = 'sample-item';
    item.dataset.sample = sampleKey;
    
    item.innerHTML = `
      <div class="sample-icon">${info.icon}</div>
      <div class="sample-info">
        <div class="sample-name">${info.name}</div>
        <div class="sample-meta">${info.category} â€¢ ${currentKit}</div>
      </div>
      <div class="sample-actions">
        <button class="sample-action-btn" data-action="preview" title="Preview">â–¶ï¸</button>
        <button class="sample-action-btn" data-action="edit" title="Edit">âœï¸</button>
        <button class="sample-action-btn" data-action="export" title="Export">ðŸ“¥</button>
      </div>
    `;
    
    // Click to select
    item.addEventListener('click', (e) => {
      if (!e.target.closest('.sample-action-btn')) {
        selectSample(sampleKey);
      }
    });
    
    // Action buttons
    item.querySelector('[data-action="preview"]').addEventListener('click', (e) => {
      e.stopPropagation();
      previewSample(sampleKey);
    });
    
    item.querySelector('[data-action="edit"]').addEventListener('click', (e) => {
      e.stopPropagation();
      selectSample(sampleKey);
    });
    
    item.querySelector('[data-action="export"]').addEventListener('click', (e) => {
      e.stopPropagation();
      exportSample(sampleKey);
    });
    
    sampleList.appendChild(item);
  });
}

function selectSample(sampleKey) {
  currentSample = sampleKey;
  sampleParams = { ...sampleKits[currentKit][sampleKey] };
  
  // Update UI
  document.querySelectorAll('.sample-item').forEach(item => {
    item.classList.toggle('active', item.dataset.sample === sampleKey);
  });
  
  // Update editor
  updateEditor();
  generateAndDisplayWaveform();
}

function updateEditor() {
  if (!currentSample) return;
  
  const info = sampleInfo[currentSample];
  document.getElementById('selectedSampleName').textContent = info.name;
  document.getElementById('selectedSampleInfo').textContent = 
    `${info.category} â€¢ ${currentKit} kit`;
  
  // Update sliders
  document.getElementById('samplePitch').value = sampleParams.pitch || 0;
  document.getElementById('sampleDecay').value = sampleParams.decay || 0.2;
  document.getElementById('sampleTone').value = sampleParams.tone || 50;
  document.getElementById('sampleNoise').value = sampleParams.noise || 30;
  document.getElementById('sampleAttack').value = sampleParams.attack || 0.001;
  document.getElementById('sampleVolume').value = 0;
  document.getElementById('sampleLofi').value = sampleParams.lofi || 0;
  document.getElementById('sampleDist').value = sampleParams.dist || 0;
  
  updateEditorValues();
}

function updateEditorValues() {
  document.getElementById('samplePitchValue').textContent = 
    (parseFloat(document.getElementById('samplePitch').value)).toFixed(1);
  document.getElementById('sampleDecayValue').textContent = 
    (parseFloat(document.getElementById('sampleDecay').value)).toFixed(3) + 's';
  document.getElementById('sampleToneValue').textContent = 
    Math.round(document.getElementById('sampleTone').value) + '%';
  document.getElementById('sampleNoiseValue').textContent = 
    Math.round(document.getElementById('sampleNoise').value) + '%';
  document.getElementById('sampleAttackValue').textContent = 
    (parseFloat(document.getElementById('sampleAttack').value)).toFixed(3) + 's';
  document.getElementById('sampleVolumeValue').textContent = 
    parseFloat(document.getElementById('sampleVolume').value).toFixed(1) + 'dB';
  document.getElementById('sampleLofiValue').textContent = 
    Math.round(document.getElementById('sampleLofi').value) + '%';
  document.getElementById('sampleDistValue').textContent = 
    Math.round(document.getElementById('sampleDist').value) + '%';
}

function generateAndDisplayWaveform() {
  if (!currentSample) return;
  
  currentBuffer = generateSampleBuffer();
  
  const canvas = document.getElementById('sampleWaveform');
  if (canvas && currentBuffer) {
    synth.drawWaveform(currentBuffer, canvas);
  }
}

function generateSampleBuffer() {
  if (!currentSample) return null;

  const params = {
    pitch: parseFloat(document.getElementById('samplePitch').value),
    decay: parseFloat(document.getElementById('sampleDecay').value),
    tone:  parseFloat(document.getElementById('sampleTone').value),
    noise: parseFloat(document.getElementById('sampleNoise').value),
    attack:parseFloat(document.getElementById('sampleAttack').value),
    lofi:  parseFloat(document.getElementById('sampleLofi').value),
    dist:  parseFloat(document.getElementById('sampleDist').value)
  };

  const type = sampleParams.type;
  const closed = sampleParams.closed;

  switch (type) {
    case 'kick':  return synth.generateKick(params);
    case 'snare': return synth.generateSnare(params);
    case 'hihat': return synth.generateHihat(params, closed);
    case 'clap':  return synth.generateClap(params);
    case 'tom':   return synth.generateTom(params, sampleParams.pitch || 0);
    // NEW
    case 'bass':  return synth.generateBass(params);
    case 'guitar':return synth.generateGuitar(params);
    case 'keys':  return synth.generateKeys(params);
    case 'lead':  return synth.generateLead(params);
    case 'riser': return synth.generateRiser(params);
    case 'fx':    return synth.generateFX(params);
    default: return null;
  }
}


function generateBufferForSampleConfig(config) {
  if (!config) return null;

  const { type, closed } = config;
  let buffer = null;

  if (type === 'kick') {
    buffer = synth.generateKick(config);
  } else if (type === 'snare') {
    buffer = synth.generateSnare(config);
  } else if (type === 'hihat') {
    buffer = synth.generateHihat(config, closed);
  } else if (type === 'clap') {
    buffer = synth.generateClap(config);
  } else if (type === 'tom') {
    buffer = synth.generateTom(config, config.pitch || 0);
  }

  return buffer;
}

function generateRandomizedKit(kitName) {
  const baseKit = baseSampleKits[kitName];
  if (!baseKit) return null;

  // Read generator controls
  const character = parseFloat(document.getElementById('genCharacter')?.value || 50); // 0â€“100
  const variation = parseFloat(document.getElementById('genVariation')?.value || 0);  // 0â€“100
  const lofi = parseFloat(document.getElementById('genLofi')?.value || 0);            // 0â€“100

  const charNorm = (character - 50) / 50; // -1 (warm/dark) .. +1 (bright/punchy)
  const varNorm = variation / 100;        // 0..1 how wild to go
  const lofiNorm = lofi / 100;            // 0..1 lo-fi intensity

  const newKit = {};

  Object.entries(baseKit).forEach(([sampleKey, base]) => {
    const cfg = { ...base };

    // 1) Pitch: more variation = more semitone wander
    const maxPitchSpread = 2 + 6 * varNorm; // up to Â±8 semis at 100% variation
    const randPitchOffset = (Math.random() * 2 - 1) * maxPitchSpread;
    cfg.pitch = (base.pitch || 0) + randPitchOffset;

    // 2) Decay: Â± up to 40% depending on variation
    const decayFactor = 1 + (Math.random() * 2 - 1) * (0.4 * varNorm);
    cfg.decay = +(base.decay * decayFactor).toFixed(3);

    // 3) Tone: "Character" biases darker or brighter + some random
    const toneBaseShift = charNorm * 25;                       // -25 to +25
    const toneRand = (Math.random() * 2 - 1) * (10 * varNorm); // extra spice
    cfg.tone = clamp(base.tone + toneBaseShift + toneRand, 0, 100);

    // 4) Noise: mostly driven by variation (more variation = more chaos)
    const noiseRand = (Math.random() * 2 - 1) * (20 * varNorm);
    cfg.noise = clamp(base.noise + noiseRand, 0, 100);

    // 5) Distortion: mostly increases as Character goes â€œbrightâ€
    const distBase = base.dist || 0;
    const distChar = Math.max(0, charNorm) * 30;              // up to +30 from character
    const distRand = (Math.random() * 2 - 1) * (10 * varNorm);
    cfg.dist = clamp(distBase + distChar + distRand, 0, 100);

    // 6) Lo-Fi: blend base lo-fi with slider value, biasing toward slider
    const baseLofi = base.lofi || 0;
    const mix = 0.4 + 0.6 * lofiNorm; // 40â€“100% influence from slider
    cfg.lofi = clamp(baseLofi * (1 - mix) + lofi * mix, 0, 100);

    // Preserve type/closed flags
    cfg.type = base.type;
    if (base.closed !== undefined) {
      cfg.closed = base.closed;
    }

    newKit[sampleKey] = cfg;
  });

  return newKit;
}

async function buildKitZip(kitName = currentKit) {
  if (!window.JSZip) {
    alert('ZIP library (JSZip) is not loaded.');
    return null;
  }

  const kit = sampleKits[kitName];
  if (!kit) {
    alert('No kit found for "' + kitName + '".');
    return null;
  }

  const zip = new JSZip();
  const folder = zip.folder(`${kitName}_kit`);

  for (const [sampleKey, config] of Object.entries(kit)) {
    const buffer = generateBufferForSampleConfig(config);
    if (!buffer) continue;

    const wavArrayBuffer = synth.bufferToWav(buffer);
    const filename = `${kitName}_${sampleKey}.wav`;
    folder.file(filename, wavArrayBuffer); // ArrayBuffer is fine
  }

  // Generate zip as a Blob
  const blob = await zip.generateAsync({ type: 'blob' });
  return blob;
}

async function previewSample(sampleKey) {
  const kit = sampleKits[currentKit];
  if (!kit) return;

  const params = kit[sampleKey];
  if (!params) return;

  const type = params.type;
  const closed = params.closed;

  // Generate audio buffer from SampleSynthesizer
  let buffer = null;
  switch (type) {
    case 'kick':   buffer = synth.generateKick(params); break;
    case 'snare':  buffer = synth.generateSnare(params); break;
    case 'hihat':  buffer = synth.generateHihat(params, closed); break;
    case 'clap':   buffer = synth.generateClap(params); break;
    case 'tom':    buffer = synth.generateTom(params, params.pitch || 0); break;
    case 'bass':   buffer = synth.generateBass(params); break;
    case 'guitar': buffer = synth.generateGuitar(params); break;
    case 'keys':   buffer = synth.generateKeys(params); break;
    case 'lead':   buffer = synth.generateLead(params); break;
    case 'riser':  buffer = synth.generateRiser(params); break;
    case 'fx':     buffer = synth.generateFX(params); break;
    default:       return;
  }

  if (!buffer) return;

  // Make sure the synth's AudioContext is running
  const ac = synth.audioContext;
  if (ac && ac.state === 'suspended') {
    try {
      await ac.resume();
    } catch (err) {
      console.warn('Could not resume audio context for preview', err);
    }
  }

  // Play at a safe level (dB)
  //   0  dB = full blast
  //  -6 dB = half power
  // -12 dB = nice safe preview
  synth.play(buffer, -12);
}


function exportSample(sampleKey) {
  const params = sampleKits[currentKit][sampleKey];
  if (!params) return;

  const info = sampleInfo[sampleKey];
  const type = params.type;
  const closed = params.closed;

  let buffer;
  if (type === 'kick') {
    buffer = synth.generateKick(params);
  } else if (type === 'snare') {
    buffer = synth.generateSnare(params);
  } else if (type === 'hihat') {
    buffer = synth.generateHihat(params, closed);
  } else if (type === 'clap') {
    buffer = synth.generateClap(params);
  } else if (type === 'tom') {
    buffer = synth.generateTom(params, params.pitch || 0);
  } else if (type === 'bass') {
    buffer = synth.generateBass(params);
  } else if (type === 'guitar') {
    buffer = synth.generateGuitar(params);
  } else if (type === 'keys') {
    buffer = synth.generateKeys(params);
  } else if (type === 'lead') {
    buffer = synth.generateLead(params);
  } else if (type === 'riser') {
    buffer = synth.generateRiser(params);
  } else if (type === 'fx') {
    buffer = synth.generateFX(params);
  }

  if (buffer) {
    const niceName = info?.name || sampleKey;
    const filename = `${currentKit}_${sampleKey}.wav`;
    synth.exportWAV(buffer, filename);
  }
}


function updateSampleCount() {
  const count = Object.keys(sampleKits[currentKit]).length;
  document.getElementById('sampleCount').textContent = `${count} sounds`;
}

function attachEventListeners() {
  // Kit selector
  document.querySelectorAll('[data-kit]').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('[data-kit]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentKit = btn.dataset.kit;
      renderSampleList();
      updateSampleCount();
      currentSample = null;
      currentBuffer = null;
      
      document.getElementById('selectedSampleName').textContent = 'Select a sample';
      document.getElementById('selectedSampleInfo').textContent = 'Click any sample to edit';
    });
  });

  // Editor sliders
  const sliders = [
    'samplePitch', 'sampleDecay', 'sampleTone', 'sampleNoise',
    'sampleAttack', 'sampleVolume', 'sampleLofi', 'sampleDist'
  ];
  
  sliders.forEach(id => {
    const slider = document.getElementById(id);
    if (slider) {
      slider.addEventListener('input', () => {
        updateEditorValues();
        generateAndDisplayWaveform();
      });
    }
  });

  // Preview button
  document.getElementById('previewSampleBtn')?.addEventListener('click', () => {
    if (currentBuffer) {
      const volume = parseFloat(document.getElementById('sampleVolume').value);
      synth.play(currentBuffer, volume);
    }
  });

  // Save button
  document.getElementById('saveSampleBtn')?.addEventListener('click', () => {
    if (!currentSample) return;
    
    sampleKits[currentKit][currentSample] = {
      ...sampleParams,
      pitch: parseFloat(document.getElementById('samplePitch').value),
      decay: parseFloat(document.getElementById('sampleDecay').value),
      tone: parseFloat(document.getElementById('sampleTone').value),
      noise: parseFloat(document.getElementById('sampleNoise').value),
      attack: parseFloat(document.getElementById('sampleAttack').value),
      lofi: parseFloat(document.getElementById('sampleLofi').value),
      dist: parseFloat(document.getElementById('sampleDist').value)
    };
    
    alert('âœ“ Sample saved to kit!');
  });

  // Export button
  document.getElementById('exportSampleBtn')?.addEventListener('click', () => {
    if (currentBuffer && currentSample) {
      const info = sampleInfo[currentSample];
      const filename = `${currentKit}_${currentSample}_custom.wav`;
      synth.exportWAV(currentBuffer, filename);
    }
  });

  // Reset button
  document.getElementById('resetSampleBtn')?.addEventListener('click', () => {
    if (currentSample) {
      sampleParams = { ...sampleKits[currentKit][currentSample] };
      updateEditor();
      generateAndDisplayWaveform();
    }
  });

  // Send current sample to multitrack
  document.getElementById('sendSampleToMultitrackBtn')?.addEventListener('click', () => {
    if (!currentBuffer || !currentSample) {
      alert('No sample selected / generated yet.');
      return;
    }
  
    if (typeof addExternalAudioTrackFromBuffer !== 'function') {
      alert('Multitrack system not ready yet.');
      return;
    }
  
    const name = `${currentKit}_${currentSample}_oneShot.wav`;
  
    try {
      // currentBuffer is an AudioBuffer from SampleSynthesizer
      addExternalAudioTrackFromBuffer(currentBuffer, name);
  
      if (typeof renderMultitrack === 'function') {
        renderMultitrack();
      }
  
      if (typeof showToast === 'function') {
        showToast(`ðŸ“¥ Sent "${name}" to the multitrack`, 'success');
      } else {
        alert(`ðŸ“¥ Sent "${name}" to the multitrack!`);
      }
    } catch (err) {
      console.error(err);
      alert('Failed to send sample to multitrack. Check the console for details.');
    }
  });
  
  // Helper: turn an AudioBuffer from SampleSynthesizer into a Blob URL
  function bufferToObjectUrlFromSynth(buffer) {
    // use the *global* synth (SampleSynthesizer instance) you already created
    const wavArrayBuffer = synth.bufferToWav(buffer); // returns ArrayBuffer for WAV
    const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
    return URL.createObjectURL(blob);
  }

  // ==================== KIT SELECTOR GRID ====================
  const kitSelector = document.getElementById('kitSelector');
  if (kitSelector) {
    kitSelector.addEventListener('click', (e) => {
      const preset = e.target.closest('.preset');
      if (!preset) return;
  
      // Remove active class from all presets
      kitSelector.querySelectorAll('.preset').forEach(btn => btn.classList.remove('active'));
  
      // Mark this one active
      preset.classList.add('active');
  
      // Set the currentKit from data-kit
      currentKit = preset.dataset.kit || 'default';
  
      // Feedback
      showToast(`ðŸŽ› Selected "${currentKit}" kit`, 'info');
    });
  }

  // ==================== LOAD KIT (DRUMS + INSTRUMENTS) ====================
  document.getElementById('loadKitBtn')?.addEventListener('click', () => {
    if (
      typeof DRUM_SAMPLES === 'undefined' ||
      typeof synths === 'undefined' ||
      typeof instruments === 'undefined'
    ) {
      alert('Sequencer is not ready yet. Try again after the app finishes loading.');
      return;
    }
  
    const kit = sampleKits[currentKit];
    if (!kit) {
      alert(`No kit found for "${currentKit}".`);
      return;
    }
  
    // Use the same engine as the Samples tab
    const synthEngine = window.synth instanceof SampleSynthesizer
      ? window.synth
      : new SampleSynthesizer();
  
    // For each entry in the kit (drums + instruments)
    Object.entries(kit).forEach(([name, cfg]) => {
      let buffer = null;
  
      switch (cfg.type) {
        case 'kick':   buffer = synthEngine.generateKick(cfg);   break;
        case 'snare':  buffer = synthEngine.generateSnare(cfg);  break;
        case 'hihat':  buffer = synthEngine.generateHihat(cfg, cfg.closed); break;
        case 'clap':   buffer = synthEngine.generateClap(cfg);   break;
        case 'tom':    buffer = synthEngine.generateTom(cfg, cfg.pitch || 0); break;
  
        case 'bass':   buffer = synthEngine.generateBass(cfg);   break;
        case 'guitar': buffer = synthEngine.generateGuitar(cfg); break;
        case 'keys':   buffer = synthEngine.generateKeys(cfg);   break;
        case 'lead':   buffer = synthEngine.generateLead(cfg);   break;
        case 'riser':  buffer = synthEngine.generateRiser(cfg);  break;
        case 'fx':     buffer = synthEngine.generateFX(cfg);     break;
        default:
          // if something exotic sneaks in, bail quietly
          return;
      }
  
      if (!buffer) return;
  
      // Keep headroom
      if (typeof normalizeBufferInPlace === 'function') {
        normalizeBufferInPlace(buffer, -1); // ~8 dB
      }
  
      const url = bufferToObjectUrlFromSynth(buffer);
  
      // ----------------- DRUM MAPPING â†’ DRUM_SAMPLES -----------------
      switch (name) {
        case 'kick':
          DRUM_SAMPLES.kick = url;
          break;
        case 'snare':
          DRUM_SAMPLES.snare = url;
          break;
        case 'hihatClosed':
          // your drum engine uses "hihat" only
          DRUM_SAMPLES.hihat = url;
          break;
        case 'hihatOpen':
          // use open hat as crash/ride stand-ins
          DRUM_SAMPLES.crash = url;
          DRUM_SAMPLES.ride  = url;
          break;
        case 'clap':
          DRUM_SAMPLES.clap = url;
          break;
        case 'rimshot':
          DRUM_SAMPLES.rimshot = url;
          break;
        case 'tomLow':
        case 'tomHigh':
          DRUM_SAMPLES.tom = url;
          break;
        default:
          break;
      }
  
      // ----------------- DRUM TRACKS: rebuild synths -----------------
      const instMeta = instruments[name];
      if (instMeta && instMeta.type === 'drum') {
        // drum track whose id matches sample name (kick, snare, etc.)
        if (synths[name]?.dispose) {
          try { synths[name].dispose(); } catch {}
        }
        synths[name] = createDrumSynth(name);
        if (instMeta.channel && synths[name]?.connect) {
          synths[name].connect(instMeta.channel);
        }
        return; // donâ€™t treat this one as a melodic instrument
      }
  
      // ----------------- INSTRUMENT TRACKS (bass/keys/guitar/lead/fx/riser) -----------------
      if (['bass', 'guitar', 'keys', 'lead', 'fx', 'riser'].includes(name)) {
        const inst = instruments[name];
        if (!inst) return;
      
        // Dispose old synth if present
        if (synths[name]?.dispose) {
          try { synths[name].dispose(); } catch {}
        }
      
        const player = new Tone.Player({
          url,
          autostart: false,
          fadeOut: 0.05,
          volume: -6
        });
      
        // Wire through existing channel -> mixer already handles routing
        if (inst.channel) {
          player.connect(inst.channel);
        } else if (window.SEQUENCER_MASTER_BUS) {
          player.connect(window.SEQUENCER_MASTER_BUS);
        } else {
          player.toDestination();
        }
      
        synths[name] = {
          player,
      
          // ðŸŽ¹ Theory-aware trigger
          triggerAttackRelease: (note, duration, time, velocity = 1) => {
            if (!player.loaded) return;
      
            const when = time ?? Tone.now();
      
            // Pick a harmony-based note for this instrument
            const currentChord =
              state.currentChord ||
              (state.progression && state.progression[0]) ||
              null;
      
            const noteName = getInstrumentNote(name, 0, currentChord);
            const rate = getPlaybackRateForNote(noteName);
      
            // Apply pitch via playbackRate
            player.playbackRate = rate;
      
            // (optional) map velocity -> volume if you want later
            player.start(when);
          },
      
          connect: (node) => {
            player.disconnect();
            player.connect(node);
            return player;
          },
      
          toDestination: () => player.toDestination(),
          dispose: () => player.dispose(),
          get loaded() {
            return player.loaded;
          }
        };
      }
    });
  
    showToast?.(`ðŸŽ¹ Loaded "${currentKit}" kit (drums + instruments) into the sequencer.`, 'success');
  });

  // ==================== RESET TO FACTORY DRUM SAMPLES ====================
  document.getElementById('defaultKitBtn')?.addEventListener('click', () => {
    // 1) Restore the original drum sample URLs
    Object.keys(DEFAULT_DRUM_SAMPLES).forEach(key => {
      DRUM_SAMPLES[key] = DEFAULT_DRUM_SAMPLES[key];
    });
  
    // 2) Rebuild the drum synths so the sequencer uses the factory sounds again
    const drumNames = ['kick','snare','hihat','tom','clap','rimshot','crash','ride','fx','riser','ambience'];
  
    drumNames.forEach(name => {
      const inst = instruments[name];
      if (!inst) return;
  
      // dispose old synth if present
      if (synths[name]?.dispose) {
        try { synths[name].dispose(); } catch (e) {
          console.warn(`Error disposing old synth for ${name}`, e);
        }
      }
  
      const s = createDrumSynth(name);
      synths[name] = s;
  
      // reconnect through existing channel / mixer
      if (inst.channel && s.connect) {
        s.connect(inst.channel);
      }
    });
  
    showToast('ðŸ¥ Restored factory drum samples.', 'success');
  });
  
  // Generate pack (real randomizer)
  document.getElementById('generatePackBtn')?.addEventListener('click', () => {
    const newKit = generateRandomizedKit(currentKit);
    if (!newKit) {
      alert('Unable to generate kit â€“ base kit not found.');
      return;
    }
  
    // Overwrite the working kit with the new randomized one
    sampleKits[currentKit] = newKit;
  
    // Re-render the list so meta text stays fresh
    renderSampleList();
  
    // Clear selection so user intentionally picks a sample to edit
    currentSample = null;
    currentBuffer = null;
    document.getElementById('selectedSampleName').textContent = 'Select a sample';
    document.getElementById('selectedSampleInfo').textContent =
      `Randomized ${currentKit} kit â€” click any sample to edit`;
  
    if (typeof showToast === 'function') {
      showToast(`ðŸŽ² Generated a new ${currentKit} kit`, 'info');
    } else {
      alert(`ðŸŽ² Generated a new variant of the "${currentKit}" kit!`);
    }
  });

  // Download pack (real ZIP export)
  document.getElementById('downloadPackBtn')?.addEventListener('click', async () => {
    const btn = document.getElementById('downloadPackBtn');
  
    try {
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'â³ Building pack...';
      }
  
      const zipBlob = await buildKitZip(currentKit);
      if (!zipBlob) return;
  
      const dateStamp = new Date().toISOString().slice(0, 10); // e.g. 2025-11-07
      const filename = `${currentKit}_kit_${dateStamp}.zip`;
  
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
  
      if (typeof showToast === 'function') {
        showToast(`ðŸ“¦ Downloaded "${currentKit}" kit as ZIP`, 'success');
      } else {
        alert(`ðŸ“¦ Downloaded "${currentKit}" kit as ${filename}`);
      }
    } catch (err) {
      console.error('Error building kit ZIP:', err);
      alert('Failed to build sample pack ZIP. Check console for details.');
    } finally {
      if (btn) {
        btn.disabled = false;
        btn.textContent = 'ðŸ“¦ Download Pack';
      }
    }
  });

  // Generator sliders
  document.getElementById('genCharacter')?.addEventListener('input', (e) => {
    const val = e.target.value;
    const label = val < 33 ? 'Warm' : val < 66 ? 'Balanced' : 'Bright';
    document.getElementById('genCharacterValue').textContent = label;
  });

  document.getElementById('genVariation')?.addEventListener('input', (e) => {
    const val = e.target.value;
    const label = val < 33 ? 'Low' : val < 66 ? 'Medium' : 'High';
    document.getElementById('genVariationValue').textContent = label;
  });

  document.getElementById('genLofi')?.addEventListener('input', (e) => {
    document.getElementById('genLofiValue').textContent = e.target.value + '%';
  });

  // Refresh button
  document.getElementById('refreshSamplesBtn')?.addEventListener('click', () => {
    renderSampleList();
    alert('âœ“ Sample library refreshed!');
  });
}

// ==================== FAB CONTROLLER ====================
class FABController {
  constructor() {
    this.fab = document.getElementById('dawFab');
    this.fabIcon = document.getElementById('dawFabIcon');
    this.menu = document.getElementById('dawFabMenu');
    this.isOpen = false;

    // Create backdrop once
    this.backdrop = document.createElement('div');
    this.backdrop.className = 'daw-fab-backdrop';
    document.body.appendChild(this.backdrop);

    this.init();
  }

  init() {
    if (!this.fab || !this.menu) return;

    // Toggle menu on FAB click
    this.fab.addEventListener('click', () => this.toggle());

    // Close on backdrop click
    this.backdrop.addEventListener('click', () => this.close());

    // Handle menu item clicks
    const menuItems = this.menu.querySelectorAll('.daw-fab-menu-item');
    console.log('Found menu items:', menuItems.length); // ADD THIS
    
    menuItems.forEach((item, index) => {
      console.log(`Item ${index}:`, item.dataset.action); // ADD THIS
      item.addEventListener('click', (e) => {
        console.log('Item clicked:', item.dataset.action); // ADD THIS
        const action = item.dataset.action;
        this.handleAction(action);
        this.close();
      });
    });

    // Close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isOpen) this.close();
    });

    // Close when tab changes
    document.addEventListener('tabChange', () => this.close());
  }

  toggle() {
    this.isOpen ? this.close() : this.open();
  }

  open() {
    this.isOpen = true;
    this.fab.classList.add('open');
    this.menu.classList.add('open');
    this.backdrop.classList.add('open');
    if (this.fabIcon) this.fabIcon.textContent = 'Ã—';
    if (navigator.vibrate) navigator.vibrate(10);
  }

  close() {
    this.isOpen = false;
    this.fab.classList.remove('open');
    this.menu.classList.remove('open');
    this.backdrop.classList.remove('open');
    if (this.fabIcon) this.fabIcon.textContent = '+';
  }

  handleAction(action) {
    switch (action) {
      case 'add-track':
        document.getElementById('addTrackBtnLeft')?.click();
        break;
      case 'toggle-inspector':
        const inspector = document.querySelector('.daw-inspector');
        inspector?.classList.toggle('inspector-open');
        break;
      case 'toggle-fx':
        const fxPanel = document.getElementById('fxChainPanel');
        fxPanel?.classList.toggle('open');
        break;
      case 'record-arm':
        const selectedStrip = document.querySelector('.daw-track-strip.selected');
        if (selectedStrip) {
          const armBtn = selectedStrip.querySelector('.track-mini-btn.arm');
          armBtn?.click();
        }
        break;
      case 'undo':
        document.getElementById('undoBtn')?.click();
        break;
    }
  }

  addTrack() {
    if (typeof showAddTrackDialog === 'function') {
      showAddTrackDialog();
    } else if (typeof createTrack === 'function') {
      createTrack();
      if (typeof showToast === 'function') showToast('âœ… Track added', 'success');
    }
  }

  toggleInspector() {
    const inspector = document.querySelector('.daw-inspector');
    if (!inspector) return;
    inspector.classList.toggle('inspector-open');
    const isOpen = inspector.classList.contains('inspector-open');
    inspector.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    if (typeof showToast === 'function') {
      showToast(isOpen ? 'ðŸŽ›ï¸ Inspector opened' : 'ðŸŽ›ï¸ Inspector closed', 'info');
    }
  }

  toggleFX() {
    const fxPanel = document.getElementById('fxChainPanel');
    if (!fxPanel) return;
    const isOpen = !fxPanel.classList.contains('open');
    fxPanel.classList.toggle('open', isOpen);
    fxPanel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    if (typeof showToast === 'function') {
      showToast(isOpen ? 'âœ¨ FX chain opened' : 'âœ¨ FX chain closed', 'info');
    }
  }

  quickRecordArm() {
    const selectedStrip = document.querySelector('.daw-track-strip.selected');
    if (!selectedStrip) {
      if (typeof showToast === 'function') showToast('âš ï¸ Tap a track first', 'warning');
      return;
    }
    const trackId = selectedStrip.dataset.trackId;
    const armBtn = document.querySelector(`.track-mini-btn.arm[data-track-id="${trackId}"]`);
    if (armBtn) armBtn.click();
  }

  undo() {
    if (window.multitrackHistory && typeof multitrackHistory.undo === 'function') {
      multitrackHistory.undo();
    } else if (typeof showToast === 'function') {
      showToast('âš ï¸ Nothing to undo', 'warning');
    }
  }
}

let fabController;

// === Cleanup on resize to desktop ===
window.addEventListener('resize', () => {
  if (window.innerWidth > 900 && fabController) fabController.close();
});

function initFAB() {
  if (!fabController && window.innerWidth <= 900) {
    fabController = new FABController();
  }
}


// ===================================================
// ðŸŽ¼ HARMONY TAB INTEGRATION
// ===================================================

// --- 1. Initialize selectors ---
function populateHarmonySelectors() {
  const keySelect = document.getElementById('keySelect');
  const scaleSelect = document.getElementById('scaleSelect');
  const octaveSelect = document.getElementById('octaveSelect');

  const keys = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const scales = ['major','minor','dorian','mixolydian','lydian','phrygian','pentatonic'];
  const octaves = [2,3,4,5];

  keySelect.innerHTML = keys.map(k => `<option value="${k}">${k}</option>`).join('');
  scaleSelect.innerHTML = scales.map(s => `<option value="${s}">${s}</option>`).join('');
  octaveSelect.innerHTML = octaves.map(o => `<option value="${o}">${o}</option>`).join('');

  keySelect.value = state.key;
  scaleSelect.value = state.scale;
  octaveSelect.value = state.octave;
}

// --- 2. Generate chords based on selected key/scale ---
function generateAvailableChords() {
  const key = document.getElementById('keySelect').value;
  const scale = document.getElementById('scaleSelect').value;
  const octave = parseInt(document.getElementById('octaveSelect').value, 10);

  const scaleData = Tonal.Scale.get(`${key} ${scale}`);
  const triads = scaleData.notes.map((n, i) => {
    const third = scaleData.notes[(i + 2) % scaleData.notes.length];
    const fifth = scaleData.notes[(i + 4) % scaleData.notes.length];
    return [n + octave, third + octave, fifth + octave];
  });

  const chordChips = document.getElementById('chordChips');
  chordChips.innerHTML = '';

  triads.forEach((chord) => {
    const chip = document.createElement('button');
    chip.className = 'chip';
    chip.textContent = chord.map(n => n.replace(/\d/, '')).join('-');
    chip.addEventListener('click', () => addChordToProgression(chord));
    chordChips.appendChild(chip);
  });
}

document.getElementById('genProgBtn')?.addEventListener('click', generateAvailableChords);

// --- 3. Manage active progression ---
function addChordToProgression(chord) {
  state.progression.push(chord);
  renderProgressionChips();
}

function renderProgressionChips() {
  const container = document.getElementById('progressionChips');
  container.innerHTML = '';

  state.progression.forEach((chord, i) => {
    const chip = document.createElement('button');
    chip.className = 'chip active';
    chip.textContent = chord.map(n => n.replace(/\d/, '')).join('-');
    chip.addEventListener('click', () => {
      state.progression.splice(i, 1);
      renderProgressionChips();
    });
    container.appendChild(chip);
  });
}

document.getElementById('clearProgBtn')?.addEventListener('click', () => {
  state.progression = [];
  renderProgressionChips();
});

// --- 4. Apply harmony settings ---
document.getElementById('keySelect')?.addEventListener('change', e => state.key = e.target.value);
document.getElementById('scaleSelect')?.addEventListener('change', e => state.scale = e.target.value);
document.getElementById('octaveSelect')?.addEventListener('change', e => state.octave = parseInt(e.target.value, 10));

// === Splash / Initialization UI ===
const splash = {
  el: null,
  messageEl: null,
  barEl: null
};

function initSplash() {
  splash.el = document.getElementById('splashOverlay');
  splash.messageEl = document.getElementById('splashMessage');
  splash.barEl = document.getElementById('splashBar');

  if (!splash.el) return;
  splash.el.classList.remove('hidden');
  // Start at a tiny bit of progress so the bar isn't empty
  if (splash.barEl) splash.barEl.style.width = '8%';
}

function updateSplash(message, percent) {
  if (!splash.el) return;

  if (message && splash.messageEl) {
    splash.messageEl.textContent = message;
  }
  if (typeof percent === 'number' && splash.barEl) {
    const clamped = Math.max(0, Math.min(100, percent));
    splash.barEl.style.width = `${clamped}%`;
  }
}

function hideSplash() {
  if (!splash.el) return;
  splash.el.classList.add('hidden');
}
  
// -------------------- Initialization --------------------
function init() {
  // === 0. Splash: start ===
  initSplash();
  updateSplash('Preparing license systemâ€¦', 10);

  // === 1. Licensing & UI gating ===
  initLicenseUI();          // sets up modal + auto-unlock if localStorage says Pro
  gateTabsForFreeUsers();   // lock non-generate tabs for free users
  if (isPro()) {
    enableProFeatures();    // ensure UI is fully unlocked if already Pro
  }

  updateSplash('Starting audio engineâ€¦', 35);

  // === 2. Core audio systems ===
  initAudioContext();
  initAudio();
  ensurePatternLength(state.sequenceLength);

  updateSplash('Wiring controls & multitrackâ€¦', 55);

  // === 3. Event wiring ===
  setupEventListeners();
  setupMultitrackListeners();
  setupRegionContextMenu();

  updateSplash('Rendering interfaceâ€¦', 75);

  // === 4. UI rendering ===
  renderSequencer();
  renderMixer();
  renderFX();
  renderHarmony();
  renderPresets();
  renderMultitrack();
  updateAllDisplays();

  updateSplash('Finalizing visualizer & samplesâ€¦', 90);

  // === 5. Final touches ===
  initVisualizerOnce();
  unlockAudioOnce();
  checkAudioPermissions();
  checkSamplesLoaded();
  loadSavedVibe();
  setupStemImport();
  initSampleLibrary();
  setupPreviewButton();
  updateUndoRedoButtons();

  // --- 6. Init Harmony tab on load ---
  populateHarmonySelectors();
  generateAvailableChords();
  renderProgressionChips();

  updateSplash('Ready! Have fun âœ¨', 100);

  setInterval(updateDAWStatus, 500);
  initPlayheadFollow();

  initFAB();
  // Small delay so the user sees "Ready!" before it disappears
  setTimeout(hideSplash, 3000);
}
  
// -------------------- Entry Point --------------------
window.addEventListener('load', () => {
  if (typeof window.Tonal === 'undefined') {
    console.warn('âš ï¸ Tonal.js failed to load â€” injecting fallback.');
    window.Tonal = {
      Scale: {
        get: () => ({ notes: ['C','D','E','F','G','A','B'] })
      },
      Chord: {
        get: () => ({ notes: ['C','E','G'] })
      }
    };
  }
  init();
});

</script>

</body>
</html>
