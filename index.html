<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#000000"/>
  <title>8-Beat Studio</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./lofi8Beat.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <style>
   /* =========================================================
      8-BEAT STUDIO — PROFESSIONAL ULTRA-MODERN REDESIGN
      Premium glassmorphic design with advanced micro-interactions
      Responsive grid system • Advanced animations • Pro gradients
    ========================================================= */
    
    /* Professional Font Stack */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    /* -------- Design System Tokens -------- */
    :root{
      /* Typography Scale */
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'Courier New', monospace;
      
      --text-xs: clamp(0.7rem, 0.65rem + 0.25vw, 0.75rem);
      --text-sm: clamp(0.8rem, 0.75rem + 0.25vw, 0.875rem);
      --text-base: clamp(0.9rem, 0.85rem + 0.25vw, 1rem);
      --text-lg: clamp(1rem, 0.95rem + 0.25vw, 1.125rem);
      --text-xl: clamp(1.125rem, 1rem + 0.5vw, 1.25rem);
      --text-2xl: clamp(1.25rem, 1.125rem + 0.625vw, 1.5rem);
      --text-3xl: clamp(1.5rem, 1.25rem + 1vw, 2rem);
      --text-4xl: clamp(1.875rem, 1.5rem + 1.5vw, 2.5rem);
    
      /* Spacing System */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.25rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-10: 2.5rem;
      --space-12: 3rem;
      --space-16: 4rem;
      
      /* Layout */
      --container-max: 1800px;
      --gutter: clamp(1rem, 3vw, 2rem);
      --sidebar-width: clamp(280px, 18vw, 340px);
      
      /* Border Radius System */
      --radius-xs: 6px;
      --radius-sm: 10px;
      --radius-md: 14px;
      --radius-lg: 18px;
      --radius-xl: 24px;
      --radius-2xl: 32px;
      --radius-full: 9999px;
    
      /* Professional Shadow System */
      --shadow-xs: 0 1px 2px rgba(0,0,0,.05);
      --shadow-sm: 0 2px 8px rgba(0,0,0,.08);
      --shadow-md: 0 4px 16px rgba(0,0,0,.12);
      --shadow-lg: 0 8px 32px rgba(0,0,0,.16);
      --shadow-xl: 0 12px 48px rgba(0,0,0,.22);
      --shadow-2xl: 0 20px 64px rgba(0,0,0,.32);
      --shadow-inner: inset 0 2px 8px rgba(0,0,0,.08);
      
      /* Glow Effects */
      --glow-sm: 0 0 20px;
      --glow-md: 0 0 40px;
      --glow-lg: 0 0 60px;
    
      /* Component Heights */
      --header-h: clamp(68px, 8vh, 80px);
      --tabs-h: clamp(52px, 6vh, 60px);
      --transport-h: clamp(88px, 10vh, 104px);
    
      /* Focus Ring */
      --ring-w: 3px;
      --ring-offset: 2px;
      --ring: rgba(180,190,255,.6);
      
      /* Glass Effects */
      --glass-border: rgba(255,255,255,.12);
      --glass-border-strong: rgba(255,255,255,.2);
      --glass-bg: rgba(255,255,255,.04);
      --glass-bg-strong: rgba(255,255,255,.08);
    
      /* Safe Areas */
      --inset-top: env(safe-area-inset-top, 0px);
      --inset-right: env(safe-area-inset-right, 0px);
      --inset-bottom: env(safe-area-inset-bottom, 0px);
      --inset-left: env(safe-area-inset-left, 0px);
    
      /* Animation Curves */
      --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
      --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --ease-elastic: cubic-bezier(0.68, -0.6, 0.32, 1.6);
      
      /* Transition Durations */
      --duration-fast: 150ms;
      --duration-base: 200ms;
      --duration-slow: 300ms;
      --duration-slower: 500ms;
    
      /* Default Theme (overridden by vibes) */
      --bg-primary: #0a0e1a;
      --bg-secondary: #0f1420;
      --bg-tertiary: #141824;
      
      --text-primary: #e9ecff;
      --text-secondary: #c8ccff;
      --text-tertiary: #9aa0c7;
      --text-muted: #6b7199;
      
      --accent-primary: #7c83ff;
      --accent-secondary: #8d6cff;
      --accent-tertiary: #9f7eff;
      
      --success: #22c55e;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;
    
      --surface: linear-gradient(135deg, rgba(255,255,255,.08) 0%, rgba(255,255,255,.04) 100%);
      --surface-elevated: linear-gradient(135deg, rgba(255,255,255,.12) 0%, rgba(255,255,255,.06) 100%);
    }
    
    /* -------- Premium Vibe Palettes -------- */
    body[data-vibe="moon"]{
      --bg-primary: #0a0e1a;
      --bg-secondary: #0f1420;
      --bg-tertiary: #141824;
      --accent-primary: #7c83ff;
      --accent-secondary: #8d6cff;
      --accent-tertiary: #9f7eff;
      --text-primary: #e9ecff;
      --text-secondary: #cfd4ff;
      --text-tertiary: #a6acd6;
    }
    
    body[data-vibe="dawn"]{
      --bg-primary: #1a0e14;
      --bg-secondary: #221318;
      --bg-tertiary: #2a1820;
      --accent-primary: #ff8fb1;
      --accent-secondary: #ffb385;
      --accent-tertiary: #ffc799;
      --text-primary: #fff4f8;
      --text-secondary: #ffdfe9;
      --text-tertiary: #f2cbd8;
    }
    
    body[data-vibe="nebula"]{
      --bg-primary: #0b0d18;
      --bg-secondary: #0f0a1c;
      --bg-tertiary: #150f24;
      --accent-primary: #9a6bff;
      --accent-secondary: #33d1ff;
      --accent-tertiary: #66e0ff;
      --text-primary: #eaf5ff;
      --text-secondary: #cfe7ff;
      --text-tertiary: #a6c9e6;
    }
    
    body[data-vibe="forest"]{
      --bg-primary: #091312;
      --bg-secondary: #0b1418;
      --bg-tertiary: #0e1a1e;
      --accent-primary: #5de6a4;
      --accent-secondary: #86f7c1;
      --accent-tertiary: #a0ffd0;
      --text-primary: #e7fff5;
      --text-secondary: #c9ffe9;
      --text-tertiary: #a1d4c2;
    }
    
    body[data-vibe="sunset"]{
      --bg-primary: #1a0e0f;
      --bg-secondary: #221214;
      --bg-tertiary: #2a161a;
      --accent-primary: #ff7a59;
      --accent-secondary: #ffb86b;
      --accent-tertiary: #ffd699;
      --text-primary: #fff1eb;
      --text-secondary: #ffd9c9;
      --text-tertiary: #ffc6ae;
    }
    
    /* -------- Global Canvas -------- */
    *, *::before, *::after{
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html{
      font-size: 16px;
      height: 100%;
      scroll-behavior: smooth;
    }
    
    body{
      min-height: 100%;
      font-family: var(--font-sans);
      font-size: var(--text-base);
      font-weight: 400;
      line-height: 1.6;
      color: var(--text-primary);
      background: 
        radial-gradient(ellipse 1200px 800px at 15% -5%, 
          color-mix(in oklab, var(--accent-primary) 15%, transparent), 
          transparent 65%),
        radial-gradient(ellipse 1000px 700px at 85% 105%, 
          color-mix(in oklab, var(--accent-secondary) 12%, transparent), 
          transparent 65%),
        radial-gradient(ellipse 800px 600px at 50% 50%, 
          color-mix(in oklab, var(--accent-tertiary) 6%, transparent), 
          transparent 70%),
        linear-gradient(135deg, 
          var(--bg-primary) 0%, 
          var(--bg-secondary) 50%, 
          var(--bg-tertiary) 100%);
      background-attachment: fixed;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      
      padding:
        calc(var(--space-4) + var(--inset-top))
        calc(var(--space-4) + var(--inset-right))
        calc(var(--space-4) + var(--inset-bottom))
        calc(var(--space-4) + var(--inset-left));
    }
    
    @media (display-mode: standalone){
      body{ 
        min-height: 100dvh;
        padding-top: calc(var(--space-6) + var(--inset-top));
      }
    }
    
    /* -------- Premium App Container -------- */
    .app{
      max-width: var(--container-max);
      margin: 0 auto;
      display: grid;
      gap: var(--gutter);
      padding: clamp(var(--space-4), 2vw, var(--space-8));
      background: 
        linear-gradient(135deg, 
          color-mix(in oklab, var(--bg-secondary) 85%, transparent) 0%, 
          color-mix(in oklab, var(--bg-primary) 70%, transparent) 100%);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-2xl);
      box-shadow: 
        var(--shadow-2xl),
        inset 0 1px 0 rgba(255,255,255,.06),
        inset 0 -1px 0 rgba(0,0,0,.2);
      backdrop-filter: blur(32px) saturate(140%);
      position: relative;
      overflow: hidden;
      
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "tabs"
        "transport"
        "main"
        "footer";
    }
    
    /* Ambient glow effect */
    .app::before{
      content: '';
      position: absolute;
      inset: -50%;
      background: 
        radial-gradient(circle at 20% 30%, 
          color-mix(in oklab, var(--accent-primary) 8%, transparent), 
          transparent 40%),
        radial-gradient(circle at 80% 70%, 
          color-mix(in oklab, var(--accent-secondary) 6%, transparent), 
          transparent 40%);
      opacity: 0.6;
      animation: ambientPulse 8s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    
    @keyframes ambientPulse{
      0%, 100%{ transform: scale(1) rotate(0deg); opacity: 0.6; }
      50%{ transform: scale(1.1) rotate(5deg); opacity: 0.4; }
    }
    
    .app > *{
      position: relative;
      z-index: 1;
    }
    
    /* Sidebar Layout */
    .app:has(.sidebar),
    .app.with-sidebar{
      grid-template-columns: var(--sidebar-width) 1fr;
      grid-template-areas:
        "header header"
        "tabs tabs"
        "transport transport"
        "sidebar main"
        "footer footer";
      gap: var(--space-6);
    }
    
    header{ grid-area: header; }
    .tabs{ grid-area: tabs; }
    .transport{ grid-area: transport; }
    section.section{ grid-area: main; }
    footer.footer{ grid-area: footer; }
    
    /* -------- Premium Header -------- */
    header{
      position: sticky;
      top: var(--space-4);
      z-index: 50;
      height: auto;
      min-height: var(--header-h);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: var(--space-4);
      align-items: center;
      padding: var(--space-4) var(--space-5);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: 
        var(--shadow-lg),
        inset 0 1px 0 rgba(255,255,255,.1);
      backdrop-filter: blur(24px) saturate(150%);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    header:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent),
        inset 0 1px 0 rgba(255,255,255,.15);
    }
    
    .logo-section{
      display: flex;
      gap: var(--space-3);
      align-items: center;
    }
    
    .logo{
      width: clamp(48px, 6vw, 56px);
      height: clamp(48px, 6vw, 56px);
      border-radius: var(--radius-md);
      display: grid;
      place-items: center;
      font-size: var(--text-2xl);
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      font-weight: 900;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
      position: relative;
      overflow: hidden;
      transition: transform var(--duration-base) var(--ease-bounce);
    }
    
    .logo::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.2) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform var(--duration-slow) var(--ease-smooth);
    }
    
    .logo:hover{
      transform: scale(1.05) rotate(5deg);
    }
    
    .logo:hover::before{
      transform: translateX(100%);
    }
    
    h1{
      margin: 0;
      font-size: var(--text-2xl);
      font-weight: 900;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .tagline{
      font-size: var(--text-sm);
      color: var(--text-tertiary);
      font-weight: 500;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-top: calc(-1 * var(--space-1));
    }
    
    /* Genre Selector - Refined */
    .genre-selector{
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .genre-btn{
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius-full);
      border: 1px solid var(--glass-border);
      background: var(--glass-bg);
      color: var(--text-secondary);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .genre-btn::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .genre-btn > span{
      position: relative;
      z-index: 1;
    }
    
    .genre-btn:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    
    .genre-btn:hover::before{
      opacity: 0.1;
    }
    
    .genre-btn.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      border-color: transparent;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
      transform: translateY(-2px);
    }
    
    .genre-btn.active::before{
      opacity: 0;
    }
    
    .genre-btn:active{
      transform: translateY(0);
    }
    
    /* Header Actions */
    .header-actions{
      display: flex;
      gap: var(--space-2);
    }
    
    /* -------- Premium Tab System -------- */
    .tabs{
      position: sticky;
      top: calc(var(--header-h) + var(--space-4) + var(--space-2));
      z-index: 49;
      display: flex;
      gap: var(--space-2);
      padding: var(--space-3);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.06);
      backdrop-filter: blur(20px) saturate(130%);
      overflow-x: auto;
      overflow-y: visible;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .tabs::-webkit-scrollbar{ display: none; }
    
    .tab{
      position: relative;
      padding: var(--space-3) var(--space-5);
      border: none;
      border-radius: var(--radius-full);
      background: transparent;
      color: var(--text-tertiary);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all var(--duration-base) var(--ease-smooth);
      white-space: nowrap;
      overflow: hidden;
    }
    
    .tab::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      border-radius: inherit;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .tab > *{
      position: relative;
      z-index: 1;
    }
    
    .tab:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: translateY(-1px);
    }
    
    .tab.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 35%, transparent);
      transform: translateY(-2px);
    }
    
    .tab:active{
      transform: translateY(0);
    }
    
    /* -------- Transport Bar - Command Center -------- */
    .transport{
      position: sticky;
      top: calc(var(--header-h) + var(--tabs-h) + var(--space-4) + var(--space-4));
      z-index: 48;
      padding: var(--space-5) var(--space-6);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: 
        var(--shadow-lg),
        inset 0 1px 0 rgba(255,255,255,.08);
      backdrop-filter: blur(24px) saturate(140%);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: var(--space-6);
      align-items: center;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .transport:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border-strong));
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 12%, transparent),
        inset 0 1px 0 rgba(255,255,255,.12);
    }
    
    .transport-controls{
      display: flex;
      gap: var(--space-2);
      align-items: center;
      flex-wrap: wrap;
    }
    
    .progress-area{
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      min-width: 0;
      flex: 1;
    }
    
    .time-info{
      display: flex;
      gap: var(--space-3);
      justify-content: space-between;
      color: var(--text-secondary);
      font-weight: 700;
      font-size: var(--text-sm);
      font-family: var(--font-mono);
      letter-spacing: 0.05em;
    }
    
    .progress-bar{
      height: 14px;
      border-radius: var(--radius-full);
      overflow: hidden;
      background: 
        linear-gradient(90deg, 
          rgba(255,255,255,.06) 0%, 
          rgba(255,255,255,.08) 50%, 
          rgba(255,255,255,.06) 100%);
      border: 1px solid rgba(255,255,255,.1);
      box-shadow: var(--shadow-inner);
      position: relative;
    }
    
    .progress-bar::before{
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 4px,
        rgba(255,255,255,.03) 4px,
        rgba(255,255,255,.03) 8px
      );
      pointer-events: none;
    }
    
    .progress-fill{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
      width: 0%;
      transition: width 120ms linear;
      box-shadow: 
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 0 0 1px rgba(255,255,255,.2);
      position: relative;
      overflow: hidden;
    }
    
    .progress-fill::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255,255,255,.3) 50%, 
        transparent 100%);
      animation: progressShimmer 2s linear infinite;
    }
    
    @keyframes progressShimmer{
      0%{ transform: translateX(-100%); }
      100%{ transform: translateX(100%); }
    }
    
    .transport-params{
      display: grid;
      grid-auto-flow: column;
      gap: var(--space-4);
      align-items: center;
    }
    
    /* -------- Premium Button System -------- */
    .btn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      padding: var(--space-3) var(--space-5);
      border: none;
      border-radius: var(--radius-md);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-smooth);
      white-space: nowrap;
      text-decoration: none;
      outline: none;
      position: relative;
      overflow: hidden;
      transform: translateY(0);
    }
    
    .btn::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.15) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform var(--duration-slow) var(--ease-smooth);
    }
    
    .btn:hover::before{
      transform: translateX(100%);
    }
    
    .btn-sm{
      padding: var(--space-2) var(--space-4);
      font-size: var(--text-xs);
      border-radius: var(--radius-sm);
    }
    
    .btn:active{
      transform: translateY(1px) scale(0.98);
    }
    
    .btn:disabled{
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    
    .btn:focus-visible{
      box-shadow: 
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    /* Button Variants */
    .btn-primary{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.2);
    }
    
    .btn-primary:hover{
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent),
        inset 0 1px 0 rgba(255,255,255,.25);
    }
    
    .btn-secondary{
      background: var(--surface);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-sm);
    }
    
    .btn-secondary:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      background: var(--surface-elevated);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    
    .btn-ghost{
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid transparent;
    }
    
    .btn-ghost:hover{
      background: var(--glass-bg-strong);
      border-color: var(--glass-border);
      color: var(--text-primary);
    }
    
    .btn-success{
      background: linear-gradient(135deg, var(--success), color-mix(in oklab, var(--success) 70%, #ffffff));
      color: #042013;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--success) 35%, transparent);
    }
    
    .btn-success:hover{
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--success) 30%, transparent);
    }
    
    /* -------- Sidebar -------- */
    .sidebar{
      grid-area: sidebar;
      position: sticky;
      top: calc(var(--header-h) + var(--tabs-h) + var(--transport-h) + var(--space-8));
      align-self: start;
      max-height: calc(100dvh - var(--header-h) - var(--tabs-h) - var(--transport-h) - var(--space-16));
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: var(--space-4);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      display: grid;
      gap: var(--space-3);
    }
    
    @media (max-width: 1060px){
      .app{
        grid-template-columns: 1fr;
        grid-template-areas: "header" "tabs" "transport" "main" "footer";
      }
      .sidebar:not(.pinned){ display: none; }
    }
    
    /* -------- Sections & Panels -------- */
    .section{
      display: none;
    }
    
    .section.active{
      display: grid;
      gap: var(--gutter);
      margin-top: var(--space-2);
      animation: sectionFadeIn var(--duration-slow) var(--ease-smooth) both;
    }
    
    @keyframes sectionFadeIn{
      from{
        opacity: 0;
        transform: translateY(20px);
      }
      to{
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .panel{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.04);
      position: relative;
      overflow: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .panel::before{
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
      opacity: 0;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .panel:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
    }
    
    .panel:hover::before{
      opacity: 0.6;
    }
    
    .panel-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-4);
      padding-bottom: var(--space-3);
      border-bottom: 1px solid var(--glass-border);
      flex-wrap: wrap;
      gap: var(--space-3);
    }
    
    .panel-title{
      font-size: var(--text-lg);
      font-weight: 800;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      letter-spacing: -0.01em;
    }
    
    /* -------- Input Controls -------- */
    .param-control{
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    
    .param-label{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
    }
    
    .param-value{
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 700;
      font-size: var(--text-sm);
      padding: var(--space-1) var(--space-2);
      background: var(--glass-bg);
      border-radius: var(--radius-xs);
    }
    
    /* Range Sliders - Premium */
    input[type="range"]{
      width: 100%;
      height: 12px;
      border-radius: var(--radius-full);
      appearance: none;
      -webkit-appearance: none;
      cursor: pointer;
      background: 
        linear-gradient(90deg, 
          rgba(255,255,255,.06) 0%, 
          rgba(255,255,255,.08) 50%, 
          rgba(255,255,255,.06) 100%);
      border: 1px solid rgba(255,255,255,.1);
      box-shadow: var(--shadow-inner);
      outline: none;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    input[type="range"]:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, rgba(255,255,255,.1));
    }
    
    input[type="range"]:focus-visible{
      box-shadow: 
        var(--shadow-inner),
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    /* Webkit Slider Thumb */
    input[type="range"]::-webkit-slider-thumb{
      appearance: none;
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.3);
      border: 2px solid rgba(255,255,255,.4);
      cursor: grab;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    input[type="range"]::-webkit-slider-thumb:hover{
      transform: scale(1.1);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
        inset 0 1px 0 rgba(255,255,255,.4);
    }
    
    input[type="range"]::-webkit-slider-thumb:active{
      cursor: grabbing;
      transform: scale(0.95);
    }
    
    /* Firefox Slider Thumb */
    input[type="range"]::-moz-range-thumb{
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.3);
      border: 2px solid rgba(255,255,255,.4);
      cursor: grab;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    input[type="range"]::-moz-range-thumb:hover{
      transform: scale(1.1);
    }
    
    input[type="range"]::-moz-range-thumb:active{
      cursor: grabbing;
      transform: scale(0.95);
    }
    
    /* Text Inputs & Select */
    input[type="text"],
    input[type="email"],
    input[type="number"],
    select{
      width: 100%;
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      font-family: var(--font-sans);
      font-weight: 600;
      font-size: var(--text-sm);
      cursor: pointer;
      outline: none;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    input[type="text"]:focus,
    input[type="email"]:focus,
    input[type="number"]:focus,
    select:focus{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
      background: var(--glass-bg-strong);
      box-shadow: 
        var(--shadow-sm),
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    input[type="text"]::placeholder{
      color: var(--text-muted);
      font-weight: 500;
    }
    
    select{
      background-image: 
        linear-gradient(45deg, transparent 50%, var(--text-tertiary) 50%),
        linear-gradient(135deg, var(--text-tertiary) 50%, transparent 50%);
      background-position: 
        calc(100% - 16px) calc(50% - 2px),
        calc(100% - 11px) calc(50% - 2px);
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: var(--space-8);
      cursor: pointer;
    }
    
    /* -------- Chips & Tags -------- */
    .chips{
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }
    
    .chip{
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius-full);
      cursor: pointer;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-secondary);
      font-weight: 700;
      font-size: var(--text-sm);
      transition: all var(--duration-fast) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .chip::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .chip > *{
      position: relative;
      z-index: 1;
    }
    
    .chip:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    
    .chip:hover::before{
      opacity: 0.1;
    }
    
    .chip.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      border-color: transparent;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    }
    
    .chip.active::before{
      opacity: 0;
    }
    
    /* -------- Preset Grid -------- */
    .preset-grid{
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: var(--space-4);
    }
    
    .preset{
      padding: var(--space-5);
      border-radius: var(--radius-md);
      cursor: pointer;
      text-align: center;
      background: var(--surface);
      border: 1px solid var(--glass-border);
      font-weight: 700;
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      align-items: center;
      transition: all var(--duration-base) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .preset::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .preset > *{
      position: relative;
      z-index: 1;
    }
    
    .preset:hover{
      transform: translateY(-4px);
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent);
    }
    
    .preset:hover::before{
      opacity: 0.08;
    }
    
    .preset:active{
      transform: translateY(-2px);
    }
    
    .preset-icon{
      font-size: var(--text-3xl);
      line-height: 1;
      filter: drop-shadow(0 2px 8px rgba(0,0,0,.3));
    }
    
    .preset-name{
      font-size: var(--text-sm);
      color: var(--text-secondary);
      transition: color var(--duration-base) var(--ease-smooth);
    }
    
    .preset:hover .preset-name{
      color: var(--text-primary);
    }
    
    /* -------- Premium Visualizer -------- */
    .visualizer{
      height: clamp(160px, 20vh, 220px);
      border-radius: var(--radius-lg);
      position: relative;
      background:
        linear-gradient(135deg, 
          color-mix(in oklab, var(--accent-primary) 10%, transparent), 
          color-mix(in oklab, var(--accent-secondary) 8%, transparent)),
        linear-gradient(180deg, rgba(0,0,0,.2), transparent 70%);
      border: 1px solid var(--glass-border-strong);
      overflow: hidden;
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.06),
        inset 0 0 0 1px rgba(255,255,255,.03);
    }
    
    .visualizer::before{
      content: '';
      position: absolute;
      inset: 0;
      background: 
        repeating-linear-gradient(
          0deg,
          transparent 0px,
          rgba(255,255,255,.01) 1px,
          transparent 2px,
          transparent 20px
        );
      pointer-events: none;
      z-index: 1;
    }
    
    .viz-bar{
      position: absolute;
      bottom: 0;
      width: 5px;
      border-radius: 3px 3px 0 0;
      opacity: 0.9;
      background: linear-gradient(
        to top, 
        var(--accent-primary) 0%,
        var(--accent-secondary) 50%,
        var(--accent-tertiary) 100%
      );
      transition: height 80ms ease-out;
      will-change: height;
      box-shadow: 
        0 -4px 12px color-mix(in oklab, var(--accent-primary) 30%, transparent),
        inset 0 0 0 1px rgba(255,255,255,.15);
      filter: brightness(1.1);
    }
    
    .viz-overlay{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        linear-gradient(180deg, 
          color-mix(in oklab, var(--bg-primary) 40%, transparent), 
          color-mix(in oklab, var(--bg-secondary) 50%, transparent));
      backdrop-filter: blur(4px);
      font-weight: 800;
      font-size: var(--text-lg);
      color: var(--text-tertiary);
      letter-spacing: 0.05em;
      text-transform: uppercase;
      pointer-events: none;
      z-index: 2;
    }
    
    /* -------- Sequencer Grid -------- */
    .sequencer{
      overflow-x: auto;
      overflow-y: visible;
      scrollbar-width: thin;
      padding-bottom: var(--space-2);
    }
    
    .seq-grid{
      display: grid;
      gap: var(--space-3);
      min-width: 900px;
      position: relative;
    }
    
    .seq-grid::before{
      content: '';
      position: absolute;
      inset: 0;
      border-radius: var(--radius-md);
      background:
        repeating-linear-gradient(
          to right,
          transparent 0,
          transparent calc(100% / 16 - 1px),
          rgba(255,255,255,.04) calc(100% / 16 - 1px),
          rgba(255,255,255,.04) calc(100% / 16)
        );
      pointer-events: none;
      z-index: 0;
    }
    
    .seq-row{
      display: grid;
      grid-template-columns: 180px repeat(16, 1fr);
      gap: var(--space-2);
      align-items: center;
      position: relative;
      z-index: 1;
    }
    
    .seq-label{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-3) var(--space-4);
      background: var(--surface);
      border-radius: var(--radius-md);
      border: 1px solid var(--glass-border);
      font-weight: 700;
      font-size: var(--text-sm);
      transition: all var(--duration-base) var(--ease-smooth);
    }

    .seq-icon[data-action="play"] {
      display: none;
    }
    
    .seq-label:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
      background: var(--surface-elevated);
    }
    
    .seq-icons{
      display: flex;
      gap: var(--space-1);
    }
    
    .seq-icon{
      width: 32px;
      height: 32px;
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-xs);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .seq-icon:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
      transform: scale(1.05);
    }
    
    .seq-icon.active{
      background: var(--error);
      color: #fff;
      box-shadow: var(--shadow-sm);
    }
    
    /* Sequencer Steps */
    .step{
      aspect-ratio: 1;
      min-height: 48px;
      border-radius: var(--radius-md);
      cursor: pointer;
      background: 
        linear-gradient(135deg, 
          rgba(255,255,255,.06), 
          rgba(255,255,255,.04));
      border: 1px solid var(--glass-border);
      position: relative;
      display: grid;
      place-items: center;
      transition: all var(--duration-fast) var(--ease-smooth);
      overflow: hidden;
    }
    
    .step::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .step:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
    }
    
    .step:hover::before{
      opacity: 0.1;
    }
    
    .step:active{
      transform: translateY(0) scale(0.97);
    }
    
    .step.active{
      background: 
        linear-gradient(135deg, 
          color-mix(in oklab, var(--accent-primary) 75%, transparent), 
          color-mix(in oklab, var(--accent-secondary) 80%, transparent));
      border-color: color-mix(in oklab, var(--accent-primary) 70%, transparent);
      box-shadow: 
        var(--shadow-sm),
        0 0 16px color-mix(in oklab, var(--accent-primary) 45%, transparent),
        inset 0 1px 0 rgba(255,255,255,.2);
    }
    
    .step.active::before{
      opacity: 0;
    }
    
    .step.playing{
      animation: stepPulse 280ms ease-out;
      box-shadow: 
        var(--shadow-md),
        0 0 28px var(--warning),
        0 0 48px color-mix(in oklab, var(--warning) 25%, transparent);
      border-color: var(--warning);
    }
    
    @keyframes stepPulse{
      0%, 100%{ transform: scale(1); }
      50%{ transform: scale(1.12); }
    }
    
    .step-prob{
      position: absolute;
      top: var(--space-1);
      right: var(--space-1);
      font-size: var(--text-xs);
      background: rgba(0,0,0,.6);
      padding: 2px var(--space-2);
      border-radius: var(--radius-xs);
      color: #fff;
      font-weight: 800;
      pointer-events: none;
      z-index: 2;
      font-family: var(--font-mono);
      backdrop-filter: blur(4px);
    }
    
    .step-vel{
      position: absolute;
      bottom: var(--space-1);
      left: var(--space-1);
      right: var(--space-1);
      height: 6px;
      background: rgba(255,255,255,.15);
      border-radius: var(--radius-full);
      overflow: hidden;
      z-index: 2;
    }
    
    .step-vel-fill{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0.95;
      transition: width 200ms var(--ease-smooth);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-primary) 50%, transparent);
    }
    
    .playhead{
      position: sticky;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    .playhead::after{
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      width: 4px;
      border-radius: var(--radius-xs);
      background: linear-gradient(
        to bottom,
        var(--warning),
        color-mix(in oklab, var(--warning) 20%, transparent)
      );
      box-shadow: 
        0 0 16px color-mix(in oklab, var(--warning) 50%, transparent),
        0 0 32px color-mix(in oklab, var(--warning) 25%, transparent);
      transform: translateX(-2px);
    }
    
    /* -------- Mixer Channels -------- */
    #tab-mixer .panel{
      display: grid;
      gap: var(--space-5);
    }
    
    #mixerGrid{
      display: grid;
      gap: var(--space-4);
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    }
    
    .mixer-channel{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .mixer-channel:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }
    
    .channel-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: var(--space-2);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .channel-name{
      font-weight: 800;
      font-size: var(--text-sm);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .channel-btns{
      display: flex;
      gap: var(--space-1);
    }
    
    .channel-btn{
      width: 34px;
      height: 34px;
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      font-weight: 800;
      font-size: var(--text-xs);
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .channel-btn:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
      transform: scale(1.05);
    }
    
    .channel-btn.active{
      color: #fff;
    }
    
    .channel-btn.mute.active{
      background: var(--error);
      box-shadow: var(--shadow-sm);
    }
    
    .channel-btn.solo.active{
      background: var(--warning);
      box-shadow: var(--shadow-sm);
    }
    
    /* -------- FX Units -------- */
    #fxGrid{
      display: grid;
      gap: var(--space-4);
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }
    
    .fx-unit{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: var(--space-5);
      box-shadow: var(--shadow-md);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .fx-unit:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .fx-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-4);
      padding-bottom: var(--space-3);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .fx-name{
      font-weight: 800;
      font-size: var(--text-base);
      color: var(--text-primary);
    }
    
    .fx-toggle{
      width: 60px;
      height: 32px;
      border-radius: var(--radius-full);
      cursor: pointer;
      background: color-mix(in oklab, var(--bg-secondary) 60%, transparent);
      border: 2px solid var(--glass-border);
      position: relative;
      transition: all var(--duration-base) var(--ease-smooth);
      box-shadow: var(--shadow-inner);
    }
    
    .fx-toggle::after{
      content: '';
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: all var(--duration-base) var(--ease-smooth);
      box-shadow: var(--shadow-sm);
    }
    
    .fx-toggle:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
    }
    
    .fx-toggle.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: transparent;
      box-shadow: 
        var(--shadow-sm),
        0 0 16px color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .fx-toggle.active::after{
      left: calc(100% - 26px);
      background: var(--bg-primary);
    }
    
    /* -------- Footer -------- */
    .footer{
      padding: var(--space-5) var(--space-6);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      text-align: center;
      color: var(--text-secondary);
      font-size: var(--text-sm);
      line-height: 1.8;
      box-shadow: var(--shadow-sm);
    }
    
    .footer strong{
      color: var(--text-primary);
      font-weight: 800;
    }
    
    kbd{
      background: var(--glass-bg-strong);
      border: 1px solid var(--glass-border-strong);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-xs);
      font-weight: 700;
      font-size: var(--text-xs);
      color: var(--text-primary);
      font-family: var(--font-mono);
      box-shadow: 
        var(--shadow-xs),
        inset 0 -1px 0 rgba(0,0,0,.2);
    }
    
    /* -------- Utility Grid System -------- */
    .grid{
      display: grid;
      gap: var(--space-4);
    }
    
    .grid-2{
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    
    .grid-3{
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    
    .grid-4{
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    
    /* -------- Flex Utilities -------- */
    .flex{
      display: flex;
      gap: var(--space-3);
      align-items: center;
      flex-wrap: wrap;
    }
    
    .flex-col{
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }
    
    /* -------- Spacing Utilities -------- */
    .mb-2{ margin-bottom: var(--space-2); }
    .mb-3{ margin-bottom: var(--space-3); }
    .mb-4{ margin-bottom: var(--space-4); }
    .mt-2{ margin-top: var(--space-2); }
    .mt-3{ margin-top: var(--space-3); }
    .mt-4{ margin-top: var(--space-4); }
    
    /* -------- Badge Component -------- */
    .badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-1) var(--space-3);
      border-radius: var(--radius-full);
      font-size: var(--text-xs);
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      line-height: 1;
    }
    
    .badge-primary{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .badge-success{
      background: var(--success);
      color: #042013;
    }
    
    .badge-warning{
      background: var(--warning);
      color: #451a03;
    }
    
    .badge-error{
      background: var(--error);
      color: #fff;
    }
    
    .badge-ghost{
      background: var(--glass-bg-strong);
      color: var(--text-secondary);
      border: 1px solid var(--glass-border);
    }
    
    /* -------- Premium Scrollbars -------- */
    *{
      scrollbar-color: 
        color-mix(in oklab, var(--accent-primary) 50%, transparent) 
        transparent;
      scrollbar-width: thin;
    }
    
    *::-webkit-scrollbar{
      height: 10px;
      width: 10px;
    }
    
    *::-webkit-scrollbar-track{
      background: transparent;
    }
    
    *::-webkit-scrollbar-thumb{
      background: linear-gradient(
        135deg, 
        color-mix(in oklab, var(--accent-primary) 85%, #fff), 
        color-mix(in oklab, var(--accent-secondary) 85%, #fff)
      );
      border-radius: var(--radius-xs);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    *::-webkit-scrollbar-corner{
      background: transparent;
    }
    
    /* -------- Selection Styling -------- */
    ::selection{
      background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      text-shadow: none;
    }
    
    ::-moz-selection{
      background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      text-shadow: none;
    }
    
    /* -------- Loading States -------- */
    .loading{
      position: relative;
      pointer-events: none;
      opacity: 0.6;
    }
    
    .loading::after{
      content: '';
      position: absolute;
      inset: 0;
      background: 
        linear-gradient(
          90deg,
          transparent 0%,
          color-mix(in oklab, var(--accent-primary) 15%, transparent) 50%,
          transparent 100%
        );
      animation: shimmer 2s infinite;
      border-radius: inherit;
    }
    
    @keyframes shimmer{
      0%{ transform: translateX(-100%); }
      100%{ transform: translateX(100%); }
    }
    
    .spinner{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid var(--glass-border);
      border-top-color: var(--accent-primary);
      animation: spin 0.8s linear infinite;
      margin: var(--space-4) auto;
    }
    
    @keyframes spin{
      to{ transform: rotate(360deg); }
    }
    
    /* -------- Toast Notifications -------- */
    .toast-container{
      position: fixed;
      top: calc(var(--space-4) + var(--inset-top));
      right: calc(var(--space-4) + var(--inset-right));
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      max-width: 420px;
      pointer-events: none;
    }
    
    .toast{
      padding: var(--space-4) var(--space-5);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent);
      backdrop-filter: blur(24px) saturate(150%);
      display: flex;
      gap: var(--space-3);
      align-items: center;
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--text-primary);
      animation: toastSlideIn var(--duration-slow) var(--ease-bounce);
      pointer-events: auto;
      position: relative;
      overflow: hidden;
    }
    
    .toast::before{
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
    }
    
    .toast.success::before{
      background: var(--success);
    }
    
    .toast.error::before{
      background: var(--error);
    }
    
    .toast.warning::before{
      background: var(--warning);
    }
    
    @keyframes toastSlideIn{
      from{
        transform: translateX(calc(100% + var(--space-4)));
        opacity: 0;
      }
      to{
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .toast-icon{
      font-size: var(--text-xl);
      line-height: 1;
    }
    
    .toast-close{
      margin-left: auto;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: var(--radius-sm);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-sm);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .toast-close:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: scale(1.05);
    }
    
    /* -------- Modal/Dialog -------- */
    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(8px);
      z-index: 999;
      display: grid;
      place-items: center;
      padding: var(--space-4);
      animation: backdropFadeIn var(--duration-base) var(--ease-smooth);
    }
    
    @keyframes backdropFadeIn{
      from{ opacity: 0; }
      to{ opacity: 1; }
    }
    
    .modal{
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-2xl);
      padding: var(--space-8);
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
      position: relative;
    }
    
    @keyframes modalSlideIn{
      from{
        transform: translateY(40px) scale(0.95);
        opacity: 0;
      }
      to{
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .modal-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-5);
      padding-bottom: var(--space-4);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .modal-title{
      font-size: var(--text-2xl);
      font-weight: 900;
      color: var(--text-primary);
      background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .modal-close{
      width: 40px;
      height: 40px;
      border: none;
      border-radius: var(--radius-sm);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-lg);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .modal-close:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: scale(1.05);
    }
    
    .modal-body{
      color: var(--text-secondary);
      line-height: 1.7;
    }
    
    .modal-footer{
      display: flex;
      gap: var(--space-3);
      justify-content: flex-end;
      margin-top: var(--space-6);
      padding-top: var(--space-4);
      border-top: 1px solid var(--glass-border);
    }
    
    /* -------- Dropdown Menu -------- */
    .dropdown{
      position: relative;
      display: inline-block;
    }
    
    .dropdown-menu{
      position: absolute;
      top: calc(100% + var(--space-2));
      right: 0;
      min-width: 220px;
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(24px) saturate(150%);
      padding: var(--space-2);
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .dropdown.open .dropdown-menu{
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .dropdown-item{
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .dropdown-item:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
    }
    
    .dropdown-item.active{
      background: linear-gradient(135deg, 
        color-mix(in oklab, var(--accent-primary) 20%, transparent),
        color-mix(in oklab, var(--accent-secondary) 15%, transparent));
      color: var(--text-primary);
      border-color: color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .dropdown-divider{
      height: 1px;
      background: var(--glass-border);
      margin: var(--space-2) 0;
    }
    
    /* -------- Tooltip -------- */
    [data-tooltip]{
      position: relative;
      cursor: help;
    }
    
    [data-tooltip]::before{
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + var(--space-2));
      left: 50%;
      transform: translateX(-50%) translateY(-5px);
      padding: var(--space-2) var(--space-3);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: var(--text-xs);
      font-weight: 600;
      white-space: nowrap;
      box-shadow: var(--shadow-lg);
      opacity: 0;
      visibility: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
      pointer-events: none;
      z-index: 200;
      backdrop-filter: blur(12px);
    }
    
    [data-tooltip]::after{
      content: '';
      position: absolute;
      bottom: calc(100% + var(--space-1));
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: var(--glass-border-strong);
      opacity: 0;
      visibility: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
      pointer-events: none;
      z-index: 200;
    }
    
    [data-tooltip]:hover::before,
    [data-tooltip]:hover::after{
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
    
    /* -------- Context Menu -------- */
    .context-menu{
      position: fixed;
      min-width: 200px;
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-2xl);
      backdrop-filter: blur(24px) saturate(150%);
      padding: var(--space-2);
      z-index: 9999;
      animation: contextMenuAppear var(--duration-fast) var(--ease-smooth);
    }
    
    @keyframes contextMenuAppear{
      from{
        opacity: 0;
        transform: scale(0.95);
      }
      to{
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* -------- Progress Indicator -------- */
    .progress{
      height: 8px;
      background: var(--glass-bg);
      border-radius: var(--radius-full);
      overflow: hidden;
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-inner);
    }
    
    .progress-value{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      border-radius: inherit;
      transition: width var(--duration-base) var(--ease-smooth);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    }
    
    /* -------- Accordion -------- */
    .accordion-item{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      margin-bottom: var(--space-3);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-item:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
    }
    
    .accordion-header{
      padding: var(--space-4) var(--space-5);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      color: var(--text-primary);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-header:hover{
      background: var(--glass-bg);
    }
    
    .accordion-icon{
      transition: transform var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-item.open .accordion-icon{
      transform: rotate(180deg);
    }
    
    .accordion-content{
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-slow) var(--ease-smooth);
    }
    
    .accordion-item.open .accordion-content{
      max-height: 1000px;
    }
    
    .accordion-body{
      padding: var(--space-4) var(--space-5);
      color: var(--text-secondary);
      line-height: 1.7;
    }

    /* -------- Professional DAW Multitrack System -------- */

    /* Timeline ruler at top */
    .timeline-ruler {
      height: 48px;
      background: linear-gradient(180deg, var(--bg-secondary), var(--bg-tertiary));
      border-bottom: 2px solid var(--glass-border-strong);
      display: flex;
      align-items: center;
      padding: 0 200px 0 var(--space-4);
      position: sticky;
      top: 0;
      z-index: 100;
      font-family: var(--font-mono);
      font-size: var(--text-xs);
      color: var(--text-tertiary);
      font-weight: 700;
    }
    
    .timeline-markers {
      display: flex;
      width: 100%;
      position: relative;
      height: 100%;
    }
    
    .timeline-marker {
      position: absolute;
      height: 100%;
      display: flex;
      align-items: center;
      padding: 0 var(--space-2);
      border-left: 1px solid var(--glass-border);
    }
    
    .timeline-marker.major {
      border-left: 2px solid var(--glass-border-strong);
      color: var(--text-primary);
    }
    
    .timeline-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--error);
      pointer-events: none;
      z-index: 200;
      box-shadow: 0 0 12px var(--error);
    }
    
    .timeline-playhead::before {
      content: '';
      position: absolute;
      top: -6px;
      left: -5px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid var(--error);
    }
    
    /* Track container */
    .multitrack-grid {
      display: flex;
      flex-direction: column;
      gap: 0;
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      overflow: hidden;
      position: relative;
    }
    
    /* Individual track strip */
    .track-strip {
      display: grid;
      grid-template-columns: 200px 1fr;
      border-bottom: 1px solid var(--glass-border);
      background: var(--surface);
      transition: all var(--duration-base) var(--ease-smooth);
      position: relative;
      min-height: 120px;
    }
    
    .track-strip:hover {
      background: var(--surface-elevated);
    }
    
    .track-strip.selected {
      background: linear-gradient(90deg, 
        color-mix(in oklab, var(--accent-primary) 8%, var(--surface)),
        var(--surface));
      border-left: 3px solid var(--accent-primary);
    }
    
    .track-strip.recording {
      background: linear-gradient(90deg,
        color-mix(in oklab, var(--error) 10%, var(--surface)),
        var(--surface));
      border-left: 3px solid var(--error);
      animation: recordPulse 1s ease-in-out infinite;
    }
    
    .track-strip.armed {
      border-left: 3px solid var(--warning);
    }
    
    /* External audio track styling */
    .track-strip.external-audio {
      border-left: 3px solid var(--info);
    }
    
    .track-strip.external-audio .track-header {
      background: linear-gradient(90deg, 
        color-mix(in oklab, var(--info) 10%, transparent),
        transparent);
    }
    
    /* Input monitoring indicator */
    .track-mini-btn.mon {
      position: relative;
    }
    
    .track-mini-btn.mon.active {
      background: var(--info);
      animation: monitorPulse 2s ease-in-out infinite;
    }
    
    @keyframes monitorPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Enhanced meter styling */
    .track-meters {
      display: flex;
      gap: var(--space-1);
      height: 60px;
      background: rgba(0,0,0,0.3);
      border-radius: var(--radius-sm);
      padding: var(--space-2);
      position: relative;
      overflow: hidden;
    }
    
    .track-meter {
      flex: 1;
      background: rgba(0,0,0,0.5);
      border-radius: var(--radius-xs);
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .track-meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, 
        var(--success) 0%,
        var(--success) 60%,
        var(--warning) 75%,
        var(--error) 90%);
      transition: height 50ms linear;
      box-shadow: 0 0 10px currentColor;
    }
    
    /* Peak indicators on meters */
    .track-meters::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--error);
      opacity: 0.5;
      pointer-events: none;
    }
    
    .track-meters::after {
      content: '-6dB';
      position: absolute;
      top: 35%;
      right: var(--space-2);
      font-size: var(--text-xs);
      color: var(--text-tertiary);
      font-family: var(--font-mono);
      pointer-events: none;
    }
    
    /* Recording with external audio visual feedback */
    .track-strip.external-audio.recording {
      box-shadow: 
        0 0 30px color-mix(in oklab, var(--info) 30%, transparent),
        inset 0 0 0 2px var(--info);
      animation: externalRecPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes externalRecPulse {
      0%, 100% { 
        box-shadow: 
          0 0 20px color-mix(in oklab, var(--info) 20%, transparent),
          inset 0 0 0 2px var(--info);
      }
      50% { 
        box-shadow: 
          0 0 40px color-mix(in oklab, var(--info) 40%, transparent),
          inset 0 0 0 2px var(--info);
      }
    }
    /* Track header (left side panel) */
    .track-header {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      padding: var(--space-4);
      background: linear-gradient(90deg, var(--bg-secondary), transparent);
      border-right: 1px solid var(--glass-border);
    }
    
    .track-header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-2);
    }
    
    .track-name {
      font-weight: 800;
      font-size: var(--text-sm);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      cursor: pointer;
      padding: var(--space-2);
      border-radius: var(--radius-xs);
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .track-name:hover {
      background: var(--glass-bg-strong);
    }
    
    .track-name.editing input {
      background: var(--glass-bg-strong);
      border: 1px solid var(--accent-primary);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-xs);
      color: var(--text-primary);
      font: inherit;
      width: 100%;
    }
    
    .track-icon {
      font-size: var(--text-lg);
    }
    
    .track-meters {
      display: flex;
      gap: var(--space-1);
      height: 40px;
      margin: var(--space-2) 0;
    }
    
    .track-meter {
      flex: 1;
      background: rgba(0,0,0,.3);
      border-radius: var(--radius-xs);
      overflow: hidden;
      position: relative;
    }
    
    .track-meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, var(--success), var(--warning), var(--error));
      transition: height 50ms linear;
    }
    
    .track-controls-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-2);
    }
    
    .track-mini-btn {
      padding: var(--space-2);
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      font-weight: 800;
      font-size: var(--text-xs);
      transition: all var(--duration-fast) var(--ease-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-1);
      min-height: 28px;
    }
    
    .track-mini-btn:hover {
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: scale(1.05);
    }
    
    .track-mini-btn.active {
      color: #fff;
      font-weight: 900;
    }
    
    .track-mini-btn.rec.active {
      background: var(--error);
      box-shadow: 0 0 12px color-mix(in oklab, var(--error) 40%, transparent);
    }
    
    .track-mini-btn.arm.active {
      background: var(--warning);
    }
    
    .track-mini-btn.mute.active {
      background: var(--error);
    }
    
    .track-mini-btn.solo.active {
      background: var(--accent-primary);
    }
    
    .track-mini-btn.mon.active {
      background: var(--info);
    }
    
    .track-volume-control {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-top: var(--space-2);
    }
    
    .track-volume-slider {
      flex: 1;
      height: 6px;
      border-radius: var(--radius-full);
      appearance: none;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      cursor: pointer;
    }
    
    .track-volume-slider::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border: 2px solid rgba(255,255,255,.4);
      cursor: grab;
      box-shadow: var(--shadow-sm);
    }
    
    .track-volume-slider::-webkit-slider-thumb:active {
      cursor: grabbing;
    }
    
    .track-volume-value {
      font-family: var(--font-mono);
      font-size: var(--text-xs);
      color: var(--text-secondary);
      font-weight: 700;
      min-width: 36px;
      text-align: right;
    }
    
    /* Track canvas area (right side) */
    .track-canvas-area {
      position: relative;
      background: linear-gradient(180deg, rgba(0,0,0,.1), transparent);
      padding: var(--space-2);
      overflow-x: auto;
      overflow-y: hidden;
    }
    
    .track-canvas-area::-webkit-scrollbar {
      height: 8px;
    }
    
    .track-canvas-area::-webkit-scrollbar-thumb {
      background: color-mix(in oklab, var(--accent-primary) 50%, transparent);
      border-radius: var(--radius-xs);
    }
    
    .track-canvas {
      position: relative;
      min-width: 100%;
      height: 100%;
      min-height: 80px;
    }
    
    /* Audio region (recorded take) */
    .audio-region {
      position: absolute;
      height: 80px;
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--accent-primary) 30%, transparent),
        color-mix(in oklab, var(--accent-secondary) 20%, transparent));
      border: 1px solid color-mix(in oklab, var(--accent-primary) 60%, transparent);
      border-radius: var(--radius-sm);
      cursor: move;
      transition: all var(--duration-fast) var(--ease-smooth);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .audio-region:hover {
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-md),
        0 0 20px color-mix(in oklab, var(--accent-primary) 25%, transparent);
      border-color: var(--accent-primary);
      z-index: 10;
    }
    
    .audio-region.selected {
      border-color: var(--accent-primary);
      border-width: 2px;
      box-shadow: 
        var(--shadow-lg),
        0 0 24px color-mix(in oklab, var(--accent-primary) 40%, transparent);
      z-index: 20;
    }
    
    .audio-region.muted {
      opacity: 0.3;
      filter: grayscale(1);
    }
    
    .audio-region.dragging {
      opacity: 0.7;
      z-index: 100;
      cursor: grabbing;
    }
    
    .region-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2) var(--space-3);
      background: rgba(0,0,0,.3);
      backdrop-filter: blur(4px);
    }
    
    .region-name {
      font-size: var(--text-xs);
      font-weight: 700;
      color: var(--text-primary);
      text-shadow: 0 1px 2px rgba(0,0,0,.5);
    }
    
    .region-actions {
      display: flex;
      gap: var(--space-1);
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .audio-region:hover .region-actions {
      opacity: 1;
    }
    
    .region-action-btn {
      width: 20px;
      height: 20px;
      border: none;
      border-radius: var(--radius-xs);
      background: rgba(0,0,0,.5);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 10px;
      display: grid;
      place-items: center;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .region-action-btn:hover {
      background: rgba(0,0,0,.8);
      transform: scale(1.1);
    }
    
    .region-waveform {
      flex: 1;
      position: relative;
      padding: var(--space-2);
    }
    
    .region-waveform canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .region-resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 8px;
      cursor: ew-resize;
      background: rgba(255,255,255,.1);
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .region-resize-handle.left {
      left: 0;
      border-left: 2px solid var(--accent-primary);
    }
    
    .region-resize-handle.right {
      right: 0;
      border-right: 2px solid var(--accent-primary);
    }
    
    .audio-region:hover .region-resize-handle {
      opacity: 1;
    }
    
    .region-resize-handle:hover {
      background: rgba(255,255,255,.2);
    }
    
    /* Automation lane */
    .automation-lane {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }
    
    .automation-curve {
      stroke: var(--warning);
      stroke-width: 2;
      fill: none;
      filter: drop-shadow(0 0 4px var(--warning));
    }
    
    .automation-point {
      fill: var(--warning);
      stroke: var(--bg-primary);
      stroke-width: 2;
      cursor: move;
      pointer-events: all;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .automation-point:hover {
      fill: var(--accent-primary);
      transform: scale(1.3);
    }
    
    /* Empty track placeholder */
    .track-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      height: 100%;
      color: var(--text-muted);
      font-size: var(--text-sm);
      text-align: center;
      padding: var(--space-6);
    }
    
    .track-empty-state-icon {
      font-size: var(--text-4xl);
      opacity: 0.5;
    }
    
    /* Recording indicator */
    .recording-indicator {
      position: absolute;
      top: var(--space-2);
      right: var(--space-2);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: rgba(0,0,0,.7);
      backdrop-filter: blur(8px);
      border-radius: var(--radius-full);
      font-size: var(--text-xs);
      font-weight: 800;
      color: #fff;
      z-index: 50;
    }
    
    .recording-indicator-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--error);
      animation: recordingDotPulse 1s ease-in-out infinite;
    }
    
    @keyframes recordingDotPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }
    
    /* Professional toolbar */
    .multitrack-toolbar {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-4);
      background: var(--surface-elevated);
      border-bottom: 1px solid var(--glass-border-strong);
      flex-wrap: wrap;
    }
    
    .toolbar-section {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding-right: var(--space-4);
      border-right: 1px solid var(--glass-border);
    }
    
    .toolbar-section:last-child {
      border-right: none;
    }
    
    .toolbar-label {
      font-size: var(--text-xs);
      font-weight: 700;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .toolbar-value {
      font-family: var(--font-mono);
      font-size: var(--text-sm);
      font-weight: 700;
      color: var(--text-primary);
      background: var(--glass-bg);
      padding: var(--space-1) var(--space-3);
      border-radius: var(--radius-xs);
      min-width: 60px;
      text-align: center;
    }
    
    .zoom-controls {
      display: flex;
      gap: var(--space-1);
    }
    
    .zoom-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-secondary);
      cursor: pointer;
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
      display: grid;
      place-items: center;
    }
    
    .zoom-btn:hover {
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: scale(1.05);
    }
    
    /* Snap grid overlay */
    .snap-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
    }
    
    .snap-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(255,255,255,.03);
    }
    
    .snap-line.beat {
      background: rgba(255,255,255,.06);
    }
    
    .snap-line.bar {
      background: rgba(255,255,255,.1);
      width: 2px;
    }

    /* FX Chain Panel */
    .fx-chain-panel {
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
      margin-top: var(--space-6);
      box-shadow: var(--shadow-xl);
    }
    
    .fx-chain-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-5);
      padding-bottom: var(--space-4);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .fx-chain-title {
      font-size: var(--text-xl);
      font-weight: 800;
      color: var(--text-primary);
    }
    
    .fx-add-dropdown {
      position: relative;
      display: inline-block;
    }
    
    .fx-add-menu {
      display: none;
      position: absolute;
      top: calc(100% + var(--space-2));
      right: 0;
      min-width: 200px;
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-2xl);
      backdrop-filter: blur(24px) saturate(150%);
      padding: var(--space-2);
      z-index: 1000;
    }
    
    .fx-add-item {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .fx-add-item:hover {
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
    }
    
    .fx-slots {
      display: grid;
      gap: var(--space-4);
    }
    
    /* Region manipulation */
    .take-region {
      position: relative;
      padding: var(--space-2) var(--space-3);
      background: linear-gradient(135deg,
        color-mix(in oklab, var(--accent-primary) 30%, transparent),
        color-mix(in oklab, var(--accent-secondary) 20%, transparent));
      border: 1px solid color-mix(in oklab, var(--accent-primary) 60%, transparent);
      border-radius: var(--radius-sm);
      cursor: move;
      user-select: none;
      transition: all var(--duration-fast) var(--ease-smooth);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: var(--text-sm);
      font-weight: 700;
      margin-bottom: var(--space-2);
    }
    
    .take-region:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      border-color: var(--accent-primary);
      z-index: 10;
    }
    
    .take-region.selected {
      border-color: var(--accent-primary);
      border-width: 2px;
      box-shadow: 
        var(--shadow-lg),
        0 0 24px color-mix(in oklab, var(--accent-primary) 40%, transparent);
    }
    
    .take-region.muted {
      opacity: 0.3;
      filter: grayscale(1);
    }
    
    .take-waveform-canvas {
      width: 120px;
      height: 40px;
      border-radius: var(--radius-xs);
      background: rgba(0,0,0,0.3);
    }
    
    /* -------- Responsive Breakpoints -------- */
    @media (max-width: 1024px){
      .transport{
        grid-template-columns: 1fr;
        gap: var(--space-4);
      }
      
      .transport-params{
        grid-auto-flow: row;
      }
    }
    
    @media (max-width: 768px){
      :root{
        --space-4: 0.75rem;
        --space-5: 1rem;
        --space-6: 1.25rem;
      }
      
      body{
        padding: var(--space-2);
      }
      
      .app{
        padding: var(--space-3);
      }
      
      header{
        grid-template-columns: 1fr;
        gap: var(--space-3);
      }
      
      .genre-selector{
        justify-content: flex-start;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        flex-wrap: nowrap;
      }
      
      .genre-selector::-webkit-scrollbar{
        display: none;
      }
      
      .preset-grid{
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      }
      
      #mixerGrid{
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      }
      
      #fxGrid{
        grid-template-columns: 1fr;
      }
      
      .grid-2,
      .grid-3,
      .grid-4{
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 480px){
      .app{
        padding: var(--space-2);
        border-radius: var(--radius-xl);
      }
      
      .panel{
        padding: var(--space-4);
      }
      
      .modal{
        padding: var(--space-5);
      }
      
      .toast-container{
        left: var(--space-2);
        right: var(--space-2);
        max-width: none;
      }
      
      .transport-controls{
        justify-content: center;
      }
      
      .seq-row{
        grid-template-columns: 140px repeat(16, 1fr);
      }
    }
    
    /* -------- Print Styles -------- */
    @media print{
      body{
        background: white;
        color: black;
      }
      
      .app::before,
      .transport,
      .tabs,
      .header-actions,
      .btn,
      button{
        display: none !important;
      }
      
      .panel{
        break-inside: avoid;
        page-break-inside: avoid;
      }
    }
    
    /* -------- High Contrast Mode -------- */
    @media (prefers-contrast: high){
      :root{
        --glass-border: rgba(255,255,255,.3);
        --glass-border-strong: rgba(255,255,255,.5);
      }
      
      .btn-primary,
      .tab.active{
        border: 2px solid var(--text-primary);
      }
    }
    
    /* -------- Reduced Motion -------- */
    @media (prefers-reduced-motion: reduce){
      *,
      *::before,
      *::after{
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      
      .app::before{
        animation: none;
      }
      
      .progress-fill::before{
        animation: none;
      }
    }
    
    /* -------- Focus Visible Enhancement -------- */
    @supports selector(:focus-visible){
      *:focus{
        outline: none;
      }
      
      *:focus-visible{
        outline: var(--ring-w) solid var(--ring);
        outline-offset: var(--ring-offset);
      }
    }
    
    /* -------- Additional Harmony Tab Styles -------- */
    #tab-harmony label{
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
    }
    
    #tab-harmony select{
      min-width: 120px;
    }
    
    /* -------- Optimize for Touch Devices -------- */
    @media (hover: none) and (pointer: coarse){
      .btn,
      .chip,
      .preset,
      .step,
      .seq-icon,
      .channel-btn,
      .fx-toggle{
        min-height: 44px;
        min-width: 44px;
      }
      
      .tab{
        padding: var(--space-4) var(--space-6);
      }
      
      .genre-btn{
        padding: var(--space-3) var(--space-5);
      }
    }
    
    /* -------- Dark Mode Enhancements -------- */
    @media (prefers-color-scheme: dark){
      body{
        color-scheme: dark;
      }
    }
    
    /* -------- Safari-specific Fixes -------- */
    @supports (-webkit-touch-callout: none){
      .app{
        -webkit-backdrop-filter: blur(32px) saturate(140%);
      }
      
      .transport,
      .tabs,
      header{
        -webkit-backdrop-filter: blur(24px) saturate(150%);
      }
    }
    
    /* -------- Custom Properties for Animations -------- */
    @property --rotate{
      syntax: '<angle>';
      initial-value: 0deg;
      inherits: false;
    }
    
    @property --shimmer-x{
      syntax: '<percentage>';
      initial-value: -100%;
      inherits: false;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="logo-section">
        <div class="logo">🎹</div>
        <div>
          <h1>8-Beat Studio</h1>
          <div class="tagline">Fun With Noise</div>
        </div>
      </div>
      
      <div class="genre-selector" id="genreSelector">
        <button class="genre-btn active" data-genre="lofi">Lo-Fi</button>
        <button class="genre-btn" data-genre="hiphop">Hip-Hop</button>
        <button class="genre-btn" data-genre="postpunk">Post-Punk</button>
        <button class="genre-btn" data-genre="rnb">R&B</button>
        <button class="genre-btn" data-genre="ambient">Ambient</button>
        <button class="genre-btn" data-genre="dazecore">Dazecore</button>
      </div>
      
      <div class="header-actions">
        <button class="btn btn-secondary btn-sm" id="installBtn" hidden>📱 Install</button>
        <button class="btn btn-secondary btn-sm" id="vibeBtn">🌈 Vibe: Moon</button>
      </div>
    </header>
    
    <div class="tabs" id="tabs">
      <button class="tab active" data-tab="generate">🎲 Generate</button>
      <button class="tab" data-tab="sequencer">🎹 Sequencer</button>
      <button class="tab" data-tab="mixer">🎚️ Mixer</button>
      <button class="tab" data-tab="fx">🎛️ Effects</button>
      <button class="tab" data-tab="harmony">🎼 Harmony</button>
      <button class="tab" data-tab="multitrack">🎙️ Multitrack</button>
    </div>
    
    <div class="transport">
      <div class="transport-controls">
        <button class="btn btn-primary" id="playBtn">▶️ Play</button>
        <button class="btn btn-secondary" id="stopBtn">⏹️ Stop</button>
        <button class="btn btn-secondary" id="exportBtn">🎧 DJ (Live Export)</button>
      </div>
      
      <div class="progress-area">
        <div class="time-info">
          <span class="time-display" id="timeDisplay">00:00</span>
          <span id="durationDisplay">/ 05:00</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      
      <div class="transport-params">
        <div class="param-control">
          <div class="param-label">
            <span>BPM</span>
            <span class="param-value" id="bpmValue">120</span>
          </div>
          <input type="range" id="bpmSlider" min="60" max="200" value="120">
        </div>
        <div class="param-control">
          <div class="param-label">
            <span>Swing</span>
            <span class="param-value" id="swingValue">50%</span>
          </div>
          <input type="range" id="swingSlider" min="0" max="100" value="50">
        </div>
      </div>
      <div class="flex" style="gap: var(--space-2);">
        <button class="btn btn-secondary btn-sm" id="metronomeBtn">
          🥁 Click: Off
        </button>
        <button class="btn btn-secondary btn-sm" id="countInBtn">
          ⏱️ Count: 1 bar
        </button>
      </div>
    </div>
    
    <section class="section active" id="tab-generate">
      <div class="panel">
        <div class="visualizer" id="visualizer">
          <div class="viz-overlay" id="vizOverlay">Generate & Press Play</div>
        </div>
      </div>
      
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">⚙️ Project Settings</div>
          </div>
          
          <div class="grid grid-3 mb-3">
            <div class="param-control">
              <div class="param-label">
                <span>Duration</span>
                <span class="param-value" id="durValue">5 min</span>
              </div>
              <input type="range" id="durSlider" min="1" max="20" value="5">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Complexity</span>
                <span class="param-value" id="complexValue">Medium</span>
              </div>
              <input type="range" id="complexSlider" min="1" max="3" value="2">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Humanize</span>
                <span class="param-value" id="humanValue">10ms</span>
              </div>
              <input type="range" id="humanSlider" min="0" max="30" value="10">
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="generateBtn">🎲 Generate Beat</button>
            <button class="btn btn-primary" id="generateRhythmBtn">🥁 Generate Rhythm</button>
            <button class="btn btn-secondary" id="randomVelBtn">🎯 Random Velocity</button>
            <button class="btn btn-secondary" id="randomProbBtn">🎲 Random Prob</button>
            <button class="btn btn-ghost" id="clearBtn">🧹 Clear</button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">💾 Projects</div>
          </div>
          
          <div class="flex-col">
            <div class="flex">
              <button class="btn btn-success" id="saveBtn">💾 Save Project</button>
              <button class="btn btn-secondary" id="loadBtn">📂 Load Project</button>
            </div>
            <div class="flex">
              <input type="text" id="projectName" placeholder="Project Name" 
                style="flex:1; padding:10px; background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:var(--radius-sm); color:var(--text-primary); font-family:inherit">
            </div>
          </div>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎨 Genre Presets</div>
        </div>
        <div class="preset-grid" id="presetGrid"></div>
      </div>
    </section>
    
    <section class="section" id="tab-sequencer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎹 Pattern Sequencer</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="lenDecBtn">− Length</button>
            <button class="btn btn-secondary btn-sm" id="lenIncBtn">+ Length</button>
            <select id="resSelect">
              <option value="16n" selected>1/16</option>
              <option value="8n">1/8</option>
              <option value="32n">1/32</option>
            </select>
            <button class="btn btn-secondary btn-sm" id="euclidBtn">∷ Euclidean</button>
            <button class="btn btn-secondary btn-sm" id="ghostBtn">👻 Ghost Notes</button>
          </div>
        </div>
        
        <div class="sequencer">
          <div class="seq-grid" id="seqGrid"></div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-mixer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎚️ Channel Mixer</div>
        </div>
        <div class="grid grid-4" id="mixerGrid"></div>
      </div>
      
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎛️ Master Bus</div>
        </div>
        
        <div class="grid grid-3">
          <div class="param-control">
            <div class="param-label">
              <span>Master Volume</span>
              <span class="param-value" id="masterVolValue">0dB</span>
            </div>
            <input type="range" id="masterVolSlider" min="-40" max="10" value="0">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Tape Saturation</span>
              <span class="param-value" id="tapeValue">25%</span>
            </div>
            <input type="range" id="tapeSlider" min="0" max="100" value="25">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Vinyl Noise</span>
              <span class="param-value" id="vinylValue">15%</span>
            </div>
            <input type="range" id="vinylSlider" min="0" max="100" value="15">
          </div>
        </div>
        
        <div class="grid grid-3 mt-3">
          <div class="param-control">
            <div class="param-label">
              <span>Low Cut</span>
              <span class="param-value" id="lowCutValue">30Hz</span>
            </div>
            <input type="range" id="lowCutSlider" min="20" max="200" value="30">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>High Cut</span>
              <span class="param-value" id="highCutValue">16kHz</span>
            </div>
            <input type="range" id="highCutSlider" min="4000" max="20000" value="16000">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Compressor</span>
              <span class="param-value" id="compValue">-18dB</span>
            </div>
            <input type="range" id="compSlider" min="-40" max="0" value="-18">
          </div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-fx">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎛️ Effects Rack</div>
        </div>
        <div class="grid grid-3" id="fxGrid"></div>
      </div>
    </section>
    
    <section class="section" id="tab-harmony">
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">🎼 Key & Scale</div>
          </div>
          
          <div class="flex mb-3">
            <label style="display:flex; align-items:center; gap:8px">
              Key: <select id="keySelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Scale: <select id="scaleSelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Octave: <select id="octaveSelect"></select>
            </label>
          </div>
          
          <div class="panel-header">
            <div class="panel-title">Available Chords</div>
            <button class="btn btn-secondary btn-sm" id="genProgBtn">↻ Generate</button>
          </div>
          <div class="chips" id="chordChips"></div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">🎵 Chord Progression</div>
            <button class="btn btn-ghost btn-sm" id="clearProgBtn">Clear</button>
          </div>
          
          <div class="chips mb-3" id="progressionChips"></div>
          
          <div class="panel-header">
            <div class="panel-title">Progression Templates</div>
          </div>
          <div class="grid grid-4">
            <button class="preset" data-prog="ii-v-i">
              <div class="preset-icon">🎷</div>
              <div class="preset-name">II-V-I</div>
            </button>
            <button class="preset" data-prog="lofi">
              <div class="preset-icon">😌</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-prog="neosoul">
              <div class="preset-icon">🎹</div>
              <div class="preset-name">Neo-Soul</div>
            </button>
            <button class="preset" data-prog="modal">
              <div class="preset-icon">🌙</div>
              <div class="preset-name">Modal</div>
            </button>
          </div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-multitrack">
      <!-- Professional Toolbar -->
      <div class="multitrack-toolbar">
        <div class="toolbar-section">
          <span class="toolbar-label">Timeline</span>
          <div class="toolbar-value" id="timelineDuration">00:00</div>
        </div>
        
        <div class="toolbar-section">
          <span class="toolbar-label">Zoom</span>
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoomOutBtn">−</button>
            <div class="toolbar-value" id="zoomLevel">100%</div>
            <button class="zoom-btn" id="zoomInBtn">+</button>
            <button class="zoom-btn" id="zoomFitBtn">⊡</button>
          </div>
        </div>
        
        <div class="toolbar-section">
          <span class="toolbar-label">Snap</span>
          <select id="snapGrid" class="btn btn-secondary btn-sm" style="padding: var(--space-2) var(--space-3);">
            <option value="off">Off</option>
            <option value="bar" selected>Bar</option>
            <option value="beat">Beat</option>
            <option value="16th">16th</option>
          </select>
        </div>
        
        <div class="toolbar-section">
          <button class="btn btn-secondary btn-sm" id="loopBtn">🔁 Loop</button>
          <button class="btn btn-secondary btn-sm" id="clickBtn">🥁 Click</button>
        </div>

        <div class="toolbar-section">
          <button class="btn btn-primary" id="recordArmedBtn">⏺️ Record Armed</button>
          <div style="font-size: var(--text-xs); color: var(--text-tertiary); margin-top: var(--space-1);">
            Arm tracks → Click here
          </div>
        </div>
        
        <div class="toolbar-section" style="margin-left: auto; border-right: none;">
          <button class="btn btn-success" id="previewMultitrackBtn">▶️ Preview Mix</button>
          <button class="btn btn-primary" id="addTrackBtn">➕ Add Track</button>
          <button class="btn btn-secondary" id="bounceAllBtn">🔽 Export Mix</button>
          <button class="btn btn-ghost" id="clearAllTracksBtn">🗑️ Clear All</button>
        </div>
      </div>
      
      <!-- Timeline Ruler -->
      <div class="timeline-ruler">
        <div class="timeline-markers" id="timelineMarkers"></div>
        <div class="timeline-playhead" id="timelinePlayhead" style="left: 0;"></div>
      </div>
      
      <!-- Tracks Container -->
      <div class="multitrack-grid" id="multitrackGrid">
        <!-- Tracks will be dynamically inserted here -->
      </div>
      
      <!-- FX Chain Panel (Hidden by default) -->
      <div class="fx-chain-panel" id="fxChainPanel" style="display: none;">
        <div class="fx-chain-header">
          <div class="fx-chain-title">🎛️ FX Chain: <span id="fxChainTrackName">Track 1</span></div>
          <div class="flex">
            <div class="fx-add-dropdown" id="fxAddDropdown">
              <button class="btn btn-primary btn-sm" id="addFxBtn">➕ Add Effect</button>
              <div class="fx-add-menu" id="fxAddMenu" style="display: none;">
                <div class="fx-add-item" data-fx-type="reverb">🌊 Reverb</div>
                <div class="fx-add-item" data-fx-type="delay">🔁 Delay</div>
                <div class="fx-add-item" data-fx-type="chorus">🎵 Chorus</div>
                <div class="fx-add-item" data-fx-type="distortion">🔥 Distortion</div>
                <div class="fx-add-item" data-fx-type="filter">🎚️ Filter</div>
                <div class="fx-add-item" data-fx-type="compressor">📊 Compressor</div>
                <div class="fx-add-item" data-fx-type="eq">🎛️ EQ</div>
                <div class="fx-add-item" data-fx-type="bitcrusher">💾 Bitcrusher</div>
              </div>
            </div>
            <button class="btn btn-ghost btn-sm" id="closeFxChainBtn">✕ Close</button>
          </div>
        </div>
        
        <div class="fx-slots" id="fxSlots">
          <!-- FX slots will be dynamically inserted here -->
        </div>
      </div>
      
      <!-- Automation Panel -->
      <div class="fx-chain-panel" id="automationPanel" style="display: none;">
        <div class="fx-chain-header">
          <div class="fx-chain-title">📈 Automation: <span id="automationTrackName">Track 1</span></div>
          <div class="flex">
            <select id="automationParamSelect" class="btn btn-secondary btn-sm">
              <option value="volume">Volume</option>
              <option value="pan">Pan</option>
              <option value="filter">Filter Cutoff</option>
            </select>
            <button class="btn btn-secondary btn-sm" id="clearAutomationBtn">🧹 Clear</button>
            <button class="btn btn-ghost btn-sm" id="closeAutomationBtn">✕ Close</button>
          </div>
        </div>
        
        <div style="padding: var(--space-4);">
          <canvas id="automationCanvas" 
                  width="800" 
                  height="200" 
                  style="width: 100%; height: 200px; background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border); cursor: crosshair;">
          </canvas>
          <div style="margin-top: var(--space-3); color: var(--text-tertiary); font-size: var(--text-sm);">
            Click to add automation points • Drag to move • Right-click to delete
          </div>
        </div>
      </div>
    </section>

    <footer class="footer">
      <strong>8-Beat Studio</strong> • Fun With Noise • 
      Shortcuts: <kbd>Space</kbd> Play/Pause • <kbd>S</kbd> Stop • <kbd>E</kbd> DJ • 
      Sequencer: <kbd>Alt</kbd> Accent Velocity • <kbd>Shift</kbd> Increase Probability
    </footer>
  </div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
// ========================================
// 8-Beat Studio - Fully Optimized JS
// Performance: Debounced events, RAF throttling, object pooling
// Memory: Weak references, proper cleanup, no leaks
// Audio: Low-latency graph, stable connections, no crackles
// ========================================

'use strict';

// -------------------- Configuration --------------------
const CONFIG = {
  MAX_BPM: 200,
  MAX_SEQUENCE_LENGTH: 64,
  MIN_SEQUENCE_LENGTH: 8,
  VISUALIZER_BARS: 32,
  VISUALIZER_FPS: 30,
  PROGRESS_UPDATE_MS: 16,
  DEBOUNCE_MS: 80,
  STORAGE_KEY: 'prostudio.vibe'
};

const VIBES = ['moon', 'dawn', 'nebula', 'forest', 'sunset'];

// -------------------- State Management --------------------
const state = {
  currentGenre: 'lofi',
  currentTab: 'generate',
  isPlaying: false,
  bpm: 120,
  swing: 50,
  duration: 5,
  complexity: 2,
  humanize: 10,
  sequenceLength: 32,  // CHANGED FROM 16
  resolution: '16n',
  currentStep: 0,
  // ... rest stays the same
  key: 'C',
  scale: 'major',
  octave: 4,
  progression: [],
  masterVolume: 0,
  tapeSaturation: 25,
  vinylNoise: 15,
  lowCut: 30,
  highCut: 16000,
  compressor: -18,
  metronomeEnabled: false,
  metronomeVolume: -6,
  countInBars: 1
};

// Metronome system
const metronome = {
  synth: null,
  enabled: false,
  loop: null
};

async function checkAudioPermissions() {
  try {
    const permissions = await navigator.permissions.query({ name: 'microphone' });
    
    if (permissions.state === 'denied') {
      console.warn('⚠️ Microphone permission denied');
      showToast('⚠️ Microphone access denied. External audio tracks will not work.', 'warning');
    } else if (permissions.state === 'prompt') {
      console.log('ℹ️ Microphone permission will be requested when adding external audio track');
    } else {
      console.log('✅ Microphone permission granted');
    }
    
    permissions.addEventListener('change', () => {
      console.log('🔄 Microphone permission changed:', permissions.state);
    });
    
  } catch (err) {
    // Permissions API not supported or microphone not in query list
    console.log('ℹ️ Cannot query microphone permissions, will request on demand');
  }
}
  
// -------------------- Data Structures --------------------
const instruments = {
  kick: { name: 'Kick', icon: '🥁', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  snare: { name: 'Snare', icon: '🎤', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  hihat: { name: 'Hi-Hat', icon: '🎩', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  clap: { name: 'Clap', icon: '👏', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  rimshot: { name: 'Rimshot', icon: '🔊', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  tom: { name: 'Tom', icon: '🪘', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  crash: { name: 'Crash', icon: '💥', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  ride: { name: 'Ride', icon: '🌊', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  
  // NEW ATMOSPHERIC INSTRUMENTS
  fx: { name: 'FX', icon: '✨', mute: false, solo: false, volume: -6, pan: 0, type: 'atmospheric' },
  riser: { name: 'Riser', icon: '📈', mute: false, solo: false, volume: -8, pan: 0, type: 'atmospheric' },
  ambience: { name: 'Ambience', icon: '🌫️', mute: false, solo: false, volume: -10, pan: 0, type: 'atmospheric' },
  
  bass: { name: 'Bass', icon: '🎸', mute: false, solo: false, volume: -3, pan: 0, type: 'melodic', note: 'C2' },
  guitar: { name: 'Guitar', icon: '🎸', mute: false, solo: false, volume: -5, pan: 20, type: 'melodic', note: 'C3' },
  keys: { name: 'Keys', icon: '🎹', mute: false, solo: false, volume: -6, pan: 0, type: 'melodic', note: 'C4' },
  lead: { name: 'Lead', icon: '🎺', mute: false, solo: false, volume: -8, pan: 0, type: 'melodic', note: 'C5' }
};

const patterns = {};
const synths = {};
const effects = {};
const master = {};

// Initialize patterns with proper structure
Object.keys(instruments).forEach(inst => {
  patterns[inst] = Array(32).fill(null).map(() => ({  // CHANGED FROM 16
    active: false,
    velocity: 0.8,
    probability: 100,
    note: instruments[inst].note,
    duration: '8n'
  }));
});

// -------------------- Genre Presets --------------------
const genrePresets = {
  lofi: {
    name: 'Lo-Fi Hip-Hop', icon: '😌', bpm: 85, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','G2','G2','C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','A2','A2'],
      guitar: ['C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','G3','D4','F3','G3','C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','C4','D4','F4','G4'],
      keys: ['C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','G3','A#3','D4','F4','C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','C4','D4','F4','G4'],
      lead: ['G4','A#4','D5','C5','A#4','G4','F4','D#4','G4','A#4','D5','C5','A#4','G4','F4','D#4']
    }
  },
  
  hiphop: {
    name: 'Hip-Hop', icon: '🎤', bpm: 90, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
      hihat:   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      bass:    [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','G2','A1','A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','A1','A1'],
      guitar: ['A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','G3','B2','A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','G3'],
      keys: ['A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','F3','B3','A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','A3'],
      lead: ['E4','G4','A4','C5','B4','A4','G4','E4','E4','G4','A4','C5','D5','C5','B4','A4']
    }
  },
  
  postpunk: {
    name: 'Post-Punk', icon: '🖤', bpm: 100, swing: 0,
    patterns: {
      kick:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0],
      rimshot: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      bass:    [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0],
      guitar:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','D2','D1','E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','E2','E1'],
      guitar: ['E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','F3','A3','D3','E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','E3','G3','B3'],
      keys: ['E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','F3','A3','C4','E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','E3','G3','B3'],
      lead: ['B3','D4','E4','G4','F4','E4','D4','B3','B3','D4','E4','G4','A4','G4','F4','E4']
    }
  },
  
  rnb: {
    name: 'R&B', icon: '💫', bpm: 75, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0]
    },
    notes: {
      bass: ['F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','C3','C3','F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','D3','D3'],
      guitar: ['F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','G3','C3','F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','F3','A3'],
      keys: ['F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','C4','F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','A3'],
      lead: ['C4','E4','F4','A4','G4','F4','E4','C4','C4','E4','F4','A4','G4','A4','C5','E5']
    }
  },
  
  ambient: {
    name: 'Ambient', icon: '🌌', bpm: 60, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      snare:   [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0],
      bass:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','A#1','A#1','A#1','A#1','C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','G#1','G#1','G#1','G#1'],
      guitar: ['C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','D3','F3','A#3','D3','C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      keys: ['C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','D3','F3','A#3','D4','C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      lead: ['G3','A#3','D4','F4','D#4','D4','A#3','G3','G3','A#3','D4','F4','D#4','D4','C4','A#3']
    }
  },

  dazecore: {
    name: 'Dazecore', icon: '☀️', bpm: 95, swing: 0,
    patterns: {
      // Warm, inviting kick - but the timing is slightly off
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      
      // Soft, jazzy snare - comforting but distant
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1],
      
      // Lounge hi-hats with subtle glitches
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1],
      
      // Intimate claps - inviting you in
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0],
      
      // Dial-up nostalgia - warm but uncanny
      rimshot: [0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,0,1],
      
      // Rare tom fills - something stirring beneath
      tom:     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      
      // Deep, warm bass - comforting rumble with wrong notes
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,0],
      
      // Lush guitar chords - too beautiful, almost sickly sweet
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0],
      
      // Dreamy keys - lounge jazz piano with dissonant undertones
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0],
      
      // Warm melody - beckoning, seductive, slightly wrong
      lead:    [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0],
      
      // Vinyl crackle and tape warble - nostalgic texture
      fx:      [1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1],
      
      // Subtle riser - the room is shifting around you
      riser:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
      
      // Warm ambient pad - the "off" feeling underneath everything
      ambience:[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
    },
    notes: {
      // Warm bass with chromatic "wrong" notes
      bass: ['D2','D2','D2','F2','F2','F2','A2','A2','A2','C3','C3','C3','D3','D3','D#3','D2','D2','D2','F2','F2','F2','A2','A2','C3','C3','C3','D3','D#3','D3','C3','A2','F2'],
      
      // Lush major 7th chords with occasional dissonance
      guitar: ['D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','A3','C#4','E4','A3','D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','B3','D4','F#4','A4'],
      
      // Jazzy extended chords - warm but unsettling
      keys: ['D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','G#4','C#4','E4','G#4','B4','D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','A4','C#4','E4','G#4','C#5'],
      
      // Nostalgic melody - familiar but you can't place it
      lead: ['A4','C#5','D5','F#5','E5','D5','C#5','A4','F#4','A4','C#5','E5','D5','C#5','B4','A4','A4','C#5','D5','F#5','E5','D5','C#5','B4','A4','C#5','E5','F#5','G#5','A5','C#6','D6']
    }
  }
};
  
// -------------------- Music Theory --------------------
const keysArr = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const scales = {
  major: [0,2,4,5,7,9,11],
  minor: [0,2,3,5,7,8,10],
  dorian: [0,2,3,5,7,9,10],
  phrygian: [0,1,3,5,7,8,10],
  lydian: [0,2,4,6,7,9,11],
  mixolydian: [0,2,4,5,7,9,10],
  pentatonic: [0,2,4,7,9]
};

// -------------------- FX Configuration --------------------
const fxConfig = {
  reverb: { name: 'Reverb', active: false, decay: 1, wet: 0.2 },
  delay: { name: 'Delay', active: false, time: '4n', feedback: 0.2 },
  chorus: { name: 'Chorus', active: false, frequency: 1.5, depth: 0.7 },
  flanger: { name: 'Flanger', active: false, frequency: 0.5, depth: 0.5 },
  distortion: { name: 'Distortion', active: false, amount: 0.5 },
  filter: { name: 'Filter', active: true, frequency: 5000, type: 'lowpass' },
  phaser: { name: 'Phaser', active: false, frequency: 0.5, octaves: 3 },
  bitcrusher: { name: 'Bitcrusher', active: false, bits: 8, frequency: 4000 }
};

// -------------------- Utilities --------------------
const debounce = (fn, ms) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), ms);
  };
};

const throttle = (fn, ms) => {
  let lastRun = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastRun >= ms) {
      lastRun = now;
      fn(...args);
    }
  };
};

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

// -------------------- Audio Context Setup --------------------
function initAudioContext() {
  if (Tone.getContext && Tone.getContext().rawContext) return;

  // Detect device type
  const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
  
  const ctx = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: isMobile ? 'balanced' : 'interactive',
    sampleRate: 48000
  });
  
  Tone.setContext(new Tone.Context(ctx));
  
  // CRITICAL: Desktop needs LESS lookahead to avoid message handler violations
  Tone.context.lookAhead = isMobile ? 0.05 : 0.02;
  Tone.context.updateInterval = isMobile ? 0.03 : 0.01;
  
  console.log('🎧 Device:', isMobile ? 'Mobile' : 'Desktop');
  console.log('🎵 Lookahead:', Tone.context.lookAhead.toFixed(3) + 's');
  console.log('🎵 Update:', Tone.context.updateInterval.toFixed(3) + 's');
}

function unlockAudioOnce() {
  const unlock = async () => {
    try {
      await Tone.start();
      await Tone.getContext().rawContext.resume();
      console.log('🔓 Audio unlocked:', Tone.getContext().rawContext.state);
    } catch (e) {
      console.warn('Unlock failed:', e);
    } finally {
      ['pointerdown', 'keydown', 'touchstart'].forEach(evt => {
        window.removeEventListener(evt, unlock);
      });
    }
  };
  
  window.addEventListener('pointerdown', unlock, { once: true });
  window.addEventListener('keydown', unlock, { once: true });
  window.addEventListener('touchstart', unlock, { once: true, passive: true });
}

// -------------------- Audio Graph Initialization --------------------
function initAudio() {
  // CRITICAL: Much lower gain + slower ramps for desktop stability
  master.fxIn = new Tone.Gain(0.25); // Reduced from 0.18
  
  // Master bus filters with SLOWER frequency ramps
  master.lowCutFilter = new Tone.Filter({
    type: 'highpass',
    frequency: state.lowCut,
    rolloff: -12
  });
  
  master.highCutFilter = new Tone.Filter({
    type: 'lowpass',
    frequency: state.highCut,
    rolloff: -12
  });
  
  // Tape saturation (subtle warm distortion)
  master.tapeDistortion = new Tone.Distortion({
    distortion: state.tapeSaturation / 100 * 0.2, // Reduced from 0.3
    wet: state.tapeSaturation / 100 * 0.6 // Reduced wet mix
  });
  
  // Vinyl noise (pink noise layer) - QUIETER
  master.vinylNoise = new Tone.Noise('pink');
  master.vinylNoise.volume.value = -50 + (state.vinylNoise / 100 * 15); // Quieter
  master.vinylNoise.start();
  master.vinylNoise.connect(master.fxIn);
  
  // Effects with MUCH gentler settings for desktop
  effects.filter = new Tone.Filter(fxConfig.filter.frequency, fxConfig.filter.type);
  effects.distortion = new Tone.Distortion(0.01); // Half strength
  effects.chorus = new Tone.Chorus(1.5, 2.5, 0.1).start(); // Reduced depth
  effects.flanger = new Tone.Chorus({
    frequency: 0.5,
    delayTime: 2,
    depth: 0.3, // Reduced from 0.5
    type: 'sine',
    spread: 0
  }).start();
  effects.phaser = new Tone.Phaser({
    frequency: 0.3, // Slower modulation
    octaves: 2, // Reduced from 3
    baseFrequency: 350
  });
  effects.bitcrusher = new Tone.BitCrusher(10); // Less crushing (was 8)
  effects.delay = new Tone.FeedbackDelay(fxConfig.delay.time, 0.08); // Less feedback
  effects.reverb = new Tone.Reverb({ decay: 0.6, wet: 0.1 }); // Drier reverb
  
  master.comp = new Tone.Compressor({
    threshold: state.compressor,
    ratio: 4, // More compression = more consistent volume
    attack: 0.003,
    release: 0.15
  });
  master.limiter = new Tone.Limiter(-2); // Safety limiter catches peaks
  
  // Connect master bus chain
  master.fxIn.chain(
    master.lowCutFilter,
    master.highCutFilter,
    master.tapeDistortion,
    effects.filter,
    effects.distortion,
    effects.bitcrusher,
    effects.chorus,
    effects.flanger,
    effects.phaser,
    effects.delay,
    effects.reverb,
    master.comp,
    master.limiter
  );
  
  master.limiter.toDestination();
  
  // Clip detection meter
  master.meter = new Tone.Meter();
  master.limiter.connect(master.meter);
  
  // Visualizer tap
  master.analyser = new Tone.Analyser('fft', 64);
  master.limiter.connect(master.analyser);
  
  // Recording tap
  const raw = Tone.getContext().rawContext;
  master.mediaDest = raw.createMediaStreamDestination();
  master.limiter.connect(master.mediaDest);
  master.mediaRecorder = null;
  master.recordedChunks = [];
  
  // Start with all FX completely dry
  Object.values(effects).forEach(fx => {
    if (fx.wet) fx.wet.value = 0;
  });
  
  // Create synths and channels
  Object.keys(instruments).forEach(inst => createInstrumentChain(inst));
  
  // Transport setup
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Initialize metronome
  metronome.synth = new Tone.MembraneSynth({
    pitchDecay: 0.008,
    octaves: 2,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
  }).toDestination();
  
  metronome.synth.volume.value = state.metronomeVolume;

  // Optimize instrument levels for better mix
  instruments.kick.volume = 0;
  instruments.snare.volume = -2;
  instruments.hihat.volume = -6;
  instruments.bass.volume = -3;
  
  metronome.loop = new Tone.Loop((time) => {
    const step = Math.floor(Tone.Transport.position.split(':')[1]);
    const isDownbeat = step === 0;
    const pitch = isDownbeat ? 'C5' : 'C4';
    const velocity = isDownbeat ? 1 : 0.6;
    
    if (state.metronomeEnabled) {
      metronome.synth.triggerAttackRelease(pitch, '32n', time, velocity);
    }
  }, '4n');
  
  metronome.loop.start(0);
  
  // CRITICAL: Batch note triggers to reduce message handler load
  const noteQueue = [];
  let batchTimeout = null;
  
  const flushNoteQueue = (time) => {
    if (noteQueue.length === 0) return;
    
    // Sort by time to maintain order
    noteQueue.sort((a, b) => a.time - b.time);
    
    // Trigger all notes at their scheduled times
    noteQueue.forEach(({ inst, step, time: noteTime }) => {
      playStep(inst, step, noteTime);
    });
    
    noteQueue.length = 0;
  };
  
  // Main sequencer loop - FIXED TIMING
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);
    
    const activeInsts = Object.keys(instruments).filter(inst => 
      patterns[inst][step]?.active
    );
    
    // 🔥 FIX: Play drum instruments IMMEDIATELY without batching
    // Only batch melodic instruments to prevent message handler overload
    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');
    
    // Play drums immediately - no offset (tight timing critical)
    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });
    
    // Batch melodic instruments with tiny offset (they're more forgiving)
    melodicInsts.forEach((inst, idx) => {
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002; // Reduced from 0.005
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });
    
    updateVisualizer();
  }, Array.from({ length: state.sequenceLength }, (_, i) => i), state.resolution);
  
  loop.start(0);
}

// In createInstrumentChain function (around line ~676), replace with:
function createInstrumentChain(inst) {
  const instData = instruments[inst];
  
  if (instData.type === 'drum') {
    synths[inst] = createDrumSynth(inst);
  } else if (instData.type === 'atmospheric') {
    synths[inst] = createFallbackDrumSynth(inst); // Use synths for atmospheric
    synths[inst].volume = { value: instData.volume };
  } else {
    synths[inst] = createMelodicSynth(inst);
    synths[inst].volume.value = instData.volume;
  }
  
  // Create channel - completely dry, no reverb sends
  const channel = new Tone.Channel({
    pan: 0,
    volume: instData.volume
  }).connect(master.fxIn);
  
  instData.channel = channel;
  synths[inst].connect(channel);
}
  
// ============ DRUM SAMPLE SYSTEM ============
const DRUM_SAMPLES = {
  kick: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/kick.mp3',
  snare: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3',
  hihat: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3',
  tom: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/tom1.mp3',
  
  // FIXED: Using working CR78 samples
  clap: 'https://tonejs.github.io/audio/drum-samples/CR78/clap.mp3',
  rimshot: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3', // Using snare as fallback
  crash: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  ride: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  
  // NEW INSTRUMENTS - using Tone.js built-in sounds since we need synths anyway
  fx: null, // Will use synth
  riser: null, // Will use synth
  ambience: null // Will use synth
};

function createDrumSynth(inst) {
  const sampleUrl = DRUM_SAMPLES[inst];
  
  if (!sampleUrl) {
    console.warn(`No sample for ${inst}, using fallback synth`);
    return createFallbackDrumSynth(inst);
  }
  
  // Use Tone.Player for single-shot samples
  const player = new Tone.Player({
    url: sampleUrl,
    fadeOut: 0.01,
    onload: () => {
      console.log(`✅ ${inst} loaded`);
    },
    onerror: (err) => {
      console.error(`❌ ${inst} failed to load:`, err);
      // Replace with fallback
      setTimeout(() => {
        if (!player.loaded) {
          synths[inst] = createFallbackDrumSynth(inst);
          console.log(`🔄 Using fallback synth for ${inst}`);
        }
      }, 3000);
    }
  });
  
  // Create volume control for this player
  const playerGain = new Tone.Gain(1);
  player.connect(playerGain);
  
  // Return proxy that matches synth interface
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      if (player.loaded) {
        player.stop(time);
        playerGain.gain.setValueAtTime(velocity, time);
        player.start(time);
      }
    },
    connect: (node) => {
      playerGain.disconnect();
      playerGain.connect(node);
      return playerGain;
    },
    toDestination: () => playerGain.toDestination(),
    dispose: () => {
      player.dispose();
      playerGain.dispose();
    },
    get loaded() {
      return player.loaded;
    },
    player: player,
    gain: playerGain
  };
}

// Add this new function after createDrumSynth
function createFallbackDrumSynth(inst) {
  let synth;
  
  switch(inst) {
    case 'kick':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
      });
      break;
      
    case 'snare':
      synth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
      });
      break;
      
    case 'hihat':
      synth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'crash':
      synth = new Tone.MetalSynth({
        frequency: 100,
        envelope: { attack: 0.001, decay: 1.4, release: 2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'ride':
      synth = new Tone.MetalSynth({
        frequency: 150,
        envelope: { attack: 0.001, decay: 0.8, release: 0.5 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'clap':
      // Layered noise bursts for clap sound
      const clap = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      const clap2 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.015, decay: 0.03, sustain: 0 }
      });
      const clap3 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.025, decay: 0.02, sustain: 0 }
      });
      
      // Merge into one synth
      const clapGain = new Tone.Gain(1);
      clap.connect(clapGain);
      clap2.connect(clapGain);
      clap3.connect(clapGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          clap.triggerAttackRelease(duration, time, velocity);
          clap2.triggerAttackRelease(duration, time + 0.015, velocity * 0.7);
          clap3.triggerAttackRelease(duration, time + 0.025, velocity * 0.5);
        },
        connect: (node) => clapGain.connect(node),
        toDestination: () => clapGain.toDestination(),
        dispose: () => {
          clap.dispose();
          clap2.dispose();
          clap3.dispose();
          clapGain.dispose();
        },
        loaded: true
      };
      
    case 'rimshot':
      synth = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      break;
      
    case 'tom':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8 }
      });
      break;
      
    // NEW ATMOSPHERIC SYNTHS
    case 'fx':
      // Glitchy stutter effect
      const fxSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
        harmonicity: 12,
        modulationIndex: 50,
        resonance: 2000,
        octaves: 0.5
      });
      const fxGain = new Tone.Gain(0.2);
      fxSynth.connect(fxGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          fxSynth.triggerAttackRelease('32n', time, velocity * 0.3);
        },
        connect: (node) => fxGain.connect(node),
        toDestination: () => fxGain.toDestination(),
        dispose: () => {
          fxSynth.dispose();
          fxGain.dispose();
        },
        loaded: true
      };
      
    case 'riser':
      // Sweeping frequency riser
      synth = new Tone.FMSynth({
        harmonicity: 3,
        modulationIndex: 10,
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 2, decay: 0.1, sustain: 0.1, release: 0.5 },
        modulation: { type: 'square' },
        modulationEnvelope: { attack: 2, decay: 0.2, sustain: 0.5, release: 0.3 }
      });
      break;
      
    case 'ambience':
      // Dark atmospheric pad
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sine' },
        envelope: { attack: 1, decay: 1, sustain: 0.5, release: 2 }
      });
      
      // Add reverb for atmosphere
      const ambReverb = new Tone.Reverb({
        decay: 8,
        wet: 0.7
      });
      ambReverb.generate();
      synth.connect(ambReverb);
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          synth.triggerAttackRelease(note, duration, time, velocity);
        },
        connect: (node) => {
          ambReverb.disconnect();
          ambReverb.connect(node);
          return ambReverb;
        },
        toDestination: () => ambReverb.toDestination(),
        dispose: () => {
          synth.dispose();
          ambReverb.dispose();
        },
        loaded: true
      };
      
    default:
      synth = new Tone.MembraneSynth();
  }
  
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      synth.triggerAttackRelease(note, duration, time, velocity);
    },
    connect: (node) => synth.connect(node),
    toDestination: () => synth.toDestination(),
    dispose: () => synth.dispose(),
    loaded: true
  };
}

function playDrumNote(inst, time, velocity) {
  const synth = synths[inst];
  if (!synth) {
    console.warn(`No synth for ${inst}`);
    return;
  }
  
  // Check if sample is loaded
  if (!synth.loaded) {
    console.warn(`${inst} sample not loaded yet`);
    return;
  }
  
  // All drums trigger at same pitch - sample handles the sound
  synth.triggerAttackRelease('C2', '8n', time, velocity * 0.9);
}

// Melodic instrument samples using Tone.Sampler
const MELODIC_SAMPLES = {
  bass: {
    'C2': 'https://tonejs.github.io/audio/salamander/C2.mp3',
    'D#2': 'https://tonejs.github.io/audio/salamander/Ds2.mp3',
    'F#2': 'https://tonejs.github.io/audio/salamander/Fs2.mp3',
    'A2': 'https://tonejs.github.io/audio/salamander/A2.mp3'
  },
  guitar: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3'
  },
  keys: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3'
  },
  lead: {
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3',
    'D#5': 'https://tonejs.github.io/audio/salamander/Ds5.mp3',
    'F#5': 'https://tonejs.github.io/audio/salamander/Fs5.mp3',
    'A5': 'https://tonejs.github.io/audio/salamander/A5.mp3'
  }
};

function createMelodicSynth(inst) {
  const samples = MELODIC_SAMPLES[inst];
  
  if (!samples) {
    console.warn(`No samples for ${inst}, using fallback synth`);
    return new Tone.PolySynth(Tone.Synth);
  }
  
  const sampler = new Tone.Sampler({
    urls: samples,
    release: 2, // Longer release = more dreamy
    onload: () => {
      console.log(`✅ ${inst} samples loaded`);
    }
  });
  
  switch (inst) {
    case 'bass':
      const bassComp = new Tone.Compressor(-30, 3);
      const bassDist = new Tone.Distortion(0.1);
      sampler.chain(bassDist, bassComp);
      return sampler;
      
    case 'guitar':
      // MORE reverb and chorus for dreamier sound
      const guitarReverb = new Tone.Reverb({
        decay: 3,
        wet: 0.4
      });
      guitarReverb.generate();
      
      const guitarChorus = new Tone.Chorus({
        frequency: 0.5, // Slower = dreamier
        delayTime: 3.5,
        depth: 0.3,
        type: 'sine',
        spread: 180
      }).start();
      
      sampler.chain(guitarChorus, guitarReverb);
      return sampler;
      
    case 'keys':
      // Dark pad sound
      const keysReverb = new Tone.Reverb({
        decay: 4,
        wet: 0.5
      });
      keysReverb.generate();
      
      const keysChorus = new Tone.Chorus(0.3, 4, 0.4).start();
      
      sampler.chain(keysChorus, keysReverb);
      return sampler;
      
    case 'lead':
      // Ethereal lead
      const leadReverb = new Tone.Reverb({
        decay: 5,
        wet: 0.6
      });
      leadReverb.generate();
      
      const leadDelay = new Tone.FeedbackDelay({
        delayTime: '8n',
        feedback: 0.4,
        wet: 0.3
      });
      
      sampler.chain(leadDelay, leadReverb);
      return sampler;
      
    default:
      return sampler;
  }
}

function playStep(inst, step, time) {
  const stepData = patterns[inst][step];
  if (!stepData.active) return;
  
  const instData = instruments[inst];
  if (instData.mute) return;
  
  const anySolo = Object.values(instruments).some(i => i.solo);
  if (anySolo && !instData.solo) return;
  
  if (Math.random() * 100 > stepData.probability) return;
  
  // 🔥 FIX: Check if sample is loaded before playing
  const synth = synths[inst];
  if (instData.type === 'drum' && synth && !synth.loaded) {
    console.warn(`⚠️ ${inst} sample not loaded, skipping step`);
    return;
  }
  
  // Per-instrument humanization scaling
  const humanizeScale = {
    kick: 0.5,
    snare: 0.7,
    hihat: 1.2,
    bass: 0.6,
    guitar: 1.0,
    keys: 0.8,
    lead: 0.9,
    fx: 0.3,
    riser: 0.1,
    ambience: 0.2
  };
  
  const scale = humanizeScale[inst] || 1.0;
  const humanize = (Math.random() - 0.5) * (state.humanize / 1000) * scale;
  
  let velocity = stepData.velocity;
  if (instData.type === 'drum') {
    velocity *= (0.95 + Math.random() * 0.1);
  }
  
  if (instData.type === 'drum') {
    playDrumNote(inst, time + humanize, velocity);
  } else if (instData.type === 'atmospheric') {
    playAtmosphericNote(inst, time + humanize, stepData);
  } else {
    playMelodicNote(inst, time + humanize, stepData);
  }
}

function playMelodicNote(inst, time, stepData) {
  const note = stepData.note || instruments[inst].note || 'C4';
  const duration = stepData.duration || '8n';
  synths[inst].triggerAttackRelease(note, duration, time, stepData.velocity);
}

function playAtmosphericNote(inst, time, stepData) {
  const duration = stepData.duration || '1n'; // Longer by default
  const velocity = stepData.velocity || 0.5;
  
  if (inst === 'fx') {
    // Glitchy FX - random pitch
    const pitch = ['C4', 'D#4', 'F#4', 'A#4'][Math.floor(Math.random() * 4)];
    synths[inst].triggerAttackRelease(pitch, '8n', time, velocity);
  } else if (inst === 'riser') {
    // Rising frequency sweep
    synths[inst].triggerAttackRelease('C2', '2n', time, velocity);
    // Add frequency sweep
    if (synths[inst].frequency) {
      synths[inst].frequency.exponentialRampTo('C6', '2n', time);
    }
  } else if (inst === 'ambience') {
    // Dark ambient chord
    const notes = ['C2', 'D#2', 'G2', 'A#2'];
    synths[inst].triggerAttackRelease(notes, duration, time, velocity * 0.4);
  }
}
  
// -------------------- Vibe System --------------------
function nextVibe() {
  const currentVibe = document.body.getAttribute('data-vibe') || 'moon';
  const currentIndex = VIBES.indexOf(currentVibe);
  const nextIndex = (currentIndex + 1) % VIBES.length;
  return VIBES[nextIndex];
}

function applyVibe(vibe) {
  document.body.setAttribute('data-vibe', vibe);
  try {
    localStorage.setItem(CONFIG.STORAGE_KEY, vibe);
    console.log('💾 Saved vibe:', vibe);
  } catch (e) {
    console.warn('localStorage unavailable:', e);
  }
  
  const label = vibe.charAt(0).toUpperCase() + vibe.slice(1);
  const btn = document.getElementById('vibeBtn');
  if (btn) btn.textContent = `🌈 Vibe: ${label}`;
}

function loadSavedVibe() {
  try {
    const savedVibe = localStorage.getItem(CONFIG.STORAGE_KEY);
    if (savedVibe && VIBES.includes(savedVibe)) {
      applyVibe(savedVibe);
      console.log('✅ Loaded saved vibe:', savedVibe);
    } else {
      applyVibe('moon');
    }
  } catch (e) {
    console.warn('Could not load vibe:', e);
    applyVibe('moon');
  }
}

function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      const next = nextVibe();
      applyVibe(next);
      console.log('🌈 Switched to:', next);
    });
  }
}

// -------------------- Pattern Management --------------------
function ensurePatternLength(length) {
  Object.keys(patterns).forEach(inst => {
    const arr = patterns[inst];
    
    while (arr.length < length) {
      arr.push({
        active: false,
        velocity: 0.8,
        probability: 100,
        note: instruments[inst].note,
        duration: '8n'
      });
    }
    
    if (arr.length > length) arr.length = length;
  });
}

// -------------------- Event Handlers Setup --------------------
function setupEventListeners() {
  setupGenreSelector();
  setupTabs();
  setupTransportControls();
  setupParameterControls();
  setupGeneratorButtons();
  setupSequencerControls();
  setupMixerListeners();
  setupFXListeners();
  setupHarmonyControls();
  setupProjectManagement();
  setupKeyboardShortcuts();
  setupVibeSelector();
  setupMultitrackListeners();
}

function setupGenreSelector() {
  document.getElementById('genreSelector').addEventListener('click', e => {
    const btn = e.target.closest('.genre-btn');
    if (!btn) return;
    
    document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.currentGenre = btn.dataset.genre;
    updateGenrePresets();
  });
}

function setupTabs() {
  document.getElementById('tabs').addEventListener('click', e => {
    const tab = e.target.closest('.tab');
    if (!tab) return;
    
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    
    state.currentTab = tab.dataset.tab;
  });
}

function setupTransportControls() {
  document.getElementById('playBtn').addEventListener('click', togglePlay);
  document.getElementById('stopBtn').addEventListener('click', stop);
  document.getElementById('exportBtn').addEventListener('click', exportAudio);
  
  // Metronome controls
  document.getElementById('metronomeBtn')?.addEventListener('click', () => {
    state.metronomeEnabled = !state.metronomeEnabled;
    const btn = document.getElementById('metronomeBtn');
    btn.textContent = state.metronomeEnabled ? '🥁 Click: On' : '🥁 Click: Off';
  });
  
  document.getElementById('countInBtn')?.addEventListener('click', () => {
    state.countInBars = state.countInBars === 1 ? 2 : state.countInBars === 2 ? 0 : 1;
    const btn = document.getElementById('countInBtn');
    const labels = ['⏱️ Count: Off', '⏱️ Count: 1 bar', '⏱️ Count: 2 bars'];
    btn.textContent = labels[state.countInBars];
  });
}

function setupParameterControls() {
  // BPM with debounce
  const bpmHandler = debounce(value => {
    state.bpm = clamp(value, 60, CONFIG.MAX_BPM);
    Tone.Transport.bpm.value = state.bpm;
  }, CONFIG.DEBOUNCE_MS);
  
  document.getElementById('bpmSlider').addEventListener('input', e => {
    const value = parseInt(e.target.value, 10);
    document.getElementById('bpmValue').textContent = value;
    bpmHandler(value);
  });
  
  // Swing
  document.getElementById('swingSlider').addEventListener('input', e => {
    state.swing = parseInt(e.target.value, 10);
    document.getElementById('swingValue').textContent = state.swing + '%';
    Tone.Transport.swing = state.swing / 100;
    Tone.Transport.swingSubdivision = '8n';
  });
  
  // Duration
  document.getElementById('durSlider').addEventListener('input', e => {
    state.duration = parseInt(e.target.value, 10);
    document.getElementById('durValue').textContent = state.duration + ' min';
    document.getElementById('durationDisplay').textContent = 
      '/ ' + String(state.duration).padStart(2, '0') + ':00';
  });
  
  // Complexity
  document.getElementById('complexSlider').addEventListener('input', e => {
    state.complexity = parseInt(e.target.value, 10);
    const labels = ['Simple', 'Medium', 'Complex'];
    document.getElementById('complexValue').textContent = labels[state.complexity - 1];
  });
  
  // Humanize
  document.getElementById('humanSlider').addEventListener('input', e => {
    state.humanize = parseInt(e.target.value, 10);
    document.getElementById('humanValue').textContent = state.humanize + 'ms';
  });
  
  // Master controls
  setupMasterControls();
}

function setupMasterControls() {
  document.getElementById('masterVolSlider').addEventListener('input', debounce(e => {
    state.masterVolume = parseInt(e.target.value, 10);
    document.getElementById('masterVolValue').textContent = state.masterVolume + 'dB';
    Tone.Destination.volume.rampTo(state.masterVolume, 0.1); // RAMP instead of instant
  }, 100)); // Debounce
  
  document.getElementById('tapeSlider').addEventListener('input', debounce(e => {
    state.tapeSaturation = parseInt(e.target.value, 10);
    document.getElementById('tapeValue').textContent = state.tapeSaturation + '%';
    if (master.tapeDistortion) {
      master.tapeDistortion.distortion = state.tapeSaturation / 100 * 0.2; // Reduced
      master.tapeDistortion.wet.rampTo(state.tapeSaturation / 100 * 0.6, 0.1); // Ramp
    }
  }, 100));
  
  document.getElementById('vinylSlider').addEventListener('input', debounce(e => {
    state.vinylNoise = parseInt(e.target.value, 10);
    document.getElementById('vinylValue').textContent = state.vinylNoise + '%';
    if (master.vinylNoise) {
      master.vinylNoise.volume.rampTo(-50 + (state.vinylNoise / 100 * 15), 0.1); // Ramp
    }
  }, 100));
  
  document.getElementById('lowCutSlider').addEventListener('input', debounce(e => {
    state.lowCut = parseInt(e.target.value, 10);
    document.getElementById('lowCutValue').textContent = state.lowCut + 'Hz';
    if (master.lowCutFilter) {
      master.lowCutFilter.frequency.rampTo(state.lowCut, 0.15); // Slower ramp
    }
  }, 100));
  
  document.getElementById('highCutSlider').addEventListener('input', debounce(e => {
    state.highCut = parseInt(e.target.value, 10);
    document.getElementById('highCutValue').textContent = 
      (state.highCut / 1000).toFixed(1) + 'kHz';
    if (master.highCutFilter) {
      master.highCutFilter.frequency.rampTo(state.highCut, 0.15); // Slower ramp
    }
  }, 100));
  
  document.getElementById('compSlider').addEventListener('input', debounce(e => {
    state.compressor = parseInt(e.target.value, 10);
    document.getElementById('compValue').textContent = state.compressor + 'dB';
    if (master.comp) {
      master.comp.threshold.rampTo(state.compressor, 0.1); // Ramp
    }
  }, 100));
}

function setupGeneratorButtons() {
  document.getElementById('generateBtn').addEventListener('click', () => {
    generateBeat();
    if (state.complexity >= 2) {
      addRhythmicVariety();
    }
  });
  
  document.getElementById('generateRhythmBtn').addEventListener('click', () => {
    generateMelodicPatterns();
    addDrumFills();
    addSwingVariations();
  });
  
  document.getElementById('randomVelBtn').addEventListener('click', randomizeVelocity);
  document.getElementById('randomProbBtn').addEventListener('click', randomizeProbability);
  document.getElementById('clearBtn').addEventListener('click', clearPattern);
}

function setupSequencerControls() {
  document.getElementById('lenDecBtn').addEventListener('click', () => {
    state.sequenceLength = Math.max(CONFIG.MIN_SEQUENCE_LENGTH, state.sequenceLength - 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('lenIncBtn').addEventListener('click', () => {
    state.sequenceLength = Math.min(CONFIG.MAX_SEQUENCE_LENGTH, state.sequenceLength + 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('resSelect').addEventListener('change', e => {
    state.resolution = e.target.value;
  });
  
  document.getElementById('euclidBtn').addEventListener('click', applyEuclidean);
  document.getElementById('ghostBtn').addEventListener('click', addGhostNotes);
  
  // Delegated sequencer events
  const seqGrid = document.getElementById('seqGrid');
  seqGrid.addEventListener('click', handleSequencerClick);
}

function handleSequencerClick(e) {
  const stepEl = e.target.closest('.step');
  if (stepEl) {
    const inst = stepEl.dataset.inst;
    const step = parseInt(stepEl.dataset.step, 10);
    toggleStep(inst, step, e);
    return;
  }
  
  const icon = e.target.closest('.seq-icon');
  if (icon) {
    const inst = icon.dataset.inst;
    const action = icon.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    } else if (action === 'note') {
      openNoteEditor(inst);
    }
    
    renderSequencer();
  }
}

function setupMixerListeners() {
  const mixerGrid = document.getElementById('mixerGrid');
  
  mixerGrid.addEventListener('click', e => {
    const btn = e.target.closest('.channel-btn');
    if (!btn) return;
    
    const inst = btn.dataset.inst;
    const action = btn.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    }
    
    renderMixer();
    renderSequencer();
  });
  
  mixerGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;
    
    const inst = e.target.dataset.inst;
    const param = e.target.dataset.param;
    const value = parseFloat(e.target.value);
    
    instruments[inst][param] = value;
    
    if (param === 'volume' && instruments[inst].channel) {
      instruments[inst].channel.volume.value = value;
    } else if (param === 'pan' && instruments[inst].channel) {
      instruments[inst].channel.pan.value = value / 100;
    }
    
    const parent = e.target.closest('.param-control');
    const valEl = parent.querySelector('.param-value');
    
    if (param === 'volume') {
      valEl.textContent = value + 'dB';
    } else if (param === 'pan') {
      const label = value > 0 ? 'R' : value < 0 ? 'L' : 'C';
      valEl.textContent = label + Math.abs(value);
    }
  });
}

function setupFXListeners() {
  const fxGrid = document.getElementById('fxGrid');
  
  fxGrid.addEventListener('click', e => {
    const toggle = e.target.closest('.fx-toggle');
    if (!toggle) return;
    
    const fx = toggle.dataset.fx;
    fxConfig[fx].active = !fxConfig[fx].active;
    
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = fxConfig[fx].active ? 0.5 : 0;
    }
    
    renderFX();
  });
  
  fxGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;
    
    const fx = e.target.dataset.fx;
    const param = e.target.dataset.param;
    const raw = parseInt(e.target.value, 10);
    const value = mapFxParam(param, raw);
    
    fxConfig[fx][param] = value;
    applyFxParam(fx, param, value);
    
    const label = e.target.closest('.param-control').querySelector('.param-value');
    label.textContent = formatFxDisplay(param, value);
  });
}

function setupHarmonyControls() {
  document.getElementById('keySelect').addEventListener('change', e => {
    state.key = e.target.value;
    updateChords();
  });
  
  document.getElementById('scaleSelect').addEventListener('change', e => {
    state.scale = e.target.value;
    updateChords();
  });
  
  document.getElementById('octaveSelect').addEventListener('change', e => {
    state.octave = parseInt(e.target.value, 10);
  });
  
  document.getElementById('genProgBtn').addEventListener('click', generateProgression);
  document.getElementById('clearProgBtn').addEventListener('click', () => {
    state.progression = [];
    renderProgression();
  });
  
  document.querySelectorAll('[data-prog]').forEach(btn => {
    btn.addEventListener('click', e => {
      loadProgressionTemplate(e.currentTarget.dataset.prog);
    });
  });
}

function setupProjectManagement() {
  document.getElementById('saveBtn').addEventListener('click', saveProject);
  document.getElementById('loadBtn').addEventListener('click', loadProject);
}

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      e.preventDefault();
      togglePlay();
    } else if (e.code === 'KeyS') {
      e.preventDefault();
      stop();
    } else if (e.code === 'KeyE') {
      e.preventDefault();
      exportAudio();
    }
  });
}

function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      applyVibe(nextVibe());
    });
  }
}

// -------------------- FX Parameter Mapping --------------------
function mapFxParam(param, raw) {
  switch (param) {
    case 'decay':
      return raw / 20;
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return raw / 100;
    case 'time':
      return ['16n', '8n', '4n', '2n'][Math.min(3, Math.floor(raw / 25))];
    case 'frequency':
      return 100 + raw * 79;
    case 'octaves':
      return Math.floor(raw / 20) + 1;
    default:
      return raw / 50;
  }
}

function applyFxParam(fx, param, value) {
  const node = effects[fx];
  if (!node) return;
  
  if (param === 'decay' && node.decay !== undefined) {
    node.decay = value;
  } else if (param === 'wet' && node.wet) {
    node.wet.value = value;
  } else if (param === 'time' && node.delayTime) {
    node.delayTime.value = Tone.Time(value);
  } else if (param === 'feedback' && node.feedback) {
    node.feedback.value = value;
  } else if (param === 'frequency') {
    // Safe frequency updates with ramp to avoid clicks
    if (node.frequency) {
      node.frequency.rampTo(value, 0.1);
    }
  } else if (param === 'depth') {
    if (node.depth !== undefined) {
      node.depth = value;
    }
  } else if (param === 'amount' && node.distortion !== undefined) {
    node.distortion = value;
  } else if (param === 'octaves' && node.octaves !== undefined) {
    node.octaves = value;
  }
}

function formatFxDisplay(param, value) {
  switch (param) {
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return Math.round(value * 100) + '%';
    case 'decay':
      return value.toFixed(2) + 's';
    case 'time':
      return String(value);
    case 'frequency':
      return Math.round(value) + 'Hz';
    case 'octaves':
      return value + ' oct';
    default:
      return String(value);
  }
}

// -------------------- Sequencer Rendering --------------------
function renderSequencer() {
  const grid = document.getElementById('seqGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const instData = instruments[inst];
    const row = document.createElement('div');
    row.className = 'seq-row';
    
    // Label
    const label = document.createElement('div');
    label.className = 'seq-label';
    label.innerHTML = `
      <span>${instData.icon} ${instData.name}</span>
      <div class="seq-icons">
        <button class="seq-icon ${instData.mute ? 'active' : ''}" 
                data-inst="${inst}" data-action="mute">M</button>
        <button class="seq-icon ${instData.solo ? 'active' : ''}" 
                data-inst="${inst}" data-action="solo">S</button>
        ${instData.type === 'melodic' ? 
          `<button class="seq-icon" data-inst="${inst}" data-action="note">🎵</button>` : ''}
      </div>
    `;
    row.appendChild(label);
    
    // Steps
    for (let i = 0; i < state.sequenceLength; i++) {
      const step = patterns[inst][i];
      const cell = document.createElement('div');
      cell.className = 'step';
      cell.dataset.inst = inst;
      cell.dataset.step = i;
      
      if (step.active) {
        cell.classList.add('active');
        
        const probLabel = document.createElement('div');
        probLabel.className = 'step-prob';
        
        if (instData.type === 'melodic' && step.note) {
          probLabel.textContent = step.note;
          probLabel.style.fontSize = '0.6rem';
        } else {
          probLabel.textContent = step.probability + '%';
        }
        
        cell.appendChild(probLabel);
        
        const velBar = document.createElement('div');
        velBar.className = 'step-vel';
        velBar.innerHTML = `<div class="step-vel-fill" 
          style="width:${Math.round((step.velocity || 0) * 100)}%"></div>`;
        cell.appendChild(velBar);
      }
      
      row.appendChild(cell);
    }
    
    fragment.appendChild(row);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
  
  // Playhead
  let playhead = document.getElementById('playhead');
  if (!playhead) {
    playhead = document.createElement('div');
    playhead.id = 'playhead';
    playhead.className = 'playhead';
    document.querySelector('.sequencer').appendChild(playhead);
  }
}

function toggleStep(inst, stepIndex, e) {
  const pattern = patterns[inst][stepIndex];
  const instData = instruments[inst];
  
  if (e.altKey) {
    if (pattern.active) {
      pattern.velocity = Math.min(1, (pattern.velocity || 0.8) + 0.2);
      if (pattern.velocity > 1) pattern.velocity = 0.4;
    }
  } else if (e.shiftKey) {
    if (pattern.active) {
      if (instData.type === 'melodic') {
        cycleNote(inst, stepIndex);
      } else {
        pattern.probability = Math.min(100, pattern.probability + 25);
        if (pattern.probability > 100) pattern.probability = 50;
      }
    }
  } else if (e.ctrlKey || e.metaKey) {
    if (instData.type === 'melodic' && pattern.active) {
      const newNote = prompt(
        `Enter note (e.g., C4, D#3):`,
        pattern.note || instData.note
      );
      if (newNote && /^[A-G]#?[1-6]$/.test(newNote)) {
        pattern.note = newNote;
      }
    }
  } else {
    pattern.active = !pattern.active;
    if (pattern.active) {
      pattern.velocity = 0.8;
      pattern.probability = 100;
      if (instData.type === 'melodic') {
        pattern.note = instData.note;
        pattern.duration = '8n';
      }
    }
  }
  
  renderSequencer();
}

function cycleNote(inst, stepIndex) {
  const pattern = patterns[inst][stepIndex];
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const currentNote = pattern.note || instruments[inst].note;
  const match = currentNote.match(/^([A-G]#?)(\d+)$/);
  if (!match) return;
  
  const [, noteName, octave] = match;
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12]);
  const index = scaleNotes.indexOf(noteName);
  const nextNote = scaleNotes[(index + 1 + scaleNotes.length) % scaleNotes.length] + octave;
  
  pattern.note = nextNote;
}

function updateStepVisuals(step) {
  const widthPerStep = 100 / state.sequenceLength;
  const playhead = document.getElementById('playhead');
  if (playhead) {
    playhead.style.transform = `translateX(${(step + 0.5) * widthPerStep}%)`;
  }
}

function openNoteEditor(inst) {
  // Create modal backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  // Get current note
  const currentNote = instruments[inst].note || 'C4';
  
  // Generate all possible notes (C1 to C6)
  const allNotes = [];
  for (let octave = 1; octave <= 6; octave++) {
    keysArr.forEach(note => {
      allNotes.push(note + octave);
    });
  }
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">🎵 ${instruments[inst].icon} ${instruments[inst].name} - Select Note</div>
      <button class="modal-close" id="closeNoteModal">✕</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom: var(--space-4); color: var(--text-secondary);">
        Choose the default note for <strong>${instruments[inst].name}</strong>. 
        This will apply to all active steps that don't have a custom note set.
      </p>
      
      <div style="display: grid; gap: var(--space-3);">
        <label style="display: flex; flex-direction: column; gap: var(--space-2);">
          <span style="font-weight: 700; color: var(--text-primary);">Note</span>
          <select id="noteSelect" style="font-size: var(--text-base); padding: var(--space-4);">
            ${allNotes.map(note => 
              `<option value="${note}" ${note === currentNote ? 'selected' : ''}>${note}</option>`
            ).join('')}
          </select>
        </label>
        
        <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border);">
          <div style="font-weight: 700; margin-bottom: var(--space-2); color: var(--text-primary);">Current: ${currentNote}</div>
          <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
            Lower octaves (1-2) = Bass range<br>
            Mid octaves (3-4) = Chord/melody range<br>
            High octaves (5-6) = Lead range
          </div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" id="cancelNoteBtn">Cancel</button>
      <button class="btn btn-primary" id="applyNoteBtn">Apply Note</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  // Focus the select
  setTimeout(() => document.getElementById('noteSelect').focus(), 100);
  
  // Event handlers
  const close = () => backdrop.remove();
  
  document.getElementById('closeNoteModal').onclick = close;
  document.getElementById('cancelNoteBtn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  document.getElementById('applyNoteBtn').onclick = () => {
    const newNote = document.getElementById('noteSelect').value;
    instruments[inst].note = newNote;
    
    // Update all active steps without custom notes
    patterns[inst].forEach(step => {
      if (step.active && !step.note) {
        step.note = newNote;
      }
    });
    
    renderSequencer();
    close();
    
    // Show confirmation toast
    showToast(`🎵 ${instruments[inst].name} note set to ${newNote}`, 'success');
  };
  
  // Keyboard support
  modal.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
    if (e.key === 'Enter' && e.target.tagName !== 'SELECT') {
      document.getElementById('applyNoteBtn').click();
    }
  });
}

function showToast(message, type = 'info') {
  let container = document.querySelector('.toast-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'toast-container';
    document.body.appendChild(container);
  }
  
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: '✅',
    error: '❌',
    warning: '⚠️',
    info: 'ℹ️'
  };
  
  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || icons.info}</span>
    <span>${message}</span>
    <button class="toast-close">✕</button>
  `;
  
  container.appendChild(toast);
  
  toast.querySelector('.toast-close').onclick = () => toast.remove();
  
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(100%)';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}
  
// -------------------- Pattern Generators --------------------
function generateBeat() {
  const genre = state.currentGenre;
  
  // Clear all patterns first
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
    });
  });
  
  // Generate rhythms based on genre theory
  // DON'T change BPM/swing - user controls those
  if (genre === 'lofi') {
    generateLoFiBeat();
  } else if (genre === 'hiphop') {
    generateHipHopBeat();
  } else if (genre === 'postpunk') {
    generatePostPunkBeat();
  } else if (genre === 'rnb') {
    generateRnBBeat();
  } else if (genre === 'ambient') {
    generateAmbientBeat();
  } else if (genre === 'dazecore') {
    generateDazecoreBeat();
  }
  
  renderSequencer();
  
  console.log(`✅ Generated ${genre} beat with ${state.complexity} complexity at ${state.bpm} BPM`);
}

// Lo-Fi: Laid back, off-grid, jazzy
function generateLoFiBeat() {
  // DON'T set BPM - user controls it
  const len = state.sequenceLength;
  
  // Kick: Sparse, on 1 and 3 throughout entire sequence
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    setStep('kick', offset + 8, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.3) setStep('kick', offset + 6, 0.7, 80);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 10, 0.75, 70);
  }
  
  // Snare: Backbeat on 2 and 4
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) setStep('snare', offset + 14, 0.4, 60);
  }
  
  // Hi-hat: Shuffled 8ths
  for (let i = 0; i < len; i += 2) {
    const vel = i % 4 === 0 ? 0.7 : 0.45;
    setStep('hihat', i, vel, 95);
    if (state.complexity >= 2 && i % 4 === 2) setStep('hihat', i + 1, 0.3, 70);
  }
  
  // Rimshot: Sparse accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.5, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.5, 80);
    }
  }
  
  // Crash: Bar markers
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
    }
  }
}
  
// Hip-Hop: Boom-bap, hard-hitting
function generateHipHopBeat() {
  const len = state.sequenceLength;
  
  // Kick: Boom-bap throughout
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.9, 100);
    setStep('kick', offset + 6, 0.85, 100);
    if (state.complexity >= 2) {
      if (Math.random() > 0.5) setStep('kick', offset + 9, 0.8, 90);
      if (Math.random() > 0.6) setStep('kick', offset + 13, 0.75, 85);
    }
  }
  
  // Snare: Hard backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.9, 100);
    setStep('snare', offset + 12, 0.9, 100);
  }
  
  // Clap: Layer with snare
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('clap', offset + 4, 0.7, 100);
    setStep('clap', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Steady 8ths and 16ths
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    for (let i = 3; i < len; i += 4) {
      setStep('hihat', i, 0.4, 85);
    }
  }
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.5) setStep('crash', offset + 6, 0.5, 75);
      if (Math.random() > 0.5) setStep('crash', offset + 14, 0.5, 75);
    }
  }
  
  // Tom fills at end of each bar
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.65, 95);
        setStep('tom', offset + 14, 0.75, 95);
        setStep('tom', offset + 15, 0.85, 95);
      }
    }
  }
}
  
// Post-Punk: Driving, motorik, relentless
function generatePostPunkBeat() {
  const len = state.sequenceLength;
  const fourOnFloor = Math.random() > 0.3;
  
  // Kick: Four-on-floor or driving 8ths
  if (fourOnFloor) {
    for (let i = 0; i < len; i += 4) {
      setStep('kick', i, 0.85, 100);
    }
  } else {
    for (let i = 0; i < len; i += 2) {
      setStep('kick', i, i % 4 === 0 ? 0.85 : 0.75, 100);
    }
  }
  
  // Snare: Backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.8, 100);
    setStep('snare', offset + 12, 0.8, 100);
    if (state.complexity >= 2) setStep('snare', offset + 10, 0.7, 80);
  }
  
  // Rimshot: Driving 16ths
  if (state.complexity >= 2) {
    for (let i = 1; i < len; i += 2) {
      if (Math.random() > 0.4) setStep('rimshot', i, 0.5, 85);
    }
  }
  
  // Hi-hat: Mechanical 16ths
  for (let i = 0; i < len; i++) {
    const vel = i % 4 === 0 ? 0.7 : 0.5;
    setStep('hihat', i, vel, 100);
  }
  
  // Ride: Alternative
  if (state.complexity >= 3 && Math.random() > 0.5) {
    for (let i = 0; i < len; i += 2) {
      if (Math.random() > 0.3) setStep('ride', i, 0.55, 90);
    }
  }
  
  // Tom fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
        setStep('tom', offset + 15, 0.8, 90);
      }
    }
  }
  
  // Crash on downbeat
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.4) setStep('crash', bar * 16, 0.75, 100);
  }
}
  
// R&B: Syncopated, groovy, pocket
function generateRnBBeat() {
  const len = state.sequenceLength;
  
  // Kick: Syncopated
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.85, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 95);
    setStep('kick', offset + 10, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) setStep('kick', offset + 13, 0.7, 85);
  }
  
  // Snare: Laid back backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) {
      setStep('snare', offset + 11, 0.4, 70);
      setStep('snare', offset + 15, 0.45, 75);
    }
  }
  
  // Rimshot: Syncopated accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.55, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.55, 80);
    }
  }
  
  // Hi-hat: Intricate 16th patterns
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    const offbeats = [1, 3, 5, 9, 11, 13];
    for (let bar = 0; bar < len / 16; bar++) {
      offbeats.forEach(pos => {
        if (Math.random() > 0.3) setStep('hihat', bar * 16 + pos, 0.35, 75);
      });
    }
  }
  
  // Clap: Occasional layers
  if (state.complexity >= 3 && Math.random() > 0.6) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      setStep('clap', offset + 4, 0.5, 85);
      setStep('clap', offset + 12, 0.5, 85);
    }
  }
}
  
// Ambient: Sparse, textural, atmospheric
function generateAmbientBeat() {
  const len = state.sequenceLength;
  
  // Kick: Minimal bar markers
  for (let bar = 0; bar < len / 16; bar++) {
    setStep('kick', bar * 16, 0.7, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) {
      setStep('kick', bar * 16 + 8, 0.65, 90);
    }
  }
  
  // Snare: Very sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) setStep('snare', bar * 16 + 8, 0.5, 85);
    }
  }
  
  // Hi-hat: Sparse texture
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    if (Math.random() > 0.3) setStep('hihat', offset + 0, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 6, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 10, 0.4, 80);
  }
  
  // Crash: Textural swells
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
      if (Math.random() > 0.4) setStep('crash', bar * 16 + 12, 0.55, 80);
    }
  }
  
  // Ride: Subtle pulse
  if (state.complexity >= 3) {
    for (let i = 0; i < len; i += 4) {
      if (Math.random() > 0.3) setStep('ride', i, 0.35, 70);
    }
  }
  
  // Tom: Occasional atmospheric hits
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.7) {
        const tomStep = [4, 8, 12][Math.floor(Math.random() * 3)];
        setStep('tom', bar * 16 + tomStep, 0.45, 75);
      }
    }
  }
}
  
function generateDazecoreBeat() {
  const len = state.sequenceLength;
  
  // Kick: Warm and bouncy
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 90);
    setStep('kick', offset + 12, 0.8, 100);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 3, 0.5, 70);
  }
  
  // Snare: Off-grid, nostalgic
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.7, 100);
    if (state.complexity >= 2) setStep('snare', offset + 7, 0.5, 80);
    setStep('snare', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Shimmering, irregular
  const glitchyHats = [0, 2, 3, 5, 6, 8, 10, 11, 13, 14];
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    glitchyHats.forEach((step, idx) => {
      const vel = idx % 3 === 0 ? 0.65 : 0.4;
      const prob = Math.random() > 0.2 ? 90 : 60;
      setStep('hihat', offset + step, vel, prob);
    });
  }
  
  // Rimshot: Dial-up clicks
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [1, 5, 9].forEach(step => {
        if (Math.random() > 0.4) setStep('rimshot', offset + step, 0.45, 75);
      });
    }
  }
  
  // Clap: Sunny handclaps
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.3) setStep('clap', offset + 7, 0.55, 85);
      if (Math.random() > 0.3) setStep('clap', offset + 15, 0.55, 85);
    }
  }
  
  // Tom: Nostalgic fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
      }
    }
  }
  
  // Crash: Sunshine swells
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.5) setStep('crash', bar * 16, 0.65, 95);
  }
}

// Helper to set a step
function setStep(inst, step, velocity, probability) {
  if (step < state.sequenceLength) {
    patterns[inst][step].active = true;
    patterns[inst][step].velocity = velocity;
    patterns[inst][step].probability = probability;
  }
}

// ==================== BEAT VARIETY GENERATORS ====================

// Add rhythmic variations - keep the groove but make it interesting
function addRhythmicVariety() {
  const len = state.sequenceLength;
  
  // Add syncopated kicks (occasional off-beat hits)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 30% chance to add syncopated kick
      if (Math.random() > 0.7) {
        const positions = [3, 7, 11, 15]; // Syncopated positions
        const pos = positions[Math.floor(Math.random() * positions.length)];
        setStep('kick', offset + pos, 0.65 + Math.random() * 0.15, 85);
      }
    }
  }
  
  // Add hi-hat variations (open hats, rolls)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // Random hi-hat roll at end of bar
      if (Math.random() > 0.6) {
        for (let i = 13; i < 16; i++) {
          if (Math.random() > 0.3) {
            setStep('hihat', offset + i, 0.4 + Math.random() * 0.2, 90);
          }
        }
      }
    }
  }
  
  // Add snare flams (double hits)
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 20% chance to add flam before main snare
      [4, 12].forEach(mainHit => {
        if (Math.random() > 0.8 && !patterns.snare[offset + mainHit - 1].active) {
          setStep('snare', offset + mainHit - 1, 0.4, 80);
        }
      });
    }
  }
  
  // Add crash accents on sections
  if (state.complexity >= 2) {
    const sectionsCount = Math.floor(len / 16);
    for (let i = 0; i < sectionsCount; i += 4) {
      // Every 4 bars, add emphasis
      if (i > 0) {
        setStep('crash', i * 16, 0.7, 100);
      }
    }
  }
  
  renderSequencer();
}

// Create a fill pattern at the end of 4/8 bar sections
function addDrumFills() {
  const len = state.sequenceLength;
  const barsPerFill = state.complexity === 1 ? 8 : state.complexity === 2 ? 4 : 2;
  
  for (let bar = barsPerFill - 1; bar < len / 16; bar += barsPerFill) {
    const fillStart = bar * 16 + 12; // Last 4 steps of bar
    
    if (fillStart + 4 > len) continue;
    
    // Random fill type
    const fillType = Math.floor(Math.random() * 3);
    
    if (fillType === 0) {
      // Tom roll descending
      for (let i = 0; i < 4; i++) {
        setStep('tom', fillStart + i, 0.6 + (i * 0.1), 95);
      }
    } else if (fillType === 1) {
      // Snare roll
      for (let i = 0; i < 4; i++) {
        if (i % 2 === 0 || state.complexity >= 3) {
          setStep('snare', fillStart + i, 0.5 + (i * 0.1), 90);
        }
      }
    } else {
      // Mixed fill (toms + crash)
      setStep('tom', fillStart + 0, 0.6, 95);
      setStep('tom', fillStart + 1, 0.7, 95);
      setStep('snare', fillStart + 2, 0.75, 95);
      setStep('crash', fillStart + 3, 0.8, 100);
    }
  }
  
  renderSequencer();
}

// Add swing feel variations
function addSwingVariations() {
  const len = state.sequenceLength;
  
  // Offset every other hi-hat slightly for swing feel
  for (let i = 1; i < len; i += 4) {
    if (patterns.hihat[i].active) {
      patterns.hihat[i].velocity *= 0.7; // Quieter on off-beats
    }
  }
  
  // Add ghost notes on snare
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      const ghostPositions = [2, 6, 10, 14];
      
      ghostPositions.forEach(pos => {
        if (Math.random() > 0.6 && !patterns.snare[offset + pos].active) {
          setStep('snare', offset + pos, 0.25 + Math.random() * 0.15, 70);
        }
      });
    }
  }
  
  renderSequencer();
}
  
// More subtle variations - don't destroy the groove
function addSubtleVariations() {
  // Only add to hi-hats and rimshots - keep kick/snare solid
  ['hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      // Only 15% chance to add variation on empty steps
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 30;
      }
    }
  });
}

// Add after generateBeat function
function applyGenreFX() {
  if (state.currentGenre === 'postpunk') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 2.0;
    fxConfig.chorus.active = true;
    fxConfig.filter.active = false;
  } else if (state.currentGenre === 'rnb') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.5;
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.3;
    fxConfig.distortion.active = false;
  } else if (state.currentGenre === 'dazecore') {
    // Warm glitchy sunshine sound
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.8; // Nostalgic space
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.5; // Shimmer
    fxConfig.bitcrusher.active = true; // Dial-up glitch texture
    fxConfig.bitcrusher.bits = 6; // Lo-fi crunch
    fxConfig.delay.active = true; // Echo memories
    fxConfig.delay.time = '8n';
    fxConfig.delay.feedback = 0.3;
    fxConfig.filter.active = true; // Warm cut
    fxConfig.filter.frequency = 4000; // Bright but not harsh
  }
  
  // Apply settings
  Object.keys(fxConfig).forEach(fx => {
    const cfg = fxConfig[fx];
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = cfg.active ? 0.25 : 0;
    }
  });
  
  renderFX();
}
  
function addVariations() {
  Object.keys(instruments).forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.2 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.3;
        patterns[inst][i].probability = 50 + Math.random() * 50;
      }
    }
  });
}

function addGhostNotes() {
  ['snare', 'hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.2 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 40;
      }
    }
  });
  renderSequencer();
}

function randomizeVelocity() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.velocity = 0.5 + Math.random() * 0.5;
      }
    });
  });
  renderSequencer();
}

function randomizeProbability() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.probability = 50 + Math.floor(Math.random() * 51);
      }
    });
  });
  renderSequencer();
}

function clearPattern() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
  renderSequencer();
}

function generateMelodicPatterns() {
  const genre = state.currentGenre;
  
  // Generate based on genre characteristics
  if (genre === 'lofi') {
    generateLoFiMelodies();
  } else if (genre === 'hiphop') {
    generateHipHopMelodies();
  } else if (genre === 'postpunk') {
    generatePostPunkMelodies();
  } else if (genre === 'rnb') {
    generateRnBMelodies();
  } else if (genre === 'ambient') {
    generateAmbientMelodies();
  } else if (genre === 'dazecore') {
    generateDazecoreMelodies();
  }
  
  renderSequencer();
}

// Lo-Fi: Jazzy chords, warm bass, sparse leads
function generateLoFiMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root movement, walking feel throughout
  const bassOctave = 2;
  const bassProgression = [0, 3, 4, 0]; // I-IV-V-I progression
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    
    // Main bass notes on downbeats
    [0, 4, 8, 12].forEach((step, idx) => {
      const degree = bassProgression[idx % bassProgression.length];
      patterns.bass[offset + step].active = true;
      patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
      patterns.bass[offset + step].velocity = 0.7;
      patterns.bass[offset + step].duration = '4n';
    });
    
    // Walking bass between roots
    if (state.complexity >= 2) {
      [2, 6, 10, 14].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = [1, 2, 5, 6][idx];
          patterns.bass[offset + step].active = true;
          patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
          patterns.bass[offset + step].velocity = 0.6;
          patterns.bass[offset + step].duration = '8n';
        }
      });
    }
  }
  
  // Keys: Jazz chords (7ths, 9ths)
  const chordOctave = 3;
  const jazzChords = bassProgression.map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = jazzChords[idx % jazzChords.length];
        patterns.keys[offset + step].velocity = 0.5;
        patterns.keys[offset + step].duration = '2n';
      }
    });
  }
  
  // Guitar: Muted strums, sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach((step, idx) => {
        if (Math.random() > 0.5) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = jazzChords[idx % jazzChords.length];
          patterns.guitar[offset + step].velocity = 0.4;
          patterns.guitar[offset + step].duration = '8n';
        }
      });
    }
  }
  
  // Lead: Melodic fragments
  if (state.complexity >= 3) {
    const leadOctave = 4;
    const melody = [0, 2, 4, 2, 0];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (Math.random() > 0.3 && melody[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[melody[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Hip-Hop: Heavy bass, sparse chords, melodic hooks
function generateHipHopMelodies() {
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root notes, heavy and sparse
  const bassOctave = 1;
  const bassPattern = [0, 0, 4, 0, 0, 3, 0, 5];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassPattern.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.8;
        patterns.bass[offset + step].duration = '4n';
      }
    });
  }
  
  // Keys: Simple triads on downbeats
  const chordOctave = 3;
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach(step => {
      const root = keysArr[keyIndex] + chordOctave;
      const third = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
      const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
      
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = [root, third, fifth];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '1n';
    });
  }
  
  // Lead: Melodic hook
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const hook = [0, 3, 2, 0, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (hook[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[hook[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.6;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 100;
        }
      });
    }
  }
}

// Post-Punk: Dark bass, angular guitars, minimal keys
function generatePostPunkMelodies() {
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Driving 8th notes, root-fifth motion
  const bassOctave = 1;
  
  for (let i = 0; i < len; i += 2) {
    patterns.bass[i].active = true;
    const useFifth = i % 4 === 2;
    const degree = useFifth ? 4 : 0;
    patterns.bass[i].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[i].velocity = 0.75;
    patterns.bass[i].duration = '8n';
  }
  
  // Guitar: Power chords, angular rhythm
  if (state.complexity >= 2) {
    const chordOctave = 2;
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [0, 4, 8, 12].forEach(step => {
        const root = keysArr[keyIndex] + chordOctave;
        const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
        const octave = keysArr[keyIndex] + (chordOctave + 1);
        
        patterns.guitar[offset + step].active = true;
        patterns.guitar[offset + step].note = [root, fifth, octave];
        patterns.guitar[offset + step].velocity = 0.6;
        patterns.guitar[offset + step].duration = '4n';
      });
    }
  }
  
  // Keys: Sparse stabs
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [6, 14].forEach(step => {
        if (Math.random() > 0.3) {
          const chordOctave = 4;
          patterns.keys[offset + step].active = true;
          patterns.keys[offset + step].note = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
          patterns.keys[offset + step].velocity = 0.5;
          patterns.keys[offset + step].duration = '16n';
        }
      });
    }
  }
}

// R&B: Smooth chords, groovy bass, soulful leads
function generateRnBMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Syncopated groove
  const bassOctave = 2;
  const bassGroove = [0, null, 4, null, 3, null, 5, null];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassGroove.forEach((degree, idx) => {
      const step = idx * 2;
      if (degree !== null && step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7;
        patterns.bass[offset + step].duration = '8n';
      }
    });
  }
  
  // Keys: 7th chords with extensions
  const chordOctave = 3;
  const rnbChords = [0, 3, 4, 5].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = rnbChords[idx % rnbChords.length];
      patterns.keys[offset + step].velocity = 0.45;
      patterns.keys[offset + step].duration = '2n';
    });
  }
  
  // Guitar: Rhythm chops
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach(step => {
        if (Math.random() > 0.4) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = rnbChords[Math.floor(step / 4) % rnbChords.length];
          patterns.guitar[offset + step].velocity = 0.35;
          patterns.guitar[offset + step].duration = '16n';
        }
      });
    }
  }
  
  // Lead: Soulful melody
  if (state.complexity >= 3) {
    const leadOctave = 5;
    const soul = [0, 2, 3, 4, 3, 2, 0, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      soul.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.55 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Ambient: Atmospheric pads, sparse melodic elements
function generateAmbientMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Long sustained root notes
  const bassOctave = 2;
  const bassProgression = [0, 4]; // Alternate between root and fifth
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    const degree = bassProgression[bar % bassProgression.length];
    
    patterns.bass[offset].active = true;
    patterns.bass[offset].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[offset].velocity = 0.6;
    patterns.bass[offset].duration = '1n';
    
    if (state.complexity >= 2 && bar % 2 === 1) {
      patterns.bass[offset + 8].active = true;
      patterns.bass[offset + 8].note = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12] + bassOctave;
      patterns.bass[offset + 8].velocity = 0.55;
      patterns.bass[offset + 8].duration = '1n';
    }
  }
  
  // Keys: Wide ambient chords
  const chordOctave = 3;
  const ambientChords = [0, 4, 5, 3].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + (chordOctave - 1), third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = ambientChords[(bar + idx) % ambientChords.length];
        patterns.keys[offset + step].velocity = 0.4;
        patterns.keys[offset + step].duration = '1n';
      }
    });
  }
  
  // Lead: Sparse ethereal notes
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const etherealNotes = [0, 2, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [4, 8, 12].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = etherealNotes[idx % etherealNotes.length];
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.35;
          patterns.lead[offset + step].duration = '2n';
          patterns.lead[offset + step].probability = 70;
        }
      });
    }
  }
}

// Dazecore: Warm, nostalgic melodies with glitchy textures
function generateDazecoreMelodies() {
  const scaleIntervals = scales.major;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Warm, syncopated bounce
  const bassOctave = 2;
  const sunnyBass = [0, 0, 2, 0, 4, 0, 2, 0];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    sunnyBass.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7 + Math.random() * 0.1;
        patterns.bass[offset + step].duration = '8n';
        patterns.bass[offset + step].probability = 95;
      }
    });
  }
  
  // Keys: Shimmering nostalgic chords with add9s
  const chordOctave = 3;
  const nostalgiaChords = [0, 4, 5, 2].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = nostalgiaChords[idx % nostalgiaChords.length];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '2n';
      patterns.keys[offset + step].probability = 95;
    });
  }
  
  // Guitar: Glitchy arpeggios (dial-up texture)
  if (state.complexity >= 2) {
    const arpSteps = [1, 2, 5, 6, 9, 10, 13, 14];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      arpSteps.forEach((step, idx) => {
        if (Math.random() > 0.3) {
          const chordIdx = Math.floor(step / 4) % nostalgiaChords.length;
          const noteIdx = idx % 4;
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = nostalgiaChords[chordIdx][noteIdx];
          patterns.guitar[offset + step].velocity = 0.35 + Math.random() * 0.15;
          patterns.guitar[offset + step].duration = '16n';
          patterns.guitar[offset + step].probability = 70 + Math.floor(Math.random() * 25);
        }
      });
    }
  }
  
  // Lead: Nostalgic melody fragments (summer memory)
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const memory = [4, 5, 4, 2, 0, 2, 4, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      memory.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16 && Math.random() > 0.2) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 85;
        }
      });
    }
  }
}
// Add after generateMelodicPatterns function
function addDrumFills() {
  // Add crash on bar 1
  patterns.crash[0].active = true;
  patterns.crash[0].velocity = 0.8;
  patterns.crash[0].probability = 100;
  
  // Random tom fills every 2 bars
  if (state.complexity >= 2) {
    for (let bar = 1; bar < state.sequenceLength / 16; bar++) {
      const fillStart = (bar * 16) - 4; // Last 4 steps of bar
      
      if (Math.random() < 0.3) { // 30% chance
        for (let i = 0; i < 4; i++) {
          if (Math.random() < 0.7) {
            patterns.tom[fillStart + i].active = true;
            patterns.tom[fillStart + i].velocity = 0.6 + (i * 0.1);
          }
        }
      }
    }
  }
}

function generateBassLine() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const root = state.key;
  const octave = 2; // Keep bass in low register
  
  // Use darker intervals - root, minor 3rd, 4th, 5th
  const bassNotes = [
    root + octave,
    keysArr[(keyIndex + scaleIntervals[2]) % 12] + octave,  // minor 3rd
    keysArr[(keyIndex + scaleIntervals[3]) % 12] + octave,  // 4th
    keysArr[(keyIndex + scaleIntervals[4]) % 12] + octave   // 5th
  ];
  
  const density = state.complexity === 1 ? 4 : state.complexity === 2 ? 6 : 8;
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % (16 / density) === 0 || (state.complexity >= 3 && Math.random() < 0.2)) {
      patterns.bass[i].active = true;
      patterns.bass[i].note = bassNotes[Math.floor(i / 4) % bassNotes.length];
      patterns.bass[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.bass[i].duration = '4n'; // Longer, sustained notes
      patterns.bass[i].probability = 100;
    }
  }
}

function generateKeyPattern() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 3; // Lower octave - darker
  
  // Build darker, more dissonant chords
  const chords = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 4][i]; // Use 2nd (adds tension), minor 3rd, 4th
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % scaleIntervals.length]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Add 7th for more color/tension
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % scaleIntervals.length]) % 12];
    
    chords.push([
      root + octave, 
      third + octave, 
      fifth + octave,
      seventh + (octave + 1)
    ]);
  }
  
  // Sparse, sustained pads
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % 8 === 0) { // Only every 8 steps = very sparse
      const index = Math.floor(i / 8) % chords.length;
      patterns.keys[i].active = true;
      patterns.keys[i].note = chords[index];
      patterns.keys[i].velocity = 0.5 + Math.random() * 0.15; // Quiet
      patterns.keys[i].duration = '1n'; // Whole note - long sustain
      patterns.keys[i].probability = 100;
    }
  }
}

function generateLeadMelody() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 4; // Medium-low register
  
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12] + octave);
  
  let lastIndex = 0;
  const density = state.complexity === 1 ? 2 : state.complexity === 2 ? 3 : 5; // Very sparse
  
  for (let i = 0; i < state.sequenceLength; i++) {
    // Much sparser - only occasional notes
    if (Math.random() < (density / 32)) { // Half the normal density
      // Prefer downward motion (darker feel)
      const jump = Math.random() < 0.6 ? -1 : (Math.random() < 0.7 ? 1 : 2);
      
      lastIndex = clamp(lastIndex + jump, 0, scaleNotes.length - 1);
      
      patterns.lead[i].active = true;
      patterns.lead[i].note = scaleNotes[lastIndex];
      patterns.lead[i].velocity = 0.4 + Math.random() * 0.2; // Quiet, ghostly
      patterns.lead[i].duration = Math.random() < 0.7 ? '4n' : '2n'; // Longer notes
      patterns.lead[i].probability = Math.random() < 0.6 ? 100 : 70; // Some randomness
    }
  }
}

// Add after line ~1260 (after generateLeadMelody function)
function generateGuitarStrums() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 2; // Lower, darker
  
  // Build power chords and sus chords (no 3rd = ambiguous/dreamy)
  const chordShapes = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 5][i];
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const fourth = keysArr[(keyIndex + scaleIntervals[(degree + 3) % scaleIntervals.length]) % 12]; // sus4
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Sus chords = dreamy, no major/minor
    chordShapes.push([
      root + octave, 
      fourth + octave, 
      fifth + octave,
      root + (octave + 1)
    ]);
  }
  
  // Very sparse strumming
  const strumPattern = [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]; // Only twice per bar
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (strumPattern[i % strumPattern.length]) {
      const chordIndex = Math.floor(i / 8) % chordShapes.length;
      patterns.guitar[i].active = true;
      patterns.guitar[i].note = chordShapes[chordIndex];
      patterns.guitar[i].velocity = 0.4 + Math.random() * 0.15; // Quiet
      patterns.guitar[i].duration = '2n'; // Half note sustain
      patterns.guitar[i].probability = 100;
    }
  }
}

function applyEuclidean() {
  const instrumentKeys = Object.keys(instruments);
  const inst = instrumentKeys[Math.floor(Math.random() * instrumentKeys.length)];
  const hits = Math.floor(Math.random() * 8) + 3;
  const steps = state.sequenceLength;
  
  const pattern = generateEuclidean(hits, steps);
  pattern.forEach((value, i) => {
    patterns[inst][i].active = value === 1;
    if (value === 1) {
      patterns[inst][i].velocity = 0.7 + Math.random() * 0.3;
      patterns[inst][i].probability = 100;
    }
  });
  
  renderSequencer();
}

function generateEuclidean(hits, steps) {
  const result = Array(steps).fill(0);
  const bucket = [];
  
  for (let i = 0; i < steps; i++) {
    bucket.push(Math.floor((i * hits) / steps));
  }
  
  for (let i = 0; i < steps; i++) {
    if (i === 0 || bucket[i] !== bucket[i - 1]) {
      result[i] = 1;
    }
  }
  
  return result;
}

// -------------------- Mixer Rendering --------------------
function renderMixer() {
  const grid = document.getElementById('mixerGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const data = instruments[inst];
    const channel = document.createElement('div');
    channel.className = 'mixer-channel';
    
    channel.innerHTML = `
      <div class="channel-header">
        <div class="channel-name">${data.icon} ${data.name}</div>
        <div class="channel-btns">
          <button class="channel-btn mute ${data.mute ? 'active' : ''}" 
                  data-inst="${inst}" data-action="mute">M</button>
          <button class="channel-btn solo ${data.solo ? 'active' : ''}" 
                  data-inst="${inst}" data-action="solo">S</button>
        </div>
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Volume</span>
          <span class="param-value">${data.volume}dB</span>
        </div>
        <input type="range" min="-40" max="10" value="${data.volume}" 
               data-inst="${inst}" data-param="volume">
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Pan</span>
          <span class="param-value">${data.pan > 0 ? 'R' : data.pan < 0 ? 'L' : 'C'}${Math.abs(data.pan)}</span>
        </div>
        <input type="range" min="-100" max="100" value="${data.pan}" 
               data-inst="${inst}" data-param="pan">
      </div>
    `;
    
    fragment.appendChild(channel);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- FX Rendering --------------------
function renderFX() {
  const grid = document.getElementById('fxGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(fxConfig).forEach(fx => {
    const config = fxConfig[fx];
    const unit = document.createElement('div');
    unit.className = 'fx-unit';
    
    const params = Object.keys(config).filter(k => k !== 'name' && k !== 'active');
    let paramsHTML = '';
    
    params.forEach(param => {
      const value = config[param];
      const display = formatFxDisplay(param, value);
      
      let sliderVal = 50;
      if (param === 'decay') {
        sliderVal = clamp(Math.round(value * 20), 0, 100);
      } else if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
        sliderVal = Math.round(value * 100);
      } else if (param === 'time') {
        const timeMap = { '16n': 0, '8n': 33, '4n': 66, '2n': 100 };
        sliderVal = timeMap[value] ?? 50;
      } else if (param === 'frequency') {
        sliderVal = Math.round((value - 100) / 79);
      } else if (param === 'octaves') {
        sliderVal = (value - 1) * 20;
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value">${display}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx="${fx}" data-param="${param}">
        </div>
      `;
    });
    
    unit.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${config.name}</div>
        <div class="fx-toggle ${config.active ? 'active' : ''}" data-fx="${fx}"></div>
      </div>
      ${paramsHTML}
    `;
    
    fragment.appendChild(unit);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- Harmony System --------------------
function renderHarmony() {
  const keySelect = document.getElementById('keySelect');
  keySelect.innerHTML = keysArr.map(k => 
    `<option value="${k}" ${k === state.key ? 'selected' : ''}>${k}</option>`
  ).join('');
  
  const scaleSelect = document.getElementById('scaleSelect');
  scaleSelect.innerHTML = Object.keys(scales).map(s => 
    `<option value="${s}" ${s === state.scale ? 'selected' : ''}>${s}</option>`
  ).join('');
  
  const octaveSelect = document.getElementById('octaveSelect');
  octaveSelect.innerHTML = [2, 3, 4, 5, 6].map(o => 
    `<option value="${o}" ${o === state.octave ? 'selected' : ''}>${o}</option>`
  ).join('');
  
  updateChords();
}

function updateChords() {
  const chordChips = document.getElementById('chordChips');
  const fragment = document.createDocumentFragment();
  
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  
  const chords = [];
  scaleIntervals.forEach((interval, i) => {
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(i + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    chords.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][i] });
  });
  
  chords.forEach(chord => {
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = `${chord.roman} - ${chord.root}${chord.type === 'minor' ? 'm' : chord.type === 'dim' ? '°' : ''}`;
    chip.addEventListener('click', () => {
      state.progression.push(chord);
      renderProgression();
    });
    fragment.appendChild(chip);
  });
  
  chordChips.innerHTML = '';
  chordChips.appendChild(fragment);
}

function renderProgression() {
  const wrap = document.getElementById('progressionChips');
  const fragment = document.createDocumentFragment();
  
  if (!state.progression.length) {
    wrap.innerHTML = '<div style="color: var(--text-muted); font-size: 0.9rem;">Click chords above to build progression</div>';
    return;
  }
  
  state.progression.forEach((chord, index) => {
    const chip = document.createElement('div');
    chip.className = 'chip active';
    chip.textContent = `${chord.roman} - ${chord.root}${chord.type === 'minor' ? 'm' : chord.type === 'dim' ? '°' : ''}`;
    chip.addEventListener('click', () => {
      state.progression.splice(index, 1);
      renderProgression();
    });
    fragment.appendChild(chip);
  });
  
  wrap.innerHTML = '';
  wrap.appendChild(fragment);
}

function generateProgression() {
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  const templates = [
    [0, 3, 4, 0],
    [0, 5, 3, 4],
    [1, 4, 0],
    [0, 4, 5, 3]
  ];
  
  const template = templates[Math.floor(Math.random() * templates.length)];
  state.progression = [];
  
  template.forEach(degree => {
    const interval = scaleIntervals[degree];
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(degree + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    state.progression.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][degree] });
  });
  
  renderProgression();
}

function loadProgressionTemplate(name) {
  const templates = {
    'ii-v-i': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'G', type: 'major', roman: 'V' },
      { root: 'C', type: 'major', roman: 'I' }
    ],
    'lofi': [
      { root: 'C', type: 'major', roman: 'I' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'F', type: 'major', roman: 'IV' },
      { root: 'G', type: 'major', roman: 'V' }
    ],
    'neosoul': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'E', type: 'minor', roman: 'III' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'D', type: 'minor', roman: 'II' }
    ],
    'modal': [
      { root: 'D', type: 'minor', roman: 'I' },
      { root: 'E', type: 'minor', roman: 'II' },
      { root: 'F', type: 'major', roman: 'III' },
      { root: 'G', type: 'major', roman: 'IV' }
    ]
  };
  
  state.progression = templates[name] || [];
  renderProgression();
}

// ==================== MULTITRACK RECORDING SYSTEM ====================

const multitrack = {
  tracks: [],
  nextTrackId: 1,
  recordingTracks: new Set(),
  currentFxTrackId: null,
  globalRecordStartTime: null
};

// ==================== ENHANCED MULTITRACK WITH EXTERNAL AUDIO ====================

class AudioTrack {
  constructor(id, name = `Track ${id}`, instrument = null, isExternalAudio = false) {
    this.id = id;
    this.name = name;
    this.instrument = instrument || 'internal';
    this.isExternalAudio = isExternalAudio;
    this.takes = [];
    this.selectedTakeIndex = -1;
    this.armed = false;
    this.recording = false;
    this.muted = false;
    this.soloed = false;
    this.volume = 0;
    this.pan = 0;
    this.inputMonitoring = false;
    this.recordStartTime = null;

    // Audio routing
    this.channel = new Tone.Channel({ volume: 0, pan: 0 }).connect(master.fxIn);
    this.recorder = null;
    this.recordedChunks = [];
    this.fxChain = [];
    
    // Meter for visual feedback
    this.meter = new Tone.Meter();
    this.channel.connect(this.meter);
    
    // External audio setup
    this.mediaStream = null;
    this.mediaStreamSource = null;
    this.externalInput = null;
    
    if (!isExternalAudio && instrument !== 'external') {
      this.routeInstrument();
    }
  }
  
  rename(newName) {
    this.name = newName.trim() || `Track ${this.id}`;
    showToast(`✏️ Renamed to "${this.name}"`, 'info');
    renderMultitrack();
  }
  
  async setupExternalAudio() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000
        }
      });
      
      console.log(`🎤 Microphone access granted for track ${this.id}`);
      
      const audioContext = Tone.context.rawContext;
      this.mediaStreamSource = audioContext.createMediaStreamSource(this.mediaStream);
      
      this.externalInput = new Tone.Gain(1);
      this.mediaStreamSource.connect(this.externalInput.input);
      
      this.externalInput.connect(this.channel);
      this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      
      console.log(`✅ External audio routed for track ${this.id}`);
      
    } catch (err) {
      console.error(`❌ Failed to access microphone for track ${this.id}:`, err);
      showToast(`❌ Microphone access denied: ${err.message}`, 'error');
    }
  }
  
  toggleInputMonitoring() {
    if (!this.mediaStreamSource) return showToast('⚠️ No input available', 'warning');

    if (!this.isExternalAudio || !this.externalInput) return;
    
    this.inputMonitoring = !this.inputMonitoring;
    this.externalInput.gain.rampTo(this.inputMonitoring ? 1 : 0, 0.05);
    
    console.log(`🔊 Input monitoring ${this.inputMonitoring ? 'ON' : 'OFF'} for ${this.name}`);
    renderMultitrack();
  }
  
  routeInstrument() {
    // Internal audio tracks no longer route from a fixed instrument.
    // They simply exist as live audio buses (Tone.Channel → master).
    console.log(`🎚️ ${this.name} ready as internal track`);
  }

  
  addFx(type, params = {}) {
    let fx;
    params = { ...params };
  
    switch (type) {
      case 'reverb': {
        const decay = params.decay ?? 1.5;
        const wet = params.wet ?? 0.3;
        fx = new Tone.Reverb({ decay, wet });
        params.decay = decay;
        params.wet = wet;
        break;
      }
      case 'delay': {
        const time = params.time ?? '8n';
        const feedback = params.feedback ?? 0.3;
        const wet = params.wet ?? 0.3;
        fx = new Tone.FeedbackDelay({ delayTime: time, feedback, wet });
        params.time = time;
        params.feedback = feedback;
        params.wet = wet;
        break;
      }
      case 'chorus': {
        const frequency = params.frequency ?? 1.5;
        const delayTime = params.delayTime ?? 3.5;
        const depth = params.depth ?? 0.7;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Chorus({ frequency, delayTime, depth, wet }).start();
        params.frequency = frequency;
        params.delayTime = delayTime;
        params.depth = depth;
        params.wet = wet;
        break;
      }
      case 'distortion': {
        const amount = params.amount ?? 0.4;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Distortion({ distortion: amount, wet });
        params.amount = amount;
        params.wet = wet;
        break;
      }
      case 'filter': {
        const typeOpt = params.type ?? 'lowpass';
        const frequency = params.frequency ?? 5000;
        const q = params.q ?? 1;
        fx = new Tone.Filter({ type: typeOpt, frequency, Q: q });
        params.type = typeOpt;
        params.frequency = frequency;
        params.q = q;
        break;
      }
      case 'compressor': {
        const threshold = params.threshold ?? -24;
        const ratio = params.ratio ?? 4;
        const attack = params.attack ?? 0.003;
        const release = params.release ?? 0.25;
        fx = new Tone.Compressor({ threshold, ratio, attack, release });
        params.threshold = threshold;
        params.ratio = ratio;
        params.attack = attack;
        params.release = release;
        break;
      }
      case 'eq': {
        const low = params.low ?? 0;
        const mid = params.mid ?? 0;
        const high = params.high ?? 0;
        fx = new Tone.EQ3({ low, mid, high });
        params.low = low;
        params.mid = mid;
        params.high = high;
        break;
      }
      case 'bitcrusher': {
        const bits = params.bits ?? 4;
        fx = new Tone.BitCrusher({ bits });
        params.bits = bits;
        break;
      }
      default:
        return null;
    }
  
    const fxObj = {
      id: Date.now() + Math.random(),
      type,
      node: fx,
      params,
      enabled: true
    };
  
    this.fxChain.push(fxObj);
    this.reconnectFxChain();
  
    return fxObj;
  }
  
  removeFx(fxId) {
    const index = this.fxChain.findIndex(fx => fx.id === fxId);
    if (index === -1) return;
    
    const fx = this.fxChain[index];
    fx.node.disconnect();
    fx.node.dispose();
    
    this.fxChain.splice(index, 1);
    this.reconnectFxChain();
  }
  
  reconnectFxChain() {
    if (this.isExternalAudio && this.externalInput) {
      this.fxChain.forEach(fx => {
        if (fx.node && typeof fx.node.disconnect === 'function') {
          fx.node.disconnect();
        }
      });
      
      this.externalInput.disconnect();
      
      let lastNode = this.externalInput;
      
      this.fxChain.forEach(fx => {
        if (fx.enabled && fx.node) {
          lastNode.connect(fx.node);
          lastNode = fx.node;
        }
      });
      
      lastNode.connect(this.channel);
      
      console.log(`🔗 Reconnected FX chain for external audio: ${this.fxChain.filter(f => f.enabled).length} active effects`);
      
    } else {
      const instSynth = synths[this.instrument];
      if (!instSynth) return;
      
      this.fxChain.forEach(fx => {
        if (fx.node && typeof fx.node.disconnect === 'function') {
          fx.node.disconnect();
        }
      });
      
      let sourceNode = null;
      
      if (typeof instSynth.disconnect === 'function') {
        instSynth.disconnect();
        sourceNode = instSynth;
      } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
        instSynth.gain.disconnect();
        sourceNode = instSynth.gain;
      } else if (instSynth.player && typeof instSynth.player.disconnect === 'function') {
        instSynth.player.disconnect();
        sourceNode = instSynth.player;
      } else {
        console.warn(`Cannot reconnect FX for ${this.instrument} - unknown synth type`);
        return;
      }
      
      let lastNode = sourceNode;
      
      this.fxChain.forEach(fx => {
        if (fx.enabled && fx.node) {
          lastNode.connect(fx.node);
          lastNode = fx.node;
        }
      });
      
      lastNode.connect(this.channel);
      
      console.log(`🔗 Reconnected FX chain for ${this.instrument}: ${this.fxChain.filter(f => f.enabled).length} active effects`);
    }
  }
  
  updateFxParam(fxId, param, value) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.params[param] = value;
    const node = fx.node;
    
    const rampTime = 0.05;
    
    try {
      if (param === 'wet' && node.wet) {
        node.wet.rampTo(value, rampTime);
      } else if (param === 'decay' && node.decay !== undefined) {
        node.decay = value;
      } else if (param === 'time' && node.delayTime) {
        node.delayTime.value = Tone.Time(value);
      } else if (param === 'feedback' && node.feedback) {
        node.feedback.rampTo(value, rampTime);
      } else if (param === 'frequency') {
        if (node.frequency) {
          node.frequency.rampTo(value, rampTime);
        }
      } else if (param === 'delayTime' && node.delayTime && fx.type === 'chorus') {
        node.delayTime = value;
      } else if (param === 'depth' && node.depth !== undefined) {
        node.depth = value;
      } else if (param === 'amount' && node.distortion !== undefined) {
        node.distortion = value;
      } else if (param === 'threshold' && node.threshold) {
        node.threshold.rampTo(value, rampTime);
      } else if (param === 'ratio' && node.ratio) {
        node.ratio.rampTo(value, rampTime);
      } else if (param === 'attack' && node.attack) {
        node.attack.rampTo(value, rampTime);
      } else if (param === 'release' && node.release) {
        node.release.rampTo(value, rampTime);
      } else if (param === 'low' && node.low) {
        node.low.rampTo(value, rampTime);
      } else if (param === 'mid' && node.mid) {
        node.mid.rampTo(value, rampTime);
      } else if (param === 'high' && node.high) {
        node.high.rampTo(value, rampTime);
      } else if (param === 'bits' && node.bits !== undefined) {
        node.bits = Math.round(value);
      } else if (param === 'q' && node.Q) {
        node.Q.rampTo(value, rampTime);
      } else if (param === 'type' && node.type !== undefined) {
        node.type = value;
      }
      
      console.log(`🎛️ ${fx.type}.${param} = ${value}`);
    } catch (err) {
      console.warn(`⚠️ Could not update ${param}:`, err);
    }
  }
  
  toggleFx(fxId) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.enabled = !fx.enabled;
    this.reconnectFxChain();
  }
  
  async startRecording() {
    if (this.recording) return;
    await Tone.start();
  
    const ctx = Tone.getContext().rawContext;
    const dest = ctx.createMediaStreamDestination();
  
    // Tap the actual audible channel
    this.channel.connect(dest);
    this.recordDest = dest;
    this.recordedChunks = [];
  
    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus'
      : 'audio/webm';
  
    this.recorder = new MediaRecorder(dest.stream, { mimeType });
    this.recorder.ondataavailable = e => e.data.size && this.recordedChunks.push(e.data);
    this.recorder.onstop = () => this.finishRecording();
  
    this.recorder.start(100);
    this.recording = true;
    showToast(`🎧 Recording ${this.name}`, 'success');
  }
  
  stopRecording() {
    if (this.recording && this.recorder) {
      this.recorder.stop();
      this.recording = false;
    }
  }
  
  async finishRecording() {
    if (this.recordedChunks.length === 0) {
      console.warn('⚠️ No audio data recorded');
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      showToast('⚠️ Recording was empty', 'warning'); 
      return;
    }
  
    const blob = new Blob(this.recordedChunks, {
      type: (this.recorder && this.recorder.mimeType) || 'audio/webm'
    });
  
    console.log(`💾 Processing ${blob.size} bytes`);
  
    if (blob.size < 1000) {
      console.error('❌ Recording too small, likely corrupted');
      showToast('❌ Recording failed - file too small', 'error');
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      return;
    }
  
    try {
      const arrayBuffer = await blob.arrayBuffer();
      if (arrayBuffer.byteLength === 0) {
        throw new Error('ArrayBuffer is empty');
      }
  
      const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
      if (!audioBuffer || audioBuffer.length === 0 || audioBuffer.numberOfChannels === 0) {
        throw new Error('Decoded buffer is invalid');
      }
  
      const duration = audioBuffer.duration;
  
      // 🔥 Compute timeline start based on global record start
      let startTime = 0;
      if (multitrack.globalRecordStartTime != null && this.recordStartTime != null) {
        startTime = Math.max(
          0,
          this.recordStartTime - multitrack.globalRecordStartTime
        );
      }
  
      const take = {
        id: Date.now(),
        buffer: audioBuffer,
        blob,
        duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime,   // <-- used by preview & bounce for alignment
        recordedAt: Date.now()
      };
  
      this.takes.push(take);
      this.selectedTakeIndex = this.takes.length - 1;
  
      console.log(
        `✅ Take ${this.takes.length} created: ${take.duration.toFixed(
          3
        )}s (start=${startTime.toFixed(3)}s)`
      );
  
      renderMultitrack();
      showToast(`✅ Recorded ${take.duration.toFixed(1)}s take`, 'success');
    } catch (err) {
      console.error('❌ Failed to decode audio:', err);
      showToast(`❌ Recording failed: ${err.message}`, 'error');
    } finally {
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
    }
  }
  
  selectTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.selectedTakeIndex = index;
    renderMultitrack();
  }

  toggleTakeMute(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.takes[index].muted = !this.takes[index].muted;
    renderMultitrack();
  }
  
  deleteTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    this.takes.splice(index, 1);
    
    if (this.selectedTakeIndex >= this.takes.length) {
      this.selectedTakeIndex = this.takes.length - 1;
    }
    
    renderMultitrack();
  }

  async playTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    if (take.muted) {
      showToast('❌ Take is muted', 'warning');
      return;
    }
    
    if (this.currentPlayer) {
      try {
        if (this.currentPlayer.state === 'started') {
          this.currentPlayer.stop();
        }
        this.currentPlayer.dispose();
      } catch (err) {
        console.warn('Error stopping previous player:', err);
      }
    }
    
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`❌ ${this.name}: Invalid or empty buffer`);
      showToast(`❌ ${this.name}: Take corrupted, cannot play`, 'error');
      return;
    }
    
    try {
      this.currentPlayer = new Tone.Player({
        buffer: take.buffer,
        fadeOut: 0.01
      }).connect(this.channel);
      
      await new Promise((resolve, reject) => {
        let attempts = 0;
        const checkReady = setInterval(() => {
          attempts++;
          
          if (this.currentPlayer.loaded) {
            clearInterval(checkReady);
            resolve();
          } else if (attempts > 50) {
            clearInterval(checkReady);
            reject(new Error('Buffer load timeout'));
          }
        }, 100);
        
        this.currentPlayer.onsuccess = () => {
          clearInterval(checkReady);
          resolve();
        };
      });
      
      await Tone.start();
      
      this.currentPlayer.start();
      
      const takeRegions = document.querySelectorAll('.take-region');
      takeRegions.forEach((region, idx) => {
        if (idx === index) {
          region.style.borderColor = 'var(--warning)';
          region.style.boxShadow = '0 0 20px var(--warning)';
        }
      });
      
      showToast(`▶️ Playing ${this.name} - Take ${index + 1}`, 'info');
      
      setTimeout(() => {
        if (this.currentPlayer) {
          try {
            if (this.currentPlayer.state === 'started') {
              this.currentPlayer.stop();
            }
            this.currentPlayer.dispose();
          } catch (err) {
            console.warn('Cleanup error:', err);
          }
          this.currentPlayer = null;
        }
        
        takeRegions.forEach(region => {
          region.style.borderColor = '';
          region.style.boxShadow = '';
        });
      }, take.duration * 1000 + 500);
      
    } catch (err) {
      console.error(`❌ Failed to play ${this.name}:`, err);
      showToast(`❌ Playback failed: ${err.message}`, 'error');
      
      if (this.currentPlayer) {
        this.currentPlayer.dispose();
        this.currentPlayer = null;
      }
    }
  }
  
  stopTake() {
    if (this.currentPlayer) {
      this.currentPlayer.stop();
      this.currentPlayer.dispose();
      this.currentPlayer = null;
    }
  }
  
  async exportTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    const url = URL.createObjectURL(take.blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.name.replace(/\s+/g, '_')}_take${index + 1}_${Date.now()}.webm`;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }
  
  dispose() {
    console.log('🗑️ Disposing track:', this.id);
    
    this.stopTake();
    
    if (this.recorder && this.recording) {
      this.stopRecording();
    }
    
    if (this.isExternalAudio) {
      if (this.mediaStreamSource) {
        this.mediaStreamSource.disconnect();
        this.mediaStreamSource = null;
      }
      
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }
      
      if (this.externalInput) {
        this.externalInput.disconnect();
        this.externalInput.dispose();
        this.externalInput = null;
      }
    } else {
      const instSynth = synths[this.instrument];
      if (instSynth && this.originalChannel) {
        if (typeof instSynth.disconnect === 'function') {
          instSynth.disconnect();
          instSynth.connect(this.originalChannel);
        } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
          instSynth.gain.disconnect();
          instSynth.gain.connect(this.originalChannel);
        }
      }
    }
    
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.dispose === 'function') {
        fx.node.disconnect();
        fx.node.dispose();
      }
    });
    
    if (this.meter && typeof this.meter.dispose === 'function') {
      this.meter.dispose();
    }
    
    if (this.channel && typeof this.channel.dispose === 'function') {
      this.channel.disconnect();
      this.channel.dispose();
    }
    
    console.log('✅ Track disposed:', this.id);
  }
}

async function createTrack(instrument = null, isExternalAudio = false) {
  const isInternal = !isExternalAudio;
  const baseName = isExternalAudio
    ? `Mic/Ext ${multitrack.tracks.filter(t => t.isExternalAudio).length + 1}`
    : `Track ${multitrack.tracks.filter(t => !t.isExternalAudio).length + 1}`;

  const track = new AudioTrack(multitrack.nextTrackId++, baseName, instrument, isExternalAudio);

  if (isExternalAudio) {
    try {
      await track.setupExternalAudio();
    } catch (err) {
      console.error('❌ External audio setup failed:', err);
      showToast(`❌ Microphone access failed: ${err.message}`, 'error');
      return null;
    }
  }

  multitrack.tracks.push(track);
  renderMultitrack();
  showToast(`✅ ${isExternalAudio ? 'External' : 'Internal'} track added`, 'success');
  return track;
}

function removeTrack(trackId) {
  const index = multitrack.tracks.findIndex(t => t.id === trackId);
  if (index === -1) return;
  
  const track = multitrack.tracks[index];
  track.dispose();
  multitrack.tracks.splice(index, 1);
  renderMultitrack();
}

function drawTakeWaveform(canvasEl, audioBuffer) {
  const ctx = canvasEl.getContext('2d');
  const width = canvasEl.width;
  const height = canvasEl.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = audioBuffer.getChannelData(0);
  const step = Math.ceil(data.length / width);
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  ctx.beginPath();
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const datum = data[(i * step) + j];
      if (datum < min) min = datum;
      if (datum > max) max = datum;
    }
    
    const x = i;
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(x, yMin, 1, yMax - yMin);
  }
}

function renderTakes(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  let html = '<div style="display: flex; flex-direction: column; gap: var(--space-2); padding: var(--space-2);">';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    html += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}" 
           data-track-id="${track.id}" data-take-index="${idx}"
           style="cursor: pointer; position: relative;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: var(--space-2);">
          <div style="flex: 1;">
            <div style="font-size: var(--text-xs); font-weight: 700;">
              Take ${idx + 1} ${isSelected ? '★' : ''}
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
              ${take.duration.toFixed(1)}s
            </div>
          </div>
          <div style="display: flex; gap: var(--space-1);">
            <button class="region-action-btn" data-action="play-take" title="Play">▶️</button>
            <button class="region-action-btn" data-action="toggle-mute-take" title="Mute/Unmute">
              ${isMuted ? '🔇' : '🔊'}
            </button>
            <button class="track-mini-btn" data-action="rename">
              ✏️ Rename
            </button>
            <button class="region-action-btn" data-action="delete-take" title="Delete">🗑️</button>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  
  return html;
}
  
// Enhanced track strip rendering
function createTrackStrip(track) {
  const strip = document.createElement('div');
  strip.className = 'track-strip';
  if (track.recording) strip.classList.add('recording');
  if (track.armed) strip.classList.add('armed');
  
  const instData = track.isExternalAudio ? 
    { icon: '🎤', name: 'External' } : 
    instruments[track.instrument];
  
  const takesCount = track.takes.length;
  const duration = track.selectedTakeIndex >= 0 ? 
    track.takes[track.selectedTakeIndex].duration.toFixed(1) + 's' : 
    '0.0s';
  
  strip.innerHTML = `
    <div class="track-header">
      <div class="track-header-top">
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      <div style="font-size: var(--text-xs); color: var(--text-tertiary); margin-top: var(--space-1);">
        ${track.isExternalAudio ? '🎤 External Input' : instData?.name || track.instrument} • ${takesCount} take${takesCount !== 1 ? 's' : ''} • ${duration}
      </div>
      
      <div class="track-controls-grid" style="margin-top: var(--space-3); grid-template-columns: repeat(3, 1fr);">
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-action="arm">
          ${track.armed ? '🔴' : '⚪'} Arm
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-action="monitor">
            ${track.inputMonitoring ? '🔊' : '🔇'} Mon
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-action="fx">
          🎛️ FX
        </button>
        <button class="track-mini-btn" data-action="edit">
          ✂️ Edit
        </button>
        <button class="track-mini-btn" data-action="delete">
          🗑️
        </button>
      </div>
      
      ${!track.isExternalAudio ? `
        <div class="track-controls-grid" style="margin-top: var(--space-2); grid-template-columns: 1fr;">
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-action="mute">
            ${track.muted ? '🔇 Unmuted' : '🔊 Muted'}
          </button>
        </div>
      ` : ''}
      
      <div style="display: grid; gap: var(--space-2); margin-top: var(--space-3);">
        <div class="param-control">
          <div class="param-label">
            <span>Vol</span>
            <span class="param-value">${track.volume}dB</span>
          </div>
          <input type="range" min="-40" max="10" value="${track.volume}" 
                 class="track-volume-slider" data-param="volume">
        </div>
        <div class="param-control">
          <div class="param-label">
            <span>Pan</span>
            <span class="param-value">${track.pan > 0 ? 'R' : track.pan < 0 ? 'L' : 'C'}${Math.abs(track.pan)}</span>
          </div>
          <input type="range" min="-100" max="100" value="${track.pan}" 
                 class="track-volume-slider" data-param="pan">
        </div>
      </div>
      
      ${track.isExternalAudio && track.meter ? `
        <div style="margin-top: var(--space-3);">
          <div style="font-size: var(--text-xs); color: var(--text-tertiary); margin-bottom: var(--space-1);">Input Level</div>
          <div class="track-meters">
            <div class="track-meter">
              <div class="track-meter-fill" style="height: 0%;" data-meter-track="${track.id}"></div>
            </div>
          </div>
        </div>
      ` : ''}
    </div>
    
    <div class="track-canvas-area">
      ${track.takes.length === 0 && !track.recording ? `
        <div class="track-empty-state">
          <div class="track-empty-state-icon">🎙️</div>
          <div>${track.isExternalAudio ? 'Arm and record external audio' : 'Arm and record to create takes'}</div>
        </div>
      ` : ''}
      ${track.recording ? `
        <div class="recording-indicator">
          <div class="recording-indicator-dot"></div>
          <span>Recording...</span>
        </div>
      ` : ''}
      ${track.takes.length > 0 ? renderTakes(track) : ''}
      </div>
  `;
  
  // Attach event listeners
  const controlsGrid = strip.querySelectorAll('.track-controls-grid');
  controlsGrid.forEach(grid => {
    grid.addEventListener('click', (e) => {
      const btn = e.target.closest('.track-mini-btn');
      if (!btn || btn.disabled) return;
      
      const action = btn.dataset.action;
      handleTrackAction(track, action);
    });
  });
  
  // Volume/pan sliders
  strip.querySelectorAll('.track-volume-slider').forEach(slider => {
    slider.addEventListener('input', (e) => {
      const param = e.target.dataset.param;
      const value = parseFloat(e.target.value);
      
      track[param] = value;
      
      if (param === 'volume') {
        track.channel.volume.rampTo(value, 0.1);
      } else if (param === 'pan') {
        track.channel.pan.rampTo(value / 100, 0.1);
      }
      
      const label = e.target.closest('.param-control').querySelector('.param-value');
      if (param === 'volume') {
        label.textContent = value + 'dB';
      } else {
        label.textContent = (value > 0 ? 'R' : value < 0 ? 'L' : 'C') + Math.abs(value);
      }
    });
  });
  
  // Add take interaction listeners
  strip.addEventListener('click', (e) => {
    const takeRegion = e.target.closest('.take-region');
    if (takeRegion) {
      const trackId = parseInt(takeRegion.dataset.trackId);
      const takeIndex = parseInt(takeRegion.dataset.takeIndex);
      const action = e.target.closest('.region-action-btn')?.dataset.action;
      
      if (action === 'play-take') {
        e.stopPropagation();
        track.playTake(takeIndex);
      } else if (action === 'toggle-mute-take') {
        e.stopPropagation();
        track.toggleTakeMute(takeIndex);
        renderMultitrack();
      } else if (action === 'delete-take') {
        e.stopPropagation();
        if (confirm('Delete this take?')) {
          track.deleteTake(takeIndex);
          renderMultitrack();
        }
      } else {
        // Click on region itself = select take
        track.selectTake(takeIndex);
        renderMultitrack();
      }
    }
  });
  
  // Start meter animation for external audio tracks
  if (track.isExternalAudio && track.meter) {
    const updateMeter = () => {
      const meterFill = strip.querySelector(`[data-meter-track="${track.id}"]`);
      if (!meterFill || !track.meter) return;
      
      const value = track.meter.getValue();
      const db = typeof value === 'number' ? value : (value[0] + value[1]) / 2;
      const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
      
      meterFill.style.height = normalized + '%';
      
      if (strip.isConnected) {
        requestAnimationFrame(updateMeter);
      }
    };
    
    requestAnimationFrame(updateMeter);
  }
  
  return strip;
}

// Enhanced track action handler
async function handleTrackAction(track, action) {
  if (action === 'arm') {
    track.armed = !track.armed;
    renderMultitrack();
  } else if (action === 'monitor') {
    if (track.isExternalAudio) {
      track.toggleInputMonitoring();
    }
  } else if (action === 'rec') {
    await toggleRecordTrack(track.id);
  } else if (action === 'mute') {
    track.muted = !track.muted;
    track.channel.mute = track.muted;
    renderMultitrack();
  } else if (action === 'solo') {
    track.soloed = !track.soloed;
    
    const anySolo = multitrack.tracks.some(t => t.soloed);
    multitrack.tracks.forEach(t => {
      t.channel.mute = anySolo && !t.soloed;
    });
    
    renderMultitrack();
  } else if (action === 'fx') {
    openFxChainEditor(track.id);
  } else if (action === 'rename') {
    const newName = prompt('Rename track:', track.name);
    if (newName !== null) track.rename(newName);
  } else if (action === 'edit') {
    openTakeEditor(track.id);
  } else if (action === 'delete') {
    if (confirm(`Delete track "${track.name}"?`)) {
      removeTrack(track.id);
    }
  }
}

// Simplified Add Track Dialog (Internal or External)
function showAddTrackDialog() {
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">➕ Add Track</div>
      <button class="modal-close">✕</button>
    </div>

    <div class="modal-body">
      <div style="display: grid; gap: var(--space-4);">
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Type
          </label>
          <select class="track-type-select" style="font-size:var(--text-base); padding:var(--space-3); width:100%;">
            <option value="internal">🎧 Internal Audio Track</option>
            <option value="external">🎤 External Audio (Mic / Line In)</option>
          </select>
        </div>

        <div class="external-info" style="display:none; padding:var(--space-4); background:var(--glass-bg); border-radius:var(--radius-md); border:1px solid var(--glass-border);">
          <div style="font-weight:700; margin-bottom:var(--space-2); color:var(--text-primary);">🎤 External Audio Input</div>
          <div style="font-size:var(--text-sm); color:var(--text-secondary); line-height:1.6;">
            <p style="margin-bottom:var(--space-2);">This will create a track that records from your microphone or audio interface.</p>
            <ul style="margin-left:var(--space-5); margin-bottom:var(--space-2);">
              <li>Real-time monitoring with effects</li>
              <li>Record vocals, guitar, or any external source</li>
              <li>Syncs perfectly with other tracks</li>
            </ul>
            <p style="font-size:var(--text-xs); color:var(--text-tertiary);">
              ⚠️ Your browser will request microphone access
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-secondary cancel-btn">Cancel</button>
      <button class="btn btn-primary confirm-btn">Add Track</button>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-btn').onclick = close;

  const trackTypeSelect = modal.querySelector('.track-type-select');
  const externalInfo = modal.querySelector('.external-info');
  const confirmBtn = modal.querySelector('.confirm-btn');

  // Toggle external info panel visibility
  trackTypeSelect.onchange = () => {
    const isExternal = trackTypeSelect.value === 'external';
    externalInfo.style.display = isExternal ? 'block' : 'none';
  };

  confirmBtn.onclick = async () => {
    const isExternal = trackTypeSelect.value === 'external';
    confirmBtn.disabled = true;
    confirmBtn.textContent = isExternal ? 'Requesting access...' : 'Adding...';

    try {
      const track = await createTrack(null, isExternal);
      if (track) {
        showToast(`✅ ${isExternal ? 'External' : 'Internal'} track added!`, 'success');
        close();
      } else {
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Add Track';
      }
    } catch (err) {
      console.error('❌ Failed to add track:', err);
      showToast(`❌ Failed to add track: ${err.message}`, 'error');
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Add Track';
    }
  };

  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

function renderMultitrack() {
  const grid = document.getElementById('multitrackGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  
  if (multitrack.tracks.length === 0) {
    grid.innerHTML = `
      <div style="grid-column: 1 / -1; padding: var(--space-8); text-align: center; color: var(--text-tertiary);">
        <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">🎙️</div>
        <div style="font-size: var(--text-lg); margin-bottom: var(--space-2);">No tracks yet</div>
        <div style="font-size: var(--text-sm);">Click "Add Track" to get started</div>
      </div>
    `;
    return;
  }
  
  multitrack.tracks.forEach(track => {
    const strip = createTrackStrip(track);
    grid.appendChild(strip);
  });
}
  
async function previewMultitrack() {
  const activeTracks = multitrack.tracks.filter(t => 
    t.selectedTakeIndex >= 0 && !t.muted
  );
  
  if (activeTracks.length === 0) {
    showToast('❌ No active takes to preview', 'error');
    return;
  }
  
  stopMultitrackPreview();
  
  await Tone.start();
  if (Tone.context.state !== 'running') {
    await Tone.context.resume();
  }
  
  multitrack.previewPlayers = [];
  let minStartTime = Infinity;
  let maxEndTime = 0;
  
  showToast('⏳ Loading takes...', 'info');
  
  for (const track of activeTracks) {
    const take = track.takes[track.selectedTakeIndex];
    if (!take || take.muted) continue;
    
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`❌ ${track.name}: Invalid buffer`);
      continue;
    }
    
    try {
      const player = new Tone.Player({
        context: Tone.context,
        loop: false,
        fadeOut: 0.01
      }).connect(track.channel);
      
      player.buffer = take.buffer;
      
      const startTime = take.startTime || 0;
      const endTime = startTime + take.duration;
      
      if (startTime < minStartTime) minStartTime = startTime;
      if (endTime > maxEndTime) maxEndTime = endTime;
      
      multitrack.previewPlayers.push({ 
        player, 
        track, 
        startTime
      });
      
      console.log(`✅ ${track.name} ready (starts at ${startTime.toFixed(3)}s)`);
      
    } catch (err) {
      console.error(`❌ ${track.name} failed:`, err);
    }
  }
  
  if (!multitrack.previewPlayers.length) {
    showToast('❌ No takes could be loaded', 'error');
    return;
  }
  
  if (minStartTime === Infinity) minStartTime = 0;
  const totalDuration = maxEndTime - minStartTime;
  
  console.log(`▶️ Preview:`);
  console.log(`   - Total duration: ${totalDuration.toFixed(3)}s`);
  console.log(`   - Earliest start (context): ${minStartTime.toFixed(3)}s`);
  console.log(`   - Latest end (context):     ${maxEndTime.toFixed(3)}s`);
  
  const now = Tone.now() + 0.1;
  
  multitrack.previewPlayers.forEach(({ player, track, startTime }) => {
    try {
      const relativeStart = (startTime || 0) - minStartTime;
      player.start(now + relativeStart);
      console.log(`▶️ ${track.name} at +${relativeStart.toFixed(3)}s`);
    } catch (err) {
      console.error(`❌ Failed to start ${track.name}:`, err);
    }
  });
  
  showToast(`▶️ Previewing ${multitrack.previewPlayers.length} track(s)`, 'success');
  
  multitrack.previewTimeout = setTimeout(() => {
    stopMultitrackPreview();
    const btn = document.getElementById('previewMultitrackBtn');
    if (btn) btn.textContent = '▶️ Preview Mix';
  }, (totalDuration + 0.5) * 1000);
}

function stopMultitrackPreview() {
  if (multitrack.previewPlayers) {
    multitrack.previewPlayers.forEach(({ player }) => {
      try {
        if (player.state === 'started') {
          player.stop();
        }
        player.dispose();
      } catch (err) {
        console.warn('Error stopping preview player:', err);
      }
    });
    multitrack.previewPlayers = null;
    console.log('⏹️ Preview stopped');
  }
  
  // Clear timeout if exists
  if (multitrack.previewTimeout) {
    clearTimeout(multitrack.previewTimeout);
    multitrack.previewTimeout = null;
  }
}

function createOfflineMasterChain(offlineContext) {
  // 🔥 Wrap the native OfflineAudioContext in a Tone.Context
  const toneOffline = new Tone.Context(offlineContext);

  const masterIn = new Tone.Gain(0.25, { context: toneOffline });

  // Rebuild master FX chain in offline context
  const lowCut = new Tone.Filter({
    type: 'highpass',
    frequency: state.lowCut,
    rolloff: -12,
    context: toneOffline
  });

  const highCut = new Tone.Filter({
    type: 'lowpass',
    frequency: state.highCut,
    rolloff: -12,
    context: toneOffline
  });

  const tape = new Tone.Distortion({
    distortion: (state.tapeSaturation / 100) * 0.2,
    wet: (state.tapeSaturation / 100) * 0.6,
    context: toneOffline
  });

  const comp = new Tone.Compressor({
    threshold: state.compressor,
    ratio: 4,
    attack: 0.003,
    release: 0.15,
    context: toneOffline
  });

  const limiter = new Tone.Limiter(-2, { context: toneOffline });

  masterIn.chain(lowCut, highCut, tape, comp, limiter);

  // Connect to the native OfflineAudioContext destination
  limiter.connect(offlineContext.destination);

  // ⬅️ Return the Tone.Context so we can use it for Players/Channels
  return { masterIn, limiter, toneOffline };
}

function createOfflineFxNode(fxDef, offlineContext) {
  const { type, params } = fxDef;
  
  switch (type) {
    case 'reverb':
      return new Tone.Reverb({ 
        decay: params.decay, 
        wet: params.wet,
        context: offlineContext 
      });
    
    case 'delay':
      return new Tone.FeedbackDelay({
        delayTime: params.time,
        feedback: params.feedback,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'chorus':
      return new Tone.Chorus({
        frequency: params.frequency,
        delayTime: params.delayTime,
        depth: params.depth,
        wet: params.wet,
        context: offlineContext
      }).start();
    
    case 'distortion':
      return new Tone.Distortion({
        distortion: params.amount,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'filter':
      return new Tone.Filter({
        type: params.type,
        frequency: params.frequency,
        Q: params.q,
        context: offlineContext
      });
    
    case 'compressor':
      return new Tone.Compressor({
        threshold: params.threshold,
        ratio: params.ratio,
        attack: params.attack,
        release: params.release,
        context: offlineContext
      });
    
    case 'eq':
      return new Tone.EQ3({
        low: params.low,
        mid: params.mid,
        high: params.high,
        context: offlineContext
      });
    
    case 'bitcrusher':
      return new Tone.BitCrusher({
        bits: params.bits,
        context: offlineContext
      });
    
    default:
      return null;
  }
}
  
async function bounceAllTracks() {
  const activeTracks = multitrack.tracks.filter(t =>
    t.selectedTakeIndex >= 0 && !t.muted
  );

  if (activeTracks.length === 0) {
    showToast('❌ No tracks to bounce!', 'error');
    return;
  }

  // Create progress modal
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">🎵 Bouncing Mix</div>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <div id="bounceStatus" style="font-weight: 700; margin-bottom: var(--space-2);">Preparing...</div>
        <div class="progress">
          <div class="progress-value" id="bounceProgress" style="width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="bounceDetails" style="font-size: var(--text-sm); color: var(--text-tertiary); margin-top: var(--space-2);"></div>
      </div>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const updateProgress = (percent, status, details = '') => {
    const prog = document.getElementById('bounceProgress');
    const stat = document.getElementById('bounceStatus');
    const det = document.getElementById('bounceDetails');
    if (prog) prog.style.width = percent + '%';
    if (stat) stat.textContent = status;
    if (det) det.textContent = details;
  };

  try {
    updateProgress(10, 'Analyzing tracks...', `${activeTracks.length} tracks to bounce`);

    let minStart = Infinity;
    let maxEnd = 0;

    activeTracks.forEach(track => {
      const take = track.takes[track.selectedTakeIndex];
      if (!take || take.muted || !take.buffer) return;

      const startTime = take.startTime || 0;
      const duration = take.duration || take.buffer.duration || 0;
      const endTime = startTime + duration;

      if (startTime < minStart) minStart = startTime;
      if (endTime > maxEnd) maxEnd = endTime;
    });

    if (minStart === Infinity || maxEnd <= minStart) {
      backdrop.remove();
      showToast('❌ Invalid take timing for bounce', 'error');
      return;
    }

    const totalDuration = maxEnd - minStart;
    updateProgress(20, 'Setting up renderer...', `Duration: ${totalDuration.toFixed(1)}s`);

    console.log(`🎬 Bouncing ${totalDuration.toFixed(2)}s`);
    console.log(`   - Earliest start (context): ${minStart.toFixed(2)}s`);
    console.log(`   - Latest end   (context):   ${maxEnd.toFixed(2)}s`);

    const sampleRate = Tone.context.sampleRate || 48000;
    const numFrames = Math.ceil(totalDuration * sampleRate);

    const offlineContext = new OfflineAudioContext({
      numberOfChannels: 2,
      length: numFrames,
      sampleRate
    });

    updateProgress(30, 'Creating audio chain...', 'Building master effects');

    const { masterIn: offlineMaster, toneOffline } = createOfflineMasterChain(offlineContext);

    updateProgress(40, 'Scheduling tracks...', `Processing ${activeTracks.length} tracks`);

    for (const track of activeTracks) {
      const take = track.takes[track.selectedTakeIndex];
      if (!take || take.muted || !take.buffer || take.buffer.length === 0) continue;

      try {
        const player = new Tone.Player({
          context: toneOffline,
          loop: false
        });
        player.buffer = take.buffer;
        
        const channel = new Tone.Channel({
          volume: track.volume,
          pan: track.pan / 100,
          context: toneOffline
        });

        player.connect(channel);
        channel.connect(offlineMaster);

        const startTime = take.startTime || 0;
        const relativeStartTime = startTime - minStart;

        player.start(relativeStartTime);

        console.log(`✅ ${track.name}:`);
        console.log(`   - Context start: ${startTime.toFixed(3)}s`);
        console.log(`   - Renders at:    ${relativeStartTime.toFixed(3)}s (offline)`);
        console.log(`   - Duration:      ${take.duration.toFixed(3)}s`);

      } catch (err) {
        console.error(`❌ Failed to schedule ${track.name}:`, err);
      }
    }

    updateProgress(50, 'Rendering audio...', 'This may take a moment');

    // Simulate progress during rendering
    const progressInterval = setInterval(() => {
      const currentProg = parseFloat(document.getElementById('bounceProgress')?.style.width) || 50;
      if (currentProg < 90) {
        updateProgress(currentProg + 2, 'Rendering audio...', `${Math.round(currentProg - 50)}% complete`);
      }
    }, 200);

    const renderedBuffer = await offlineContext.startRendering();
    
    clearInterval(progressInterval);
    updateProgress(95, 'Converting to WAV...', 'Almost done');

    console.log(`✅ Rendered ${renderedBuffer.duration.toFixed(2)}s`);

    const wavData = bufferToWavImproved(renderedBuffer);
    const blob = new Blob([wavData], { type: 'audio/wav' });

    const projectName = document.getElementById('projectName')?.value || 'mix';
    const filename = `${projectName.replace(/\s+/g, '_')}_bounce_${Date.now()}.wav`;

    updateProgress(100, 'Complete!', `Downloading ${filename}`);

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;

    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    setTimeout(() => URL.revokeObjectURL(url), 5000);

    console.log(`✅ Bounce complete: ${filename}`);
    
    setTimeout(() => {
      backdrop.remove();
      showToast(`✅ Bounce complete! ${totalDuration.toFixed(1)}s exported`, 'success');
    }, 1000);

  } catch (err) {
    console.error('❌ Bounce failed:', err);
    backdrop.remove();
    showToast(`❌ Bounce failed: ${err.message}`, 'error');
  }
}
  
// Add this NEW function
async function validateAllArmedTracks() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const errors = [];
  
  for (const track of armedTracks) {
    // Check if drum samples are loaded
    if (!track.isExternalAudio && instruments[track.instrument]?.type === 'drum') {
      const synth = synths[track.instrument];
      if (synth && !synth.loaded) {
        errors.push(`${track.instrument} sample not loaded`);
      }
    }
    
    // Check external audio setup
    if (track.isExternalAudio && !track.mediaStream) {
      errors.push(`${track.name} has no audio input`);
    }
  }
  
  if (errors.length > 0) {
    throw new Error(errors.join('\n'));
  }
}
  
async function toggleRecordAllArmed() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const recordingTracks = multitrack.tracks.filter(t => t.recording);

  if (recordingTracks.length > 0) {
    recordingTracks.forEach(track => track.stopRecording());
    // ❗️Do NOT clear globalRecordStartTime here – finishRecording needs it
    showToast(`⏹️ Stopped recording ${recordingTracks.length} track(s)`, 'info');
    renderMultitrack();
    return;
  }

  if (armedTracks.length === 0) {
    showToast('❌ No armed tracks to record', 'error');
    return;
  }

  // 🔥 NEW: Validate BEFORE starting any recordings
  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`❌ Cannot record:\n${err.message}`, 'error');
    return;
  }

  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();

  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  console.log(`🎬 GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    await track.startRecording({ forcedStartTime: globalStart });
  }

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`🎙️ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`🎙️ Recording ${armedTracks.length} track(s)`, 'success');
  renderMultitrack();
}
  
// Toggle recording for a single track
async function toggleRecordTrack(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.recording) {
    track.stopRecording();
    showToast(`⏹️ Stopped recording ${track.name}`, 'info');
  } else {
    if (!track.armed) {
      track.armed = true;
    }

    if (!state.isPlaying) {
      await togglePlay();
    }

    await Tone.start();
    const start = Tone.now();
    await track.startRecording({ forcedStartTime: start });

    showToast(`🎙️ Recording ${track.name}...`, 'success');
  }
  
  renderMultitrack();
}

// Open FX chain editor for a track
function openFxChainEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  multitrack.currentFxTrackId = trackId;
  
  const panel = document.getElementById('fxChainPanel');
  if (!panel) return;
  
  document.getElementById('fxChainTrackName').textContent = track.name;
  
  renderFxChain(track);
  
  panel.style.display = 'block';
  panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  
  // Re-setup listeners after panel is shown
  setupMultitrackListeners();
}

function renderFxChain(track) {
  const slots = document.getElementById('fxSlots');
  if (!slots) return;
  
  slots.innerHTML = '';
  
  if (track.fxChain.length === 0) {
    slots.innerHTML = `
      <div style="padding: var(--space-8); text-align: center; color: var(--text-tertiary);">
        <div style="font-size: var(--text-xl); margin-bottom: var(--space-2);">🎛️</div>
        <div>No effects on this track</div>
        <div style="font-size: var(--text-sm); margin-top: var(--space-2);">Click "Add Effect" above</div>
      </div>
    `;
    return;
  }
  
  track.fxChain.forEach((fx, idx) => {
    const fxSlot = document.createElement('div');
    fxSlot.className = 'fx-unit';
    fxSlot.style.opacity = fx.enabled ? '1' : '0.5';
    
    let paramsHTML = '';
    
    // Define parameter ranges for each FX type
    const paramConfig = {
      reverb: {
        decay: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 's' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      delay: {
        time: { min: 0, max: 3, options: ['16n', '8n', '4n', '2n', '1n'], default: '8n', format: (v) => v },
        feedback: { min: 0, max: 0.9, default: 0.3, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      chorus: {
        frequency: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 'Hz' },
        delayTime: { min: 2, max: 20, default: 3.5, format: (v) => v.toFixed(1) + 'ms' },
        depth: { min: 0, max: 1, default: 0.7, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      distortion: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      filter: {
        type: { options: ['lowpass', 'highpass', 'bandpass'], default: 'lowpass', format: (v) => v },
        frequency: { min: 20, max: 20000, default: 5000, format: (v) => Math.round(v) + 'Hz' },
        q: { min: 0.1, max: 10, default: 1, format: (v) => v.toFixed(1) }
      },
      compressor: {
        threshold: { min: -60, max: 0, default: -24, format: (v) => Math.round(v) + 'dB' },
        ratio: { min: 1, max: 20, default: 4, format: (v) => v.toFixed(1) + ':1' },
        attack: { min: 0.001, max: 1, default: 0.003, format: (v) => (v * 1000).toFixed(1) + 'ms' },
        release: { min: 0.01, max: 1, default: 0.25, format: (v) => (v * 1000).toFixed(0) + 'ms' }
      },
      eq: {
        low: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        mid: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        high: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' }
      },
      bitcrusher: {
        bits: { min: 1, max: 16, default: 4, format: (v) => Math.round(v) + ' bits' }
      }
    };
    
    const typeConfig = paramConfig[fx.type] || {};
    
    Object.entries(fx.params).forEach(([param, value]) => {
      const config = typeConfig[param] || { min: 0, max: 100, default: 50, format: (v) => v };
      
      let sliderVal = 50;
      let displayVal = value;
      
      // Handle special cases
      if (config.options) {
        // Discrete options (like delay time or filter type)
        const optIndex = config.options.indexOf(value);
        sliderVal = optIndex >= 0 ? (optIndex / (config.options.length - 1)) * 100 : 50;
      } else {
        // Continuous values
        sliderVal = ((value - config.min) / (config.max - config.min)) * 100;
        sliderVal = Math.max(0, Math.min(100, sliderVal));
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value" data-fx-id="${fx.id}" data-param="${param}">${config.format(value)}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx-id="${fx.id}" 
                 data-param="${param}"
                 data-fx-type="${fx.type}"
                 class="fx-param-slider">
        </div>
      `;
    });
    
    fxSlot.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${fx.type.toUpperCase()}</div>
        <div style="display: flex; gap: var(--space-2); align-items: center;">
          <div class="fx-toggle ${fx.enabled ? 'active' : ''}" data-fx-id="${fx.id}"></div>
          <button class="btn btn-ghost btn-sm" data-action="remove-fx" data-fx-id="${fx.id}">✕</button>
        </div>
      </div>
      ${paramsHTML}
    `;
    
    slots.appendChild(fxSlot);
  });
  
  // Attach listeners AFTER all DOM is ready
  setTimeout(() => {
    // Toggle switches
    slots.querySelectorAll('.fx-toggle').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const fxId = parseFloat(toggle.dataset.fxId);
        track.toggleFx(fxId);
        renderFxChain(track);
      });
    });
    
    // Remove buttons
    slots.querySelectorAll('[data-action="remove-fx"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const fxId = parseFloat(btn.dataset.fxId);
        if (confirm('Remove this effect?')) {
          track.removeFx(fxId);
          renderFxChain(track);
        }
      });
    });
    
    // Parameter sliders with proper mapping
    slots.querySelectorAll('.fx-param-slider').forEach(slider => {
      slider.addEventListener('input', (e) => {
        const fxId = parseFloat(e.target.dataset.fxId);
        const param = e.target.dataset.param;
        const fxType = e.target.dataset.fxType;
        const sliderPercent = parseInt(e.target.value, 10);
        
        const fx = track.fxChain.find(f => f.id === fxId);
        if (!fx) return;
        
        const typeConfig = {
          reverb: {
            decay: { min: 0.1, max: 10 },
            wet: { min: 0, max: 1 }
          },
          delay: {
            time: { options: ['16n', '8n', '4n', '2n', '1n'] },
            feedback: { min: 0, max: 0.9 },
            wet: { min: 0, max: 1 }
          },
          chorus: {
            frequency: { min: 0.1, max: 10 },
            delayTime: { min: 2, max: 20 },
            depth: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          distortion: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          filter: {
            type: { options: ['lowpass', 'highpass', 'bandpass'] },
            frequency: { min: 20, max: 20000 },
            q: { min: 0.1, max: 10 }
          },
          compressor: {
            threshold: { min: -60, max: 0 },
            ratio: { min: 1, max: 20 },
            attack: { min: 0.001, max: 1 },
            release: { min: 0.01, max: 1 }
          },
          eq: {
            low: { min: -24, max: 24 },
            mid: { min: -24, max: 24 },
            high: { min: -24, max: 24 }
          },
          bitcrusher: {
            bits: { min: 1, max: 16 }
          }
        };
        
        const config = typeConfig[fxType]?.[param];
        if (!config) return;
        
        let value;
        
        if (config.options) {
          // Discrete options
          const index = Math.round((sliderPercent / 100) * (config.options.length - 1));
          value = config.options[index];
        } else {
          // Continuous value
          value = config.min + (sliderPercent / 100) * (config.max - config.min);
        }
        
        track.updateFxParam(fxId, param, value);
        
        // Update display
        const label = e.target.closest('.param-control').querySelector('.param-value');
        if (label) {
          if (param === 'decay' || param === 'frequency' || param === 'delayTime') {
            label.textContent = typeof value === 'number' ? value.toFixed(1) : value;
            if (param === 'decay') label.textContent += 's';
            if (param === 'frequency') label.textContent += 'Hz';
            if (param === 'delayTime') label.textContent += 'ms';
          } else if (param === 'wet' || param === 'feedback' || param === 'depth' || param === 'amount') {
            label.textContent = Math.round(value * 100) + '%';
          } else if (param === 'threshold' || param === 'low' || param === 'mid' || param === 'high') {
            label.textContent = (value > 0 ? '+' : '') + Math.round(value) + 'dB';
          } else if (param === 'ratio') {
            label.textContent = value.toFixed(1) + ':1';
          } else if (param === 'attack' || param === 'release') {
            label.textContent = (value * 1000).toFixed(param === 'attack' ? 1 : 0) + 'ms';
          } else if (param === 'bits') {
            label.textContent = Math.round(value) + ' bits';
          } else if (param === 'q') {
            label.textContent = value.toFixed(1);
          } else {
            label.textContent = value.toString();
          }
        }
      });
    });
  }, 0);
}

// Open take editor for a track
function openTakeEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.takes.length === 0) {
    showToast('❌ No takes to edit', 'error');
    return;
  }
  
  // Create modal
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '700px';
  
  let takesHTML = '';
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    takesHTML += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${take.muted ? 'muted' : ''}" 
           style="margin-bottom: var(--space-3); padding: var(--space-4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="flex: 1;">
            <div style="font-weight: 800; font-size: var(--text-base); margin-bottom: var(--space-2);">
              Take ${idx + 1} ${isSelected ? '(Active)' : ''}
            </div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              ${take.duration.toFixed(2)}s • ${new Date(take.timestamp).toLocaleString()}
            </div>
          </div>
          <div style="display: flex; gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" data-action="play-take" data-index="${idx}">
              ▶️ Play
            </button>
            <button class="btn btn-secondary btn-sm" data-action="select-take" data-index="${idx}">
              ${isSelected ? '✓ Active' : 'Set Active'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="toggle-mute-take" data-index="${idx}">
              ${take.muted ? '🔇 Unmute' : '🔊 Mute'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="export-take" data-index="${idx}">
              💾
            </button>
            <button class="btn btn-ghost btn-sm" data-action="delete-take" data-index="${idx}">
              🗑️
            </button>
          </div>
        </div>
      </div>
    `;
  });
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">✂️ Edit Takes: ${track.name}</div>
      <button class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          <strong>${track.takes.length}</strong> take${track.takes.length !== 1 ? 's' : ''} recorded
        </div>
      </div>
      ${takesHTML}
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary close-btn">Close</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const close = () => {
    backdrop.remove();
    renderMultitrack();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.close-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  // Handle take actions
  modal.querySelectorAll('[data-action]').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      const index = parseInt(btn.dataset.index);
      
      if (action === 'play-take') {
        track.playTake(index);
      } else if (action === 'select-take') {
        track.selectTake(index);
        close();
      } else if (action === 'toggle-mute-take') {
        track.toggleTakeMute(index);
        close();
      } else if (action === 'export-take') {
        track.exportTake(index);
      } else if (action === 'delete-take') {
        if (confirm('Delete this take?')) {
          track.deleteTake(index);
          if (track.takes.length === 0) {
            close();
          } else {
            close();
          }
        }
      }
    });
  });
}
  
function setupMultitrackListeners() {
  const addTrackBtn = document.getElementById('addTrackBtn');
  if (addTrackBtn) {
    addTrackBtn.onclick = () => showAddTrackDialog();
  }
  
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) {
    previewBtn.onclick = async () => {
      if (previewBtn.textContent.includes('Stop')) {
        stopMultitrackPreview();
        previewBtn.textContent = '▶️ Preview Mix';
      } else {
        await previewMultitrack();
        previewBtn.textContent = '⏹️ Stop Preview';
      }
    };
  }
  
  const recordArmedBtn = document.getElementById('recordArmedBtn');
  if (recordArmedBtn) {
    recordArmedBtn.onclick = async () => await toggleRecordAllArmed();
  }
  
  const bounceBtn = document.getElementById('bounceAllBtn');
  if (bounceBtn) {
    bounceBtn.onclick = () => bounceAllTracks();
  }
  
  const clearBtn = document.getElementById('clearAllTracksBtn');
  if (clearBtn) {
    clearBtn.onclick = () => {
      if (confirm('Delete all tracks? This cannot be undone.')) {
        multitrack.tracks.forEach(track => track.dispose());
        multitrack.tracks = [];
        multitrack.nextTrackId = 1;
        renderMultitrack();
      }
    };
  }
  
  const closeFxBtn = document.getElementById('closeFxChainBtn');
  if (closeFxBtn) {
    closeFxBtn.onclick = () => {
      document.getElementById('fxChainPanel').style.display = 'none';
    };
  }
  
  const addFxBtn = document.getElementById('addFxBtn');
  const fxAddMenu = document.getElementById('fxAddMenu');
  
  if (addFxBtn && fxAddMenu) {
    addFxBtn.onclick = (e) => {
      e.stopPropagation();
      fxAddMenu.style.display = fxAddMenu.style.display === 'block' ? 'none' : 'block';
    };
    
    document.onclick = (e) => {
      const dropdown = document.getElementById('fxAddDropdown');
      if (dropdown && !dropdown.contains(e.target)) {
        fxAddMenu.style.display = 'none';
      }
    };
    
    fxAddMenu.querySelectorAll('.fx-add-item').forEach(item => {
      item.onclick = (e) => {
        e.stopPropagation();
        const fxType = item.dataset.fxType;
        const trackId = multitrack.currentFxTrackId;
        const track = multitrack.tracks.find(t => t.id === trackId);
        
        if (track) {
          track.addFx(fxType);
          renderFxChain(track);
          showToast(`✅ Added ${fxType} to ${track.name}`, 'success');
        }
        
        fxAddMenu.style.display = 'none';
      };
    });
  }
}
  
// -------------------- Preset System --------------------
function renderPresets() {
  const grid = document.getElementById('presetGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(genrePresets).forEach(genre => {
    const preset = genrePresets[genre];
    const div = document.createElement('div');
    div.className = 'preset';
    div.innerHTML = `
      <div class="preset-icon">${preset.icon}</div>
      <div class="preset-name">${preset.name}</div>
    `;
    div.addEventListener('click', () => loadPreset(genre));
    fragment.appendChild(div);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

function loadPreset(genre) {
  state.currentGenre = genre;
  document.querySelectorAll('.genre-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.genre === genre);
  });
  generateBeat();
}

function updateGenrePresets() {
  renderPresets();
}

// -------------------- Transport Controls --------------------
async function togglePlay() {
  if (state.isPlaying) {
    Tone.Transport.pause();
    state.isPlaying = false;
    document.getElementById('playBtn').innerHTML = '▶️ Play';
    stopTimer();
    stopVisualizer();
    return;
  }
  
  const hasActive = Object.keys(patterns).some(inst => 
    patterns[inst].some(s => s.active)
  );
  
  if (!hasActive) {
    alert('No active notes — click "Generate Beat" or add steps.');
    return;
  }
  
  try {
    await Tone.start();
    const raw = Tone.getContext().rawContext;
    if (raw.state !== 'running') await raw.resume();
    console.log('🎵 Audio started:', raw.state);
  } catch (e) {
    console.error('Could not start audio:', e);
    alert('Could not start audio. Click anywhere on the page, then press Play again.');
    return;
  }
  
  Tone.Transport.start();
  state.isPlaying = true;
  document.getElementById('playBtn').innerHTML = '⏸️ Pause';
  startTimer();
  document.getElementById('vizOverlay').style.display = 'none';
  updateVisualizer();
}

function stop() {
  Tone.Transport.stop();
  state.isPlaying = false;
  state.currentStep = 0;
  document.getElementById('playBtn').innerHTML = '▶️ Play';
  document.getElementById('timeDisplay').textContent = '00:00';
  document.getElementById('progressFill').style.width = '0%';
  document.querySelectorAll('.step').forEach(el => el.classList.remove('playing'));
  stopTimer();
  stopVisualizer();
  
  // Stop multitrack preview
  stopMultitrackPreview();
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) previewBtn.textContent = '▶️ Preview Mix';
}

// -------------------- Timer System --------------------
let progressRAF = 0;

function startTimer() {
  cancelAnimationFrame(progressRAF);
  
  const totalSeconds = state.duration * 60;
  const updateProgress = throttle(() => {
    const seconds = Tone.Transport.seconds;
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    
    document.getElementById('timeDisplay').textContent = 
      String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    
    document.getElementById('progressFill').style.width = 
      Math.min(100, (seconds / totalSeconds) * 100) + '%';
  }, CONFIG.PROGRESS_UPDATE_MS);
  
  const tick = () => {
    updateProgress();
    progressRAF = requestAnimationFrame(tick);
  };
  
  progressRAF = requestAnimationFrame(tick);
}

function stopTimer() {
  cancelAnimationFrame(progressRAF);
  progressRAF = 0;
}

// -------------------- Visualizer System --------------------
let visualizerRAF = 0;
let lastVisualizerUpdate = 0;

function initVisualizerOnce() {
  const viz = document.getElementById('visualizer');
  if (viz.dataset.ready) return;
  
  viz.dataset.ready = '1';
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < CONFIG.VISUALIZER_BARS; i++) {
    const bar = document.createElement('div');
    bar.className = 'viz-bar';
    bar.style.left = (i * 100 / CONFIG.VISUALIZER_BARS) + '%';
    bar.style.height = '10%';
    fragment.appendChild(bar);
  }
  
  viz.appendChild(fragment);
}

function updateVisualizer() {
  if (visualizerRAF) return;
  
  const viz = document.getElementById('visualizer');
  const bars = viz ? viz.querySelectorAll('.viz-bar') : [];
  const barCount = bars.length || 0;
  
  const updateInterval = 1000 / CONFIG.VISUALIZER_FPS;
  
  const loop = (timestamp) => {
    visualizerRAF = requestAnimationFrame(loop);
    
    if (!lastVisualizerUpdate || (timestamp - lastVisualizerUpdate) >= updateInterval) {
      lastVisualizerUpdate = timestamp;
      
      let heights;
      if (master.analyser) {
        const values = master.analyser.getValue();
        heights = new Array(barCount).fill(0).map((_, i) => {
          const index = Math.floor((i / barCount) * values.length);
          const value = values[clamp(index, 0, values.length - 1)];
          
          if (master.analyser.type === 'fft') {
            const db = clamp(value, -100, 0);
            const normalized = (db + 100) / 100;
            return (5 + normalized * 90).toFixed(1) + '%';
          } else {
            const normalized = (value + 1) / 2;
            return (5 + normalized * 90).toFixed(1) + '%';
          }
        });
      } else {
        heights = Array.from({ length: barCount }, () => 
          (Math.random() * 60 + 10).toFixed(1) + '%'
        );
      }
      
      bars.forEach((bar, i) => {
        bar.style.height = heights[i];
        bar.style.transform = '';
      });
    }
  };
  
  visualizerRAF = requestAnimationFrame(loop);
}

function stopVisualizer() {
  cancelAnimationFrame(visualizerRAF);
  visualizerRAF = 0;
}

// -------------------- Project Management --------------------
function getSerializableInstruments() {
  const keep = ['name', 'icon', 'mute', 'solo', 'volume', 'pan', 'type', 'note'];
  const cleaned = {};
  
  Object.keys(instruments).forEach(key => {
    cleaned[key] = {};
    keep.forEach(field => {
      cleaned[key][field] = instruments[key][field];
    });
  });
  
  return cleaned;
}

async function saveProject() {
  const projectName = document.getElementById('projectName').value || 'Untitled';
  
  showToast('💾 Saving project...', 'info');
  
  // Serialize patterns
  const plainPatterns = {};
  Object.keys(patterns).forEach(inst => {
    plainPatterns[inst] = patterns[inst].map(step => ({
      active: !!step.active,
      velocity: step.velocity ?? 0.8,
      probability: step.probability ?? 100,
      note: step.note ?? instruments[inst].note ?? null,
      duration: step.duration ?? '8n'
    }));
  });
  
  // Serialize multitrack WITH AUDIO
  const multitrackData = {
    tracks: [],
    nextTrackId: multitrack.nextTrackId
  };
  
  // Convert audio blobs to base64 for each track
  for (const track of multitrack.tracks) {
    const trackData = {
      id: track.id,
      name: track.name,
      instrument: track.instrument,
      isExternalAudio: track.isExternalAudio,
      volume: track.volume,
      pan: track.pan,
      muted: track.muted,
      soloed: track.soloed,
      selectedTakeIndex: track.selectedTakeIndex,
      fxChain: track.fxChain.map(fx => ({
        type: fx.type,
        params: fx.params,
        enabled: fx.enabled
      })),
      takes: []
    };
    
    // Convert each take's audio blob to base64
    for (const take of track.takes) {
      try {
        // Convert blob to base64
        const base64Audio = await blobToBase64(take.blob);
        
        trackData.takes.push({
          id: take.id,
          duration: take.duration,
          timestamp: take.timestamp,
          muted: take.muted,
          startTime: take.startTime,
          transportStartTime: take.transportStartTime,
          recordedAt: take.recordedAt,
          audioData: base64Audio, // Base64 encoded audio
          mimeType: take.blob.type
        });
      } catch (err) {
        console.error(`Failed to encode take ${take.id}:`, err);
      }
    }
    
    multitrackData.tracks.push(trackData);
  }
  
  const project = {
    version: '2.0', // Increment version for audio support
    name: projectName,
    state: {
      bpm: state.bpm,
      swing: state.swing,
      duration: state.duration,
      complexity: state.complexity,
      humanize: state.humanize,
      sequenceLength: state.sequenceLength,
      resolution: state.resolution,
      key: state.key,
      scale: state.scale,
      octave: state.octave,
      progression: state.progression,
      masterVolume: state.masterVolume,
      tapeSaturation: state.tapeSaturation,
      vinylNoise: state.vinylNoise,
      lowCut: state.lowCut,
      highCut: state.highCut,
      compressor: state.compressor,
      metronomeEnabled: state.metronomeEnabled,
      metronomeVolume: state.metronomeVolume,
      countInBars: state.countInBars
    },
    patterns: plainPatterns,
    instruments: getSerializableInstruments(),
    multitrack: multitrackData,
    timestamp: Date.now()
  };
  
  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  
  // Calculate file size
  const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${projectName.replace(/\s+/g, '_')}.8beat.json`;
  link.click();
  
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  console.log(`💾 Project saved: ${projectName} (${sizeMB}MB)`);
  showToast(`✅ Project saved! (${sizeMB}MB)`, 'success');
}

// Helper function to convert Blob to Base64
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // Remove the data URL prefix (e.g., "data:audio/webm;base64,")
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert Base64 back to Blob
function base64ToBlob(base64, mimeType) {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function applyLoadedInstruments(loaded) {
  Object.keys(loaded).forEach(inst => {
    const source = loaded[inst];
    if (!instruments[inst]) return;
    
    instruments[inst].mute = !!source.mute;
    instruments[inst].solo = !!source.solo;
    instruments[inst].volume = source.volume ?? instruments[inst].volume;
    instruments[inst].pan = source.pan ?? instruments[inst].pan;
    instruments[inst].note = source.note ?? instruments[inst].note;
    
    if (instruments[inst].channel) {
      instruments[inst].channel.volume.value = instruments[inst].volume;
      instruments[inst].channel.pan.value = (instruments[inst].pan || 0) / 100;
    }
  });
}

// Replace the loadProject function (around line 3600):
function loadProject() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.8beat.json';
  
  input.onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async ev => {
      try {
        const project = JSON.parse(ev.target.result);
        
        console.log('📂 Loading project:', project.name);
        showToast('⏳ Loading project...', 'info');
        
        // Stop playback
        if (state.isPlaying) {
          stop();
        }
        
        // Load state
        Object.assign(state, {
          ...state,
          ...project.state,
          isPlaying: false,
          currentStep: 0
        });
        
        // Load patterns
        Object.keys(patterns).forEach(k => delete patterns[k]);
        Object.assign(patterns, project.patterns || {});
        
        // Load instruments
        if (project.instruments) {
          applyLoadedInstruments(project.instruments);
        }
        
        // Load multitrack
        if (project.multitrack) {
          // Clear existing tracks
          multitrack.tracks.forEach(t => t.dispose());
          multitrack.tracks = [];
          
          // Restore tracks with audio
          for (const trackData of project.multitrack.tracks) {
            const track = new AudioTrack(
              trackData.id,
              trackData.name,
              trackData.instrument,
              trackData.isExternalAudio
            );
            
            track.volume = trackData.volume;
            track.pan = trackData.pan;
            track.muted = trackData.muted;
            track.soloed = trackData.soloed;
            track.selectedTakeIndex = trackData.selectedTakeIndex;
            
            // Update channel settings
            track.channel.volume.value = track.volume;
            track.channel.pan.value = track.pan / 100;
            
            // Restore FX chain
            if (trackData.fxChain && trackData.fxChain.length > 0) {
              trackData.fxChain.forEach(fxData => {
                track.addFx(fxData.type, fxData.params);
                const fx = track.fxChain[track.fxChain.length - 1];
                if (fx) {
                  fx.enabled = fxData.enabled;
                }
              });
            }
            
            // Restore takes with audio
            if (trackData.takes && trackData.takes.length > 0) {
              showToast(`🎵 Restoring ${trackData.takes.length} take(s) for ${track.name}...`, 'info');
              
              for (const takeData of trackData.takes) {
                try {
                  // Convert base64 back to blob
                  const blob = base64ToBlob(takeData.audioData, takeData.mimeType);
                  
                  // Decode audio buffer
                  const arrayBuffer = await blob.arrayBuffer();
                  const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
                  
                  // Recreate the take
                  const take = {
                    id: takeData.id,
                    buffer: audioBuffer,
                    blob: blob,
                    duration: takeData.duration,
                    timestamp: takeData.timestamp,
                    muted: takeData.muted,
                    startTime: takeData.startTime,
                    transportStartTime: takeData.transportStartTime,
                    recordedAt: takeData.recordedAt
                  };
                  
                  track.takes.push(take);
                  console.log(`✅ Restored take ${take.id} (${take.duration.toFixed(2)}s)`);
                  
                } catch (err) {
                  console.error(`Failed to restore take ${takeData.id}:`, err);
                }
              }
            }
            
            multitrack.tracks.push(track);
          }
          
          multitrack.nextTrackId = project.multitrack.nextTrackId;
        }
        
        // Update all displays
        updateAllDisplays();
        ensurePatternLength(state.sequenceLength);
        
        renderSequencer();
        renderMixer();
        renderFX();
        renderHarmony();
        renderMultitrack();
        
        document.getElementById('projectName').value = project.name || 'Untitled';
        
        const totalTakes = multitrack.tracks.reduce((sum, t) => sum + t.takes.length, 0);
        console.log('✅ Project loaded successfully');
        showToast(`✅ Project loaded with ${totalTakes} recording(s)!`, 'success');
        
      } catch (err) {
        console.error('❌ Load project error:', err);
        showToast('❌ Error loading project: ' + err.message, 'error');
      }
    };
    
    reader.readAsText(file);
  };
  
  input.click();
}
  
function updateAllDisplays() {
  state.bpm = Math.min(CONFIG.MAX_BPM, state.bpm);
  
  document.getElementById('bpmSlider').value = state.bpm;
  document.getElementById('bpmValue').textContent = state.bpm;
  document.getElementById('swingSlider').value = state.swing;
  document.getElementById('swingValue').textContent = state.swing + '%';
  document.getElementById('durSlider').value = state.duration;
  document.getElementById('durValue').textContent = state.duration + ' min';
  document.getElementById('durationDisplay').textContent = 
    '/ ' + String(state.duration).padStart(2, '0') + ':00';
  document.getElementById('complexSlider').value = state.complexity;
  document.getElementById('complexValue').textContent = 
    ['Simple', 'Medium', 'Complex'][state.complexity - 1];
  document.getElementById('humanSlider').value = state.humanize;
  document.getElementById('humanValue').textContent = state.humanize + 'ms';
  
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';
}

// -------------------- Audio Export --------------------
function bufferToWav(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = clamp(channels[c][i], -1, 1);
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

async function exportAudio() {
  // Live recording only - captures real-time output
  await exportLiveRecording();
}

// Improved WAV converter with peak normalization
function bufferToWavImproved(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  
  // Find peak for normalization
  let peak = 0;
  for (let c = 0; c < numChannels; c++) {
    const channelData = audioBuffer.getChannelData(c);
    for (let i = 0; i < numFrames; i++) {
      const abs = Math.abs(channelData[i]);
      if (abs > peak) peak = abs;
    }
  }
  
  // Calculate normalization factor (leave 1dB headroom)
  const targetPeak = 0.891; // -1dB
  const normFactor = peak > 0 ? Math.min(targetPeak / peak, 1) : 1;
  
  console.log(`🎚️ Normalizing: peak=${peak.toFixed(3)}, factor=${normFactor.toFixed(3)}`);
  
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples with normalization
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = channels[c][i] * normFactor;
      sample = Math.max(-1, Math.min(1, sample)); // Hard clip
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

// Live recording - captures what you hear in real-time
async function exportLiveRecording() {
  // if we're already recording, this call means "stop & download"
  if (master.mediaRecorder && master.mediaRecorder.state === 'recording') {
    master.mediaRecorder.stop();
    return;
  }

  await Tone.start();

  const stream = master.mediaDest?.stream;
  if (!stream) {
    alert('❌ No recording stream available.');
    return;
  }

  let mimeType = '';
  if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
    mimeType = 'audio/webm;codecs=opus';
  } else if (MediaRecorder.isTypeSupported('audio/webm')) {
    mimeType = 'audio/webm';
  }

  master.recordedChunks = [];
  const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
  master.mediaRecorder = rec;

  rec.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) {
      master.recordedChunks.push(e.data);
    }
  };

  rec.onstop = () => {
    const blob = new Blob(master.recordedChunks, {
      type: rec.mimeType || 'audio/webm'
    });

    const name = (document.getElementById('projectName')?.value || 'live_mix')
      .replace(/\s+/g, '_') + `_${Date.now()}`;

    let ext = 'webm';
    if ((rec.mimeType || '').includes('ogg')) ext = 'ogg';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.${ext}`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    const btn = document.getElementById('exportBtn');
    if (btn) btn.textContent = '🎧 DJ Export';
    
    showToast('✅ Live mix exported!', 'success');
  };

  rec.start();

  const btn = document.getElementById('exportBtn');
  if (btn) btn.textContent = '⏹️ Stop Recording';
  
  showToast('🎙️ Recording live output...', 'info');
}
  
// -------------------- PWA Installation --------------------
let deferredPrompt;

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').hidden = false;
});

document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  
  if (outcome === 'accepted') {
    document.getElementById('installBtn').hidden = true;
  }
  
  deferredPrompt = null;
});

function checkSamplesLoaded() {
  const drumInsts = Object.keys(instruments).filter(k => instruments[k].type === 'drum');
  const totalDrums = drumInsts.length;
  let loadedCount = 0;
  let lastLoggedCount = -1;
  
  const checkInterval = setInterval(() => {
    loadedCount = 0;
    const statusList = [];
    
    drumInsts.forEach(inst => {
      const synth = synths[inst];
      if (synth && synth.loaded) {
        loadedCount++;
        statusList.push(`✅ ${inst}`);
      } else {
        statusList.push(`⏳ ${inst}`);
      }
    });
    
    // Only log when count changes
    if (loadedCount !== lastLoggedCount) {
      console.log(`📦 Drum samples: ${loadedCount}/${totalDrums}`);
      console.log(statusList.join(', '));
      lastLoggedCount = loadedCount;
    }
    
    if (loadedCount === totalDrums) {
      clearInterval(checkInterval);
      console.log('✅ All drum samples ready!');
      document.getElementById('vizOverlay').textContent = 'All Samples Loaded - Generate & Press Play';
    }
  }, 500);
  
  // Stop checking after 15 seconds
  setTimeout(() => {
    clearInterval(checkInterval);
    if (loadedCount < totalDrums) {
      console.warn(`⚠️ Only ${loadedCount}/${totalDrums} samples loaded after timeout`);
      console.warn('Missing samples:', drumInsts.filter(inst => !synths[inst]?.loaded));
    }
  }, 15000);
}

// -------------------- Initialization --------------------
function init() {
  initAudioContext();
  initAudio();
  ensurePatternLength(state.sequenceLength);
  setupEventListeners();
  setupMultitrackListeners(); // Add this explicit call
  renderSequencer();
  renderMixer();
  renderFX();
  renderHarmony();
  renderPresets();
  renderMultitrack(); // Add this to render initial state
  updateAllDisplays();
  initVisualizerOnce();
  unlockAudioOnce();
  checkAudioPermissions();
  checkSamplesLoaded();
  loadSavedVibe();
}
  
// -------------------- Entry Point --------------------
document.addEventListener('DOMContentLoaded', init);
</script>

</body>
</html>
