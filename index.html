<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#000000"/>
  <title>8-Beat Studio</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./lofi8Beat.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <style>
   /* =========================================================
      8-BEAT STUDIO — PROFESSIONAL ULTRA-MODERN REDESIGN
      Premium glassmorphic design with advanced micro-interactions
      Responsive grid system • Advanced animations • Pro gradients
    ========================================================= */
    
    /* Professional Font Stack */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    /* -------- Design System Tokens -------- */
    :root{
      /* Typography Scale */
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'Courier New', monospace;
      
      --text-xs: clamp(0.7rem, 0.65rem + 0.25vw, 0.75rem);
      --text-sm: clamp(0.8rem, 0.75rem + 0.25vw, 0.875rem);
      --text-base: clamp(0.9rem, 0.85rem + 0.25vw, 1rem);
      --text-lg: clamp(1rem, 0.95rem + 0.25vw, 1.125rem);
      --text-xl: clamp(1.125rem, 1rem + 0.5vw, 1.25rem);
      --text-2xl: clamp(1.25rem, 1.125rem + 0.625vw, 1.5rem);
      --text-3xl: clamp(1.5rem, 1.25rem + 1vw, 2rem);
      --text-4xl: clamp(1.875rem, 1.5rem + 1.5vw, 2.5rem);
    
      /* Spacing System */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.25rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-10: 2.5rem;
      --space-12: 3rem;
      --space-16: 4rem;
      
      /* Layout */
      --container-max: 1800px;
      --gutter: clamp(1rem, 3vw, 2rem);
      --sidebar-width: clamp(280px, 18vw, 340px);
      
      /* Border Radius System */
      --radius-xs: 6px;
      --radius-sm: 10px;
      --radius-md: 14px;
      --radius-lg: 18px;
      --radius-xl: 24px;
      --radius-2xl: 32px;
      --radius-full: 9999px;
    
      /* Professional Shadow System */
      --shadow-xs: 0 1px 2px rgba(0,0,0,.05);
      --shadow-sm: 0 2px 8px rgba(0,0,0,.08);
      --shadow-md: 0 4px 16px rgba(0,0,0,.12);
      --shadow-lg: 0 8px 32px rgba(0,0,0,.16);
      --shadow-xl: 0 12px 48px rgba(0,0,0,.22);
      --shadow-2xl: 0 20px 64px rgba(0,0,0,.32);
      --shadow-inner: inset 0 2px 8px rgba(0,0,0,.08);
      
      /* Glow Effects */
      --glow-sm: 0 0 20px;
      --glow-md: 0 0 40px;
      --glow-lg: 0 0 60px;
    
      /* Component Heights */
      --header-h: clamp(68px, 8vh, 80px);
      --tabs-h: clamp(52px, 6vh, 60px);
      --transport-h: clamp(88px, 10vh, 104px);
    
      /* Focus Ring */
      --ring-w: 3px;
      --ring-offset: 2px;
      --ring: rgba(180,190,255,.6);
      
      /* Glass Effects */
      --glass-border: rgba(255,255,255,.12);
      --glass-border-strong: rgba(255,255,255,.2);
      --glass-bg: rgba(255,255,255,.04);
      --glass-bg-strong: rgba(255,255,255,.08);
    
      /* Safe Areas */
      --inset-top: env(safe-area-inset-top, 0px);
      --inset-right: env(safe-area-inset-right, 0px);
      --inset-bottom: env(safe-area-inset-bottom, 0px);
      --inset-left: env(safe-area-inset-left, 0px);
    
      /* Animation Curves */
      --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
      --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --ease-elastic: cubic-bezier(0.68, -0.6, 0.32, 1.6);
      
      /* Transition Durations */
      --duration-fast: 150ms;
      --duration-base: 200ms;
      --duration-slow: 300ms;
      --duration-slower: 500ms;
    
      /* Default Theme (overridden by vibes) */
      --bg-primary: #0a0e1a;
      --bg-secondary: #0f1420;
      --bg-tertiary: #141824;
      
      --text-primary: #e9ecff;
      --text-secondary: #c8ccff;
      --text-tertiary: #9aa0c7;
      --text-muted: #6b7199;
      
      --accent-primary: #7c83ff;
      --accent-secondary: #8d6cff;
      --accent-tertiary: #9f7eff;
      
      --success: #22c55e;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;
    
      --surface: linear-gradient(135deg, rgba(255,255,255,.08) 0%, rgba(255,255,255,.04) 100%);
      --surface-elevated: linear-gradient(135deg, rgba(255,255,255,.12) 0%, rgba(255,255,255,.06) 100%);
    }
    
    /* -------- Premium Vibe Palettes -------- */
    body[data-vibe="moon"]{
      --bg-primary: #0a0e1a;
      --bg-secondary: #0f1420;
      --bg-tertiary: #141824;
      --accent-primary: #7c83ff;
      --accent-secondary: #8d6cff;
      --accent-tertiary: #9f7eff;
      --text-primary: #e9ecff;
      --text-secondary: #cfd4ff;
      --text-tertiary: #a6acd6;
    }
    
    body[data-vibe="dawn"]{
      --bg-primary: #1a0e14;
      --bg-secondary: #221318;
      --bg-tertiary: #2a1820;
      --accent-primary: #ff8fb1;
      --accent-secondary: #ffb385;
      --accent-tertiary: #ffc799;
      --text-primary: #fff4f8;
      --text-secondary: #ffdfe9;
      --text-tertiary: #f2cbd8;
    }
    
    body[data-vibe="nebula"]{
      --bg-primary: #0b0d18;
      --bg-secondary: #0f0a1c;
      --bg-tertiary: #150f24;
      --accent-primary: #9a6bff;
      --accent-secondary: #33d1ff;
      --accent-tertiary: #66e0ff;
      --text-primary: #eaf5ff;
      --text-secondary: #cfe7ff;
      --text-tertiary: #a6c9e6;
    }
    
    body[data-vibe="forest"]{
      --bg-primary: #091312;
      --bg-secondary: #0b1418;
      --bg-tertiary: #0e1a1e;
      --accent-primary: #5de6a4;
      --accent-secondary: #86f7c1;
      --accent-tertiary: #a0ffd0;
      --text-primary: #e7fff5;
      --text-secondary: #c9ffe9;
      --text-tertiary: #a1d4c2;
    }
    
    body[data-vibe="sunset"]{
      --bg-primary: #1a0e0f;
      --bg-secondary: #221214;
      --bg-tertiary: #2a161a;
      --accent-primary: #ff7a59;
      --accent-secondary: #ffb86b;
      --accent-tertiary: #ffd699;
      --text-primary: #fff1eb;
      --text-secondary: #ffd9c9;
      --text-tertiary: #ffc6ae;
    }

    /* === 8-Beat Splash / Initialization Overlay === */
    #splashOverlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-6, 1.5rem);
      background:
        radial-gradient(circle at top, rgba(148, 163, 253, 0.3), transparent 60%),
        radial-gradient(circle at bottom, rgba(45, 212, 191, 0.25), transparent 60%),
        rgba(3, 7, 18, 0.95);
      backdrop-filter: blur(10px);
    }

    #splashOverlay.hidden {
      display: none;
    }

    #splashOverlay .splash-inner {
      background: var(--surface-elevated, rgba(15, 23, 42, 0.9));
      border-radius: var(--radius-2xl, 1.25rem);
      padding: var(--space-7, 1.75rem) var(--space-8, 2rem);
      border: 1px solid var(--glass-border-strong, rgba(148, 163, 184, 0.3));
      box-shadow: var(--shadow-2xl, 0 24px 80px rgba(15, 23, 42, 0.8));
      max-width: 420px;
      width: 100%;
      text-align: center;
      animation: modalSlideIn var(--duration-slow, 320ms) var(--ease-bounce, cubic-bezier(0.34, 1.56, 0.64, 1));
    }

    #splashOverlay .splash-logo {
      font-size: var(--text-2xl, 1.5rem);
      font-weight: 900;
      margin-bottom: var(--space-4, 1rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: linear-gradient(135deg, #a5b4fc, #f97316);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #splashOverlay .splash-message {
      font-size: var(--text-base, 1rem);
      color: var(--text-primary, #e5e7eb);
      margin-bottom: var(--space-4, 1rem);
    }

    #splashOverlay .splash-progress {
      width: 100%;
      height: 0.5rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid var(--glass-border, rgba(148, 163, 184, 0.2));
      overflow: hidden;
      margin-bottom: var(--space-3, 0.75rem);
    }

    #splashOverlay .splash-progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, #22d3ee, #a855f7, #f97316);
      transition: width 220ms var(--ease-smooth, cubic-bezier(0.22, 0.61, 0.36, 1));
    }

    #splashOverlay .splash-sub {
      font-size: var(--text-xs, 0.75rem);
      color: var(--text-muted, #94a3b8);
      opacity: 0.85;
    }
    
    /* -------- Global Canvas -------- */
    *, *::before, *::after{
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html{
      font-size: 16px;
      height: 100%;
      scroll-behavior: smooth;
    }
    
    body{
      min-height: 100%;
      font-family: var(--font-sans);
      font-size: var(--text-base);
      font-weight: 400;
      line-height: 1.6;
      color: var(--text-primary);
      background: 
        radial-gradient(ellipse 1200px 800px at 15% -5%, 
          color-mix(in oklab, var(--accent-primary) 15%, transparent), 
          transparent 65%),
        radial-gradient(ellipse 1000px 700px at 85% 105%, 
          color-mix(in oklab, var(--accent-secondary) 12%, transparent), 
          transparent 65%),
        radial-gradient(ellipse 800px 600px at 50% 50%, 
          color-mix(in oklab, var(--accent-tertiary) 6%, transparent), 
          transparent 70%),
        linear-gradient(135deg, 
          var(--bg-primary) 0%, 
          var(--bg-secondary) 50%, 
          var(--bg-tertiary) 100%);
      background-attachment: fixed;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      
      padding:
        calc(var(--space-4) + var(--inset-top))
        calc(var(--space-4) + var(--inset-right))
        calc(var(--space-4) + var(--inset-bottom))
        calc(var(--space-4) + var(--inset-left));
    }
    
    @media (display-mode: standalone){
      body{ 
        min-height: 100dvh;
        padding-top: calc(var(--space-6) + var(--inset-top));
      }
    }
    
    /* -------- Premium App Container -------- */
    .app{
      max-width: var(--container-max);
      margin: 0 auto;
      display: grid;
      gap: var(--gutter);
      padding: clamp(var(--space-4), 2vw, var(--space-8));
      background: 
        linear-gradient(135deg, 
          color-mix(in oklab, var(--bg-secondary) 85%, transparent) 0%, 
          color-mix(in oklab, var(--bg-primary) 70%, transparent) 100%);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-2xl);
      box-shadow: 
        var(--shadow-2xl),
        inset 0 1px 0 rgba(255,255,255,.06),
        inset 0 -1px 0 rgba(0,0,0,.2);
      backdrop-filter: blur(32px) saturate(140%);
      position: relative;
      overflow: hidden;
      
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "tabs"
        "transport"
        "main"
        "footer";
    }
    
    /* Ambient glow effect */
    .app::before{
      content: '';
      position: absolute;
      inset: -50%;
      background: 
        radial-gradient(circle at 20% 30%, 
          color-mix(in oklab, var(--accent-primary) 8%, transparent), 
          transparent 40%),
        radial-gradient(circle at 80% 70%, 
          color-mix(in oklab, var(--accent-secondary) 6%, transparent), 
          transparent 40%);
      opacity: 0.6;
      animation: ambientPulse 8s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    
    @keyframes ambientPulse{
      0%, 100%{ transform: scale(1) rotate(0deg); opacity: 0.6; }
      50%{ transform: scale(1.1) rotate(5deg); opacity: 0.4; }
    }
    
    .app > *{
      position: relative;
      z-index: 1;
    }
    
    /* Sidebar Layout */
    .app:has(.sidebar),
    .app.with-sidebar{
      grid-template-columns: var(--sidebar-width) 1fr;
      grid-template-areas:
        "header header"
        "tabs tabs"
        "transport transport"
        "sidebar main"
        "footer footer";
      gap: var(--space-6);
    }
    
    header{ grid-area: header; }
    .tabs{ grid-area: tabs; }
    .transport{ grid-area: transport; }
    section.section{ grid-area: main; }
    footer.footer{ grid-area: footer; }
    
    /* -------- Premium Header -------- */
    header{
      position: sticky;
      top: var(--space-4);
      z-index: 50;
      height: auto;
      min-height: var(--header-h);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: var(--space-4);
      align-items: center;
      padding: var(--space-4) var(--space-5);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: 
        var(--shadow-lg),
        inset 0 1px 0 rgba(255,255,255,.1);
      backdrop-filter: blur(24px) saturate(150%);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    header:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent),
        inset 0 1px 0 rgba(255,255,255,.15);
    }
    
    .logo-section{
      display: flex;
      gap: var(--space-3);
      align-items: center;
    }
    
    .logo{
      width: clamp(48px, 6vw, 56px);
      height: clamp(48px, 6vw, 56px);
      border-radius: var(--radius-md);
      display: grid;
      place-items: center;
      font-size: var(--text-2xl);
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      font-weight: 900;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
      position: relative;
      overflow: hidden;
      transition: transform var(--duration-base) var(--ease-bounce);
    }
    
    .logo::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.2) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform var(--duration-slow) var(--ease-smooth);
    }
    
    .logo:hover{
      transform: scale(1.05) rotate(5deg);
    }
    
    .logo:hover::before{
      transform: translateX(100%);
    }
    
    h1{
      margin: 0;
      font-size: var(--text-2xl);
      font-weight: 900;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .tagline{
      font-size: var(--text-sm);
      color: var(--text-tertiary);
      font-weight: 500;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      margin-top: calc(-1 * var(--space-1));
    }
    
    /* Genre Selector - Refined */
    .genre-selector{
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .genre-btn{
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius-full);
      border: 1px solid var(--glass-border);
      background: var(--glass-bg);
      color: var(--text-secondary);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .genre-btn::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .genre-btn > span{
      position: relative;
      z-index: 1;
    }
    
    .genre-btn:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    
    .genre-btn:hover::before{
      opacity: 0.1;
    }
    
    .genre-btn.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      border-color: transparent;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
      transform: translateY(-2px);
    }
    
    .genre-btn.active::before{
      opacity: 0;
    }
    
    .genre-btn:active{
      transform: translateY(0);
    }
    
    /* Header Actions */
    .header-actions{
      display: flex;
      gap: var(--space-2);
    }
    
    /* -------- Premium Tab System -------- */
    .tabs{
      position: sticky;
      top: calc(var(--header-h) + var(--space-4) + var(--space-2));
      z-index: 49;
      display: flex;
      gap: var(--space-2);
      padding: var(--space-3);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.06);
      backdrop-filter: blur(20px) saturate(130%);
      overflow-x: auto;
      overflow-y: visible;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .tabs::-webkit-scrollbar{ display: none; }
    
    .tab{
      position: relative;
      padding: var(--space-3) var(--space-5);
      border: none;
      border-radius: var(--radius-full);
      background: transparent;
      color: var(--text-tertiary);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all var(--duration-base) var(--ease-smooth);
      white-space: nowrap;
      overflow: hidden;
    }
    
    .tab::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      border-radius: inherit;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .tab > *{
      position: relative;
      z-index: 1;
    }
    
    .tab:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: translateY(-1px);
    }
    
    .tab.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 35%, transparent);
      transform: translateY(-2px);
    }
    
    .tab:active{
      transform: translateY(0);
    }
    
    /* -------- Transport Bar - Command Center -------- */
    .transport{
      position: sticky;
      top: calc(var(--header-h) + var(--tabs-h) + var(--space-4) + var(--space-4));
      z-index: 48;
      padding: var(--space-5) var(--space-6);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: 
        var(--shadow-lg),
        inset 0 1px 0 rgba(255,255,255,.08);
      backdrop-filter: blur(24px) saturate(140%);
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: var(--space-6);
      align-items: center;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .transport:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border-strong));
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 12%, transparent),
        inset 0 1px 0 rgba(255,255,255,.12);
    }
    
    .transport-controls{
      display: flex;
      gap: var(--space-2);
      align-items: center;
      flex-wrap: wrap;
    }
    
    .progress-area{
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      min-width: 0;
      flex: 1;
    }
    
    .time-info{
      display: flex;
      gap: var(--space-3);
      justify-content: space-between;
      color: var(--text-secondary);
      font-weight: 700;
      font-size: var(--text-sm);
      font-family: var(--font-mono);
      letter-spacing: 0.05em;
    }
    
    .progress-bar{
      height: 14px;
      border-radius: var(--radius-full);
      overflow: hidden;
      background: 
        linear-gradient(90deg, 
          rgba(255,255,255,.06) 0%, 
          rgba(255,255,255,.08) 50%, 
          rgba(255,255,255,.06) 100%);
      border: 1px solid rgba(255,255,255,.1);
      box-shadow: var(--shadow-inner);
      position: relative;
    }
    
    .progress-bar::before{
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 4px,
        rgba(255,255,255,.03) 4px,
        rgba(255,255,255,.03) 8px
      );
      pointer-events: none;
    }
    
    .progress-fill{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
      width: 0%;
      transition: width 120ms linear;
      box-shadow: 
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 0 0 1px rgba(255,255,255,.2);
      position: relative;
      overflow: hidden;
    }
    
    .progress-fill::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255,255,255,.3) 50%, 
        transparent 100%);
      animation: progressShimmer 2s linear infinite;
    }
    
    @keyframes progressShimmer{
      0%{ transform: translateX(-100%); }
      100%{ transform: translateX(100%); }
    }
    
    .transport-params{
      display: grid;
      grid-auto-flow: column;
      gap: var(--space-4);
      align-items: center;
    }
    
    /* -------- Premium Button System -------- */
    .btn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      padding: var(--space-3) var(--space-5);
      border: none;
      border-radius: var(--radius-md);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-sm);
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-smooth);
      white-space: nowrap;
      text-decoration: none;
      outline: none;
      position: relative;
      overflow: hidden;
      transform: translateY(0);
    }
    
    .btn::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.15) 50%, transparent 70%);
      transform: translateX(-100%);
      transition: transform var(--duration-slow) var(--ease-smooth);
    }
    
    .btn:hover::before{
      transform: translateX(100%);
    }
    
    .btn-sm{
      padding: var(--space-2) var(--space-4);
      font-size: var(--text-xs);
      border-radius: var(--radius-sm);
    }
    
    .btn:active{
      transform: translateY(1px) scale(0.98);
    }
    
    .btn:disabled{
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    
    .btn:focus-visible{
      box-shadow: 
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    /* Button Variants */
    .btn-primary{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.2);
    }
    
    .btn-primary:hover{
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent),
        inset 0 1px 0 rgba(255,255,255,.25);
    }
    
    .btn-secondary{
      background: var(--surface);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-sm);
    }
    
    .btn-secondary:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      background: var(--surface-elevated);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    
    .btn-ghost{
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid transparent;
    }
    
    .btn-ghost:hover{
      background: var(--glass-bg-strong);
      border-color: var(--glass-border);
      color: var(--text-primary);
    }
    
    .btn-success{
      background: linear-gradient(135deg, var(--success), color-mix(in oklab, var(--success) 70%, #ffffff));
      color: #042013;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--success) 35%, transparent);
    }
    
    .btn-success:hover{
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--success) 30%, transparent);
    }
    
    /* -------- Sidebar -------- */
    .sidebar{
      grid-area: sidebar;
      position: sticky;
      top: calc(var(--header-h) + var(--tabs-h) + var(--transport-h) + var(--space-8));
      align-self: start;
      max-height: calc(100dvh - var(--header-h) - var(--tabs-h) - var(--transport-h) - var(--space-16));
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: var(--space-4);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      display: grid;
      gap: var(--space-3);
    }

    /* -------- Sidebar Navigation -------- */
    .sidebar-toggle {
      position: fixed;
      top: calc(var(--space-4) + var(--inset-top));
      left: calc(var(--space-4) + var(--inset-left));
      z-index: 9999;
      width: 56px;
      height: 56px;
      border-radius: var(--radius-full);
      background: var(--glass-bg-strong);
      border: 1px solid var(--glass-border-strong);
      backdrop-filter: blur(12px) saturate(130%);
      color: var(--text-primary);
      font-size: var(--text-2xl);
      cursor: pointer;
      display: grid;
      place-items: center;
      box-shadow: var(--shadow-lg);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .sidebar-toggle:hover {
      background: var(--glass-bg-strong);
      border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border-strong));
      box-shadow: 
        var(--shadow-xl),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent);
      transform: scale(1.05);
    }
    
    .sidebar-toggle:active {
      transform: scale(0.95);
    }
    
    .sidebar-nav {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(85vw, 380px);
      background: var(--surface-elevated);
      border-right: 1px solid var(--glass-border-strong);
      box-shadow: var(--shadow-2xl);
      backdrop-filter: blur(32px) saturate(150%);
      z-index: 9998;
      transform: translateX(-100%);
      transition: transform var(--duration-slow) var(--ease-smooth);
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: calc(var(--space-20) + var(--inset-top)) var(--space-4) calc(var(--space-4) + var(--inset-bottom)) var(--space-4);
    }
    
    .sidebar-nav.open {
      transform: translateX(0);
    }
    
    .sidebar-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      z-index: 9997;
      opacity: 0;
      visibility: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .sidebar-backdrop.open {
      opacity: 1;
      visibility: visible;
    }
    
    .sidebar-section {
      margin-bottom: var(--space-8);
    }
    
    .sidebar-section-title {
      font-size: var(--text-lg);
      font-weight: 800;
      color: var(--text-primary);
      margin-bottom: var(--space-4);
      padding-bottom: var(--space-3);
      border-bottom: 2px solid var(--glass-border);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .sidebar-tabs {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    
    .sidebar-tab {
      padding: var(--space-4) var(--space-5);
      border: none;
      border-radius: var(--radius-md);
      background: var(--glass-bg);
      color: var(--text-secondary);
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: var(--text-base);
      cursor: pointer;
      transition: all var(--duration-base) var(--ease-smooth);
      text-align: left;
      display: flex;
      align-items: center;
      gap: var(--space-3);
      border: 1px solid transparent;
    }
    
    .sidebar-tab:hover {
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
      transform: translateX(4px);
    }
    
    .sidebar-tab.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 35%, transparent);
      transform: translateX(8px);
    }
    
    .sidebar-presets {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-3);
    }
    
    .sidebar-preset {
      padding: var(--space-4);
      border-radius: var(--radius-md);
      cursor: pointer;
      text-align: center;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      font-weight: 700;
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      align-items: center;
      transition: all var(--duration-base) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .sidebar-preset::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .sidebar-preset > * {
      position: relative;
      z-index: 1;
    }
    
    .sidebar-preset:hover {
      transform: translateY(-2px);
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      box-shadow: var(--shadow-md);
    }
    
    .sidebar-preset:hover::before {
      opacity: 0.08;
    }
    
    .sidebar-preset-icon {
      font-size: var(--text-3xl);
      line-height: 1;
    }
    
    .sidebar-preset-name {
      font-size: var(--text-sm);
      color: var(--text-secondary);
      transition: color var(--duration-base) var(--ease-smooth);
    }
    
    .sidebar-preset:hover .sidebar-preset-name {
      color: var(--text-primary);
    }
    
    /* Adjust app layout */
    .app {
      grid-template-areas:
        "header"
        "transport"
        "main"
        "footer";
    }
    
    @media (max-width: 768px) {
      .sidebar-nav {
        width: 100vw;
        max-width: 100vw;
      }
      
      .sidebar-toggle {
        width: 48px;
        height: 48px;
        font-size: var(--text-xl);
      }
    }
    
    @media (max-width: 1060px){
      .app{
        grid-template-columns: 1fr;
        grid-template-areas: "header" "tabs" "transport" "main" "footer";
      }
      .sidebar:not(.pinned){ display: none; }
    }
    
    /* -------- Sections & Panels -------- */
    .section{
      display: none;
    }
    
    .section.active{
      display: grid;
      gap: var(--gutter);
      margin-top: var(--space-2);
      animation: sectionFadeIn var(--duration-slow) var(--ease-smooth) both;
    }
    
    @keyframes sectionFadeIn{
      from{
        opacity: 0;
        transform: translateY(20px);
      }
      to{
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .panel{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.04);
      position: relative;
      overflow: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .panel::before{
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
      opacity: 0;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .panel:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
    }
    
    .panel:hover::before{
      opacity: 0.6;
    }
    
    .panel-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-4);
      padding-bottom: var(--space-3);
      border-bottom: 1px solid var(--glass-border);
      flex-wrap: wrap;
      gap: var(--space-3);
    }
    
    .panel-title{
      font-size: var(--text-lg);
      font-weight: 800;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      letter-spacing: -0.01em;
    }
    
    /* -------- Input Controls -------- */
    .param-control{
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    
    .param-label{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
    }
    
    .param-value{
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-weight: 700;
      font-size: var(--text-sm);
      padding: var(--space-1) var(--space-2);
      background: var(--glass-bg);
      border-radius: var(--radius-xs);
    }
    
    /* Range Sliders - Premium */
    input[type="range"]{
      width: 100%;
      height: 12px;
      border-radius: var(--radius-full);
      appearance: none;
      -webkit-appearance: none;
      cursor: pointer;
      background: 
        linear-gradient(90deg, 
          rgba(255,255,255,.06) 0%, 
          rgba(255,255,255,.08) 50%, 
          rgba(255,255,255,.06) 100%);
      border: 1px solid rgba(255,255,255,.1);
      box-shadow: var(--shadow-inner);
      outline: none;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    input[type="range"]:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, rgba(255,255,255,.1));
    }
    
    input[type="range"]:focus-visible{
      box-shadow: 
        var(--shadow-inner),
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    /* Webkit Slider Thumb */
    input[type="range"]::-webkit-slider-thumb{
      appearance: none;
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.3);
      border: 2px solid rgba(255,255,255,.4);
      cursor: grab;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    input[type="range"]::-webkit-slider-thumb:hover{
      transform: scale(1.1);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
        inset 0 1px 0 rgba(255,255,255,.4);
    }
    
    input[type="range"]::-webkit-slider-thumb:active{
      cursor: grabbing;
      transform: scale(0.95);
    }
    
    /* Firefox Slider Thumb */
    input[type="range"]::-moz-range-thumb{
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
        inset 0 1px 0 rgba(255,255,255,.3);
      border: 2px solid rgba(255,255,255,.4);
      cursor: grab;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    input[type="range"]::-moz-range-thumb:hover{
      transform: scale(1.1);
    }
    
    input[type="range"]::-moz-range-thumb:active{
      cursor: grabbing;
      transform: scale(0.95);
    }
    
    /* Text Inputs & Select */
    input[type="text"],
    input[type="email"],
    input[type="number"],
    select{
      width: 100%;
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-primary);
      font-family: var(--font-sans);
      font-weight: 600;
      font-size: var(--text-sm);
      cursor: pointer;
      outline: none;
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    input[type="text"]:focus,
    input[type="email"]:focus,
    input[type="number"]:focus,
    select:focus{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
      background: var(--glass-bg-strong);
      box-shadow: 
        var(--shadow-sm),
        0 0 0 var(--ring-offset) var(--bg-primary),
        0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
    }
    
    input[type="text"]::placeholder{
      color: var(--text-muted);
      font-weight: 500;
    }
    
    select{
      background-image: 
        linear-gradient(45deg, transparent 50%, var(--text-tertiary) 50%),
        linear-gradient(135deg, var(--text-tertiary) 50%, transparent 50%);
      background-position: 
        calc(100% - 16px) calc(50% - 2px),
        calc(100% - 11px) calc(50% - 2px);
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
      padding-right: var(--space-8);
      cursor: pointer;
    }
    
    /* -------- Chips & Tags -------- */
    .chips{
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }
    
    .chip{
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius-full);
      cursor: pointer;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-secondary);
      font-weight: 700;
      font-size: var(--text-sm);
      transition: all var(--duration-fast) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .chip::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .chip > *{
      position: relative;
      z-index: 1;
    }
    
    .chip:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    
    .chip:hover::before{
      opacity: 0.1;
    }
    
    .chip.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      border-color: transparent;
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    }
    
    .chip.active::before{
      opacity: 0;
    }
    
    /* -------- Preset Grid -------- */
    .preset-grid{
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: var(--space-4);
    }
    
    .preset{
      padding: var(--space-5);
      border-radius: var(--radius-md);
      cursor: pointer;
      text-align: center;
      background: var(--surface);
      border: 1px solid var(--glass-border);
      font-weight: 700;
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      align-items: center;
      transition: all var(--duration-base) var(--ease-smooth);
      position: relative;
      overflow: hidden;
    }
    
    .preset::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-base) var(--ease-smooth);
    }
    
    .preset > *{
      position: relative;
      z-index: 1;
    }
    
    .preset:hover{
      transform: translateY(-4px);
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      box-shadow: 
        var(--shadow-lg),
        var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent);
    }
    
    .preset:hover::before{
      opacity: 0.08;
    }
    
    .preset:active{
      transform: translateY(-2px);
    }
    
    .preset-icon{
      font-size: var(--text-3xl);
      line-height: 1;
      filter: drop-shadow(0 2px 8px rgba(0,0,0,.3));
    }
    
    .preset-name{
      font-size: var(--text-sm);
      color: var(--text-secondary);
      transition: color var(--duration-base) var(--ease-smooth);
    }
    
    .preset:hover .preset-name{
      color: var(--text-primary);
    }
    
    /* -------- Premium Visualizer -------- */
    .visualizer{
      height: clamp(160px, 20vh, 220px);
      border-radius: var(--radius-lg);
      position: relative;
      background:
        linear-gradient(135deg, 
          color-mix(in oklab, var(--accent-primary) 10%, transparent), 
          color-mix(in oklab, var(--accent-secondary) 8%, transparent)),
        linear-gradient(180deg, rgba(0,0,0,.2), transparent 70%);
      border: 1px solid var(--glass-border-strong);
      overflow: hidden;
      box-shadow: 
        var(--shadow-md),
        inset 0 1px 0 rgba(255,255,255,.06),
        inset 0 0 0 1px rgba(255,255,255,.03);
    }
    
    .visualizer::before{
      content: '';
      position: absolute;
      inset: 0;
      background: 
        repeating-linear-gradient(
          0deg,
          transparent 0px,
          rgba(255,255,255,.01) 1px,
          transparent 2px,
          transparent 20px
        );
      pointer-events: none;
      z-index: 1;
    }
    
    .viz-bar{
      position: absolute;
      bottom: 0;
      width: 5px;
      border-radius: 3px 3px 0 0;
      opacity: 0.9;
      background: linear-gradient(
        to top, 
        var(--accent-primary) 0%,
        var(--accent-secondary) 50%,
        var(--accent-tertiary) 100%
      );
      transition: height 80ms ease-out;
      will-change: height;
      box-shadow: 
        0 -4px 12px color-mix(in oklab, var(--accent-primary) 30%, transparent),
        inset 0 0 0 1px rgba(255,255,255,.15);
      filter: brightness(1.1);
    }
    
    .viz-overlay{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: 
        linear-gradient(180deg, 
          color-mix(in oklab, var(--bg-primary) 40%, transparent), 
          color-mix(in oklab, var(--bg-secondary) 50%, transparent));
      backdrop-filter: blur(4px);
      font-weight: 800;
      font-size: var(--text-lg);
      color: var(--text-tertiary);
      letter-spacing: 0.05em;
      text-transform: uppercase;
      pointer-events: none;
      z-index: 2;
    }
    
    /* -------- Sequencer Grid -------- */
    .sequencer{
      overflow-x: auto;
      overflow-y: visible;
      scrollbar-width: thin;
      padding-bottom: var(--space-2);
    }
    
    .seq-grid{
      display: grid;
      gap: var(--space-3);
      min-width: 900px;
      position: relative;
    }
    
    .seq-grid::before{
      content: '';
      position: absolute;
      inset: 0;
      border-radius: var(--radius-md);
      background:
        repeating-linear-gradient(
          to right,
          transparent 0,
          transparent calc(100% / 16 - 1px),
          rgba(255,255,255,.04) calc(100% / 16 - 1px),
          rgba(255,255,255,.04) calc(100% / 16)
        );
      pointer-events: none;
      z-index: 0;
    }
    
    .seq-row{
      display: grid;
      grid-template-columns: 180px repeat(16, 1fr);
      gap: var(--space-2);
      align-items: center;
      position: relative;
      z-index: 1;
    }
    
    .seq-label{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-3) var(--space-4);
      background: var(--surface);
      border-radius: var(--radius-md);
      border: 1px solid var(--glass-border);
      font-weight: 700;
      font-size: var(--text-sm);
      transition: all var(--duration-base) var(--ease-smooth);
    }

    .seq-icon[data-action="play"] {
      display: none;
    }
    
    .seq-label:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
      background: var(--surface-elevated);
    }
    
    .seq-icons{
      display: flex;
      gap: var(--space-1);
    }
    
    .seq-icon{
      width: 32px;
      height: 32px;
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-xs);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .seq-icon:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
      transform: scale(1.05);
    }
    
    .seq-icon.active{
      background: var(--error);
      color: #fff;
      box-shadow: var(--shadow-sm);
    }
    
    /* Sequencer Steps */
    .step{
      aspect-ratio: 1;
      min-height: 48px;
      border-radius: var(--radius-md);
      cursor: pointer;
      background: 
        linear-gradient(135deg, 
          rgba(255,255,255,.06), 
          rgba(255,255,255,.04));
      border: 1px solid var(--glass-border);
      position: relative;
      display: grid;
      place-items: center;
      transition: all var(--duration-fast) var(--ease-smooth);
      overflow: hidden;
    }
    
    .step::before{
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0;
      transition: opacity var(--duration-fast) var(--ease-smooth);
    }
    
    .step:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
    }
    
    .step:hover::before{
      opacity: 0.1;
    }
    
    .step:active{
      transform: translateY(0) scale(0.97);
    }
    
    .step.active{
      background: 
        linear-gradient(135deg, 
          color-mix(in oklab, var(--accent-primary) 75%, transparent), 
          color-mix(in oklab, var(--accent-secondary) 80%, transparent));
      border-color: color-mix(in oklab, var(--accent-primary) 70%, transparent);
      box-shadow: 
        var(--shadow-sm),
        0 0 16px color-mix(in oklab, var(--accent-primary) 45%, transparent),
        inset 0 1px 0 rgba(255,255,255,.2);
    }
    
    .step.active::before{
      opacity: 0;
    }
    
    .step.playing{
      animation: stepPulse 280ms ease-out;
      box-shadow: 
        var(--shadow-md),
        0 0 28px var(--warning),
        0 0 48px color-mix(in oklab, var(--warning) 25%, transparent);
      border-color: var(--warning);
    }
    
    @keyframes stepPulse{
      0%, 100%{ transform: scale(1); }
      50%{ transform: scale(1.12); }
    }
    
    .step-prob{
      position: absolute;
      top: var(--space-1);
      right: var(--space-1);
      font-size: var(--text-xs);
      background: rgba(0,0,0,.6);
      padding: 2px var(--space-2);
      border-radius: var(--radius-xs);
      color: #fff;
      font-weight: 800;
      pointer-events: none;
      z-index: 2;
      font-family: var(--font-mono);
      backdrop-filter: blur(4px);
    }
    
    .step-vel{
      position: absolute;
      bottom: var(--space-1);
      left: var(--space-1);
      right: var(--space-1);
      height: 6px;
      background: rgba(255,255,255,.15);
      border-radius: var(--radius-full);
      overflow: hidden;
      z-index: 2;
    }
    
    .step-vel-fill{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      opacity: 0.95;
      transition: width 200ms var(--ease-smooth);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-primary) 50%, transparent);
    }
    
    .playhead{
      position: sticky;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    .playhead::after{
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      width: 4px;
      border-radius: var(--radius-xs);
      background: linear-gradient(
        to bottom,
        var(--warning),
        color-mix(in oklab, var(--warning) 20%, transparent)
      );
      box-shadow: 
        0 0 16px color-mix(in oklab, var(--warning) 50%, transparent),
        0 0 32px color-mix(in oklab, var(--warning) 25%, transparent);
      transform: translateX(-2px);
    }
    
    /* -------- Mixer Channels -------- */
    #tab-mixer .panel{
      display: grid;
      gap: var(--space-5);
    }
    
    #mixerGrid{
      display: grid;
      gap: var(--space-4);
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    }
    
    .mixer-channel{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .mixer-channel:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }
    
    .channel-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: var(--space-2);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .channel-name{
      font-weight: 800;
      font-size: var(--text-sm);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .channel-btns{
      display: flex;
      gap: var(--space-1);
    }
    
    .channel-btn{
      width: 34px;
      height: 34px;
      border: none;
      border-radius: var(--radius-xs);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      font-weight: 800;
      font-size: var(--text-xs);
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .channel-btn:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
      transform: scale(1.05);
    }
    
    .channel-btn.active{
      color: #fff;
    }
    
    .channel-btn.mute.active{
      background: var(--error);
      box-shadow: var(--shadow-sm);
    }
    
    .channel-btn.solo.active{
      background: var(--warning);
      box-shadow: var(--shadow-sm);
    }
    
    /* -------- FX Units -------- */
    #fxGrid{
      display: grid;
      gap: var(--space-4);
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }
    
    .fx-unit{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: var(--space-5);
      box-shadow: var(--shadow-md);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .fx-unit:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .fx-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-4);
      padding-bottom: var(--space-3);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .fx-name{
      font-weight: 800;
      font-size: var(--text-base);
      color: var(--text-primary);
    }
    
    .fx-toggle{
      width: 60px;
      height: 32px;
      border-radius: var(--radius-full);
      cursor: pointer;
      background: color-mix(in oklab, var(--bg-secondary) 60%, transparent);
      border: 2px solid var(--glass-border);
      position: relative;
      transition: all var(--duration-base) var(--ease-smooth);
      box-shadow: var(--shadow-inner);
    }
    
    .fx-toggle::after{
      content: '';
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: all var(--duration-base) var(--ease-smooth);
      box-shadow: var(--shadow-sm);
    }
    
    .fx-toggle:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
    }
    
    .fx-toggle.active{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: transparent;
      box-shadow: 
        var(--shadow-sm),
        0 0 16px color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .fx-toggle.active::after{
      left: calc(100% - 26px);
      background: var(--bg-primary);
    }
    
    /* -------- Footer -------- */
    .footer{
      padding: var(--space-5) var(--space-6);
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      text-align: center;
      color: var(--text-secondary);
      font-size: var(--text-sm);
      line-height: 1.8;
      box-shadow: var(--shadow-sm);
    }
    
    .footer strong{
      color: var(--text-primary);
      font-weight: 800;
    }
    
    kbd{
      background: var(--glass-bg-strong);
      border: 1px solid var(--glass-border-strong);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-xs);
      font-weight: 700;
      font-size: var(--text-xs);
      color: var(--text-primary);
      font-family: var(--font-mono);
      box-shadow: 
        var(--shadow-xs),
        inset 0 -1px 0 rgba(0,0,0,.2);
    }
    
    /* -------- Utility Grid System -------- */
    .grid{
      display: grid;
      gap: var(--space-4);
    }
    
    .grid-2{
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    
    .grid-3{
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
    
    .grid-4{
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    
    /* -------- Flex Utilities -------- */
    .flex{
      display: flex;
      gap: var(--space-3);
      align-items: center;
      flex-wrap: wrap;
    }
    
    .flex-col{
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }
    
    /* -------- Spacing Utilities -------- */
    .mb-2{ margin-bottom: var(--space-2); }
    .mb-3{ margin-bottom: var(--space-3); }
    .mb-4{ margin-bottom: var(--space-4); }
    .mt-2{ margin-top: var(--space-2); }
    .mt-3{ margin-top: var(--space-3); }
    .mt-4{ margin-top: var(--space-4); }
    
    /* -------- Badge Component -------- */
    .badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-1) var(--space-3);
      border-radius: var(--radius-full);
      font-size: var(--text-xs);
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      line-height: 1;
    }
    
    .badge-primary{
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--bg-primary);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .badge-success{
      background: var(--success);
      color: #042013;
    }
    
    .badge-warning{
      background: var(--warning);
      color: #451a03;
    }
    
    .badge-error{
      background: var(--error);
      color: #fff;
    }
    
    .badge-ghost{
      background: var(--glass-bg-strong);
      color: var(--text-secondary);
      border: 1px solid var(--glass-border);
    }
    
    /* -------- Premium Scrollbars -------- */
    *{
      scrollbar-color: 
        color-mix(in oklab, var(--accent-primary) 50%, transparent) 
        transparent;
      scrollbar-width: thin;
    }
    
    *::-webkit-scrollbar{
      height: 10px;
      width: 10px;
    }
    
    *::-webkit-scrollbar-track{
      background: transparent;
    }
    
    *::-webkit-scrollbar-thumb{
      background: linear-gradient(
        135deg, 
        color-mix(in oklab, var(--accent-primary) 85%, #fff), 
        color-mix(in oklab, var(--accent-secondary) 85%, #fff)
      );
      border-radius: var(--radius-xs);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    *::-webkit-scrollbar-corner{
      background: transparent;
    }
    
    /* -------- Selection Styling -------- */
    ::selection{
      background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      text-shadow: none;
    }
    
    ::-moz-selection{
      background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
      color: var(--text-primary);
      text-shadow: none;
    }
    
    /* -------- Loading States -------- */
    .loading{
      position: relative;
      pointer-events: none;
      opacity: 0.6;
    }
    
    .loading::after{
      content: '';
      position: absolute;
      inset: 0;
      background: 
        linear-gradient(
          90deg,
          transparent 0%,
          color-mix(in oklab, var(--accent-primary) 15%, transparent) 50%,
          transparent 100%
        );
      animation: shimmer 2s infinite;
      border-radius: inherit;
    }
    
    @keyframes shimmer{
      0%{ transform: translateX(-100%); }
      100%{ transform: translateX(100%); }
    }
    
    .spinner{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid var(--glass-border);
      border-top-color: var(--accent-primary);
      animation: spin 0.8s linear infinite;
      margin: var(--space-4) auto;
    }
    
    @keyframes spin{
      to{ transform: rotate(360deg); }
    }
    
    /* -------- Toast Notifications -------- */
    .toast-container{
      position: fixed;
      bottom: calc(var(--space-4) + var(--inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      max-width: 90vw;
      width: auto;
      pointer-events: none;
      align-items: center;
    }
    
    .toast{
      padding: var(--space-2) var(--space-4);
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-full);
      box-shadow: 
        var(--shadow-md),
        var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent);
      backdrop-filter: blur(24px) saturate(150%);
      display: inline-flex;
      gap: var(--space-2);
      align-items: center;
      font-size: var(--text-xs);
      font-weight: 600;
      color: var(--text-primary);
      animation: toastSlideUp var(--duration-base) var(--ease-smooth);
      pointer-events: auto;
      position: relative;
      overflow: hidden;
      white-space: nowrap;
      max-width: 400px;
    }
    
    .toast::before{
      display: none;
    }
    
    .toast.success{
      border-color: rgba(34, 197, 94, 0.5);
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
    }
    
    .toast.error{
      border-color: rgba(239, 68, 68, 0.5);
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
    }
    
    .toast.warning{
      border-color: rgba(245, 158, 11, 0.5);
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
    }
    
    .toast.info{
      border-color: rgba(59, 130, 246, 0.5);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
    }
    
    @keyframes toastSlideUp{
      from{
        transform: translateY(100px);
        opacity: 0;
      }
      to{
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .toast-icon{
      font-size: var(--text-base);
      line-height: 1;
    }
    
    .toast-close{
      margin-left: var(--space-2);
      width: 20px;
      height: 20px;
      border: none;
      border-radius: var(--radius-xs);
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-xs);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .toast-close:hover{
      background: rgba(255, 255, 255, 0.2);
      color: var(--text-primary);
      transform: scale(1.1);
    }
    
    /* -------- Modal/Dialog -------- */
    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(8px);
      z-index: 999;
      display: grid;
      place-items: center;
      padding: var(--space-4);
      animation: backdropFadeIn var(--duration-base) var(--ease-smooth);
    }
    
    @keyframes backdropFadeIn{
      from{ opacity: 0; }
      to{ opacity: 1; }
    }
    
    .modal{
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-2xl);
      padding: var(--space-8);
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
      position: relative;
    }
    
    @keyframes modalSlideIn{
      from{
        transform: translateY(40px) scale(0.95);
        opacity: 0;
      }
      to{
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .modal-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-5);
      padding-bottom: var(--space-4);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .modal-title{
      font-size: var(--text-2xl);
      font-weight: 900;
      color: var(--text-primary);
      background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .modal-close{
      width: 40px;
      height: 40px;
      border: none;
      border-radius: var(--radius-sm);
      background: var(--glass-bg);
      color: var(--text-tertiary);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: var(--text-lg);
      font-weight: 800;
      transition: all var(--duration-fast) var(--ease-smooth);
    }
    
    .modal-close:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      transform: scale(1.05);
    }
    
    .modal-body{
      color: var(--text-secondary);
      line-height: 1.7;
    }
    
    .modal-footer{
      display: flex;
      gap: var(--space-3);
      justify-content: flex-end;
      margin-top: var(--space-6);
      padding-top: var(--space-4);
      border-top: 1px solid var(--glass-border);
    }
    
    /* -------- Dropdown Menu -------- */
    .dropdown{
      position: relative;
      display: inline-block;
    }
    
    .dropdown-menu{
      position: absolute;
      top: calc(100% + var(--space-2));
      right: 0;
      min-width: 220px;
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      backdrop-filter: blur(24px) saturate(150%);
      padding: var(--space-2);
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .dropdown.open .dropdown-menu{
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .dropdown-item{
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      transition: all var(--duration-fast) var(--ease-smooth);
      border: 1px solid transparent;
    }
    
    .dropdown-item:hover{
      background: var(--glass-bg-strong);
      color: var(--text-primary);
      border-color: var(--glass-border);
    }
    
    .dropdown-item.active{
      background: linear-gradient(135deg, 
        color-mix(in oklab, var(--accent-primary) 20%, transparent),
        color-mix(in oklab, var(--accent-secondary) 15%, transparent));
      color: var(--text-primary);
      border-color: color-mix(in oklab, var(--accent-primary) 30%, transparent);
    }
    
    .dropdown-divider{
      height: 1px;
      background: var(--glass-border);
      margin: var(--space-2) 0;
    }
    
    /* -------- Tooltip -------- */
    [data-tooltip]{
      position: relative;
      cursor: help;
    }
    
    [data-tooltip]::before{
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + var(--space-2));
      left: 50%;
      transform: translateX(-50%) translateY(-5px);
      padding: var(--space-2) var(--space-3);
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: var(--text-xs);
      font-weight: 600;
      white-space: nowrap;
      box-shadow: var(--shadow-lg);
      opacity: 0;
      visibility: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
      pointer-events: none;
      z-index: 200;
      backdrop-filter: blur(12px);
    }
    
    [data-tooltip]::after{
      content: '';
      position: absolute;
      bottom: calc(100% + var(--space-1));
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: var(--glass-border-strong);
      opacity: 0;
      visibility: hidden;
      transition: all var(--duration-base) var(--ease-smooth);
      pointer-events: none;
      z-index: 200;
    }
    
    [data-tooltip]:hover::before,
    [data-tooltip]:hover::after{
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
    
    /* -------- Context Menu -------- */
    .context-menu{
      position: fixed;
      min-width: 200px;
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-2xl);
      backdrop-filter: blur(24px) saturate(150%);
      padding: var(--space-2);
      z-index: 9999;
      animation: contextMenuAppear var(--duration-fast) var(--ease-smooth);
    }
    
    @keyframes contextMenuAppear{
      from{
        opacity: 0;
        transform: scale(0.95);
      }
      to{
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* -------- Progress Indicator -------- */
    .progress{
      height: 8px;
      background: var(--glass-bg);
      border-radius: var(--radius-full);
      overflow: hidden;
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-inner);
    }
    
    .progress-value{
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      border-radius: inherit;
      transition: width var(--duration-base) var(--ease-smooth);
      box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    }
    
    /* -------- Accordion -------- */
    .accordion-item{
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      margin-bottom: var(--space-3);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-item:hover{
      border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
    }
    
    .accordion-header{
      padding: var(--space-4) var(--space-5);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      color: var(--text-primary);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-header:hover{
      background: var(--glass-bg);
    }
    
    .accordion-icon{
      transition: transform var(--duration-base) var(--ease-smooth);
    }
    
    .accordion-item.open .accordion-icon{
      transform: rotate(180deg);
    }
    
    .accordion-content{
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-slow) var(--ease-smooth);
    }
    
    .accordion-item.open .accordion-content{
      max-height: 1000px;
    }
    
    .accordion-body{
      padding: var(--space-4) var(--space-5);
      color: var(--text-secondary);
      line-height: 1.7;
    }

    /* === PRO FEATURE LOCK === */
    .pro-locked {
      position: relative;
      opacity: 0.65;
      pointer-events: none;
    }
    
    .pro-locked::after {
      content: "🔒 Pro Feature — Unlock 8-Beat Studio Pro";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      border-radius: var(--radius-md);
      padding: 1rem;
      pointer-events: all;
      z-index: 50;
    }
    
    /* Remove overlay when Pro is active */
    body.pro .pro-locked {
      opacity: 1;
      pointer-events: auto;
    }
    body.pro .pro-locked::after {
      display: none;
    }
    
    /* Optional: dim locked sidebar tabs */
    .sidebar-tab.locked {
      opacity: 0.5;
      pointer-events: none;
    }

    /* Unlock Pro Button Styling */
    #unlockProBtn {
      padding: var(--space-4) var(--space-5);
      border: none;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      color: #451a03;
      font-family: var(--font-sans);
      font-weight: 800;
      font-size: var(--text-base);
      cursor: pointer;
      transition: all var(--duration-base) var(--ease-smooth);
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      box-shadow: 
        var(--shadow-md),
        0 0 20px color-mix(in oklab, #f59e0b 40%, transparent);
      margin-top: var(--space-4);
    }
    
    #unlockProBtn:hover {
      transform: translateY(-2px);
      box-shadow: 
        var(--shadow-lg),
        0 0 30px color-mix(in oklab, #f59e0b 50%, transparent);
    }
    
    #unlockProBtn:active {
      transform: translateY(0);
    }
    
    /* Locked Tab Styling */
    .sidebar-tab.locked {
      opacity: 0.5;
      pointer-events: none;
      position: relative;
    }
    
    .sidebar-tab.locked::after {
      content: '🔒';
      margin-left: var(--space-2);
      font-size: var(--text-sm);
    }
    
    /* Modal Improvements */
    #unlockModal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 10000;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      padding: var(--space-4);
      align-items: center;
      justify-content: center;
    }
    
    #unlockModal:not(.hidden) {
      display: flex;
    }
    
    #unlockModal .pro-modal-inner {
      background: var(--surface-elevated);
      border: 1px solid var(--glass-border-strong);
      border-radius: var(--radius-xl);
      padding: var(--space-8);
      max-width: 500px;
      width: 100%;
      box-shadow: var(--shadow-2xl);
      animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
      height: auto;
      min-height: auto;
      max-height: calc(100vh - 4rem);
      align-self: center;
    }
    
    #unlockModal h2 {
      font-size: var(--text-2xl);
      font-weight: 900;
      color: var(--text-primary);
      margin-bottom: var(--space-4);
      background: linear-gradient(135deg, var(--text-primary), #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    #unlockModal p {
      color: var(--text-secondary);
      margin-bottom: var(--space-4);
      line-height: 1.6;
    }
    
    #unlockModal input {
      width: 100%;
      padding: var(--space-4);
      font-family: var(--font-mono);
      font-size: var(--text-base);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      margin-bottom: var(--space-4);
      transition: all var(--duration-base) var(--ease-smooth);
    }
    
    #unlockModal input:focus {
      outline: none;
      border-color: #fbbf24;
      box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
    }
    
    #unlockModal .modal-actions {
      display: flex;
      gap: var(--space-3);
      margin-top: var(--space-4);
    }
    
    #unlockModal .status {
      margin-top: var(--space-4);
      padding: var(--space-3);
      border-radius: var(--radius-sm);
      font-size: var(--text-sm);
      font-weight: 600;
      text-align: center;
    }
    
    #unlockModal .status:not(:empty) {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
    }
    
    /* ==================== PROFESSIONAL DAW / MULTITRACK ==================== */

/* === WAVEFORM VISUALIZATION === */
.clip-waveform {
  flex: 1;
  position: relative;
  overflow: hidden;
  padding: var(--space-1);
  background: rgba(0, 0, 0, 0.2);
}

.clip-waveform canvas {
  width: 100%;
  height: 100%;
  display: block;
  image-rendering: crisp-edges;
}

/* Waveform colors based on clip type */
.daw-clip.audio .clip-waveform canvas {
  filter: brightness(1.1);
}

.daw-clip.midi .clip-waveform {
  background: rgba(0, 0, 0, 0.3);
}

.daw-clip.midi .clip-waveform canvas {
  opacity: 0.9;
}

/* Loading state for waveforms */
.clip-waveform.loading::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.1) 50%,
    transparent 100%);
  animation: waveformShimmer 1.5s infinite;
}

@keyframes waveformShimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
    
/* === TRANSPORT BAR === */
.daw-transport-bar {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  padding: var(--space-4) var(--space-5);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  margin-bottom: var(--space-4);
  box-shadow: var(--shadow-md);
  flex-wrap: wrap;
}

.transport-section {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.transport-btn {
  width: 44px;
  height: 44px;
  border: none;
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  color: var(--text-primary);
  font-size: var(--text-xl);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.transport-btn:hover {
  background: var(--glass-bg-strong);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.transport-btn:active {
  transform: translateY(0);
}

.transport-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-md), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.transport-display {
  padding: var(--space-2) var(--space-4);
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-base);
  color: var(--text-primary);
  min-width: 120px;
  text-align: center;
}

/* === MAIN CONTAINER: 3-COLUMN LAYOUT === */
.daw-main-container {
  display: grid;
  grid-template-columns: 1fr; /* Single column for responsiveness */
  grid-template-rows: auto 1fr auto auto; /* toolbar, timeline, track headers, master */
  gap: 0;
  height: auto;
  min-height: 600px;
  max-height: calc(100vh - 400px);
}

/* Responsive: Tablet landscape */
@media (max-width: 1280px) {
  .daw-main-container {
    grid-template-columns: 240px 1fr 280px;
  }
}

/* Responsive: Tablet portrait */
@media (max-width: 1024px) {
  .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr;
  }
  
  .daw-track-list {
    max-height: 250px;
    order: 1;
  }
  
  .daw-timeline-container {
    order: 2;
    min-height: 400px;
  }
  
  .daw-inspector {
    order: 3;
    max-height: 300px;
  }
}

/* Responsive: Mobile */
@media (max-width: 768px) {
  .daw-main-container {
    min-height: 400px;
    max-height: calc(100vh - 250px);
  }
  
  .daw-track-list {
    max-height: 200px;
  }
  
  .daw-inspector {
    max-height: 250px;
  }
}

/* === LEFT: TRACK LIST / MIXER COLUMN WITH BUBBLES === */
.daw-track-list {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden; /* CRITICAL */
  height: 100%; /* Fill grid cell */
  min-height: 0; /* Allow flex shrinking */
  max-height: none;
}

.daw-section-header {
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  border-radius: var(--radius-sm) var(--radius-sm) 0 0;
  font-weight: 800;
  font-size: var(--text-sm);
  color: var(--text-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.daw-track-list-scroll {
  flex: 0 1 auto;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  padding: var(--space-2);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  min-height: 0; /* CRITICAL for flexbox scrolling */
  max-height: calc(3 * 220px);
}

.daw-track-strip {
  padding: var(--space-4);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  background: var(--surface);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  gap: var(--space-3);
}

.daw-track-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-lg);
  transform: translateY(-2px);
}

.daw-track-strip.selected {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 12%, var(--surface)),
    var(--surface));
  border-color: var(--accent-primary);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 25%, transparent);
}

.daw-track-strip.recording {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--error) 12%, var(--surface)),
    var(--surface));
  border-color: var(--error);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-sm) color-mix(in oklab, var(--error) 30%, transparent);
  animation: recordPulse 1s ease-in-out infinite;
}

@keyframes recordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.track-strip-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
}

.track-strip-name {
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  cursor: text;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.track-strip-controls {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
}

.track-strip-btn {
  width: 28px;
  height: 28px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  font-size: var(--text-xs);
  font-weight: 800;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.track-strip-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: scale(1.05);
}

.track-strip-btn.active {
  background: var(--error);
  color: white;
  box-shadow: var(--shadow-sm);
}

.track-strip-btn.solo.active {
  background: var(--warning);
}

.track-strip-meters {
  display: flex;
  gap: var(--space-1);
  height: 32px;
  margin-bottom: var(--space-2);
}

.track-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-xs);
  position: relative;
  overflow: hidden;
}

.track-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 50ms linear;
  will-change: height;
}

.track-strip-fader {
  width: 100%;
  height: 80px;
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

/* === MASTER STRIP AS BUBBLE === */
.daw-master-strip {
  padding: var(--space-4);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  flex-shrink: 0; /* Don't shrink */
  position: static; /* Remove from track list */
  background: var(--surface-elevated);
  border-top: 2px solid var(--glass-border-strong);
}

.daw-master-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
  box-shadow: var(--shadow-lg);
}

.master-strip-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding-bottom: var(--space-2);
  border-bottom: 1px solid var(--glass-border);
}

.daw-meters {
  display: flex;
  gap: var(--space-2);
  height: 100px; /* Fixed height for consistency */
}

.daw-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.6);
  border-radius: var(--radius-sm);
  position: relative;
  overflow: hidden;
  border: 1px solid var(--glass-border);
}

.daw-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 30ms linear;
  box-shadow: 0 0 10px currentColor;
  will-change: height;
}

#masterFader {
  width: 100%;
  height: 100px; /* Match meters */
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

.daw-fader-label {
  text-align: center;
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  margin-top: var(--space-2);
}

/* === CENTER: TIMELINE / ARRANGEMENT VIEW AS BUBBLE === */
.daw-timeline-container {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  height: 100%; /* Fill grid cell */
  grid-row: 2;
  order: 2;
  min-height: 400px;
}

.daw-timeline-container:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-timeline-toolbar {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-wrap: wrap;
  flex-shrink: 0;
  overflow-x: auto;
  scrollbar-width: thin;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.toolbar-label {
  font-size: var(--text-xs);
  color: var(--text-tertiary);
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.tool-btn {
  width: 36px;
  height: 36px;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-lg);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.tool-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.tool-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-sm);
}

.tool-btn:active {
  transform: translateY(0);
}

/* === REGION / LOOP CONTROLS === */
.region-controls {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3) var(--space-4);
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
  margin-bottom: var(--space-4);
}

.region-controls:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-md);
}

.region-label {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.region-input-group {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.region-input {
  width: 80px;
  padding: var(--space-2) var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  text-align: center;
}

.region-input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

.region-btn {
  padding: var(--space-2) var(--space-4);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-xs);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.region-btn:hover {
  background: var(--glass-bg-strong);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
  color: var(--text-primary);
}

.region-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: var(--shadow-sm);
}

/* Loop region visual in timeline */
.daw-loop-region {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(124, 131, 255, 0.12);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 50;
  box-shadow: inset 0 0 20px rgba(124, 131, 255, 0.15);
}

.loop-region-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 12px;
  cursor: ew-resize;
  z-index: 60;
  pointer-events: auto;
  background: rgba(124, 131, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.loop-region-handle:hover {
  background: rgba(124, 131, 255, 0.3);
}

.loop-region-handle.left {
  left: -6px;
}

.loop-region-handle.right {
  right: -6px;
}

.loop-region-label {
  position: absolute;
  top: 4px;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--space-1) var(--space-2);
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--accent-primary);
  border-radius: var(--radius-xs);
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  pointer-events: none;
  white-space: nowrap;
  backdrop-filter: blur(8px);
}
    
/* === RULER + PLAYHEAD === */
.daw-ruler {
  position: relative;
  height: 48px;
  background: linear-gradient(180deg, var(--bg-secondary), var(--bg-tertiary));
  border-bottom: 2px solid var(--glass-border-strong);
  overflow: hidden;
  flex-shrink: 0;
}

.daw-ruler-markers {
  position: relative;
  height: 100%;
  width: var(--timeline-width, 100%);
  min-width: var(--timeline-width, 100%);
}

.daw-ruler-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 1px;
  background: rgba(255, 255, 255, 0.15);
}

.daw-ruler-marker.bar {
  width: 2px;
  background: rgba(255, 255, 255, 0.3);
}

.daw-ruler-label {
  position: absolute;
  top: 4px;
  left: 4px;
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  pointer-events: none;
}

.daw-playhead {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--error);
  pointer-events: none;
  z-index: 100;
  box-shadow: 0 0 12px var(--error);
}

.daw-playhead::before {
  content: '';
  position: absolute;
  top: -6px;
  left: -5px;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 8px solid var(--error);
}

.daw-loop-region {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(124, 131, 255, 0.15);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 50;
}

/* === ARRANGEMENT VIEW === */
.daw-arrangement-scroll {
  flex: 1;
  overflow: auto;
  background: var(--bg-primary);
  position: relative;
  scrollbar-width: thin;
  -webkit-overflow-scrolling: touch;
  min-height: 0; /* CRITICAL */
}

.daw-arrangement-scroll::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

.daw-arrangement-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
}

.daw-arrangement-scroll::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 85%, #fff), 
    color-mix(in oklab, var(--accent-secondary) 85%, #fff));
  border-radius: var(--radius-xs);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.daw-arrangement-grid {
  position: relative;
  width: var(--timeline-width, 3200px);
  min-width: var(--timeline-width, 3200px);
  min-height: 216px;
  background-image: 
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      transparent 1px,
      transparent 100px),
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.08) 0px,
      rgba(255, 255, 255, 0.08) 2px,
      transparent 2px,
      transparent 400px);
}

.loop-region-highlight {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(124, 131, 255, 0.08);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 5;
  display: none;
}

.loop-region-highlight.active {
  display: block;
}

/* === TRACK LANES === */
.daw-track-lane {
  position: relative;
  height: 72px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  transition: background var(--duration-fast) var(--ease-smooth);
  margin-bottom: 4px;
}

.daw-track-lane:hover {
  background: rgba(255, 255, 255, 0.02);
}

.daw-track-lane.selected {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--accent-primary) 8%, transparent),
    transparent);
}

.daw-track-lane.recording {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--error) 8%, transparent),
    transparent);
  animation: laneRecordPulse 1s ease-in-out infinite;
}

@keyframes laneRecordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

/* === TRACK HEADER IMPROVEMENTS === */
.track-header {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  padding: var(--space-4);
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  transition: all var(--duration-base) var(--ease-smooth);
}

.track-header:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-lg);
  transform: translateY(-1px);
}

.track-header-top {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.track-icon {
  width: 36px;
  height: 36px;
  display: grid;
  place-items: center;
  font-size: var(--text-xl);
  background: var(--glass-bg-strong);
  border-radius: var(--radius-sm);
  flex-shrink: 0;
}

.track-name {
  flex: 1;
  font-weight: 700;
  font-size: var(--text-base);
  color: var(--text-primary);
  outline: none;
  padding: var(--space-2);
  border-radius: var(--radius-xs);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.track-name:hover {
  background: var(--glass-bg);
}

.track-name:focus {
  background: var(--glass-bg-strong);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.track-controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
  gap: var(--space-2);
}

.track-mini-btn {
  padding: var(--space-2) var(--space-3);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-xs);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  white-space: nowrap;
}

.track-mini-btn:hover {
  background: var(--glass-bg-strong);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
  color: var(--text-primary);
  transform: translateY(-1px);
}

.track-mini-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: var(--shadow-sm);
}

.track-mini-btn.rec.active {
  background: var(--error);
  animation: recordPulse 1s ease-in-out infinite;
}

.track-volume-control {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.track-volume-slider {
  flex: 1;
}

.track-volume-value {
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-xs);
  color: var(--text-primary);
  min-width: 45px;
  text-align: right;
}
    
/* === AUDIO/MIDI CLIPS === */
.daw-clip {
  position: absolute;
  top: 4px;
  bottom: 4px;
  border-radius: var(--radius-sm);
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 60%, transparent),
    color-mix(in oklab, var(--accent-secondary) 50%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 70%, transparent);
  cursor: move;
  overflow: hidden;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
  display: flex;
  flex-direction: column;
}

.daw-clip:hover {
  border-color: var(--accent-primary);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  transform: translateY(-1px);
  z-index: 10;
}

.daw-clip.selected {
  border-color: var(--warning);
  box-shadow: 
    var(--shadow-md),
    0 0 16px color-mix(in oklab, var(--warning) 40%, transparent);
  z-index: 15;
}

.daw-clip.dragging {
  opacity: 0.7;
  cursor: grabbing;
  z-index: 100;
}

.clip-header {
  padding: var(--space-1) var(--space-2);
  background: rgba(0, 0, 0, 0.3);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.clip-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.clip-waveform {
  flex: 1;
  position: relative;
  overflow: hidden;
  padding: var(--space-1);
}

.clip-waveform canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.clip-resize-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 8px;
  cursor: ew-resize;
  background: rgba(255, 255, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.clip-resize-handle.left {
  left: 0;
}

.clip-resize-handle.right {
  right: 0;
}

.clip-resize-handle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.clip-fade-handle {
  position: absolute;
  top: 0;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--text-primary);
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.daw-clip:hover .clip-fade-handle {
  opacity: 1;
}

.clip-fade-handle.fade-in {
  left: 4px;
  top: 4px;
}

.clip-fade-handle.fade-out {
  right: 4px;
  top: 4px;
}

/* === RIGHT: INSPECTOR PANEL AS BUBBLE === */
.daw-inspector {
  display: none;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  height: 100%; /* Fill grid cell */
  min-height: 0;
}

.daw-inspector:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-inspector-tabs {
  display: flex;
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  padding: var(--space-2);
  gap: var(--space-2);
  overflow-x: auto;
  scrollbar-width: thin;
}

.inspector-tab {
  flex: 1;
  padding: var(--space-3);
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  background: transparent;
  color: var(--text-tertiary);
  font-weight: 700;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.inspector-tab:hover {
  color: var(--text-primary);
  background: var(--glass-bg-strong);
  border-color: var(--glass-border);
}

.inspector-tab.active {
  color: var(--bg-primary);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  border-color: transparent;
  box-shadow: var(--shadow-sm);
}

.daw-inspector-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-5);
  -webkit-overflow-scrolling: touch;
  min-height: 0; /* CRITICAL */
}

.inspector-section {
  margin-bottom: var(--space-6);
  padding: var(--space-4);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
}

.inspector-section:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
}

.inspector-section-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 2px solid var(--glass-border);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.inspector-param {
  margin-bottom: var(--space-3);
}

.inspector-param-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  font-weight: 600;
}

.inspector-param-value {
  font-family: var(--font-mono);
  font-weight: 700;
  color: var(--text-primary);
}

.inspector-param input[type="range"] {
  width: 100%;
}

.inspector-param select,
.inspector-param input[type="text"],
.inspector-param input[type="number"] {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-size: var(--text-sm);
}

/* === FX CHAIN PANEL === */
.fx-chain-panel {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-height: 50vh;
  background: var(--surface-elevated);
  border-top: 2px solid var(--glass-border-strong);
  box-shadow: var(--shadow-2xl);
  backdrop-filter: blur(32px) saturate(150%);
  z-index: 100;
  display: none;
  flex-direction: column;
  overflow: hidden;
}

.fx-chain-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-4) var(--space-5);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
}

.fx-chain-slots {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-4);
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--space-4);
  -webkit-overflow-scrolling: touch;
}

.fx-chain-footer {
  padding: var(--space-3) var(--space-5);
  background: var(--glass-bg);
  border-top: 1px solid var(--glass-border);
  flex-shrink: 0;
}

/* === DAW STATUS BAR === */
.daw-status-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-top: 1px solid var(--glass-border);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  flex-wrap: wrap;
  gap: var(--space-3);
  margin-top: var(--space-4);
}

/* === FLOATING ADD TRACK BUTTON (MOBILE) === */
.daw-fab {
  position: fixed;
  bottom: calc(1.5rem + var(--inset-bottom));
  right: calc(1.5rem + var(--inset-right));
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  font-size: var(--text-2xl);
  border: none;
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  z-index: 999;
  cursor: pointer;
  display: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

.daw-fab:hover {
  transform: scale(1.05) rotate(90deg);
  box-shadow: 
    var(--shadow-xl),
    var(--glow-lg) color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

.daw-fab:active {
  transform: scale(0.95);
}

@media (max-width: 1024px) {
  .daw-fab {
    display: grid;
    place-items: center;
  }
}

    .track-fx-panel {
  padding: var(--space-3);
  background: var(--glass-bg);
  border-top: 1px solid var(--glass-border);
  margin-top: var(--space-2);
}

.fx-slots-inline {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  margin-top: var(--space-2);
}

.fx-unit-mini {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-2) var(--space-3);
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  font-size: var(--text-xs);
}

.fx-unit-mini .fx-toggle {
  width: 40px;
  height: 20px;
}

.fx-unit-mini .fx-remove-btn {
  width: 20px;
  height: 20px;
  padding: 0;
  background: transparent;
  border: none;
  color: var(--error);
  cursor: pointer;
  font-size: 14px;
}

/* === IMPROVED REGION CONTROLS (NO OVERLAP) === */

.audio-region {
  position: absolute;
  height: 90px; /* Increased height */
  top: 15px;
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 40%, transparent),
    color-mix(in oklab, var(--accent-secondary) 30%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 60%, transparent);
  border-radius: var(--radius-sm);
  cursor: move;
  overflow: visible; /* Changed from hidden */
  display: flex;
  flex-direction: column;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-md);
  user-select: none;
}

.region-header {
  position: sticky;
  top: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-2) var(--space-3);
  background: rgba(0,0,0,.9);
  backdrop-filter: blur(12px);
  z-index: 200;
  border-radius: var(--radius-sm) var(--radius-sm) 0 0;
  gap: var(--space-2);
  min-height: 32px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.region-actions {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
  z-index: 201;
}

.region-action-btn {
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  border: none;
  border-radius: var(--radius-xs);
  background: rgba(255,255,255,0.1);
  color: #fff;
  cursor: pointer;
  font-size: 14px;
  display: grid;
  place-items: center;
  transition: all var(--duration-fast) var(--ease-smooth);
  padding: 0;
  backdrop-filter: blur(4px);
}

.region-action-btn:hover,
.region-action-btn:active {
  background: rgba(255,255,255,0.2);
  transform: scale(1.15);
}

.region-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0,0,0,.8);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}
    
/* === MOBILE/TABLET TRANSPORT ADJUSTMENTS === */
@media (max-width: 768px) {
  .daw-transport-bar {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  .transport-btn {
    width: 40px;
    height: 40px;
    font-size: var(--text-lg);
  }
  
  .transport-display {
    min-width: 100px;
    font-size: var(--text-sm);
    padding: var(--space-1) var(--space-3);
  }
}

/* === MOBILE PORTRAIT SPECIFIC === */
@media (max-width: 768px) and (orientation: portrait) {
  .daw-track-strip {
    padding: var(--space-2);
  }
  
  .track-strip-name {
    font-size: var(--text-xs);
  }
  
  .track-strip-btn {
    width: 24px;
    height: 24px;
  }
  
  .track-strip-meters {
    height: 24px;
  }
  
  .track-strip-fader {
    height: 60px;
  }
  
  .daw-meters {
    height: 80px;
  }
  
  #masterFader {
    height: 80px;
  }
  
  .daw-timeline-toolbar {
    padding: var(--space-2);
    gap: var(--space-2);
  }
  
  .tool-btn {
    width: 32px;
    height: 32px;
    font-size: var(--text-base);
  }
  
  .daw-ruler {
    height: 40px;
  }
  
  .daw-track-lane {
    height: 60px;
  }
  
  .daw-clip {
    top: 2px;
    bottom: 2px;
  }
  
  .clip-header {
    padding: 2px var(--space-1);
  }
  
  .clip-name {
    font-size: 10px;
  }
}

/* === MOBILE LANDSCAPE SPECIFIC === */
@media (max-width: 768px) and (orientation: landscape) {
  .daw-track-strip {
    padding: var(--space-2);
  }
  
  .track-strip-name {
    font-size: var(--text-xs);
  }
  
  .track-strip-fader {
    height: 60px;
  }
  
  .daw-track-lane {
    height: 70px;
  }
}
    
    /* -------- Responsive Breakpoints -------- */
    @media (max-width: 1024px){
      .transport{
        grid-template-columns: 1fr;
        gap: var(--space-4);
      }
      
      .transport-params{
        grid-auto-flow: row;
      }
    }
    
    @media (max-width: 768px){
      :root{
        --space-4: 0.75rem;
        --space-5: 1rem;
        --space-6: 1.25rem;
      }
      
      body{
        padding: var(--space-2);
      }
      
      .app{
        padding: var(--space-3);
      }
      
      header{
        grid-template-columns: 1fr;
        gap: var(--space-3);
      }
      
      .genre-selector{
        justify-content: flex-start;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        flex-wrap: nowrap;
      }
      
      .genre-selector::-webkit-scrollbar{
        display: none;
      }
      
      .preset-grid{
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      }
      
      #mixerGrid{
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      }
      
      #fxGrid{
        grid-template-columns: 1fr;
      }
      
      .grid-2,
      .grid-3,
      .grid-4{
        grid-template-columns: 1fr;
      }

      .toast-container {
        bottom: calc(var(--space-8) + var(--inset-bottom));
        transform: translateX(-50%);
      }
      
      .toast {
        font-size: var(--text-xs);
        padding: var(--space-2) var(--space-3);
        max-width: 90vw;
      }

      .daw-arrangement-scroll {
        overflow-x: auto;
        overscroll-behavior: contain;
        overflow-y: hidden;
        scrollbar-width: thin;
      }
      
      .multitrack-wrapper {
        touch-action: pan-x pan-y;
        -webkit-overflow-scrolling: touch;
      }

      .multitrack-toolbar {
        padding: var(--space-3);
        gap: var(--space-2);
        grid-row: 1;
        order: 1;
      }
    
      .toolbar-section {
        padding-right: var(--space-2);
      }
    
      .toolbar-section .btn,
      .toolbar-section .zoom-btn {
        padding: var(--space-2) var(--space-3);
      }
      
      .track-canvas-area {
        touch-action: pan-x;
      }
      
      .audio-region {
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
        height: 100px;
      }
      
      .audio-region.dragging {
        opacity: 0.8;
        pointer-events: none;
      }

      .timeline-playhead {
        width: 3px;
        box-shadow: 0 0 15px var(--error);
      }
    
      .timeline-playhead::before {
        border-width: 8px;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 10px solid var(--error);
      }
      
      /* Larger touch targets on mobile */
      .track-mini-btn {
        min-height: 44px;
        min-width: 44px;
        font-size: var(--text-base);
      }

      .region-action-btn {
        width: 36px;
        height: 36px;
        min-width: 36px;
        min-height: 36px;
        font-size: 16px;
      }
      
      .region-actions {
        gap: var(--space-2);
      }
      
      .region-header {
        padding: var(--space-3);
        gap: var(--space-3);
      }
    
      /* Ensure buttons work during drag */
      .audio-region.dragging .region-action-btn {
        pointer-events: none;
      }
      
      .audio-region:not(.dragging) .region-action-btn {
        pointer-events: auto;
      }
    
      
      /* Prevent accidental scrolling during region drag */
      body.dragging-region {
        overflow: hidden;
        touch-action: none;
      }
    }
    
    @media (max-width: 480px){
      .app{
        padding: var(--space-2);
        border-radius: var(--radius-xl);
      }
      
      .panel{
        padding: var(--space-4);
      }
      
      .modal{
        padding: var(--space-5);
      }
      
      .toast-container{
        left: var(--space-2);
        right: var(--space-2);
        max-width: none;
      }
      
      .transport-controls{
        justify-content: center;
      }
      
      .seq-row{
        grid-template-columns: 140px repeat(16, 1fr);
      }
    }

    /* --- DAW Transport Responsive --- */
    @media (max-width: 768px){
      .daw-transport-bar {
        flex-wrap: wrap;
        justify-content: center;
        gap: var(--space-2);
        padding: var(--space-3);
      }
    
      .daw-transport-bar .transport-section {
        justify-content: center;
        flex: 1 1 100%;
      }

      .multitrack-toolbar .toolbar-label {
        display: none; /* Hide labels, keep values */
      }
    
      .daw-timeline-container {
        min-height: 250px;
      }
    
      .daw-track-list {
        max-height: 150px;
      }
    
      .daw-master-strip {
        grid-template-columns: 1fr;
      }
    
      .daw-transport-bar input[type="number"],
      .daw-transport-bar select {
        font-size: var(--text-sm);
        padding: var(--space-2);
        width: 70px;
      }
    
      .transport-btn {
        width: 38px;
        height: 38px;
        font-size: 1.2rem;
      }
    
      .transport-display {
        min-width: 70px;
        font-size: var(--text-xs);
      }
    }
    
    @media (hover: none) and (pointer: coarse){
      .transport-btn {
        width: 48px;
        height: 48px;
      }
    }

    /* --- DAW Main Container Responsive --- */
    @media (max-width: 1024px){
      .daw-main-container {
        grid-template-columns: 200px 1fr 240px;
      }
    }
    
    /* === MOBILE-OPTIMIZED MULTITRACK === */

@media (max-width: 900px) {
  /* Stack everything vertically */
  .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr auto auto;
    height: auto;
    max-height: none;
    gap: var(--space-3);
  }

  /* Toolbar: wrap controls, no collapse */
  .multitrack-toolbar {
    padding: var(--space-3);
    gap: var(--space-2);
  }

  .multitrack-toolbar .toolbar-section {
    flex: 1 1 100%;
    border-right: none;
    border-bottom: 1px solid var(--glass-border);
    padding-bottom: var(--space-2);
    margin-bottom: var(--space-2);
  }

  .multitrack-toolbar .toolbar-section:last-child {
    border-bottom: none;
  }

  /* Timeline: full width, scrollable */
  .daw-timeline-container {
    min-height: 300px;
    max-height: 50vh;
  }

  .multitrack-wrapper {
    touch-action: pan-x pan-y;
    -webkit-overflow-scrolling: touch;
  }

  /* Track list: collapsible accordion */
  .daw-track-list {
    max-height: 200px;
    background: var(--surface);
  }

  .daw-section-header {
    cursor: pointer;
    user-select: none;
  }

  .daw-section-header::after {
    content: '▼';
    margin-left: auto;
    transition: transform 0.3s;
  }

  .daw-track-list.collapsed .daw-section-header::after {
    transform: rotate(-90deg);
  }

  .daw-track-list.collapsed .daw-track-list-scroll {
    display: none;
  }

  /* Master strip: full width, always visible */
  .daw-master-strip {
    padding: var(--space-4);
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: var(--space-3);
  }

  /* Larger touch targets */
  .transport-btn,
  .track-strip-btn,
  .region-action-btn {
    min-width: 44px;
    min-height: 44px;
  }

  /* Region controls: prevent overlap */
  .region-header {
    flex-wrap: nowrap;
    padding: var(--space-2);
    justify-content: space-between;
  }

  .region-actions {
    flex-shrink: 0;
    gap: var(--space-1);
  }

  .region-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 120px;
  }
}

    
    /* -------- Print Styles -------- */
    @media print{
      body{
        background: white;
        color: black;
      }
      
      .app::before,
      .transport,
      .tabs,
      .header-actions,
      .btn,
      button{
        display: none !important;
      }
      
      .panel{
        break-inside: avoid;
        page-break-inside: avoid;
      }
    }
    
    /* -------- High Contrast Mode -------- */
    @media (prefers-contrast: high){
      :root{
        --glass-border: rgba(255,255,255,.3);
        --glass-border-strong: rgba(255,255,255,.5);
      }
      
      .btn-primary,
      .tab.active{
        border: 2px solid var(--text-primary);
      }
    }
    
    /* -------- Reduced Motion -------- */
    @media (prefers-reduced-motion: reduce){
      *,
      *::before,
      *::after{
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      
      .app::before{
        animation: none;
      }
      
      .progress-fill::before{
        animation: none;
      }
    }
    
    /* -------- Focus Visible Enhancement -------- */
    @supports selector(:focus-visible){
      *:focus{
        outline: none;
      }
      
      *:focus-visible{
        outline: var(--ring-w) solid var(--ring);
        outline-offset: var(--ring-offset);
      }
    }
    
    /* -------- Additional Harmony Tab Styles -------- */
    #tab-harmony label{
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: var(--text-sm);
    }
    
    #tab-harmony select{
      min-width: 120px;
    }
    
    /* -------- Optimize for Touch Devices -------- */
    @media (hover: none) and (pointer: coarse){
      .btn,
      .chip,
      .preset,
      .step,
      .seq-icon,
      .channel-btn,
      .fx-toggle{
        min-height: 44px;
        min-width: 44px;
      }
      
      .tab{
        padding: var(--space-4) var(--space-6);
      }
      
      .genre-btn{
        padding: var(--space-3) var(--space-5);
      }
    }
    
    /* -------- Dark Mode Enhancements -------- */
    @media (prefers-color-scheme: dark){
      body{
        color-scheme: dark;
      }
    }
    
    /* -------- Safari-specific Fixes -------- */
    @supports (-webkit-touch-callout: none){
      .app{
        -webkit-backdrop-filter: blur(32px) saturate(140%);
      }
      
      .transport,
      .tabs,
      header{
        -webkit-backdrop-filter: blur(24px) saturate(150%);
      }
    }
    
    /* -------- Custom Properties for Animations -------- */
    @property --rotate{
      syntax: '<angle>';
      initial-value: 0deg;
      inherits: false;
    }
    
    @property --shimmer-x{
      syntax: '<percentage>';
      initial-value: -100%;
      inherits: false;
    }

    /* ==================== MULTITRACK FIX BUNDLE ==================== */

    /* --- 1) Region Context Menu: real right-click menu look --- */
    
    .region-context-menu {
      position: fixed;
      min-width: 220px;
      max-width: 260px;
      padding: 4px 0;
      background: var(--surface-elevated, rgba(9, 9, 11, 0.98));
      border-radius: var(--radius-md, 8px);
      border: 1px solid var(--glass-border-strong, rgba(255, 255, 255, 0.16));
      box-shadow:
        0 14px 40px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      z-index: 10000;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      font-size: var(--text-sm, 0.875rem);
      color: var(--text-primary, #f9fafb);
      animation: contextMenuFadeIn 0.12s var(--ease-smooth, ease-out);
    }
    
    .region-context-item {
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    
    .region-context-item::before {
      /* ensures emoji / icon column lines up nicely */
      content: '';
      width: 1.2em;
      flex: 0 0 auto;
    }
    
    .region-context-item:hover {
      background: color-mix(in oklab,
        var(--accent-primary, #4f46e5) 12%,
        transparent);
    }
    
    .region-context-item.danger {
      color: #fecaca;
    }
    
    .region-context-item.danger:hover {
      background: color-mix(in oklab,
        #ef4444 18%,
        transparent);
      color: #fee2e2;
    }
    
    @keyframes contextMenuFadeIn {
      from {
        opacity: 0;
        transform: translateY(-4px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    /* --- 2) Per-Track FX panel + “Add FX” menu styling --- */
    
    /* Inline mini FX summary inside each track header */
    .track-fx-panel {
      margin-top: var(--space-2, 0.5rem);
      padding: var(--space-3, 0.75rem);
      border-radius: var(--radius-md, 8px);
      border: 1px dashed var(--glass-border, rgba(148, 163, 184, 0.35));
      background: color-mix(in oklab,
        var(--surface, #020617) 70%,
        rgba(148, 163, 184, 0.12));
      display: flex;
      flex-direction: column;
      gap: var(--space-2, 0.5rem);
    }
    
    .track-fx-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: var(--text-xs, 0.75rem);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary, #9ca3af);
    }
    
    .fx-chain-mini {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2, 0.5rem);
      flex-wrap: wrap;
    }
    
    .fx-label-mini {
      font-size: var(--text-xs, 0.75rem);
      color: var(--text-secondary, #9ca3af);
    }
    
    .fx-slots-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .fx-chip {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .fx-chip.disabled {
      opacity: 0.5;
    }
    
    /* The little “+ Add FX” pop-up menu – now pops ABOVE the header */
    .fx-chain-header {
      position: relative; /* anchor for the menu */
    }
    
    .fx-add-menu {
      position: absolute;
      bottom: 100%;       /* sit ABOVE the header */
      right: 0;
      top: auto;
      left: auto;
      margin-bottom: 8px;
      margin-top: 0;
      min-width: 220px;
      max-width: 260px;
      padding: 6px 0;
      background: var(--surface-elevated, rgba(9, 9, 11, 0.98));
      border-radius: var(--radius-md, 8px);
      border: 1px solid var(--glass-border-strong, rgba(148, 163, 184, 0.6));
      box-shadow:
        0 18px 50px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      z-index: 1200;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    
    .fx-add-menu h4 {
      margin: 0;
      padding: 6px 12px;
      font-size: var(--text-xs, 0.75rem);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-tertiary, #6b7280);
      border-bottom: 1px solid rgba(31, 41, 55, 0.8);
    }
    
    .fx-add-menu button {
      width: 100%;
      border: none;
      background: transparent;
      text-align: left;
      padding: 6px 12px;
      font-size: var(--text-sm, 0.875rem);
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: var(--text-primary, #e5e7eb);
    }
    
    .fx-add-menu button:hover {
      background: color-mix(in oklab,
        var(--accent-primary, #4f46e5) 12%,
        transparent);
    }
    
    /* Ensure the FX header controls line up cleanly in a track header */
    .track-header {
      position: relative;
    }
    
    /* --- 3) Track meters: slim bar, not full column --- */
    
    .track-meters {
      display: flex;
      align-items: center;
      gap: 4px;
      height: 22px; /* fixed slim strip */
    }
    
    .track-meter {
      position: relative;
      flex: 1;
      height: 100%;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      overflow: hidden;
      border: 1px solid rgba(30, 64, 175, 0.7);
    }
    
    .track-meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0; /* JS will animate this */
      background: linear-gradient(
        180deg,
        #22c55e,
        #f97316 60%,
        #ef4444 100%
      );
      transform-origin: bottom;
      transition: height 0.06s linear;
    }
    
    /* Keep meters from stretching if header grows vertically */
    .track-head {
      align-items: center;
    }
    
    /* --- 4) Timeline focus & scroll behaviour --- */
    
    /* Let the whole DAW area breathe and make the timeline the star */
    .daw-main-container {
      max-height: none;         /* override earlier limit */
      height: auto;
    }
    
    /* Timeline area should feel like the focal point */
    .daw-timeline-container {
      display: flex;
      flex-direction: column;
      gap: var(--space-3, 0.75rem);
      min-height: 420px;        /* visible area for lanes + ruler */
    }
    
    /* Arrangement scroll: at least 3 lanes tall, scrolls for more */
    .daw-arrangement-scroll {
      flex: 1;
      min-height: 240px;        /* ~3 x 80px lanes */
      max-height: none;
      overflow-x: auto;
      overflow-y: auto;         /* allows vertical scroll when many tracks */
    }
    
    /* Track lanes: keep a solid height so 3 are clearly visible */
    .daw-track-lane {
      min-height: 80px;
      max-height: 120px;
    }
    
    /* Track list: show up to ~3 track headers before scrolling */
    .daw-track-list-scroll {
      max-height: calc(3 * 220px);
    }

    /* === Multitrack drag-scroll behaviour === */
    .daw-arrangement-scroll {
      overflow-x: auto;
      overflow-y: auto;
      touch-action: pan-x pan-y;
      cursor: grab;
    }
    
    .daw-arrangement-scroll.drag-scroll-active {
      cursor: grabbing;
    }

    /* Make FX chain panel & its Add FX menu float above the footer */
    .fx-chain-panel {
      z-index: 600;      /* above footer (no z-index) but below modal-backdrop (999) */
      overflow: visible; /* let the Add FX menu pop outside the panel */
    }
    
    /* Ensure the FX Add dropdown itself is always above app chrome */
    #fxAddMenu {
      z-index: 1200;
    }

  </style>
</head>
<body>
  <div id="splashOverlay">
    <div class="splash-inner">
      <div class="splash-logo">8-Beat Studio</div>
      <div class="splash-message" id="splashMessage">
        Initializing engine…
      </div>
      <div class="splash-progress">
        <div class="splash-progress-bar" id="splashBar"></div>
      </div>
      <div class="splash-sub">
        This should only take a moment ✨
      </div>
    </div>
  </div>
  <!-- Sidebar Toggle Button -->
  <button class="sidebar-toggle" id="sidebarToggle" aria-label="Menu">
    🧭
  </button>
  
  <!-- Sidebar Backdrop -->
  <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
  
  <!-- Sidebar Navigation -->
  <nav class="sidebar-nav" id="sidebarNav">
    <div class="sidebar-section">
      <div class="sidebar-section-title">...</div>
      <div class="sidebar-tabs" id="sidebarTabs">
        <button class="sidebar-tab active" data-tab="generate">🎲 Generate</button>
        <button class="sidebar-tab active" data-tab="sequencer">🎹 Sequencer</button>
        <button class="sidebar-tab" data-tab="mixer">🎚️ Mixer</button>
        <button class="sidebar-tab" data-tab="fx">🎛️ Effects</button>
        <button class="sidebar-tab" data-tab="harmony">🎼 Harmony</button>
        <button class="sidebar-tab" data-tab="multitrack">🎙️ Multitrack</button>
        <!--<button class="sidebar-tab" data-tab="samples">📂 Samples</button> -->
        <button id="unlockProBtn">🔓 Unlock Pro</button>

        <div id="unlockModal" class="hidden">
          <div class="pro-modal-inner">
            <h2>🔓 Unlock 8-Beat Studio Pro</h2>
            <p>Paste your license key to unlock all features.</p>
            <input id="licenseInput" type="text" placeholder="8BEAT-XXXX-XXXX-XXXX">
            <div class="modal-actions">
              <div>
                <style>.pp-58FUHY8RYFPP2{text-align:center;border:none;border-radius:0.25rem;min-width:11.625rem;padding:0 2rem;height:2.625rem;font-weight:bold;background-color:#FFD140;color:#000000;font-family:"Helvetica Neue",Arial,sans-serif;font-size:1rem;line-height:1.25rem;cursor:pointer;}</style>
                <form action="https://www.paypal.com/ncp/payment/58FUHY8RYFPP2" method="post" target="_blank" style="display:inline-grid;justify-items:center;align-content:start;gap:0.5rem;">
                  <input class="pp-58FUHY8RYFPP2" type="submit" value="Buy Now" />
                  <img src=https://www.paypalobjects.com/images/Debit_Credit_APM.svg alt="cards" />
                  <section style="font-size: 0.75rem;"> Powered by <img src="https://www.paypalobjects.com/paypal-ui/logos/svg/paypal-wordmark-color.svg" alt="paypal" style="height:0.875rem;vertical-align:middle;"/></section>
                </form>
              </div>
              <button id="confirmLicenseBtn" class="btn btn-primary">Confirm</button>
              <button id="cancelLicenseBtn" class="btn btn-secondary">Cancel</button>
            </div>
            <p id="licenseStatus" class="status"></p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="sidebar-section">
      <div class="sidebar-section-title">🎨 Genre Presets</div>
      <div class="sidebar-presets" id="sidebarPresets">
        <!-- Presets will be rendered here by JS -->
      </div>
    </div>
  </nav>
  <div class="app">
    <header>
      <div class="logo-section">
        <div class="logo">🎹</div>
        <div>
          <h1>8-Beat Studio</h1>
          <div class="tagline">Fun With Noise</div>
        </div>
      </div>
      
      <div class="genre-selector" id="genreSelector">
        <button class="genre-btn active" data-genre="lofi">Lo-Fi</button>
        <button class="genre-btn" data-genre="hiphop">Hip-Hop</button>
        <button class="genre-btn" data-genre="postpunk">Post-Punk</button>
        <button class="genre-btn" data-genre="rnb">R&B</button>
        <button class="genre-btn" data-genre="ambient">Ambient</button>
        <button class="genre-btn" data-genre="dazecore">Dazecore</button>
      </div>
      
      <div class="header-actions">
        <button class="btn btn-secondary btn-sm" id="installBtn" hidden>📱 Install</button>
        <button class="btn btn-secondary btn-sm" id="vibeBtn">🌈 Vibe: Moon</button>
      </div>
    </header>
    
    <div class="transport">
      <div class="transport-controls">
        <button class="btn btn-primary" id="playBtn">▶️ Play</button>
        <button class="btn btn-secondary" id="stopBtn">⏹️ Stop</button>
        <button class="btn btn-secondary" id="exportBtn">🎧 DJ (Live Export)</button>
      </div>
      
      <div class="progress-area">
        <div class="time-info">
          <span class="time-display" id="timeDisplay">00:00</span>
          <span id="durationDisplay">/ 05:00</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      
      <div class="transport-params">
        <div class="param-control">
          <div class="param-label">
            <span>BPM</span>
            <span class="param-value" id="bpmValue">120</span>
          </div>
          <input type="range" id="bpmSlider" min="60" max="200" value="120">
        </div>
        <div class="param-control">
          <div class="param-label">
            <span>Swing</span>
            <span class="param-value" id="swingValue">50%</span>
          </div>
          <input type="range" id="swingSlider" min="0" max="100" value="50">
        </div>
      </div>
      <div class="flex" style="gap: var(--space-2);">
        <button class="btn btn-secondary btn-sm" id="metronomeBtn">
          🥁 Click: Off
        </button>
        <button class="btn btn-secondary btn-sm" id="countInBtn">
          ⏱️ Count: 1 bar
        </button>
      </div>
    </div>
    
    <section class="section active" id="tab-generate">
      <div class="panel">
        <div class="visualizer" id="visualizer">
          <div class="viz-overlay" id="vizOverlay">Generate & Press Play</div>
        </div>
      </div>
      
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">⚙️ Project Settings</div>
          </div>
          
          <div class="grid grid-3 mb-3">
            <div class="param-control">
              <div class="param-label">
                <span>Duration</span>
                <span class="param-value" id="durValue">5 min</span>
              </div>
              <input type="range" id="durSlider" min="1" max="20" value="5">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Complexity</span>
                <span class="param-value" id="complexValue">Medium</span>
              </div>
              <input type="range" id="complexSlider" min="1" max="3" value="2">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Humanize</span>
                <span class="param-value" id="humanValue">10ms</span>
              </div>
              <input type="range" id="humanSlider" min="0" max="30" value="10">
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="generateBtn">🎲 Generate Beat</button>
            <button class="btn btn-primary" id="generateRhythmBtn">🥁 Generate Rhythm</button>
            <button class="btn btn-secondary" id="randomVelBtn">🎯 Random Velocity</button>
            <button class="btn btn-secondary" id="randomProbBtn">🎲 Random Prob</button>
            <button class="btn btn-ghost" id="clearBtn">🧹 Clear</button>
          </div>
          
          <!-- NEW: AI Generation Section -->
          <div class="panel-header" style="margin-top: var(--space-6);">
            <div class="panel-title">🤖 AI Beat Generator</div>
          </div>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); margin-bottom: var(--space-3);">
            <div style="font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6;">
              AI analyzes your current pattern and creates intelligent variations using music theory and production techniques.
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="aiVariationBtn">
              🤖 AI Drum Variation
            </button>
            <button class="btn btn-primary" id="aiMelodicBtn">
              🎹 AI Melodic Variation
            </button>
          </div>
          
          <div class="panel-header" style="margin-top: var(--space-4);">
            <div class="panel-title">Groove Templates</div>
          </div>
          
          <div class="grid grid-4">
            <button class="preset groove-template-btn" data-template="shuffle">
              <div class="preset-icon">🎵</div>
              <div class="preset-name">Shuffle</div>
            </button>
            <button class="preset groove-template-btn" data-template="halfTime">
              <div class="preset-icon">🐌</div>
              <div class="preset-name">Half-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="doubleTime">
              <div class="preset-icon">⚡</div>
              <div class="preset-name">Double-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="breakbeat">
              <div class="preset-icon">💥</div>
              <div class="preset-name">Breakbeat</div>
            </button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">💾 Projects</div>
          </div>
          
          <div class="flex-col">
            <div class="flex">
              <button class="btn btn-success" id="saveBtn">💾 Save Project</button>
              <button class="btn btn-secondary" id="loadBtn">📂 Load Project</button>
            </div>
            <div class="flex">
              <input type="text" id="projectName" placeholder="Project Name" 
                style="flex:1; padding:10px; background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:var(--radius-sm); color:var(--text-primary); font-family:inherit">
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-sequencer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎹 Pattern Sequencer</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="lenDecBtn">− Length</button>
            <button class="btn btn-secondary btn-sm" id="lenIncBtn">+ Length</button>
            <select id="resSelect">
              <option value="16n" selected>1/16</option>
              <option value="8n">1/8</option>
              <option value="32n">1/32</option>
            </select>
            <button class="btn btn-secondary btn-sm" id="euclidBtn">∷ Euclidean</button>
            <button class="btn btn-secondary btn-sm" id="ghostBtn">👻 Ghost Notes</button>
          </div>
        </div>
        
        <div class="sequencer">
          <div class="seq-grid" id="seqGrid"></div>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-mixer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎚️ Channel Mixer</div>
        </div>
        <div class="grid grid-4" id="mixerGrid"></div>
      </div>
      
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎛️ Master Bus</div>
        </div>
        
        <div class="grid grid-3">
          <div class="param-control">
            <div class="param-label">
              <span>Master Volume</span>
              <span class="param-value" id="masterVolValue">0dB</span>
            </div>
            <input type="range" id="masterVolSlider" min="-40" max="10" value="0">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Tape Saturation</span>
              <span class="param-value" id="tapeValue">25%</span>
            </div>
            <input type="range" id="tapeSlider" min="0" max="100" value="25">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Vinyl Noise</span>
              <span class="param-value" id="vinylValue">15%</span>
            </div>
            <input type="range" id="vinylSlider" min="0" max="100" value="15">
          </div>
        </div>
        
        <div class="grid grid-3 mt-3">
          <div class="param-control">
            <div class="param-label">
              <span>Low Cut</span>
              <span class="param-value" id="lowCutValue">30Hz</span>
            </div>
            <input type="range" id="lowCutSlider" min="20" max="200" value="30">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>High Cut</span>
              <span class="param-value" id="highCutValue">16kHz</span>
            </div>
            <input type="range" id="highCutSlider" min="4000" max="20000" value="16000">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Compressor</span>
              <span class="param-value" id="compValue">-18dB</span>
            </div>
            <input type="range" id="compSlider" min="-40" max="0" value="-18">
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🤖 AI Mixing & Mastering</div>
          <button class="btn btn-secondary btn-sm" id="toggleAIMixingBtn">
            <span id="aiMixingStatus">Enable AI</span>
          </button>
        </div>
        
        <div class="grid grid-2" style="margin-bottom: var(--space-4);">
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoGainCheckbox" checked>
            <span style="font-weight: 600;">Auto Gain Staging</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoPanCheckbox" checked>
            <span style="font-weight: 600;">Auto Panning</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoEQCheckbox" checked>
            <span style="font-weight: 600;">Auto EQ</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoCompCheckbox" checked>
            <span style="font-weight: 600;">Auto Compression</span>
          </label>
        </div>
        
        <button class="btn btn-primary" id="applyAIMixBtn" disabled>
          🎚️ Apply AI Mix
        </button>
        
        <div class="panel-header" style="margin-top: var(--space-6);">
          <div class="panel-title">Mastering Presets</div>
        </div>
        
        <div class="grid grid-4">
          <button class="preset" data-master-preset="gentle">
            <div class="preset-icon">🌙</div>
            <div class="preset-name">Gentle</div>
          </button>
          <button class="preset" data-master-preset="modern">
            <div class="preset-icon">🎧</div>
            <div class="preset-name">Modern</div>
          </button>
          <button class="preset" data-master-preset="aggressive">
            <div class="preset-icon">🔥</div>
            <div class="preset-name">Aggressive</div>
          </button>
          <button class="preset" data-master-preset="lofi">
            <div class="preset-icon">📻</div>
            <div class="preset-name">Lo-Fi</div>
          </button>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-fx">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">🎛️ Effects Rack</div>
        </div>
        <div class="grid grid-3" id="fxGrid"></div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-harmony">
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">🎼 Key & Scale</div>
          </div>
          
          <div class="flex mb-3">
            <label style="display:flex; align-items:center; gap:8px">
              Key: <select id="keySelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Scale: <select id="scaleSelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Octave: <select id="octaveSelect"></select>
            </label>
          </div>
          
          <div class="panel-header">
            <div class="panel-title">Available Chords</div>
            <button class="btn btn-secondary btn-sm" id="genProgBtn">↻ Generate</button>
          </div>
          <div class="chips" id="chordChips"></div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">🎵 Chord Progression</div>
            <button class="btn btn-ghost btn-sm" id="clearProgBtn">Clear</button>
          </div>
          
          <div class="chips mb-3" id="progressionChips"></div>
          
          <div class="panel-header">
            <div class="panel-title">Progression Templates</div>
          </div>
          <div class="grid grid-4">
            <button class="preset" data-prog="ii-v-i">
              <div class="preset-icon">🎷</div>
              <div class="preset-name">II-V-I</div>
            </button>
            <button class="preset" data-prog="lofi">
              <div class="preset-icon">😌</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-prog="neosoul">
              <div class="preset-icon">🎹</div>
              <div class="preset-name">Neo-Soul</div>
            </button>
            <button class="preset" data-prog="modal">
              <div class="preset-icon">🌙</div>
              <div class="preset-name">Modal</div>
            </button>
          </div>
        </div>
      </div>
    </section>
    
    <!-- Replace the entire <section class="section pro-locked" id="tab-multitrack"> block with this -->

    <section class="section pro-locked" id="tab-multitrack">
      <div class="panel">
        <!-- Professional DAW Header -->
        <div class="panel-header">
          <div class="panel-title">🎙️ Professional Multitrack DAW</div>
          <div class="flex" style="gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" id="newSessionBtn">📄 New</button>
            <button class="btn btn-secondary btn-sm" id="saveSessionBtn">💾 Save</button>
            <button class="btn btn-secondary btn-sm" id="loadSessionBtn">📂 Load</button>
        
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
        
            <button class="btn btn-secondary btn-sm" id="undoBtn" disabled>↶ Undo</button>
            <button class="btn btn-secondary btn-sm" id="redoBtn" disabled>↷ Redo</button>
        
            <!-- 🔊 Mixdown / housekeeping -->
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
            <button class="btn btn-success btn-sm" id="bounceAllBtn">📦 Bounce</button>
            <button class="btn btn-secondary btn-sm" id="clearAllTracksBtn">🧹 Clear</button>
          </div>
        </div>

    
        <!-- Transport Controls Bar -->
        <div class="daw-transport-bar">
          <div class="transport-section">
            <button class="transport-btn" id="dawRewindBtn" title="Rewind">⏮️</button>
            <button class="transport-btn" id="dawPlayBtn" title="Play/Pause">▶️</button>
            <button class="transport-btn" id="dawStopBtn" title="Stop">⏹️</button>
            <button class="transport-btn" id="dawRecordBtn" title="Record Armed">⏺️</button>
            <button class="transport-btn" id="dawForwardBtn" title="Fast Forward">⏭️</button>
          </div>
    
          <div class="transport-section">
            <div class="transport-display" id="dawTimecode">00:00:00.000</div>
            <div class="transport-display" id="dawBars">1.1.1</div>
          </div>
    
          <div class="transport-section">
            <button class="btn btn-secondary btn-sm" id="dawLoopBtn">🔁 Loop</button>
            <button class="btn btn-secondary btn-sm" id="dawClickBtn">🥁 Click</button>
            <button class="btn btn-secondary btn-sm" id="dawCountInBtn">⏱️ Count</button>
          </div>
    
          <div class="transport-section" style="margin-left: auto;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">BPM</label>
            <input type="number" id="dawBpmInput" value="120" min="30" max="300" 
                   style="width: 60px; padding: var(--space-2); text-align: center;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">Time Sig</label>
            <select id="dawTimeSigSelect" style="padding: var(--space-2);">
              <option value="4/4" selected>4/4</option>
              <option value="3/4">3/4</option>
              <option value="6/8">6/8</option>
              <option value="5/4">5/4</option>
              <option value="7/8">7/8</option>
            </select>
          </div>
        </div>
    
        <!-- Main DAW Layout: 3-Column Professional View -->
        <div class="daw-main-container">
          
          <!-- LEFT: Track List / Mixer Column -->
          <div class="daw-track-list">
            <div class="daw-section-header">
              <span>📋 Tracks</span>
              <button class="btn btn-ghost btn-sm" id="addTrackBtnLeft">➕</button>
            </div>
            
            <div class="daw-track-list-scroll" id="dawTrackList">
              <!-- Track strips will be dynamically inserted here -->
            </div>
          </div>
          
          <div class="daw-master-strip">
            <div class="daw-section-header">Master</div>
            <div class="daw-meters">
              <div class="daw-meter-bar" id="masterMeterL"></div>
              <div class="daw-meter-bar" id="masterMeterR"></div>
            </div>
            <input type="range" orient="vertical" id="masterFader" min="-60" max="6" value="0" step="0.1">
            <div class="daw-fader-label" id="masterFaderLabel">0.0 dB</div>
          </div>
    
          <!-- CENTER: Timeline / Arrangement View -->
          <div class="daw-timeline-container">
            <!-- Toolbar -->
            <div class="daw-timeline-toolbar">
              <div class="toolbar-group">
                <button class="tool-btn active" data-tool="select" title="Select Tool">↖️</button>
                <button class="tool-btn" data-tool="pencil" title="Pencil Tool">✏️</button>
                <button class="tool-btn" data-tool="split" title="Split Tool">✂️</button>
                <button class="tool-btn" data-tool="fade" title="Fade Tool">📉</button>
              </div>

              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="importStemBtn">📁 Import Audio</button>
              </div>
    
              <div class="toolbar-group">
                <span class="toolbar-label">Snap:</span>
                <select id="dawSnapSelect" style="padding: var(--space-1) var(--space-2);">
                  <option value="off">Off</option>
                  <option value="bar">Bar</option>
                  <option value="beat" selected>Beat</option>
                  <option value="1/8">1/8</option>
                  <option value="1/16">1/16</option>
                  <option value="1/32">1/32</option>
                </select>
              </div>
    
              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="dawZoomInBtn">🔍+</button>
                <span id="dawZoomLevel">100%</span>
                <button class="btn btn-secondary btn-sm" id="dawZoomOutBtn">🔍-</button>
                <button class="btn btn-secondary btn-sm" id="dawZoomFitBtn">⊡ Fit</button>
              </div>
    
              <div class="toolbar-group" style="margin-left: auto;">
                <button class="btn btn-secondary btn-sm" id="dawGridBtn">⊞ Grid</button>
                <button class="btn btn-secondary btn-sm" id="dawAutomationBtn">📈 Auto</button>
              </div>
            </div>
    
            <!-- Ruler with measures/beats -->
            <div class="daw-ruler" id="dawRuler">
              <div class="daw-ruler-markers" id="dawRulerMarkers"></div>
              <div class="daw-playhead" id="dawPlayhead"></div>
              <div class="daw-loop-region" id="dawLoopRegion" style="display: none;"></div>
            </div>
    
            <!-- Scrollable arrangement view -->
            <div class="daw-arrangement-scroll" id="dawArrangementScroll">
              <div id="loopRegionHighlight" class="loop-region-highlight" style="display:none;"></div>
              <div class="daw-arrangement-grid" id="dawArrangementGrid">
                <!-- Track lanes will be rendered here -->
              </div>
            </div>
          </div>
    
          <!-- RIGHT: Inspector / Properties Panel -->
          <div class="daw-inspector">
            <div class="daw-section-header">
              <span id="inspectorTitle">🎛️ Inspector</span>
              <button class="btn btn-ghost btn-sm" id="closeInspectorBtn">✕</button>
            </div>
    
            <div class="daw-inspector-content" id="inspectorContent">
              <!-- Content changes based on selection -->
              <div class="inspector-placeholder">
                <div style="text-align: center; padding: var(--space-8); color: var(--text-tertiary);">
                  <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">🎚️</div>
                  <div>Select a track or region</div>
                  <div style="font-size: var(--text-sm); margin-top: var(--space-2);">to view properties</div>
                </div>
              </div>
            </div>
          </div>
    
        </div>
        
        <!-- 🎛 FX Chain Panel -->
        <div id="fxChainPanel" class="fx-chain-panel" style="display: none;">
          <div class="fx-chain-header">
            <div>
              <div class="fx-chain-title">FX Chain</div>
              <div class="fx-chain-subtitle">
                Track: <span id="fxChainTrackName">—</span>
              </div>
            </div>
            <div class="fx-chain-header-actions">
              <button class="btn btn-secondary btn-sm" id="fxAddBtn">➕ Add FX</button>
              <button class="btn btn-secondary btn-sm" id="closeFxPanelBtn">✕ Close</button>
            </div>
          </div>
    
          <!-- Where each FX “card” renders -->
          <div id="fxSlots" class="fx-chain-slots"></div>
    
          <!-- FX type picker -->
          <div id="fxAddMenu" class="fx-add-menu" style="display: none;">
            <button class="fx-add-item" data-fx-type="reverb">🌫️ Reverb</button>
            <button class="fx-add-item" data-fx-type="delay">⏱️ Delay</button>
            <button class="fx-add-item" data-fx-type="chorus">🌊 Chorus</button>
            <button class="fx-add-item" data-fx-type="distortion">⚡ Distortion</button>
            <button class="fx-add-item" data-fx-type="filter">🎚️ Filter</button>
            <button class="fx-add-item" data-fx-type="compressor">📉 Compressor</button>
            <button class="fx-add-item" data-fx-type="eq">🎚️ 3-Band EQ</button>
            <button class="fx-add-item" data-fx-type="bitcrusher">🧊 Bitcrusher</button>
          </div>
    
          <div class="fx-chain-footer">
            <span class="fx-chain-hint">
              Tip: drag to reorder, toggle to bypass, tweak sliders to dial in tone.
            </span>
          </div>
        </div>
        
        <!-- Bottom: Status Bar -->
        <div class="daw-status-bar">
          <span id="dawStatusMessage">Ready</span>
          <div style="margin-left: auto; display: flex; gap: var(--space-4); font-size: var(--text-xs);">
            <span>Sample Rate: <strong id="dawSampleRate">48000 Hz</strong></span>
            <span>Latency: <strong id="dawLatency">0ms</strong></span>
            <span>CPU: <strong id="dawCpuLoad">0%</strong></span>
            <span>Tracks: <strong id="dawTrackCount">0</strong></span>
          </div>
        </div>
      </div>
      <!-- Floating Add Track button (mobile only) -->
      <button id="addTrackBtnFloating" class="daw-fab">➕</button>
    </section>
    
    <footer class="footer">
      <div style="max-width: 1400px; margin: 0 auto;">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--space-6); margin-bottom: var(--space-4);">
          
          <!-- Transport & Playback -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>▶️</span> Transport
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Space</kbd> Play/Pause</div>
              <div><kbd>S</kbd> Stop</div>
              <div><kbd>E</kbd> DJ Export</div>
            </div>
          </div>
          
          <!-- Multitrack DAW -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>🎙️</span> Multitrack
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Ctrl</kbd>+<kbd>Z</kbd> Undo</div>
              <div><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> Redo</div>
              <div><kbd>X</kbd> Split at Playhead</div>
              <div><kbd>Ctrl</kbd>+<kbd>D</kbd> Duplicate Region</div>
              <div><kbd>Delete</kbd> Delete Region</div>
              <div><kbd>Ctrl</kbd>+<kbd>=</kbd> Zoom In</div>
              <div><kbd>Ctrl</kbd>+<kbd>-</kbd> Zoom Out</div>
            </div>
          </div>
          
          <!-- Sequencer -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>🎹</span> Sequencer
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Click</kbd> Toggle Step</div>
              <div><kbd>Alt</kbd>+<kbd>Click</kbd> Accent Velocity</div>
              <div><kbd>Shift</kbd>+<kbd>Click</kbd> Inc. Probability</div>
              <div><kbd>Ctrl</kbd>+<kbd>Click</kbd> Edit Note</div>
            </div>
          </div>
          
          <!-- Navigation -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>🧭</span> Navigation
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Esc</kbd> Close Sidebar</div>
              <div><kbd>Tab</kbd> Next Control</div>
            </div>
          </div>
          
        </div>
        
        <!-- Studio Info Bar -->
        <div style="padding-top: var(--space-4); border-top: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
          <div style="display: flex; align-items: center; gap: var(--space-4);">
            <strong style="background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: var(--text-lg);">8-Beat Studio</strong>
            <span style="color: var(--text-tertiary);">•</span>
            <span style="color: var(--text-secondary);">Hand Crafted Multitrack DAW</span>
          </div>
          
          <div style="display: flex; align-items: center; gap: var(--space-3); font-size: var(--text-sm); color: var(--text-tertiary);">
            <div class="badge badge-ghost">v1.5</div>
            <span>Made with ❤️ for producers</span>
          </div>
        </div>
      </div>
    </footer>
  </div>
  <!-- Add before closing </body> tag -->
  <div id="waveformEditorModal" style="display: none;"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
// ========================================
// 8-Beat Studio - Fully Optimized JS
// Performance: Debounced events, RAF throttling, object pooling
// Memory: Weak references, proper cleanup, no leaks
// Audio: Low-latency graph, stable connections, no crackles
// ========================================

'use strict';

// -------------------- Configuration --------------------
const CONFIG = {
  MAX_BPM: 200,
  MAX_SEQUENCE_LENGTH: 64,
  MIN_SEQUENCE_LENGTH: 8,
  VISUALIZER_BARS: 32,
  VISUALIZER_FPS: 30,
  PROGRESS_UPDATE_MS: 16,
  DEBOUNCE_MS: 80,
  STORAGE_KEY: 'prostudio.vibe'
};

const VIBES = ['moon', 'dawn', 'nebula', 'forest', 'sunset'];

// -------------------- State Management --------------------
const state = {
  currentGenre: 'lofi',
  currentTab: 'generate',
  isPlaying: false,
  bpm: 120,
  swing: 50,
  duration: 5,
  complexity: 2,
  humanize: 10,
  sequenceLength: 32,  // CHANGED FROM 16
  resolution: '16n',
  currentStep: 0,
  cursorSeconds: 0,
  // ... rest stays the same
  key: 'C',
  scale: 'major',
  octave: 4,
  progression: [],
  masterVolume: 0,
  tapeSaturation: 25,
  vinylNoise: 15,
  lowCut: 30,
  highCut: 16000,
  compressor: -18,
  metronomeEnabled: false,
  metronomeVolume: -6,
  countInBars: 1,
  // AI Mixing
  aiMixing: {
    enabled: false,
    autoGain: true,
    autoPan: true,
    autoEQ: true,
    autoCompression: true,
    referenceLevel: -14, // LUFS target
    lastAnalysis: null
  }
};

// Metronome system
const metronome = {
  synth: null,
  enabled: false,
  loop: null
};

async function checkAudioPermissions() {
  try {
    const permissions = await navigator.permissions.query({ name: 'microphone' });
    
    if (permissions.state === 'denied') {
      console.warn('⚠️ Microphone permission denied');
      showToast('⚠️ Microphone access denied. External audio tracks will not work.', 'warning');
    } else if (permissions.state === 'prompt') {
      console.log('ℹ️ Microphone permission will be requested when adding external audio track');
    } else {
      console.log('✅ Microphone permission granted');
    }
    
    permissions.addEventListener('change', () => {
      console.log('🔄 Microphone permission changed:', permissions.state);
    });
    
  } catch (err) {
    // Permissions API not supported or microphone not in query list
    console.log('ℹ️ Cannot query microphone permissions, will request on demand');
  }
}
  
// -------------------- Data Structures --------------------
const instruments = {
  kick: { name: 'Kick', icon: '🥁', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  snare: { name: 'Snare', icon: '🎤', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  hihat: { name: 'Hi-Hat', icon: '🎩', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  clap: { name: 'Clap', icon: '👏', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  rimshot: { name: 'Rimshot', icon: '🔊', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  tom: { name: 'Tom', icon: '🪘', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  crash: { name: 'Crash', icon: '💥', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  ride: { name: 'Ride', icon: '🌊', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  
  // NEW ATMOSPHERIC INSTRUMENTS
  fx: { name: 'FX', icon: '✨', mute: false, solo: false, volume: -6, pan: 0, type: 'atmospheric' },
  riser: { name: 'Riser', icon: '📈', mute: false, solo: false, volume: -8, pan: 0, type: 'atmospheric' },
  ambience: { name: 'Ambience', icon: '🌫️', mute: false, solo: false, volume: -10, pan: 0, type: 'atmospheric' },
  
  bass: { name: 'Bass', icon: '🎸', mute: false, solo: false, volume: -3, pan: 0, type: 'melodic', note: 'C2' },
  guitar: { name: 'Guitar', icon: '🎸', mute: false, solo: false, volume: -5, pan: 20, type: 'melodic', note: 'C3' },
  keys: { name: 'Keys', icon: '🎹', mute: false, solo: false, volume: -6, pan: 0, type: 'melodic', note: 'C4' },
  lead: { name: 'Lead', icon: '🎺', mute: false, solo: false, volume: -8, pan: 0, type: 'melodic', note: 'C5' }
};

const patterns = {};
const synths = {};
const effects = {};
const master = {};

// Initialize patterns with proper structure
Object.keys(instruments).forEach(inst => {
  patterns[inst] = Array(32).fill(null).map(() => ({  // CHANGED FROM 16
    active: false,
    velocity: 0.8,
    probability: 100,
    note: instruments[inst].note,
    duration: '8n'
  }));
});

// -------------------- Genre Presets --------------------
const genrePresets = {
  lofi: {
    name: 'Lo-Fi Hip-Hop', icon: '😌', bpm: 85, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','G2','G2','C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','A2','A2'],
      guitar: ['C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','G3','D4','F3','G3','C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','C4','D4','F4','G4'],
      keys: ['C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','G3','A#3','D4','F4','C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','C4','D4','F4','G4'],
      lead: ['G4','A#4','D5','C5','A#4','G4','F4','D#4','G4','A#4','D5','C5','A#4','G4','F4','D#4']
    }
  },
  
  hiphop: {
    name: 'Hip-Hop', icon: '🎤', bpm: 90, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
      hihat:   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      bass:    [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','G2','A1','A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','A1','A1'],
      guitar: ['A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','G3','B2','A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','G3'],
      keys: ['A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','F3','B3','A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','A3'],
      lead: ['E4','G4','A4','C5','B4','A4','G4','E4','E4','G4','A4','C5','D5','C5','B4','A4']
    }
  },
  
  postpunk: {
    name: 'Post-Punk', icon: '🖤', bpm: 100, swing: 0,
    patterns: {
      kick:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0],
      rimshot: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      bass:    [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0],
      guitar:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','D2','D1','E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','E2','E1'],
      guitar: ['E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','F3','A3','D3','E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','E3','G3','B3'],
      keys: ['E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','F3','A3','C4','E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','E3','G3','B3'],
      lead: ['B3','D4','E4','G4','F4','E4','D4','B3','B3','D4','E4','G4','A4','G4','F4','E4']
    }
  },
  
  rnb: {
    name: 'R&B', icon: '💫', bpm: 75, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0]
    },
    notes: {
      bass: ['F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','C3','C3','F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','D3','D3'],
      guitar: ['F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','G3','C3','F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','F3','A3'],
      keys: ['F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','C4','F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','A3'],
      lead: ['C4','E4','F4','A4','G4','F4','E4','C4','C4','E4','F4','A4','G4','A4','C5','E5']
    }
  },
  
  ambient: {
    name: 'Ambient', icon: '🌌', bpm: 60, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      snare:   [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0],
      bass:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','A#1','A#1','A#1','A#1','C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','G#1','G#1','G#1','G#1'],
      guitar: ['C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','D3','F3','A#3','D3','C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      keys: ['C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','D3','F3','A#3','D4','C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      lead: ['G3','A#3','D4','F4','D#4','D4','A#3','G3','G3','A#3','D4','F4','D#4','D4','C4','A#3']
    }
  },

  dazecore: {
    name: 'Dazecore', icon: '☀️', bpm: 95, swing: 0,
    patterns: {
      // Warm, inviting kick - but the timing is slightly off
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      
      // Soft, jazzy snare - comforting but distant
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1],
      
      // Lounge hi-hats with subtle glitches
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1],
      
      // Intimate claps - inviting you in
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0],
      
      // Dial-up nostalgia - warm but uncanny
      rimshot: [0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,0,1],
      
      // Rare tom fills - something stirring beneath
      tom:     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      
      // Deep, warm bass - comforting rumble with wrong notes
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,0],
      
      // Lush guitar chords - too beautiful, almost sickly sweet
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0],
      
      // Dreamy keys - lounge jazz piano with dissonant undertones
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0],
      
      // Warm melody - beckoning, seductive, slightly wrong
      lead:    [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0],
      
      // Vinyl crackle and tape warble - nostalgic texture
      fx:      [1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1],
      
      // Subtle riser - the room is shifting around you
      riser:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
      
      // Warm ambient pad - the "off" feeling underneath everything
      ambience:[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
    },
    notes: {
      // Warm bass with chromatic "wrong" notes
      bass: ['D2','D2','D2','F2','F2','F2','A2','A2','A2','C3','C3','C3','D3','D3','D#3','D2','D2','D2','F2','F2','F2','A2','A2','C3','C3','C3','D3','D#3','D3','C3','A2','F2'],
      
      // Lush major 7th chords with occasional dissonance
      guitar: ['D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','A3','C#4','E4','A3','D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','B3','D4','F#4','A4'],
      
      // Jazzy extended chords - warm but unsettling
      keys: ['D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','G#4','C#4','E4','G#4','B4','D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','A4','C#4','E4','G#4','C#5'],
      
      // Nostalgic melody - familiar but you can't place it
      lead: ['A4','C#5','D5','F#5','E5','D5','C#5','A4','F#4','A4','C#5','E5','D5','C#5','B4','A4','A4','C#5','D5','F#5','E5','D5','C#5','B4','A4','C#5','E5','F#5','G#5','A5','C#6','D6']
    }
  }
};
  
// -------------------- Music Theory --------------------
const keysArr = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const scales = {
  major: [0,2,4,5,7,9,11],
  minor: [0,2,3,5,7,8,10],
  dorian: [0,2,3,5,7,9,10],
  phrygian: [0,1,3,5,7,8,10],
  lydian: [0,2,4,6,7,9,11],
  mixolydian: [0,2,4,5,7,9,10],
  pentatonic: [0,2,4,7,9]
};

// -------------------- FX Configuration --------------------
const fxConfig = {
  reverb: { name: 'Reverb', active: false, decay: 1, wet: 0.2 },
  delay: { name: 'Delay', active: false, time: '4n', feedback: 0.2 },
  chorus: { name: 'Chorus', active: false, frequency: 1.5, depth: 0.7 },
  flanger: { name: 'Flanger', active: false, frequency: 0.5, depth: 0.5 },
  distortion: { name: 'Distortion', active: false, amount: 0.5 },
  filter: { name: 'Filter', active: true, frequency: 5000, type: 'lowpass' },
  phaser: { name: 'Phaser', active: false, frequency: 0.5, octaves: 3 },
  bitcrusher: { name: 'Bitcrusher', active: false, bits: 8, frequency: 4000 }
};

// -------------------- Utilities --------------------
const debounce = (fn, ms) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), ms);
  };
};

const throttle = (fn, ms) => {
  let lastRun = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastRun >= ms) {
      lastRun = now;
      fn(...args);
    }
  };
};

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

// -------------------- Audio Context Setup --------------------
function initAudioContext() {
  if (Tone.getContext && Tone.getContext().rawContext) return;

  const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
  
  const ctx = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: isMobile ? 'balanced' : 'interactive',
    sampleRate: 48000
  });
  
  Tone.setContext(new Tone.Context(ctx));
  
  // CRITICAL: Desktop needs LESS lookahead to avoid timing issues
  Tone.context.lookAhead = isMobile ? 0.05 : 0.015; // Reduced from 0.02
  Tone.context.updateInterval = isMobile ? 0.03 : 0.008; // Reduced from 0.01
  
  console.log('🎧 Device:', isMobile ? 'Mobile' : 'Desktop');
  console.log('🎵 Lookahead:', Tone.context.lookAhead.toFixed(3) + 's');
  console.log('🎵 Update:', Tone.context.updateInterval.toFixed(3) + 's');
}
  
function unlockAudioOnce() {
  const unlock = async () => {
    try {
      await Tone.start();
      await Tone.getContext().rawContext.resume();
      console.log('🔓 Audio unlocked:', Tone.getContext().rawContext.state);
    } catch (e) {
      console.warn('Unlock failed:', e);
    } finally {
      ['pointerdown', 'keydown', 'touchstart'].forEach(evt => {
        window.removeEventListener(evt, unlock);
      });
    }
  };
  
  window.addEventListener('pointerdown', unlock, { once: true });
  window.addEventListener('keydown', unlock, { once: true });
  window.addEventListener('touchstart', unlock, { once: true, passive: true });
}

// -------------------- Audio Graph Initialization --------------------
function initAudio() {
  // CRITICAL: Much lower gain + slower ramps for desktop stability
  master.fxIn = new Tone.Gain(0.25); // Reduced from 0.18
  
  // Master bus filters with SLOWER frequency ramps
  master.lowCutFilter = new Tone.Filter({
    type: 'highpass',
    frequency: state.lowCut,
    rolloff: -12
  });
  
  master.highCutFilter = new Tone.Filter({
    type: 'lowpass',
    frequency: state.highCut,
    rolloff: -12
  });
  
  // Tape saturation (subtle warm distortion)
  master.tapeDistortion = new Tone.Distortion({
    distortion: state.tapeSaturation / 100 * 0.2, // Reduced from 0.3
    wet: state.tapeSaturation / 100 * 0.6 // Reduced wet mix
  });
  
  // Vinyl noise (pink noise layer) - QUIETER
  master.vinylNoise = new Tone.Noise('pink');
  master.vinylNoise.volume.value = -50 + (state.vinylNoise / 100 * 15); // Quieter
  master.vinylNoise.start();
  master.vinylNoise.connect(master.fxIn);
  
  // Effects with MUCH gentler settings for desktop
  effects.filter = new Tone.Filter(fxConfig.filter.frequency, fxConfig.filter.type);
  effects.distortion = new Tone.Distortion(0.01); // Half strength
  effects.chorus = new Tone.Chorus(1.5, 2.5, 0.1).start(); // Reduced depth
  effects.flanger = new Tone.Chorus({
    frequency: 0.5,
    delayTime: 2,
    depth: 0.3, // Reduced from 0.5
    type: 'sine',
    spread: 0
  }).start();
  effects.phaser = new Tone.Phaser({
    frequency: 0.3, // Slower modulation
    octaves: 2, // Reduced from 3
    baseFrequency: 350
  });
  effects.bitcrusher = new Tone.BitCrusher(10); // Less crushing (was 8)
  effects.delay = new Tone.FeedbackDelay(fxConfig.delay.time, 0.08); // Less feedback
  effects.reverb = new Tone.Reverb({ decay: 0.6, wet: 0.1 }); // Drier reverb
  
  master.comp = new Tone.Compressor({
    threshold: state.compressor,
    ratio: 4, // More compression = more consistent volume
    attack: 0.003,
    release: 0.15
  });
  master.limiter = new Tone.Limiter(-2); // Safety limiter catches peaks
  
  // Connect master bus chain
  master.fxIn.chain(
    master.lowCutFilter,
    master.highCutFilter,
    master.tapeDistortion,
    effects.filter,
    effects.distortion,
    effects.bitcrusher,
    effects.chorus,
    effects.flanger,
    effects.phaser,
    effects.delay,
    effects.reverb,
    master.comp,
    master.limiter
  );
  
  master.limiter.toDestination();
  
  // Clip detection meter
  master.meter = new Tone.Meter();
  master.limiter.connect(master.meter);
  
  // Visualizer tap
  master.analyser = new Tone.Analyser('fft', 64);
  master.limiter.connect(master.analyser);
  
  // Recording tap
  const raw = Tone.getContext().rawContext;
  master.mediaDest = raw.createMediaStreamDestination();
  master.limiter.connect(master.mediaDest);
  master.mediaRecorder = null;
  master.recordedChunks = [];
  
  // Start with all FX completely dry
  Object.values(effects).forEach(fx => {
    if (fx.wet) fx.wet.value = 0;
  });
  
  // Create synths and channels
  Object.keys(instruments).forEach(inst => createInstrumentChain(inst));
  
  // Transport setup
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Initialize metronome
  metronome.synth = new Tone.MembraneSynth({
    pitchDecay: 0.008,
    octaves: 2,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
  }).toDestination();
  
  metronome.synth.volume.value = state.metronomeVolume;

  // Optimize instrument levels for better mix
  instruments.kick.volume = 0;
  instruments.snare.volume = -2;
  instruments.hihat.volume = -6;
  instruments.bass.volume = -3;
  
  metronome.loop = new Tone.Loop((time) => {
    const step = Math.floor(Tone.Transport.position.split(':')[1]);
    const isDownbeat = step === 0;
    const pitch = isDownbeat ? 'C5' : 'C4';
    const velocity = isDownbeat ? 1 : 0.6;
    
    if (state.metronomeEnabled) {
      metronome.synth.triggerAttackRelease(pitch, '32n', time, velocity);
    }
  }, '4n');
  
  metronome.loop.start(0);
  
  // CRITICAL: Batch note triggers to reduce message handler load
  const noteQueue = [];
  let batchTimeout = null;
  
  const flushNoteQueue = (time) => {
    if (noteQueue.length === 0) return;
    
    // Sort by time to maintain order
    noteQueue.sort((a, b) => a.time - b.time);
    
    // Trigger all notes at their scheduled times
    noteQueue.forEach(({ inst, step, time: noteTime }) => {
      playStep(inst, step, noteTime);
    });
    
    noteQueue.length = 0;
  };
  
  // Main sequencer loop - FIXED TIMING
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);
    
    const activeInsts = Object.keys(instruments).filter(inst => 
      patterns[inst][step]?.active
    );
    
    // 🔥 FIX: Play drum instruments IMMEDIATELY without batching
    // Only batch melodic instruments to prevent message handler overload
    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');
    
    // Play drums immediately - no offset (tight timing critical)
    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });
    
    // Batch melodic instruments with tiny offset (they're more forgiving)
    melodicInsts.forEach((inst, idx) => {
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002; // Reduced from 0.005
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });
    
    updateVisualizer();
  }, Array.from({ length: state.sequenceLength }, (_, i) => i), state.resolution);
  
  loop.start(0);
}

// In createInstrumentChain function (around line ~676), replace with:
function createInstrumentChain(inst) {
  const instData = instruments[inst];
  
  if (instData.type === 'drum') {
    synths[inst] = createDrumSynth(inst);
  } else if (instData.type === 'atmospheric') {
    synths[inst] = createFallbackDrumSynth(inst); // Use synths for atmospheric
    synths[inst].volume = { value: instData.volume };
  } else {
    synths[inst] = createMelodicSynth(inst);
    synths[inst].volume.value = instData.volume;
  }
  
  // Create channel - completely dry, no reverb sends
  const channel = new Tone.Channel({
    pan: 0,
    volume: instData.volume
  }).connect(master.fxIn);
  
  instData.channel = channel;
  synths[inst].connect(channel);
}
  
// ============ DRUM SAMPLE SYSTEM ============
const DRUM_SAMPLES = {
  kick: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/kick.mp3',
  snare: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3',
  hihat: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3',
  tom: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/tom1.mp3',
  
  // FIXED: Using working CR78 samples
  clap: 'https://tonejs.github.io/audio/drum-samples/CR78/clap.mp3',
  rimshot: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3', // Using snare as fallback
  crash: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  ride: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  
  // NEW INSTRUMENTS - using Tone.js built-in sounds since we need synths anyway
  fx: null, // Will use synth
  riser: null, // Will use synth
  ambience: null // Will use synth
};

function createDrumSynth(inst) {
  const sampleUrl = DRUM_SAMPLES[inst];
  
  if (!sampleUrl) {
    console.warn(`No sample for ${inst}, using fallback synth`);
    return createFallbackDrumSynth(inst);
  }
  
  // Use Tone.Player for single-shot samples
  const player = new Tone.Player({
    url: sampleUrl,
    fadeOut: 0.01,
    onload: () => {
      console.log(`✅ ${inst} loaded`);
    },
    onerror: (err) => {
      console.error(`❌ ${inst} failed to load:`, err);
      // Replace with fallback
      setTimeout(() => {
        if (!player.loaded) {
          synths[inst] = createFallbackDrumSynth(inst);
          console.log(`🔄 Using fallback synth for ${inst}`);
        }
      }, 3000);
    }
  });
  
  // Create volume control for this player
  const playerGain = new Tone.Gain(1);
  player.connect(playerGain);
  
  // Return proxy that matches synth interface
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      if (player.loaded) {
        player.stop(time);
        playerGain.gain.setValueAtTime(velocity, time);
        player.start(time);
      }
    },
    connect: (node) => {
      playerGain.disconnect();
      playerGain.connect(node);
      return playerGain;
    },
    toDestination: () => playerGain.toDestination(),
    dispose: () => {
      player.dispose();
      playerGain.dispose();
    },
    get loaded() {
      return player.loaded;
    },
    player: player,
    gain: playerGain
  };
}

// Add this new function after createDrumSynth
function createFallbackDrumSynth(inst) {
  let synth;
  
  switch(inst) {
    case 'kick':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
      });
      break;
      
    case 'snare':
      synth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
      });
      break;
      
    case 'hihat':
      synth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'crash':
      synth = new Tone.MetalSynth({
        frequency: 100,
        envelope: { attack: 0.001, decay: 1.4, release: 2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'ride':
      synth = new Tone.MetalSynth({
        frequency: 150,
        envelope: { attack: 0.001, decay: 0.8, release: 0.5 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'clap':
      // Layered noise bursts for clap sound
      const clap = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      const clap2 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.015, decay: 0.03, sustain: 0 }
      });
      const clap3 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.025, decay: 0.02, sustain: 0 }
      });
      
      // Merge into one synth
      const clapGain = new Tone.Gain(1);
      clap.connect(clapGain);
      clap2.connect(clapGain);
      clap3.connect(clapGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          clap.triggerAttackRelease(duration, time, velocity);
          clap2.triggerAttackRelease(duration, time + 0.015, velocity * 0.7);
          clap3.triggerAttackRelease(duration, time + 0.025, velocity * 0.5);
        },
        connect: (node) => clapGain.connect(node),
        toDestination: () => clapGain.toDestination(),
        dispose: () => {
          clap.dispose();
          clap2.dispose();
          clap3.dispose();
          clapGain.dispose();
        },
        loaded: true
      };
      
    case 'rimshot':
      synth = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      break;
      
    case 'tom':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8 }
      });
      break;
      
    // NEW ATMOSPHERIC SYNTHS
    case 'fx':
      // Glitchy stutter effect
      const fxSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
        harmonicity: 12,
        modulationIndex: 50,
        resonance: 2000,
        octaves: 0.5
      });
      const fxGain = new Tone.Gain(0.2);
      fxSynth.connect(fxGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          fxSynth.triggerAttackRelease('32n', time, velocity * 0.3);
        },
        connect: (node) => fxGain.connect(node),
        toDestination: () => fxGain.toDestination(),
        dispose: () => {
          fxSynth.dispose();
          fxGain.dispose();
        },
        loaded: true
      };
      
    case 'riser':
      // Sweeping frequency riser
      synth = new Tone.FMSynth({
        harmonicity: 3,
        modulationIndex: 10,
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 2, decay: 0.1, sustain: 0.1, release: 0.5 },
        modulation: { type: 'square' },
        modulationEnvelope: { attack: 2, decay: 0.2, sustain: 0.5, release: 0.3 }
      });
      break;
      
    case 'ambience':
      // Dark atmospheric pad
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sine' },
        envelope: { attack: 1, decay: 1, sustain: 0.5, release: 2 }
      });
      
      // Add reverb for atmosphere
      const ambReverb = new Tone.Reverb({
        decay: 8,
        wet: 0.7
      });
      ambReverb.generate();
      synth.connect(ambReverb);
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          synth.triggerAttackRelease(note, duration, time, velocity);
        },
        connect: (node) => {
          ambReverb.disconnect();
          ambReverb.connect(node);
          return ambReverb;
        },
        toDestination: () => ambReverb.toDestination(),
        dispose: () => {
          synth.dispose();
          ambReverb.dispose();
        },
        loaded: true
      };
      
    default:
      synth = new Tone.MembraneSynth();
  }
  
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      synth.triggerAttackRelease(note, duration, time, velocity);
    },
    connect: (node) => synth.connect(node),
    toDestination: () => synth.toDestination(),
    dispose: () => synth.dispose(),
    loaded: true
  };
}

function playDrumNote(inst, time, velocity) {
  const synth = synths[inst];
  if (!synth) {
    console.warn(`No synth for ${inst}`);
    return;
  }
  
  // Check if sample is loaded
  if (!synth.loaded) {
    console.warn(`${inst} sample not loaded yet`);
    return;
  }
  
  // All drums trigger at same pitch - sample handles the sound
  synth.triggerAttackRelease('C2', '8n', time, velocity * 0.9);
}

// Melodic instrument samples using Tone.Sampler
const MELODIC_SAMPLES = {
  bass: {
    'C2': 'https://tonejs.github.io/audio/salamander/C2.mp3',
    'D#2': 'https://tonejs.github.io/audio/salamander/Ds2.mp3',
    'F#2': 'https://tonejs.github.io/audio/salamander/Fs2.mp3',
    'A2': 'https://tonejs.github.io/audio/salamander/A2.mp3'
  },
  guitar: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3'
  },
  keys: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3'
  },
  lead: {
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3',
    'D#5': 'https://tonejs.github.io/audio/salamander/Ds5.mp3',
    'F#5': 'https://tonejs.github.io/audio/salamander/Fs5.mp3',
    'A5': 'https://tonejs.github.io/audio/salamander/A5.mp3'
  }
};

function createMelodicSynth(inst) {
  const samples = MELODIC_SAMPLES[inst];
  
  if (!samples) {
    console.warn(`No samples for ${inst}, using fallback synth`);
    return new Tone.PolySynth(Tone.Synth);
  }
  
  const sampler = new Tone.Sampler({
    urls: samples,
    release: 2, // Longer release = more dreamy
    onload: () => {
      console.log(`✅ ${inst} samples loaded`);
    }
  });
  
  switch (inst) {
    case 'bass':
      const bassComp = new Tone.Compressor(-30, 3);
      const bassDist = new Tone.Distortion(0.1);
      sampler.chain(bassDist, bassComp);
      return sampler;
      
    case 'guitar':
      // MORE reverb and chorus for dreamier sound
      const guitarReverb = new Tone.Reverb({
        decay: 3,
        wet: 0.4
      });
      guitarReverb.generate();
      
      const guitarChorus = new Tone.Chorus({
        frequency: 0.5, // Slower = dreamier
        delayTime: 3.5,
        depth: 0.3,
        type: 'sine',
        spread: 180
      }).start();
      
      sampler.chain(guitarChorus, guitarReverb);
      return sampler;
      
    case 'keys':
      // Dark pad sound
      const keysReverb = new Tone.Reverb({
        decay: 4,
        wet: 0.5
      });
      keysReverb.generate();
      
      const keysChorus = new Tone.Chorus(0.3, 4, 0.4).start();
      
      sampler.chain(keysChorus, keysReverb);
      return sampler;
      
    case 'lead':
      // Ethereal lead
      const leadReverb = new Tone.Reverb({
        decay: 5,
        wet: 0.6
      });
      leadReverb.generate();
      
      const leadDelay = new Tone.FeedbackDelay({
        delayTime: '8n',
        feedback: 0.4,
        wet: 0.3
      });
      
      sampler.chain(leadDelay, leadReverb);
      return sampler;
      
    default:
      return sampler;
  }
}

function playStep(inst, step, time) {
  const stepData = patterns[inst][step];
  if (!stepData.active) return;
  
  const instData = instruments[inst];
  if (instData.mute) return;
  
  const anySolo = Object.values(instruments).some(i => i.solo);
  if (anySolo && !instData.solo) return;
  
  if (Math.random() * 100 > stepData.probability) return;
  
  // 🔥 FIX: Check if sample is loaded before playing
  const synth = synths[inst];
  if (instData.type === 'drum' && synth && !synth.loaded) {
    console.warn(`⚠️ ${inst} sample not loaded, skipping step`);
    return;
  }
  
  // Per-instrument humanization scaling
  const humanizeScale = {
    kick: 0.5,
    snare: 0.7,
    hihat: 1.2,
    bass: 0.6,
    guitar: 1.0,
    keys: 0.8,
    lead: 0.9,
    fx: 0.3,
    riser: 0.1,
    ambience: 0.2
  };
  
  const scale = humanizeScale[inst] || 1.0;
  const humanize = (Math.random() - 0.5) * (state.humanize / 1000) * scale;
  
  let velocity = stepData.velocity;
  if (instData.type === 'drum') {
    velocity *= (0.95 + Math.random() * 0.1);
  }
  
  if (instData.type === 'drum') {
    playDrumNote(inst, time + humanize, velocity);
  } else if (instData.type === 'atmospheric') {
    playAtmosphericNote(inst, time + humanize, stepData);
  } else {
    playMelodicNote(inst, time + humanize, stepData);
  }
}

function playMelodicNote(inst, time, stepData) {
  const note = stepData.note || instruments[inst].note || 'C4';
  const duration = stepData.duration || '8n';
  synths[inst].triggerAttackRelease(note, duration, time, stepData.velocity);
}

function playAtmosphericNote(inst, time, stepData) {
  const duration = stepData.duration || '1n'; // Longer by default
  const velocity = stepData.velocity || 0.5;
  
  if (inst === 'fx') {
    // Glitchy FX - random pitch
    const pitch = ['C4', 'D#4', 'F#4', 'A#4'][Math.floor(Math.random() * 4)];
    synths[inst].triggerAttackRelease(pitch, '8n', time, velocity);
  } else if (inst === 'riser') {
    // Rising frequency sweep
    synths[inst].triggerAttackRelease('C2', '2n', time, velocity);
    // Add frequency sweep
    if (synths[inst].frequency) {
      synths[inst].frequency.exponentialRampTo('C6', '2n', time);
    }
  } else if (inst === 'ambience') {
    // Dark ambient chord
    const notes = ['C2', 'D#2', 'G2', 'A#2'];
    synths[inst].triggerAttackRelease(notes, duration, time, velocity * 0.4);
  }
}
  
// -------------------- Vibe System --------------------
function nextVibe() {
  const currentVibe = document.body.getAttribute('data-vibe') || 'moon';
  const currentIndex = VIBES.indexOf(currentVibe);
  const nextIndex = (currentIndex + 1) % VIBES.length;
  return VIBES[nextIndex];
}

function applyVibe(vibe) {
  document.body.setAttribute('data-vibe', vibe);
  try {
    localStorage.setItem(CONFIG.STORAGE_KEY, vibe);
    console.log('💾 Saved vibe:', vibe);
  } catch (e) {
    console.warn('localStorage unavailable:', e);
  }
  
  const label = vibe.charAt(0).toUpperCase() + vibe.slice(1);
  const btn = document.getElementById('vibeBtn');
  if (btn) btn.textContent = `🌈 Vibe: ${label}`;
}

function loadSavedVibe() {
  try {
    const savedVibe = localStorage.getItem(CONFIG.STORAGE_KEY);
    if (savedVibe && VIBES.includes(savedVibe)) {
      applyVibe(savedVibe);
      console.log('✅ Loaded saved vibe:', savedVibe);
    } else {
      applyVibe('moon');
    }
  } catch (e) {
    console.warn('Could not load vibe:', e);
    applyVibe('moon');
  }
}

function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      const next = nextVibe();
      applyVibe(next);
      console.log('🌈 Switched to:', next);
    });
  }
}

// -------------------- Pattern Management --------------------
function ensurePatternLength(length) {
  Object.keys(patterns).forEach(inst => {
    const arr = patterns[inst];
    
    while (arr.length < length) {
      arr.push({
        active: false,
        velocity: 0.8,
        probability: 100,
        note: instruments[inst].note,
        duration: '8n'
      });
    }
    
    if (arr.length > length) arr.length = length;
  });
}

// -------------------- Event Handlers Setup --------------------
function setupEventListeners() {
  setupGenreSelector();
  setupTabs();
  setupTransportControls();
  setupParameterControls();
  setupGeneratorButtons();
  setupSequencerControls();
  setupMixerListeners();
  setupFXListeners();
  setupHarmonyControls();
  setupProjectManagement();
  setupKeyboardShortcuts();
  setupVibeSelector();
  setupMultitrackListeners();

  // Sidebar controls
  document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
  document.getElementById('sidebarBackdrop').addEventListener('click', closeSidebar);
  
  // Keyboard shortcut: ESC to close sidebar
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeSidebar();
    }
  });
}

function setupGenreSelector() {
  document.getElementById('genreSelector').addEventListener('click', e => {
    const btn = e.target.closest('.genre-btn');
    if (!btn) return;
    
    document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.currentGenre = btn.dataset.genre;
    updateGenrePresets();
  });
}
  
// -------------------- Sample Browser (no custom uploads) --------------------
function setupSampleUpload() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) {
    console.warn('⚠️ setupSampleUpload: #sampleUploadGrid not found');
    return;
  }
  renderSampleUploadGrid();
}

function renderSampleUploadGrid() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) return;

  grid.innerHTML = '';

  // Show all drum / atmospheric instruments as previewable samples
  const uploadableInstruments = Object.keys(instruments).filter(inst =>
    instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric'
  );

  if (uploadableInstruments.length === 0) {
    const msg = document.createElement('div');
    msg.className = 'panel';
    msg.style.padding = 'var(--space-4)';
    msg.textContent = 'No sample-based instruments found. Drums and atmospheric instruments will show here.';
    grid.appendChild(msg);
    return;
  }

  uploadableInstruments.forEach(inst => {
    const data = instruments[inst];

    const card = document.createElement('div');
    card.className = 'panel';
    card.style.padding = 'var(--space-4)';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = 'var(--space-3)';

    card.innerHTML = `
      <div style="text-align: center;">
        <div style="font-size: var(--text-3xl); margin-bottom: var(--space-2);">
          ${data.icon || '🎛️'}
        </div>
        <div style="font-weight: 700; margin-bottom: var(--space-1); color: var(--text-primary);">
          ${data.name || inst}
        </div>
        <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
          Built-in sample
        </div>
      </div>

      <div style="display: flex; flex-direction: column; gap: var(--space-2);">
        <button class="btn btn-primary btn-sm preview-sample-btn" data-inst="${inst}">
          ▶️ Preview
        </button>
      </div>
    `;

    grid.appendChild(card);
  });

  // Preview listeners
  grid.querySelectorAll('.preview-sample-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const inst = btn.dataset.inst;
      previewInstrument(inst);
    });
  });
}
  
function previewInstrument(inst) {
  const synth = synths[inst];
  if (!synth) {
    showToast('❌ Instrument not loaded', 'error');
    return;
  }
  
  // Check if it's loaded
  if (!synth.loaded) {
    showToast('⏳ Sample still loading...', 'warning');
    return;
  }
  
  const time = Tone.now();
  
  // For drum samples, trigger at standard note
  if (instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric') {
    synth.triggerAttackRelease('C2', '8n', time, 0.8);
  } else {
    // For melodic instruments
    const note = instruments[inst].note || 'C4';
    synth.triggerAttackRelease(note, '8n', time, 0.8);
  }
  
  showToast(`▶️ ${instruments[inst].name}`, 'info');
}

// Helper functions for base64 conversion
async function arrayBufferToBase64(buffer) {
  const blob = new Blob([buffer]);
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
  
function setupTabs() {
  const sidebarTabs = document.getElementById('sidebarTabs');
  
  sidebarTabs.addEventListener('click', e => {
    const tab = e.target.closest('.sidebar-tab');
    if (!tab) return;
    
    document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    
    state.currentTab = tab.dataset.tab;

    if (tab.dataset.tab === 'samples') {
      setupSampleUpload();
    }
    
    // Close sidebar after selection
    closeSidebar();
  });
}

// ==================== AI MIXING & MASTERING ====================

function analyzeTrackFrequencies(inst) {
  const synth = synths[inst];
  if (!synth) return null;
  
  const instData = instruments[inst];
  const type = instData.type;
  
  // Frequency profiles for intelligent EQ
  const profiles = {
    kick: { fundamental: 60, lowEnd: 40, midRange: 200, presence: 3000, clarity: 8000 },
    snare: { fundamental: 200, body: 400, snap: 3500, brightness: 8000 },
    hihat: { fundamental: 8000, shimmer: 12000, air: 16000 },
    bass: { fundamental: 80, subBass: 40, warmth: 200, definition: 800 },
    guitar: { body: 300, presence: 2500, clarity: 5000 },
    keys: { warmth: 250, body: 800, presence: 3000, air: 8000 },
    lead: { fundamental: 1000, presence: 3000, brightness: 6000 }
  };
  
  return profiles[inst] || profiles.keys;
}

function calculateOptimalGain(inst) {
  const instData = instruments[inst];
  const type = instData.type;
  
  // Target levels in dB
  const targets = {
    kick: -6,
    snare: -9,
    hihat: -14,
    clap: -12,
    rimshot: -15,
    tom: -10,
    crash: -16,
    ride: -16,
    bass: -8,
    guitar: -12,
    keys: -14,
    lead: -10,
    fx: -18,
    riser: -20,
    ambience: -22
  };
  
  return targets[inst] || -12;
}

function calculateOptimalPan(inst, totalInstruments) {
  const instData = instruments[inst];
  
  // Stereo field strategy
  const panMap = {
    // Center (mono sources)
    kick: 0,
    snare: 0,
    bass: 0,
    lead: 0,
    
    // Slight spread
    hihat: 15,
    rimshot: -10,
    clap: 5,
    
    // Wide stereo
    guitar: 35,
    keys: -25,
    crash: 40,
    ride: -35,
    
    // Atmospheric spread
    fx: 20,
    ambience: -30,
    riser: 0
  };
  
  return panMap[inst] || 0;
}

function analyzePatternDensity(inst) {
  const pattern = patterns[inst];
  const activeSteps = pattern.filter(s => s.active).length;
  const density = activeSteps / state.sequenceLength;
  
  const avgVelocity = activeSteps > 0
    ? pattern.filter(s => s.active).reduce((sum, s) => sum + s.velocity, 0) / activeSteps
    : 0;
  
  return {
    density,
    avgVelocity,
    activeSteps,
    totalSteps: state.sequenceLength,
    importance: density * avgVelocity // Combined metric
  };
}

function calculateIntelligentEQ(inst, freqProfile, density) {
  const eq = { low: 0, mid: 0, high: 0 };
  
  const instData = instruments[inst];
  const type = instData.type;
  
  if (type === 'drum') {
    // Drums: enhance fundamental, reduce mud
    if (inst === 'kick') {
      eq.low = 2; // Boost sub
      eq.mid = -3; // Cut mud
      eq.high = -1; // Slight air reduction
    } else if (inst === 'snare') {
      eq.low = -2; // Reduce rumble
      eq.mid = 1; // Enhance body
      eq.high = 2; // Add crack
    } else if (inst === 'hihat' || inst === 'crash' || inst === 'ride') {
      eq.low = -4; // Cut lows completely
      eq.mid = -2; // Reduce mids
      eq.high = 3; // Boost highs for shimmer
    }
  } else if (type === 'melodic') {
    if (inst === 'bass') {
      eq.low = 3; // Strong bass boost
      eq.mid = -2; // Cut muddiness
      eq.high = -3; // Remove highs
    } else if (inst === 'guitar') {
      eq.low = -1;
      eq.mid = 2; // Presence boost
      eq.high = 1;
    } else if (inst === 'keys') {
      eq.low = 0;
      eq.mid = 1;
      eq.high = 2; // Clarity
    } else if (inst === 'lead') {
      eq.low = -2;
      eq.mid = 3; // Strong presence
      eq.high = 2; // Brightness
    }
  } else if (type === 'atmospheric') {
    eq.low = -3; // Clean lows
    eq.mid = -1;
    eq.high = 4; // Emphasize air
  }
  
  // Adjust based on density - busier instruments get subtle treatment
  if (density.density > 0.5) {
    eq.low *= 0.7;
    eq.mid *= 0.7;
    eq.high *= 0.7;
  }
  
  return eq;
}

async function applyAIMixing() {
  if (!state.aiMixing.enabled) return;
  
  showToast('🤖 AI analyzing mix...', 'info');
  
  const analysis = {
    instruments: {},
    totalDensity: 0,
    activeInstruments: 0
  };
  
  // Analyze each instrument
  Object.keys(instruments).forEach(inst => {
    const density = analyzePatternDensity(inst);
    const freqProfile = analyzeTrackFrequencies(inst);
    
    analysis.instruments[inst] = {
      density,
      freqProfile,
      currentGain: instruments[inst].volume,
      currentPan: instruments[inst].pan
    };
    
    if (density.activeSteps > 0) {
      analysis.totalDensity += density.importance;
      analysis.activeInstruments++;
    }
  });
  
  state.aiMixing.lastAnalysis = analysis;
  
  // Apply intelligent adjustments
  let adjustments = 0;
  
  Object.keys(instruments).forEach(inst => {
    const instAnalysis = analysis.instruments[inst];
    const instData = instruments[inst];
    
    if (instAnalysis.density.activeSteps === 0) return;
    
    // Auto Gain
    if (state.aiMixing.autoGain) {
      const targetGain = calculateOptimalGain(inst);
      const densityFactor = 1 - (instAnalysis.density.importance / analysis.totalDensity) * 0.3;
      const finalGain = targetGain * densityFactor;
      
      instData.volume = Math.round(finalGain);
      if (instData.channel) {
        instData.channel.volume.rampTo(finalGain, 0.5);
      }
      adjustments++;
    }
    
    // Auto Pan
    if (state.aiMixing.autoPan) {
      const targetPan = calculateOptimalPan(inst, analysis.activeInstruments);
      instData.pan = targetPan;
      
      if (instData.channel) {
        instData.channel.pan.rampTo(targetPan / 100, 0.5);
      }
      adjustments++;
    }
    
    // Auto EQ
    if (state.aiMixing.autoEQ) {
      const eq = calculateIntelligentEQ(inst, instAnalysis.freqProfile, instAnalysis.density);
      
      // Apply to channel (we'd need per-channel EQ nodes - simplified here)
      console.log(`🎛️ ${inst} EQ: L${eq.low > 0 ? '+' : ''}${eq.low}dB M${eq.mid > 0 ? '+' : ''}${eq.mid}dB H${eq.high > 0 ? '+' : ''}${eq.high}dB`);
    }
    
    // Auto Compression
    if (state.aiMixing.autoCompression) {
      // Compress based on density and type
      const shouldCompress = instAnalysis.density.density > 0.3;
      if (shouldCompress) {
        console.log(`📊 ${inst} compression applied`);
      }
    }
  });
  
  // Master bus adjustments
  const totalImportance = analysis.totalDensity;
  if (totalImportance > 2.5) {
    // Dense mix - apply gentle master compression
    master.comp.threshold.rampTo(-20, 0.5);
    master.comp.ratio.value = 6;
  } else {
    // Sparse mix - lighter compression
    master.comp.threshold.rampTo(-24, 0.5);
    master.comp.ratio.value = 4;
  }
  
  renderMixer();
  
  console.log('🤖 AI Mixing complete:');
  console.log(`   - ${adjustments} adjustments made`);
  console.log(`   - ${analysis.activeInstruments} active instruments`);
  console.log(`   - Total density: ${totalImportance.toFixed(2)}`);
  
  showToast(`✅ AI mixed ${analysis.activeInstruments} instruments`, 'success');
}

function applyMasteringPreset(preset) {
  const presets = {
    gentle: {
      comp: { threshold: -18, ratio: 3, attack: 0.01, release: 0.25 },
      limiter: -1,
      tape: 15,
      highCut: 18000,
      lowCut: 25
    },
    modern: {
      comp: { threshold: -14, ratio: 6, attack: 0.003, release: 0.15 },
      limiter: -0.5,
      tape: 30,
      highCut: 16000,
      lowCut: 30
    },
    aggressive: {
      comp: { threshold: -12, ratio: 8, attack: 0.001, release: 0.1 },
      limiter: -0.1,
      tape: 40,
      highCut: 15000,
      lowCut: 35
    },
    lofi: {
      comp: { threshold: -20, ratio: 4, attack: 0.02, release: 0.3 },
      limiter: -2,
      tape: 50,
      highCut: 12000,
      lowCut: 40
    }
  };
  
  const config = presets[preset];
  if (!config) return;
  
  // Apply compression
  master.comp.threshold.rampTo(config.comp.threshold, 0.5);
  master.comp.ratio.value = config.comp.ratio;
  master.comp.attack.rampTo(config.comp.attack, 0.5);
  master.comp.release.rampTo(config.comp.release, 0.5);
  
  // Apply filtering
  state.lowCut = config.lowCut;
  state.highCut = config.highCut;
  master.lowCutFilter.frequency.rampTo(config.lowCut, 0.5);
  master.highCutFilter.frequency.rampTo(config.highCut, 0.5);
  
  // Apply tape saturation
  state.tapeSaturation = config.tape;
  master.tapeDistortion.distortion = config.tape / 100 * 0.2;
  master.tapeDistortion.wet.rampTo(config.tape / 100 * 0.6, 0.5);
  
  // Update UI
  document.getElementById('compSlider').value = config.comp.threshold;
  document.getElementById('compValue').textContent = config.comp.threshold + 'dB';
  document.getElementById('lowCutSlider').value = config.lowCut;
  document.getElementById('lowCutValue').textContent = config.lowCut + 'Hz';
  document.getElementById('highCutSlider').value = config.highCut;
  document.getElementById('highCutValue').textContent = (config.highCut / 1000).toFixed(1) + 'kHz';
  document.getElementById('tapeSlider').value = config.tape;
  document.getElementById('tapeValue').textContent = config.tape + '%';
  
  showToast(`✅ Applied "${preset}" mastering`, 'success');
}
  
function setupTransportControls() {
  document.getElementById('playBtn').addEventListener('click', togglePlay);
  document.getElementById('stopBtn').addEventListener('click', stop);
  document.getElementById('exportBtn').addEventListener('click', exportAudio);
  
  // Metronome controls
  document.getElementById('metronomeBtn')?.addEventListener('click', () => {
    state.metronomeEnabled = !state.metronomeEnabled;
    const btn = document.getElementById('metronomeBtn');
    btn.textContent = state.metronomeEnabled ? '🥁 Click: On' : '🥁 Click: Off';
  });
  
  document.getElementById('countInBtn')?.addEventListener('click', () => {
    state.countInBars = state.countInBars === 1 ? 2 : state.countInBars === 2 ? 0 : 1;
    const btn = document.getElementById('countInBtn');
    const labels = ['⏱️ Count: Off', '⏱️ Count: 1 bar', '⏱️ Count: 2 bars'];
    btn.textContent = labels[state.countInBars];
  });
}

function setupParameterControls() {
  // BPM with debounce
  const bpmHandler = debounce(value => {
    state.bpm = clamp(value, 60, CONFIG.MAX_BPM);
    Tone.Transport.bpm.value = state.bpm;
  }, CONFIG.DEBOUNCE_MS);
  
  document.getElementById('bpmSlider').addEventListener('input', e => {
    const value = parseInt(e.target.value, 10);
    document.getElementById('bpmValue').textContent = value;
    bpmHandler(value);
  });
  
  // Swing
  document.getElementById('swingSlider').addEventListener('input', e => {
    state.swing = parseInt(e.target.value, 10);
    document.getElementById('swingValue').textContent = state.swing + '%';
    Tone.Transport.swing = state.swing / 100;
    Tone.Transport.swingSubdivision = '8n';
  });
  
  // Duration
  document.getElementById('durSlider').addEventListener('input', e => {
    state.duration = parseInt(e.target.value, 10);
    document.getElementById('durValue').textContent = state.duration + ' min';
    document.getElementById('durationDisplay').textContent = 
      '/ ' + String(state.duration).padStart(2, '0') + ':00';
  });
  
  // Complexity
  document.getElementById('complexSlider').addEventListener('input', e => {
    state.complexity = parseInt(e.target.value, 10);
    const labels = ['Simple', 'Medium', 'Complex'];
    document.getElementById('complexValue').textContent = labels[state.complexity - 1];
  });
  
  // Humanize
  document.getElementById('humanSlider').addEventListener('input', e => {
    state.humanize = parseInt(e.target.value, 10);
    document.getElementById('humanValue').textContent = state.humanize + 'ms';
  });
  
  // Master controls
  setupMasterControls();
}

function setupMasterControls() {
  const masterVolSlider  = document.getElementById('masterVolSlider');
  const masterVolValue   = document.getElementById('masterVolValue');
  const masterFader      = document.getElementById('masterFader');
  const masterFaderLabel = document.getElementById('masterFaderLabel');

  // ---- MASTER VOLUME SYNC (Mixer slider <-> Master strip fader) ----
  function applyMasterVolume(db, source) {
    // Persist in state
    state.masterVolume = db;

    // Mixer tab label
    if (masterVolValue) {
      masterVolValue.textContent = db.toFixed(0) + 'dB';
    }

    // Master strip label
    if (masterFaderLabel) {
      masterFaderLabel.textContent = db.toFixed(1) + ' dB';
    }

    // Keep controls in sync, but avoid loops
    if (masterVolSlider && source !== 'slider') {
      masterVolSlider.value = db;
    }
    if (masterFader && source !== 'fader') {
      masterFader.value = db;
    }

    // Actually apply to audio
    // (this is what you already had for the mixer slider)
    Tone.Destination.volume.rampTo(db, 0.1);
  }

  // Initial volume (default 0 dB)
  const initialDb =
    typeof state.masterVolume === 'number' ? state.masterVolume : 0;
  applyMasterVolume(initialDb);

  // Mixer Master Volume slider (horizontal, existing control)
  if (masterVolSlider) {
    masterVolSlider.addEventListener(
      'input',
      debounce((e) => {
        const db = parseInt(e.target.value, 10);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'slider');
      }, 100)
    );
  }

  // NEW: Master Strip fader (vertical, in multitrack column)
  if (masterFader) {
    masterFader.addEventListener(
      'input',
      debounce((e) => {
        const db = parseFloat(e.target.value);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'fader');
      }, 50)
    );
  }

  // ---- EXISTING MASTER FX CONTROLS (unchanged, just moved under here) ----

  const tapeSlider = document.getElementById('tapeSlider');
  if (tapeSlider) {
    tapeSlider.addEventListener(
      'input',
      debounce((e) => {
        state.tapeSaturation = parseInt(e.target.value, 10);
        document.getElementById('tapeValue').textContent =
          state.tapeSaturation + '%';
        if (master.tapeDistortion) {
          master.tapeDistortion.distortion =
            (state.tapeSaturation / 100) * 0.2; // Reduced
          master.tapeDistortion.wet.rampTo(
            (state.tapeSaturation / 100) * 0.6,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const vinylSlider = document.getElementById('vinylSlider');
  if (vinylSlider) {
    vinylSlider.addEventListener(
      'input',
      debounce((e) => {
        state.vinylNoise = parseInt(e.target.value, 10);
        document.getElementById('vinylValue').textContent =
          state.vinylNoise + '%';
        if (master.vinylNoise) {
          master.vinylNoise.volume.rampTo(
            -50 + (state.vinylNoise / 100) * 15,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const lowCutSlider = document.getElementById('lowCutSlider');
  if (lowCutSlider) {
    lowCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.lowCut = parseInt(e.target.value, 10);
        document.getElementById('lowCutValue').textContent =
          state.lowCut + 'Hz';
        if (master.lowCutFilter) {
          master.lowCutFilter.frequency.rampTo(state.lowCut, 0.15); // Slower ramp
        }
      }, 100)
    );
  }

  const highCutSlider = document.getElementById('highCutSlider');
  if (highCutSlider) {
    highCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.highCut = parseInt(e.target.value, 10);
        document.getElementById('highCutValue').textContent =
          state.highCut + 'Hz';
        if (master.highCutFilter) {
          master.highCutFilter.frequency.rampTo(state.highCut, 0.15);
        }
      }, 100)
    );
  }

  const compSlider = document.getElementById('compressorSlider');
  if (compSlider) {
    compSlider.addEventListener(
      'input',
      debounce((e) => {
        state.compressor = parseInt(e.target.value, 10);
        document.getElementById('compressorValue').textContent =
          state.compressor + 'dB';
        if (master.comp) {
          master.comp.threshold.rampTo(state.compressor, 0.15);
        }
      }, 100)
    );
  }

  // Finally: wire up the master meters
  setupMasterMeters();
}

function setupMasterMeters() {
  if (!master || !master.meter) return;

  const meterL = document.getElementById('masterMeterL');
  const meterR = document.getElementById('masterMeterR');
  if (!meterL || !meterR) return;

  // Ensure inner fill elements exist
  function ensureFill(el) {
    let fill = el.querySelector('.daw-meter-fill');
    if (!fill) {
      fill = document.createElement('div');
      fill.className = 'daw-meter-fill';
      el.appendChild(fill);
    }
    return fill;
  }

  const fillL = ensureFill(meterL);
  const fillR = ensureFill(meterR);

  function dbToNorm(db) {
    if (db === -Infinity) return 0;
    const minDb = -60;
    if (db < minDb) db = minDb;
    const norm = (db - minDb) / -minDb; // map [-60,0] → [0,1]
    return Math.max(0, Math.min(norm, 1));
  }

  function update() {
    // Tone.Meter returns either a single value or an array for stereo
    const value = master.meter.getValue();
    let left, right;

    if (Array.isArray(value)) {
      left = value[0];
      right = value[1] != null ? value[1] : value[0];
    } else {
      left = right = value;
    }

    const lNorm = dbToNorm(left);
    const rNorm = dbToNorm(right);

    fillL.style.height = (lNorm * 100).toFixed(1) + '%';
    fillR.style.height = (rNorm * 100).toFixed(1) + '%';

    requestAnimationFrame(update);
  }

  requestAnimationFrame(update);
}

function setupGeneratorButtons() {
  document.getElementById('generateBtn').addEventListener('click', () => {
    generateBeat();
    if (state.complexity >= 2) {
      addRhythmicVariety();
    }
  });
  
  document.getElementById('generateRhythmBtn').addEventListener('click', () => {
    generateMelodicPatterns();
    addDrumFills();
    addSwingVariations();
  });

  document.getElementById('aiVariationBtn')?.addEventListener('click', generateAIVariation);
  document.getElementById('aiMelodicBtn')?.addEventListener('click', generateMelodicAIVariation);
  
  document.querySelectorAll('.groove-template-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const template = e.currentTarget.dataset.template;
      applyGrooveTemplate(template);
    });
  });
  
  document.getElementById('randomVelBtn').addEventListener('click', randomizeVelocity);
  document.getElementById('randomProbBtn').addEventListener('click', randomizeProbability);
  document.getElementById('clearBtn').addEventListener('click', clearPattern);
}

function setupSequencerControls() {
  document.getElementById('lenDecBtn').addEventListener('click', () => {
    state.sequenceLength = Math.max(CONFIG.MIN_SEQUENCE_LENGTH, state.sequenceLength - 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('lenIncBtn').addEventListener('click', () => {
    state.sequenceLength = Math.min(CONFIG.MAX_SEQUENCE_LENGTH, state.sequenceLength + 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('resSelect').addEventListener('change', e => {
    state.resolution = e.target.value;
  });
  
  document.getElementById('euclidBtn').addEventListener('click', applyEuclidean);
  document.getElementById('ghostBtn').addEventListener('click', addGhostNotes);
  
  // Delegated sequencer events
  const seqGrid = document.getElementById('seqGrid');
  seqGrid.addEventListener('click', handleSequencerClick);
}

function handleSequencerClick(e) {
  const stepEl = e.target.closest('.step');
  if (stepEl) {
    const inst = stepEl.dataset.inst;
    const step = parseInt(stepEl.dataset.step, 10);
    toggleStep(inst, step, e);
    return;
  }
  
  const icon = e.target.closest('.seq-icon');
  if (icon) {
    const inst = icon.dataset.inst;
    const action = icon.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    } else if (action === 'note') {
      openNoteEditor(inst);
    }
    
    renderSequencer();
  }
}

function setupMixerListeners() {
  const mixerGrid = document.getElementById('mixerGrid');
  
  mixerGrid.addEventListener('click', e => {
    const btn = e.target.closest('.channel-btn');
    if (!btn) return;
    
    const inst = btn.dataset.inst;
    const action = btn.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    }
    
    renderMixer();
    renderSequencer();
  });
  
  mixerGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;
    
    const inst = e.target.dataset.inst;
    const param = e.target.dataset.param;
    const value = parseFloat(e.target.value);
    
    instruments[inst][param] = value;
    
    if (param === 'volume' && instruments[inst].channel) {
      instruments[inst].channel.volume.value = value;
    } else if (param === 'pan' && instruments[inst].channel) {
      instruments[inst].channel.pan.value = value / 100;
    }
    
    const parent = e.target.closest('.param-control');
    const valEl = parent.querySelector('.param-value');
    
    if (param === 'volume') {
      valEl.textContent = value + 'dB';
    } else if (param === 'pan') {
      const label = value > 0 ? 'R' : value < 0 ? 'L' : 'C';
      valEl.textContent = label + Math.abs(value);
    }
  });

  // AI Mixing controls
  const toggleAIBtn = document.getElementById('toggleAIMixingBtn');
  const applyAIMixBtn = document.getElementById('applyAIMixBtn');
  const aiStatus = document.getElementById('aiMixingStatus');
  
  if (toggleAIBtn) {
    toggleAIBtn.addEventListener('click', () => {
      state.aiMixing.enabled = !state.aiMixing.enabled;
      aiStatus.textContent = state.aiMixing.enabled ? 'Disable AI' : 'Enable AI';
      toggleAIBtn.classList.toggle('btn-success', state.aiMixing.enabled);
      applyAIMixBtn.disabled = !state.aiMixing.enabled;
      
      if (state.aiMixing.enabled) {
        showToast('✅ AI Mixing enabled', 'success');
      }
    });
  }
  
  if (applyAIMixBtn) {
    applyAIMixBtn.addEventListener('click', () => applyAIMixing());
  }
  
  ['autoGain', 'autoPan', 'autoEQ', 'autoComp'].forEach(feature => {
    const checkbox = document.getElementById(feature + 'Checkbox');
    if (checkbox) {
      checkbox.addEventListener('change', (e) => {
        const key = feature === 'autoComp' ? 'autoCompression' : feature;
        state.aiMixing[key] = e.target.checked;
      });
    }
  });
  
  // Mastering presets
  document.querySelectorAll('[data-master-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      const preset = btn.dataset.masterPreset;
      applyMasteringPreset(preset);
    });
  });
}

function setupFXListeners() {
  const fxGrid = document.getElementById('fxGrid');
  
  fxGrid.addEventListener('click', e => {
    const toggle = e.target.closest('.fx-toggle');
    if (!toggle) return;
    
    const fx = toggle.dataset.fx;
    fxConfig[fx].active = !fxConfig[fx].active;
    
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = fxConfig[fx].active ? 0.5 : 0;
    }
    
    renderFX();
  });
  
  fxGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;
    
    const fx = e.target.dataset.fx;
    const param = e.target.dataset.param;
    const raw = parseInt(e.target.value, 10);
    const value = mapFxParam(param, raw);
    
    fxConfig[fx][param] = value;
    applyFxParam(fx, param, value);
    
    const label = e.target.closest('.param-control').querySelector('.param-value');
    label.textContent = formatFxDisplay(param, value);
  });
}

function setupHarmonyControls() {
  document.getElementById('keySelect').addEventListener('change', e => {
    state.key = e.target.value;
    updateChords();
  });
  
  document.getElementById('scaleSelect').addEventListener('change', e => {
    state.scale = e.target.value;
    updateChords();
  });
  
  document.getElementById('octaveSelect').addEventListener('change', e => {
    state.octave = parseInt(e.target.value, 10);
  });
  
  document.getElementById('genProgBtn').addEventListener('click', generateProgression);
  document.getElementById('clearProgBtn').addEventListener('click', () => {
    state.progression = [];
    renderProgression();
  });
  
  document.querySelectorAll('[data-prog]').forEach(btn => {
    btn.addEventListener('click', e => {
      loadProgressionTemplate(e.currentTarget.dataset.prog);
    });
  });
}

function setupProjectManagement() {
  document.getElementById('saveBtn').addEventListener('click', saveProject);
  document.getElementById('loadBtn').addEventListener('click', loadProject);
}

function setupKeyboardShortcuts() {
  // Detect if device is mobile/tablet
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);
  
  // Don't enable keyboard shortcuts on mobile devices
  if (isMobile) {
    console.log('📱 Mobile device detected - keyboard shortcuts disabled');
    return;
  }

  document.addEventListener('keydown', e => {
    // Also check if user is typing in an input field
    const isTyping = e.target.tagName === 'INPUT' || 
                     e.target.tagName === 'TEXTAREA' || 
                     e.target.isContentEditable;
    
    if (isTyping) return; // Don't trigger shortcuts while typing

    // Basic transport shortcuts
    if (e.code === 'Space') {
      e.preventDefault();
      togglePlay();
    } else if (e.code === 'KeyS') {
      e.preventDefault();
      stop();
    } else if (e.code === 'KeyE') {
      e.preventDefault();
      exportAudio();
    }

    // === NEW MULTITRACK SHORTCUTS ===
    if (e.code === 'KeyX' && !e.ctrlKey && !e.metaKey) {
      // Split at playhead
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'split'
        );
      }
    }

    if (e.code === 'KeyD' && (e.ctrlKey || e.metaKey)) {
      // Duplicate region
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'duplicate'
        );
      }
    }

    if ((e.code === 'Delete' || e.code === 'Backspace') && !isTyping) {
      // Delete selected region
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        e.preventDefault();
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        const track = multitrack.tracks.find(t => t.id === trackId);
        if (track && confirm('Delete selected region?')) {
          track.deleteTake(takeIndex);
          renderMultitrack();
        }
      }
    }

    // Zoom shortcuts
    if (e.code === 'Equal' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomInBtn')?.click();
    }
    
    if (e.code === 'Minus' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomOutBtn')?.click();
    }
    
    // === UNDO/REDO ===
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && !e.shiftKey) {
      e.preventDefault();
      multitrackHistory.undo();
    }
      
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'KeyZ') {
      e.preventDefault();
      multitrackHistory.redo();
    }
      
    // Alternative: Ctrl+Y for redo
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {
      e.preventDefault();
      multitrackHistory.redo();
    }
  });
}


function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      applyVibe(nextVibe());
    });
  }
}

// -------------------- FX Parameter Mapping --------------------
function mapFxParam(param, raw) {
  switch (param) {
    case 'decay':
      return raw / 20;
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return raw / 100;
    case 'time':
      return ['16n', '8n', '4n', '2n'][Math.min(3, Math.floor(raw / 25))];
    case 'frequency':
      return 100 + raw * 79;
    case 'octaves':
      return Math.floor(raw / 20) + 1;
    default:
      return raw / 50;
  }
}

function applyFxParam(fx, param, value) {
  const node = effects[fx];
  if (!node) return;
  
  if (param === 'decay' && node.decay !== undefined) {
    node.decay = value;
  } else if (param === 'wet' && node.wet) {
    node.wet.value = value;
  } else if (param === 'time' && node.delayTime) {
    node.delayTime.value = Tone.Time(value);
  } else if (param === 'feedback' && node.feedback) {
    node.feedback.value = value;
  } else if (param === 'frequency') {
    // Safe frequency updates with ramp to avoid clicks
    if (node.frequency) {
      node.frequency.rampTo(value, 0.1);
    }
  } else if (param === 'depth') {
    if (node.depth !== undefined) {
      node.depth = value;
    }
  } else if (param === 'amount' && node.distortion !== undefined) {
    node.distortion = value;
  } else if (param === 'octaves' && node.octaves !== undefined) {
    node.octaves = value;
  }
}

function formatFxDisplay(param, value) {
  switch (param) {
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return Math.round(value * 100) + '%';
    case 'decay':
      return value.toFixed(2) + 's';
    case 'time':
      return String(value);
    case 'frequency':
      return Math.round(value) + 'Hz';
    case 'octaves':
      return value + ' oct';
    default:
      return String(value);
  }
}

// -------------------- Sequencer Rendering --------------------
function renderSequencer() {
  const grid = document.getElementById('seqGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const instData = instruments[inst];
    const row = document.createElement('div');
    row.className = 'seq-row';
    
    // Label
    const label = document.createElement('div');
    label.className = 'seq-label';
    label.innerHTML = `
      <span>${instData.icon} ${instData.name}</span>
      <div class="seq-icons">
        <button class="seq-icon ${instData.mute ? 'active' : ''}" 
                data-inst="${inst}" data-action="mute">M</button>
        <button class="seq-icon ${instData.solo ? 'active' : ''}" 
                data-inst="${inst}" data-action="solo">S</button>
        ${instData.type === 'melodic' ? 
          `<button class="seq-icon" data-inst="${inst}" data-action="note">🎵</button>` : ''}
      </div>
    `;
    row.appendChild(label);
    
    // Steps
    for (let i = 0; i < state.sequenceLength; i++) {
      const step = patterns[inst][i];
      const cell = document.createElement('div');
      cell.className = 'step';
      cell.dataset.inst = inst;
      cell.dataset.step = i;
      
      if (step.active) {
        cell.classList.add('active');
        
        const probLabel = document.createElement('div');
        probLabel.className = 'step-prob';
        
        if (instData.type === 'melodic' && step.note) {
          probLabel.textContent = step.note;
          probLabel.style.fontSize = '0.6rem';
        } else {
          probLabel.textContent = step.probability + '%';
        }
        
        cell.appendChild(probLabel);
        
        const velBar = document.createElement('div');
        velBar.className = 'step-vel';
        velBar.innerHTML = `<div class="step-vel-fill" 
          style="width:${Math.round((step.velocity || 0) * 100)}%"></div>`;
        cell.appendChild(velBar);
      }
      
      row.appendChild(cell);
    }
    
    fragment.appendChild(row);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
  
  // Playhead
  let playhead = document.getElementById('playhead');
  if (!playhead) {
    playhead = document.createElement('div');
    playhead.id = 'playhead';
    playhead.className = 'playhead';
    document.querySelector('.sequencer').appendChild(playhead);
  }
}

function toggleStep(inst, stepIndex, e) {
  const pattern = patterns[inst][stepIndex];
  const instData = instruments[inst];
  
  if (e.altKey) {
    if (pattern.active) {
      pattern.velocity = Math.min(1, (pattern.velocity || 0.8) + 0.2);
      if (pattern.velocity > 1) pattern.velocity = 0.4;
    }
  } else if (e.shiftKey) {
    if (pattern.active) {
      if (instData.type === 'melodic') {
        cycleNote(inst, stepIndex);
      } else {
        pattern.probability = Math.min(100, pattern.probability + 25);
        if (pattern.probability > 100) pattern.probability = 50;
      }
    }
  } else if (e.ctrlKey || e.metaKey) {
    if (instData.type === 'melodic' && pattern.active) {
      const newNote = prompt(
        `Enter note (e.g., C4, D#3):`,
        pattern.note || instData.note
      );
      if (newNote && /^[A-G]#?[1-6]$/.test(newNote)) {
        pattern.note = newNote;
      }
    }
  } else {
    pattern.active = !pattern.active;
    if (pattern.active) {
      pattern.velocity = 0.8;
      pattern.probability = 100;
      if (instData.type === 'melodic') {
        pattern.note = instData.note;
        pattern.duration = '8n';
      }
    }
  }
  
  renderSequencer();
}

function cycleNote(inst, stepIndex) {
  const pattern = patterns[inst][stepIndex];
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const currentNote = pattern.note || instruments[inst].note;
  const match = currentNote.match(/^([A-G]#?)(\d+)$/);
  if (!match) return;
  
  const [, noteName, octave] = match;
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12]);
  const index = scaleNotes.indexOf(noteName);
  const nextNote = scaleNotes[(index + 1 + scaleNotes.length) % scaleNotes.length] + octave;
  
  pattern.note = nextNote;
}

function updateStepVisuals(step) {
  const widthPerStep = 100 / state.sequenceLength;
  const playhead = document.getElementById('playhead');
  if (playhead) {
    playhead.style.transform = `translateX(${(step + 0.5) * widthPerStep}%)`;
  }
}

function openNoteEditor(inst) {
  // Create modal backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  // Get current note
  const currentNote = instruments[inst].note || 'C4';
  
  // Generate all possible notes (C1 to C6)
  const allNotes = [];
  for (let octave = 1; octave <= 6; octave++) {
    keysArr.forEach(note => {
      allNotes.push(note + octave);
    });
  }
  
  modal.innerHTML = `
    <div class="pro-locked">
      <div class="modal-header">
        <div class="modal-title">🎵 ${instruments[inst].icon} ${instruments[inst].name} - Select Note</div>
        <button class="modal-close" id="closeNoteModal">✕</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: var(--space-4); color: var(--text-secondary);">
          Choose the default note for <strong>${instruments[inst].name}</strong>. 
          This will apply to all active steps that don't have a custom note set.
        </p>
        
        <div style="display: grid; gap: var(--space-3);">
          <label style="display: flex; flex-direction: column; gap: var(--space-2);">
            <span style="font-weight: 700; color: var(--text-primary);">Note</span>
            <select id="noteSelect" style="font-size: var(--text-base); padding: var(--space-4);">
              ${allNotes.map(note => 
                `<option value="${note}" ${note === currentNote ? 'selected' : ''}>${note}</option>`
              ).join('')}
            </select>
          </label>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border);">
            <div style="font-weight: 700; margin-bottom: var(--space-2); color: var(--text-primary);">Current: ${currentNote}</div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              Lower octaves (1-2) = Bass range<br>
              Mid octaves (3-4) = Chord/melody range<br>
              High octaves (5-6) = Lead range
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelNoteBtn">Cancel</button>
        <button class="btn btn-primary" id="applyNoteBtn">Apply Note</button>
      </div>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  // Focus the select
  setTimeout(() => document.getElementById('noteSelect').focus(), 100);
  
  // Event handlers
  const close = () => backdrop.remove();
  
  document.getElementById('closeNoteModal').onclick = close;
  document.getElementById('cancelNoteBtn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  document.getElementById('applyNoteBtn').onclick = () => {
    const newNote = document.getElementById('noteSelect').value;
    instruments[inst].note = newNote;
    
    // Update all active steps without custom notes
    patterns[inst].forEach(step => {
      if (step.active && !step.note) {
        step.note = newNote;
      }
    });
    
    renderSequencer();
    close();
    
    // Show confirmation toast
    showToast(`🎵 ${instruments[inst].name} note set to ${newNote}`, 'success');
  };
  
  // Keyboard support
  modal.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
    if (e.key === 'Enter' && e.target.tagName !== 'SELECT') {
      document.getElementById('applyNoteBtn').click();
    }
  });
}

function showToast(message, type = 'info') {
  let container = document.querySelector('.toast-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'toast-container';
    document.body.appendChild(container);
  }
  
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: '✓',
    error: '✕',
    warning: '⚠',
    info: 'ℹ'
  };
  
  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || icons.info}</span>
    <span>${message}</span>
    <button class="toast-close">✕</button>
  `;
  
  container.appendChild(toast);
  
  toast.querySelector('.toast-close').onclick = () => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => toast.remove(), 200);
  };
  
  // Auto-dismiss faster based on message length
  const baseTime = 1500; // 1.5s base
  const charTime = message.length * 30; // 30ms per character
  const dismissTime = Math.min(baseTime + charTime, 2000); // Max 2s
  
  setTimeout(() => {
    if (toast.parentElement) {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      setTimeout(() => toast.remove(), 200);
    }
  }, dismissTime);
  
  // Limit to 3 toasts at once
  const toasts = container.querySelectorAll('.toast');
  if (toasts.length > 3) {
    toasts[0].remove();
  }
}
  
// -------------------- Pattern Generators --------------------
function generateBeat() {
  const genre = state.currentGenre;
  
  // Clear all patterns first
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
    });
  });
  
  // Generate rhythms based on genre theory
  if (genre === 'lofi') {
    generateLoFiBeat();
  } else if (genre === 'hiphop') {
    generateHipHopBeat();
  } else if (genre === 'postpunk') {
    generatePostPunkBeat();
  } else if (genre === 'rnb') {
    generateRnBBeat();
  } else if (genre === 'ambient') {
    generateAmbientBeat();
  } else if (genre === 'dazecore') {
    generateDazecoreBeat();
  }
  
  renderSequencer();
  
  // Auto-apply AI mixing if enabled
  if (state.aiMixing.enabled) {
    setTimeout(() => applyAIMixing(), 500);
  }
  
  console.log(`✅ Generated ${genre} beat with ${state.complexity} complexity at ${state.bpm} BPM`);
}
  
// AI-powered beat generation
function generateAIVariation() {
  const activeInsts = Object.keys(patterns).filter(inst =>
    patterns[inst].some(s => s.active)
  );
  
  if (activeInsts.length === 0) {
    showToast('❌ Generate a beat first', 'error');
    return;
  }
  
  showToast('🤖 AI generating variation...', 'info');
  
  // Analyze current pattern
  const analysis = analyzePattern();
  
  // Generate variation based on style
  const variationType = Math.random();
  
  if (variationType < 0.25) {
    generateRhythmicDisplacement(analysis);
    showToast('🎲 Applied: Rhythmic Displacement', 'success');
  } else if (variationType < 0.5) {
    generateDensityVariation(analysis);
    showToast('🎲 Applied: Density Variation', 'success');
  } else if (variationType < 0.75) {
    generatePolyrhythmicLayer(analysis);
    showToast('🎲 Applied: Polyrhythmic Layer', 'success');
  } else {
    generateSyncopation(analysis);
    showToast('🎲 Applied: Syncopation', 'success');
  }
  
  renderSequencer();
}

function analyzePattern() {
  const analysis = {
    density: {},
    complexity: 0,
    activeSteps: 0,
    totalSteps: state.sequenceLength,
    instruments: {}
  };
  
  Object.keys(instruments).forEach(inst => {
    const steps = patterns[inst];
    const active = steps.filter(s => s.active).length;
    
    analysis.instruments[inst] = {
      density: active / state.sequenceLength,
      avgVelocity: active > 0 
        ? steps.filter(s => s.active).reduce((sum, s) => sum + s.velocity, 0) / active
        : 0,
      pattern: steps.map(s => s.active ? 1 : 0)
    };
    
    analysis.activeSteps += active;
  });
  
  analysis.complexity = analysis.activeSteps / (state.sequenceLength * Object.keys(instruments).length);
  
  return analysis;
}

function generateRhythmicDisplacement(analysis) {
  // Shift patterns by random amounts to create variation
  const shiftAmount = Math.floor(Math.random() * 4) + 1;
  
  Object.keys(instruments).forEach(inst => {
    if (Math.random() > 0.6) return; // Only shift 40% of instruments
    
    const oldPattern = [...patterns[inst]];
    
    for (let i = 0; i < state.sequenceLength; i++) {
      const newIndex = (i + shiftAmount) % state.sequenceLength;
      patterns[inst][newIndex] = { ...oldPattern[i] };
    }
  });
}

function generateDensityVariation(analysis) {
  // Add or remove notes to change groove density
  const shouldAdd = Math.random() > 0.5;
  
  Object.keys(instruments).forEach(inst => {
    const currentDensity = analysis.instruments[inst].density;
    
    if (shouldAdd && currentDensity < 0.6) {
      // Add ghost notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (!patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = true;
          patterns[inst][i].velocity = 0.3 + Math.random() * 0.2;
          patterns[inst][i].probability = 60 + Math.random() * 30;
        }
      }
    } else if (!shouldAdd && currentDensity > 0.3) {
      // Remove some notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = false;
        }
      }
    }
  });
}

function generatePolyrhythmicLayer(analysis) {
  // Add polyrhythmic patterns (e.g., 3-over-4, 5-over-4)
  const polyrhythms = [3, 5, 7];
  const poly = polyrhythms[Math.floor(Math.random() * polyrhythms.length)];
  
  // Choose a percussive instrument
  const percInsts = Object.keys(instruments).filter(k => 
    instruments[k].type === 'drum' || instruments[k].type === 'atmospheric'
  );
  
  if (percInsts.length === 0) return;
  
  const inst = percInsts[Math.floor(Math.random() * percInsts.length)];
  
  // Clear existing pattern
  patterns[inst].forEach(s => s.active = false);
  
  // Apply polyrhythm
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % Math.floor(state.sequenceLength / poly) === 0) {
      patterns[inst][i].active = true;
      patterns[inst][i].velocity = 0.6 + Math.random() * 0.2;
      patterns[inst][i].probability = 90 + Math.random() * 10;
    }
  }
}

function generateSyncopation(analysis) {
  // Add off-beat accents
  Object.keys(instruments).forEach(inst => {
    const instData = instruments[inst];
    if (instData.type !== 'drum') return;
    
    for (let i = 0; i < state.sequenceLength; i++) {
      // Target off-beats (odd steps)
      if (i % 2 === 1 && !patterns[inst][i].active && Math.random() > 0.6) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.5 + Math.random() * 0.3;
        patterns[inst][i].probability = 70 + Math.random() * 25;
      }
      
      // Occasionally accent existing off-beats
      if (i % 2 === 1 && patterns[inst][i].active && Math.random() > 0.7) {
        patterns[inst][i].velocity = Math.min(1, patterns[inst][i].velocity * 1.3);
      }
    }
  });
}

// Melodic AI variations
function generateMelodicAIVariation() {
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  if (!melodicInsts.some(inst => patterns[inst].some(s => s.active))) {
    showToast('❌ Generate melodies first', 'error');
    return;
  }
  
  showToast('🎹 AI generating melodic variation...', 'info');
  
  const variationType = Math.random();
  
  if (variationType < 0.33) {
    generateMelodicInversion();
    showToast('🎲 Applied: Melodic Inversion', 'success');
  } else if (variationType < 0.66) {
    generateArpeggiation();
    showToast('🎲 Applied: Arpeggiation', 'success');
  } else {
    generateHarmonicVariation();
    showToast('🎲 Applied: Harmonic Variation', 'success');
  }
  
  renderSequencer();
}

function generateMelodicInversion() {
  // Invert melodic contours
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  melodicInsts.forEach(inst => {
    const notes = patterns[inst]
      .filter(s => s.active && s.note)
      .map(s => s.note);
    
    if (notes.length === 0) return;
    
    // Find pivot point (median note)
    const midiNotes = notes.map(n => Tone.Frequency(n).toMidi());
    const pivot = midiNotes.reduce((a, b) => a + b, 0) / midiNotes.length;
    
    // Invert around pivot
    patterns[inst].forEach(step => {
      if (step.active && step.note) {
        const midi = Tone.Frequency(step.note).toMidi();
        const distance = midi - pivot;
        const newMidi = Math.round(pivot - distance);
        step.note = Tone.Frequency(newMidi, 'midi').toNote();
      }
    });
  });
}

function generateArpeggiation() {
  // Convert chords to arpeggios
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = state.octave;
  
  // Target keys instrument
  patterns.keys.forEach(step => step.active = false);
  
  // Create ascending arpeggio
  const arpPattern = [0, 2, 4, 2]; // I - III - V - III
  const arpSpeed = 2; // Every 2 steps
  
  for (let i = 0; i < state.sequenceLength; i += arpSpeed) {
    const degree = arpPattern[(i / arpSpeed) % arpPattern.length];
    const note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + octave;
    
    if (i < state.sequenceLength) {
      patterns.keys[i].active = true;
      patterns.keys[i].note = note;
      patterns.keys[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.keys[i].duration = '8n';
    }
  }
}

function generateHarmonicVariation() {
  // Change chord voicings/extensions
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = state.octave;
  
  patterns.keys.forEach((step, idx) => {
    if (!step.active) return;
    
    // Add 9ths and 11ths for color
    if (Math.random() > 0.5) {
      const baseNote = Array.isArray(step.note) ? step.note[0] : step.note;
      const match = baseNote.match(/^([A-G]#?)(\d+)$/);
      if (!match) return;
      
      const [, noteName, oct] = match;
      const noteIndex = keysArr.indexOf(noteName);
      
      // Add extensions
      const extensions = [];
      
      // 9th
      if (Math.random() > 0.3) {
        const ninth = keysArr[(noteIndex + scaleIntervals[1]) % 12] + (parseInt(oct) + 1);
        extensions.push(ninth);
      }
      
      // 11th
      if (Math.random() > 0.5) {
        const eleventh = keysArr[(noteIndex + scaleIntervals[3]) % 12] + (parseInt(oct) + 1);
        extensions.push(eleventh);
      }
      
      if (extensions.length > 0) {
        const originalChord = Array.isArray(step.note) ? step.note : [step.note];
        step.note = [...originalChord, ...extensions];
      }
    }
  });
}

// Groove template system
function applyGrooveTemplate(template) {
  const templates = {
    shuffle: {
      name: 'Shuffle',
      // swing: 66,  // REMOVED - user controls this
      hihatPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      velocityMap: [0.8, 0.4, 0.7, 0.35, 0.8, 0.4, 0.7, 0.35]
    },
    halfTime: {
      name: 'Half-Time',
      // bpmMultiplier: 0.5,  // REMOVED
      kickPattern: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
    },
    doubleTime: {
      name: 'Double-Time',
      // bpmMultiplier: 2,  // REMOVED
      kickPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      hihatPattern: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    },
    breakbeat: {
      name: 'Breakbeat',
      kickPattern: [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1],
      complexity: 3
    }
  };
  
  const groove = templates[template];
  if (!groove) return;
  
  showToast(`🎵 Applying ${groove.name} groove...`, 'info');
  
  // NO BPM OR SWING CHANGES - user controls these for recording!
  
  // Apply patterns (extend to 32 steps if needed)
  if (groove.kickPattern) {
    patterns.kick.forEach((step, i) => {
      const patternIndex = i % groove.kickPattern.length;
      step.active = groove.kickPattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.8;
        step.probability = 100;
      }
    });
  }
  
  if (groove.snarePattern) {
    patterns.snare.forEach((step, i) => {
      const patternIndex = i % groove.snarePattern.length;
      step.active = groove.snarePattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.75;
        step.probability = 100;
      }
    });
  }
  
  if (groove.hihatPattern) {
    patterns.hihat.forEach((step, i) => {
      const patternIndex = i % groove.hihatPattern.length;
      step.active = groove.hihatPattern[patternIndex] === 1;
      if (step.active) {
        const velIdx = i % (groove.velocityMap?.length || 8);
        step.velocity = groove.velocityMap ? groove.velocityMap[velIdx] : 0.6;
        step.probability = 100;
      }
    });
  }
  
  renderSequencer();
  showToast(`✅ ${groove.name} groove applied! (BPM/swing unchanged)`, 'success');
}
  
// Lo-Fi: Laid back, off-grid, jazzy
function generateLoFiBeat() {
  // DON'T set BPM - user controls it
  const len = state.sequenceLength;
  
  // Kick: Sparse, on 1 and 3 throughout entire sequence
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    setStep('kick', offset + 8, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.3) setStep('kick', offset + 6, 0.7, 80);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 10, 0.75, 70);
  }
  
  // Snare: Backbeat on 2 and 4
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) setStep('snare', offset + 14, 0.4, 60);
  }
  
  // Hi-hat: Shuffled 8ths
  for (let i = 0; i < len; i += 2) {
    const vel = i % 4 === 0 ? 0.7 : 0.45;
    setStep('hihat', i, vel, 95);
    if (state.complexity >= 2 && i % 4 === 2) setStep('hihat', i + 1, 0.3, 70);
  }
  
  // Rimshot: Sparse accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.5, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.5, 80);
    }
  }
  
  // Crash: Bar markers
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
    }
  }
}
  
// Hip-Hop: Boom-bap, hard-hitting
function generateHipHopBeat() {
  const len = state.sequenceLength;
  
  // Kick: Boom-bap throughout
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.9, 100);
    setStep('kick', offset + 6, 0.85, 100);
    if (state.complexity >= 2) {
      if (Math.random() > 0.5) setStep('kick', offset + 9, 0.8, 90);
      if (Math.random() > 0.6) setStep('kick', offset + 13, 0.75, 85);
    }
  }
  
  // Snare: Hard backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.9, 100);
    setStep('snare', offset + 12, 0.9, 100);
  }
  
  // Clap: Layer with snare
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('clap', offset + 4, 0.7, 100);
    setStep('clap', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Steady 8ths and 16ths
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    for (let i = 3; i < len; i += 4) {
      setStep('hihat', i, 0.4, 85);
    }
  }
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.5) setStep('crash', offset + 6, 0.5, 75);
      if (Math.random() > 0.5) setStep('crash', offset + 14, 0.5, 75);
    }
  }
  
  // Tom fills at end of each bar
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.65, 95);
        setStep('tom', offset + 14, 0.75, 95);
        setStep('tom', offset + 15, 0.85, 95);
      }
    }
  }
}
  
// Post-Punk: Driving, motorik, relentless
function generatePostPunkBeat() {
  const len = state.sequenceLength;
  const fourOnFloor = Math.random() > 0.3;
  
  // Kick: Four-on-floor or driving 8ths
  if (fourOnFloor) {
    for (let i = 0; i < len; i += 4) {
      setStep('kick', i, 0.85, 100);
    }
  } else {
    for (let i = 0; i < len; i += 2) {
      setStep('kick', i, i % 4 === 0 ? 0.85 : 0.75, 100);
    }
  }
  
  // Snare: Backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.8, 100);
    setStep('snare', offset + 12, 0.8, 100);
    if (state.complexity >= 2) setStep('snare', offset + 10, 0.7, 80);
  }
  
  // Rimshot: Driving 16ths
  if (state.complexity >= 2) {
    for (let i = 1; i < len; i += 2) {
      if (Math.random() > 0.4) setStep('rimshot', i, 0.5, 85);
    }
  }
  
  // Hi-hat: Mechanical 16ths
  for (let i = 0; i < len; i++) {
    const vel = i % 4 === 0 ? 0.7 : 0.5;
    setStep('hihat', i, vel, 100);
  }
  
  // Ride: Alternative
  if (state.complexity >= 3 && Math.random() > 0.5) {
    for (let i = 0; i < len; i += 2) {
      if (Math.random() > 0.3) setStep('ride', i, 0.55, 90);
    }
  }
  
  // Tom fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
        setStep('tom', offset + 15, 0.8, 90);
      }
    }
  }
  
  // Crash on downbeat
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.4) setStep('crash', bar * 16, 0.75, 100);
  }
}
  
// R&B: Syncopated, groovy, pocket
function generateRnBBeat() {
  const len = state.sequenceLength;
  
  // Kick: Syncopated
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.85, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 95);
    setStep('kick', offset + 10, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) setStep('kick', offset + 13, 0.7, 85);
  }
  
  // Snare: Laid back backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) {
      setStep('snare', offset + 11, 0.4, 70);
      setStep('snare', offset + 15, 0.45, 75);
    }
  }
  
  // Rimshot: Syncopated accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.55, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.55, 80);
    }
  }
  
  // Hi-hat: Intricate 16th patterns
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    const offbeats = [1, 3, 5, 9, 11, 13];
    for (let bar = 0; bar < len / 16; bar++) {
      offbeats.forEach(pos => {
        if (Math.random() > 0.3) setStep('hihat', bar * 16 + pos, 0.35, 75);
      });
    }
  }
  
  // Clap: Occasional layers
  if (state.complexity >= 3 && Math.random() > 0.6) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      setStep('clap', offset + 4, 0.5, 85);
      setStep('clap', offset + 12, 0.5, 85);
    }
  }
}
  
// Ambient: Sparse, textural, atmospheric
function generateAmbientBeat() {
  const len = state.sequenceLength;
  
  // Kick: Minimal bar markers
  for (let bar = 0; bar < len / 16; bar++) {
    setStep('kick', bar * 16, 0.7, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) {
      setStep('kick', bar * 16 + 8, 0.65, 90);
    }
  }
  
  // Snare: Very sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) setStep('snare', bar * 16 + 8, 0.5, 85);
    }
  }
  
  // Hi-hat: Sparse texture
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    if (Math.random() > 0.3) setStep('hihat', offset + 0, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 6, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 10, 0.4, 80);
  }
  
  // Crash: Textural swells
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
      if (Math.random() > 0.4) setStep('crash', bar * 16 + 12, 0.55, 80);
    }
  }
  
  // Ride: Subtle pulse
  if (state.complexity >= 3) {
    for (let i = 0; i < len; i += 4) {
      if (Math.random() > 0.3) setStep('ride', i, 0.35, 70);
    }
  }
  
  // Tom: Occasional atmospheric hits
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.7) {
        const tomStep = [4, 8, 12][Math.floor(Math.random() * 3)];
        setStep('tom', bar * 16 + tomStep, 0.45, 75);
      }
    }
  }
}
  
function generateDazecoreBeat() {
  const len = state.sequenceLength;
  
  // Kick: Warm and bouncy
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 90);
    setStep('kick', offset + 12, 0.8, 100);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 3, 0.5, 70);
  }
  
  // Snare: Off-grid, nostalgic
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.7, 100);
    if (state.complexity >= 2) setStep('snare', offset + 7, 0.5, 80);
    setStep('snare', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Shimmering, irregular
  const glitchyHats = [0, 2, 3, 5, 6, 8, 10, 11, 13, 14];
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    glitchyHats.forEach((step, idx) => {
      const vel = idx % 3 === 0 ? 0.65 : 0.4;
      const prob = Math.random() > 0.2 ? 90 : 60;
      setStep('hihat', offset + step, vel, prob);
    });
  }
  
  // Rimshot: Dial-up clicks
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [1, 5, 9].forEach(step => {
        if (Math.random() > 0.4) setStep('rimshot', offset + step, 0.45, 75);
      });
    }
  }
  
  // Clap: Sunny handclaps
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.3) setStep('clap', offset + 7, 0.55, 85);
      if (Math.random() > 0.3) setStep('clap', offset + 15, 0.55, 85);
    }
  }
  
  // Tom: Nostalgic fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
      }
    }
  }
  
  // Crash: Sunshine swells
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.5) setStep('crash', bar * 16, 0.65, 95);
  }
}

// Helper to set a step
function setStep(inst, step, velocity, probability) {
  if (step < state.sequenceLength) {
    patterns[inst][step].active = true;
    patterns[inst][step].velocity = velocity;
    patterns[inst][step].probability = probability;
  }
}

// ==================== BEAT VARIETY GENERATORS ====================

// Add rhythmic variations - keep the groove but make it interesting
function addRhythmicVariety() {
  const len = state.sequenceLength;
  
  // Add syncopated kicks (occasional off-beat hits)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 30% chance to add syncopated kick
      if (Math.random() > 0.7) {
        const positions = [3, 7, 11, 15]; // Syncopated positions
        const pos = positions[Math.floor(Math.random() * positions.length)];
        setStep('kick', offset + pos, 0.65 + Math.random() * 0.15, 85);
      }
    }
  }
  
  // Add hi-hat variations (open hats, rolls)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // Random hi-hat roll at end of bar
      if (Math.random() > 0.6) {
        for (let i = 13; i < 16; i++) {
          if (Math.random() > 0.3) {
            setStep('hihat', offset + i, 0.4 + Math.random() * 0.2, 90);
          }
        }
      }
    }
  }
  
  // Add snare flams (double hits)
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 20% chance to add flam before main snare
      [4, 12].forEach(mainHit => {
        if (Math.random() > 0.8 && !patterns.snare[offset + mainHit - 1].active) {
          setStep('snare', offset + mainHit - 1, 0.4, 80);
        }
      });
    }
  }
  
  // Add crash accents on sections
  if (state.complexity >= 2) {
    const sectionsCount = Math.floor(len / 16);
    for (let i = 0; i < sectionsCount; i += 4) {
      // Every 4 bars, add emphasis
      if (i > 0) {
        setStep('crash', i * 16, 0.7, 100);
      }
    }
  }
  
  renderSequencer();
}

// Create a fill pattern at the end of 4/8 bar sections
function addDrumFills() {
  const len = state.sequenceLength;
  const barsPerFill = state.complexity === 1 ? 8 : state.complexity === 2 ? 4 : 2;
  
  for (let bar = barsPerFill - 1; bar < len / 16; bar += barsPerFill) {
    const fillStart = bar * 16 + 12; // Last 4 steps of bar
    
    if (fillStart + 4 > len) continue;
    
    // Random fill type
    const fillType = Math.floor(Math.random() * 3);
    
    if (fillType === 0) {
      // Tom roll descending
      for (let i = 0; i < 4; i++) {
        setStep('tom', fillStart + i, 0.6 + (i * 0.1), 95);
      }
    } else if (fillType === 1) {
      // Snare roll
      for (let i = 0; i < 4; i++) {
        if (i % 2 === 0 || state.complexity >= 3) {
          setStep('snare', fillStart + i, 0.5 + (i * 0.1), 90);
        }
      }
    } else {
      // Mixed fill (toms + crash)
      setStep('tom', fillStart + 0, 0.6, 95);
      setStep('tom', fillStart + 1, 0.7, 95);
      setStep('snare', fillStart + 2, 0.75, 95);
      setStep('crash', fillStart + 3, 0.8, 100);
    }
  }
  
  renderSequencer();
}

// Add swing feel variations
function addSwingVariations() {
  const len = state.sequenceLength;
  
  // Offset every other hi-hat slightly for swing feel
  for (let i = 1; i < len; i += 4) {
    if (patterns.hihat[i].active) {
      patterns.hihat[i].velocity *= 0.7; // Quieter on off-beats
    }
  }
  
  // Add ghost notes on snare
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      const ghostPositions = [2, 6, 10, 14];
      
      ghostPositions.forEach(pos => {
        if (Math.random() > 0.6 && !patterns.snare[offset + pos].active) {
          setStep('snare', offset + pos, 0.25 + Math.random() * 0.15, 70);
        }
      });
    }
  }
  
  renderSequencer();
}
  
// More subtle variations - don't destroy the groove
function addSubtleVariations() {
  // Only add to hi-hats and rimshots - keep kick/snare solid
  ['hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      // Only 15% chance to add variation on empty steps
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 30;
      }
    }
  });
}

// Add after generateBeat function
function applyGenreFX() {
  if (state.currentGenre === 'postpunk') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 2.0;
    fxConfig.chorus.active = true;
    fxConfig.filter.active = false;
  } else if (state.currentGenre === 'rnb') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.5;
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.3;
    fxConfig.distortion.active = false;
  } else if (state.currentGenre === 'dazecore') {
    // Warm glitchy sunshine sound
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.8; // Nostalgic space
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.5; // Shimmer
    fxConfig.bitcrusher.active = true; // Dial-up glitch texture
    fxConfig.bitcrusher.bits = 6; // Lo-fi crunch
    fxConfig.delay.active = true; // Echo memories
    fxConfig.delay.time = '8n';
    fxConfig.delay.feedback = 0.3;
    fxConfig.filter.active = true; // Warm cut
    fxConfig.filter.frequency = 4000; // Bright but not harsh
  }
  
  // Apply settings
  Object.keys(fxConfig).forEach(fx => {
    const cfg = fxConfig[fx];
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = cfg.active ? 0.25 : 0;
    }
  });
  
  renderFX();
}
  
function addVariations() {
  Object.keys(instruments).forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.2 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.3;
        patterns[inst][i].probability = 50 + Math.random() * 50;
      }
    }
  });
}

function addGhostNotes() {
  ['snare', 'hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.2 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 40;
      }
    }
  });
  renderSequencer();
}

function randomizeVelocity() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.velocity = 0.5 + Math.random() * 0.5;
      }
    });
  });
  renderSequencer();
}

function randomizeProbability() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.probability = 50 + Math.floor(Math.random() * 51);
      }
    });
  });
  renderSequencer();
}

function clearPattern() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
  renderSequencer();
}

function generateMelodicPatterns() {
  const genre = state.currentGenre;
  
  // Generate based on genre characteristics
  if (genre === 'lofi') {
    generateLoFiMelodies();
  } else if (genre === 'hiphop') {
    generateHipHopMelodies();
  } else if (genre === 'postpunk') {
    generatePostPunkMelodies();
  } else if (genre === 'rnb') {
    generateRnBMelodies();
  } else if (genre === 'ambient') {
    generateAmbientMelodies();
  } else if (genre === 'dazecore') {
    generateDazecoreMelodies();
  }
  
  renderSequencer();
}

// Lo-Fi: Jazzy chords, warm bass, sparse leads
function generateLoFiMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root movement, walking feel throughout
  const bassOctave = 2;
  const bassProgression = [0, 3, 4, 0]; // I-IV-V-I progression
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    
    // Main bass notes on downbeats
    [0, 4, 8, 12].forEach((step, idx) => {
      const degree = bassProgression[idx % bassProgression.length];
      patterns.bass[offset + step].active = true;
      patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
      patterns.bass[offset + step].velocity = 0.7;
      patterns.bass[offset + step].duration = '4n';
    });
    
    // Walking bass between roots
    if (state.complexity >= 2) {
      [2, 6, 10, 14].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = [1, 2, 5, 6][idx];
          patterns.bass[offset + step].active = true;
          patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
          patterns.bass[offset + step].velocity = 0.6;
          patterns.bass[offset + step].duration = '8n';
        }
      });
    }
  }
  
  // Keys: Jazz chords (7ths, 9ths)
  const chordOctave = 3;
  const jazzChords = bassProgression.map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = jazzChords[idx % jazzChords.length];
        patterns.keys[offset + step].velocity = 0.5;
        patterns.keys[offset + step].duration = '2n';
      }
    });
  }
  
  // Guitar: Muted strums, sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach((step, idx) => {
        if (Math.random() > 0.5) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = jazzChords[idx % jazzChords.length];
          patterns.guitar[offset + step].velocity = 0.4;
          patterns.guitar[offset + step].duration = '8n';
        }
      });
    }
  }
  
  // Lead: Melodic fragments
  if (state.complexity >= 3) {
    const leadOctave = 4;
    const melody = [0, 2, 4, 2, 0];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (Math.random() > 0.3 && melody[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[melody[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Hip-Hop: Heavy bass, sparse chords, melodic hooks
function generateHipHopMelodies() {
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root notes, heavy and sparse
  const bassOctave = 1;
  const bassPattern = [0, 0, 4, 0, 0, 3, 0, 5];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassPattern.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.8;
        patterns.bass[offset + step].duration = '4n';
      }
    });
  }
  
  // Keys: Simple triads on downbeats
  const chordOctave = 3;
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach(step => {
      const root = keysArr[keyIndex] + chordOctave;
      const third = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
      const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
      
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = [root, third, fifth];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '1n';
    });
  }
  
  // Lead: Melodic hook
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const hook = [0, 3, 2, 0, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (hook[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[hook[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.6;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 100;
        }
      });
    }
  }
}

// Post-Punk: Dark bass, angular guitars, minimal keys
function generatePostPunkMelodies() {
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Driving 8th notes, root-fifth motion
  const bassOctave = 1;
  
  for (let i = 0; i < len; i += 2) {
    patterns.bass[i].active = true;
    const useFifth = i % 4 === 2;
    const degree = useFifth ? 4 : 0;
    patterns.bass[i].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[i].velocity = 0.75;
    patterns.bass[i].duration = '8n';
  }
  
  // Guitar: Power chords, angular rhythm
  if (state.complexity >= 2) {
    const chordOctave = 2;
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [0, 4, 8, 12].forEach(step => {
        const root = keysArr[keyIndex] + chordOctave;
        const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
        const octave = keysArr[keyIndex] + (chordOctave + 1);
        
        patterns.guitar[offset + step].active = true;
        patterns.guitar[offset + step].note = [root, fifth, octave];
        patterns.guitar[offset + step].velocity = 0.6;
        patterns.guitar[offset + step].duration = '4n';
      });
    }
  }
  
  // Keys: Sparse stabs
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [6, 14].forEach(step => {
        if (Math.random() > 0.3) {
          const chordOctave = 4;
          patterns.keys[offset + step].active = true;
          patterns.keys[offset + step].note = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
          patterns.keys[offset + step].velocity = 0.5;
          patterns.keys[offset + step].duration = '16n';
        }
      });
    }
  }
}

// R&B: Smooth chords, groovy bass, soulful leads
function generateRnBMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Syncopated groove
  const bassOctave = 2;
  const bassGroove = [0, null, 4, null, 3, null, 5, null];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassGroove.forEach((degree, idx) => {
      const step = idx * 2;
      if (degree !== null && step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7;
        patterns.bass[offset + step].duration = '8n';
      }
    });
  }
  
  // Keys: 7th chords with extensions
  const chordOctave = 3;
  const rnbChords = [0, 3, 4, 5].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = rnbChords[idx % rnbChords.length];
      patterns.keys[offset + step].velocity = 0.45;
      patterns.keys[offset + step].duration = '2n';
    });
  }
  
  // Guitar: Rhythm chops
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach(step => {
        if (Math.random() > 0.4) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = rnbChords[Math.floor(step / 4) % rnbChords.length];
          patterns.guitar[offset + step].velocity = 0.35;
          patterns.guitar[offset + step].duration = '16n';
        }
      });
    }
  }
  
  // Lead: Soulful melody
  if (state.complexity >= 3) {
    const leadOctave = 5;
    const soul = [0, 2, 3, 4, 3, 2, 0, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      soul.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.55 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Ambient: Atmospheric pads, sparse melodic elements
function generateAmbientMelodies() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Long sustained root notes
  const bassOctave = 2;
  const bassProgression = [0, 4]; // Alternate between root and fifth
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    const degree = bassProgression[bar % bassProgression.length];
    
    patterns.bass[offset].active = true;
    patterns.bass[offset].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[offset].velocity = 0.6;
    patterns.bass[offset].duration = '1n';
    
    if (state.complexity >= 2 && bar % 2 === 1) {
      patterns.bass[offset + 8].active = true;
      patterns.bass[offset + 8].note = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12] + bassOctave;
      patterns.bass[offset + 8].velocity = 0.55;
      patterns.bass[offset + 8].duration = '1n';
    }
  }
  
  // Keys: Wide ambient chords
  const chordOctave = 3;
  const ambientChords = [0, 4, 5, 3].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + (chordOctave - 1), third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = ambientChords[(bar + idx) % ambientChords.length];
        patterns.keys[offset + step].velocity = 0.4;
        patterns.keys[offset + step].duration = '1n';
      }
    });
  }
  
  // Lead: Sparse ethereal notes
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const etherealNotes = [0, 2, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [4, 8, 12].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = etherealNotes[idx % etherealNotes.length];
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.35;
          patterns.lead[offset + step].duration = '2n';
          patterns.lead[offset + step].probability = 70;
        }
      });
    }
  }
}

// Dazecore: Warm, nostalgic melodies with glitchy textures
function generateDazecoreMelodies() {
  const scaleIntervals = scales.major;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Warm, syncopated bounce
  const bassOctave = 2;
  const sunnyBass = [0, 0, 2, 0, 4, 0, 2, 0];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    sunnyBass.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7 + Math.random() * 0.1;
        patterns.bass[offset + step].duration = '8n';
        patterns.bass[offset + step].probability = 95;
      }
    });
  }
  
  // Keys: Shimmering nostalgic chords with add9s
  const chordOctave = 3;
  const nostalgiaChords = [0, 4, 5, 2].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = nostalgiaChords[idx % nostalgiaChords.length];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '2n';
      patterns.keys[offset + step].probability = 95;
    });
  }
  
  // Guitar: Glitchy arpeggios (dial-up texture)
  if (state.complexity >= 2) {
    const arpSteps = [1, 2, 5, 6, 9, 10, 13, 14];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      arpSteps.forEach((step, idx) => {
        if (Math.random() > 0.3) {
          const chordIdx = Math.floor(step / 4) % nostalgiaChords.length;
          const noteIdx = idx % 4;
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = nostalgiaChords[chordIdx][noteIdx];
          patterns.guitar[offset + step].velocity = 0.35 + Math.random() * 0.15;
          patterns.guitar[offset + step].duration = '16n';
          patterns.guitar[offset + step].probability = 70 + Math.floor(Math.random() * 25);
        }
      });
    }
  }
  
  // Lead: Nostalgic melody fragments (summer memory)
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const memory = [4, 5, 4, 2, 0, 2, 4, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      memory.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16 && Math.random() > 0.2) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 85;
        }
      });
    }
  }
}
// Add after generateMelodicPatterns function
function addDrumFills() {
  // Add crash on bar 1
  patterns.crash[0].active = true;
  patterns.crash[0].velocity = 0.8;
  patterns.crash[0].probability = 100;
  
  // Random tom fills every 2 bars
  if (state.complexity >= 2) {
    for (let bar = 1; bar < state.sequenceLength / 16; bar++) {
      const fillStart = (bar * 16) - 4; // Last 4 steps of bar
      
      if (Math.random() < 0.3) { // 30% chance
        for (let i = 0; i < 4; i++) {
          if (Math.random() < 0.7) {
            patterns.tom[fillStart + i].active = true;
            patterns.tom[fillStart + i].velocity = 0.6 + (i * 0.1);
          }
        }
      }
    }
  }
}

function generateBassLine() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const root = state.key;
  const octave = 2; // Keep bass in low register
  
  // Use darker intervals - root, minor 3rd, 4th, 5th
  const bassNotes = [
    root + octave,
    keysArr[(keyIndex + scaleIntervals[2]) % 12] + octave,  // minor 3rd
    keysArr[(keyIndex + scaleIntervals[3]) % 12] + octave,  // 4th
    keysArr[(keyIndex + scaleIntervals[4]) % 12] + octave   // 5th
  ];
  
  const density = state.complexity === 1 ? 4 : state.complexity === 2 ? 6 : 8;
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % (16 / density) === 0 || (state.complexity >= 3 && Math.random() < 0.2)) {
      patterns.bass[i].active = true;
      patterns.bass[i].note = bassNotes[Math.floor(i / 4) % bassNotes.length];
      patterns.bass[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.bass[i].duration = '4n'; // Longer, sustained notes
      patterns.bass[i].probability = 100;
    }
  }
}

function generateKeyPattern() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 3; // Lower octave - darker
  
  // Build darker, more dissonant chords
  const chords = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 4][i]; // Use 2nd (adds tension), minor 3rd, 4th
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % scaleIntervals.length]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Add 7th for more color/tension
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % scaleIntervals.length]) % 12];
    
    chords.push([
      root + octave, 
      third + octave, 
      fifth + octave,
      seventh + (octave + 1)
    ]);
  }
  
  // Sparse, sustained pads
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % 8 === 0) { // Only every 8 steps = very sparse
      const index = Math.floor(i / 8) % chords.length;
      patterns.keys[i].active = true;
      patterns.keys[i].note = chords[index];
      patterns.keys[i].velocity = 0.5 + Math.random() * 0.15; // Quiet
      patterns.keys[i].duration = '1n'; // Whole note - long sustain
      patterns.keys[i].probability = 100;
    }
  }
}

function generateLeadMelody() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 4; // Medium-low register
  
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12] + octave);
  
  let lastIndex = 0;
  const density = state.complexity === 1 ? 2 : state.complexity === 2 ? 3 : 5; // Very sparse
  
  for (let i = 0; i < state.sequenceLength; i++) {
    // Much sparser - only occasional notes
    if (Math.random() < (density / 32)) { // Half the normal density
      // Prefer downward motion (darker feel)
      const jump = Math.random() < 0.6 ? -1 : (Math.random() < 0.7 ? 1 : 2);
      
      lastIndex = clamp(lastIndex + jump, 0, scaleNotes.length - 1);
      
      patterns.lead[i].active = true;
      patterns.lead[i].note = scaleNotes[lastIndex];
      patterns.lead[i].velocity = 0.4 + Math.random() * 0.2; // Quiet, ghostly
      patterns.lead[i].duration = Math.random() < 0.7 ? '4n' : '2n'; // Longer notes
      patterns.lead[i].probability = Math.random() < 0.6 ? 100 : 70; // Some randomness
    }
  }
}

// Add after line ~1260 (after generateLeadMelody function)
function generateGuitarStrums() {
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 2; // Lower, darker
  
  // Build power chords and sus chords (no 3rd = ambiguous/dreamy)
  const chordShapes = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 5][i];
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const fourth = keysArr[(keyIndex + scaleIntervals[(degree + 3) % scaleIntervals.length]) % 12]; // sus4
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Sus chords = dreamy, no major/minor
    chordShapes.push([
      root + octave, 
      fourth + octave, 
      fifth + octave,
      root + (octave + 1)
    ]);
  }
  
  // Very sparse strumming
  const strumPattern = [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]; // Only twice per bar
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (strumPattern[i % strumPattern.length]) {
      const chordIndex = Math.floor(i / 8) % chordShapes.length;
      patterns.guitar[i].active = true;
      patterns.guitar[i].note = chordShapes[chordIndex];
      patterns.guitar[i].velocity = 0.4 + Math.random() * 0.15; // Quiet
      patterns.guitar[i].duration = '2n'; // Half note sustain
      patterns.guitar[i].probability = 100;
    }
  }
}

function applyEuclidean() {
  const instrumentKeys = Object.keys(instruments);
  const inst = instrumentKeys[Math.floor(Math.random() * instrumentKeys.length)];
  const hits = Math.floor(Math.random() * 8) + 3;
  const steps = state.sequenceLength;
  
  const pattern = generateEuclidean(hits, steps);
  pattern.forEach((value, i) => {
    patterns[inst][i].active = value === 1;
    if (value === 1) {
      patterns[inst][i].velocity = 0.7 + Math.random() * 0.3;
      patterns[inst][i].probability = 100;
    }
  });
  
  renderSequencer();
}

function generateEuclidean(hits, steps) {
  const result = Array(steps).fill(0);
  const bucket = [];
  
  for (let i = 0; i < steps; i++) {
    bucket.push(Math.floor((i * hits) / steps));
  }
  
  for (let i = 0; i < steps; i++) {
    if (i === 0 || bucket[i] !== bucket[i - 1]) {
      result[i] = 1;
    }
  }
  
  return result;
}

// -------------------- Mixer Rendering --------------------
function renderMixer() {
  const grid = document.getElementById('mixerGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const data = instruments[inst];
    const channel = document.createElement('div');
    channel.className = 'mixer-channel';
    
    channel.innerHTML = `
      <div class="channel-header">
        <div class="channel-name">${data.icon} ${data.name}</div>
        <div class="channel-btns">
          <button class="channel-btn mute ${data.mute ? 'active' : ''}" 
                  data-inst="${inst}" data-action="mute">M</button>
          <button class="channel-btn solo ${data.solo ? 'active' : ''}" 
                  data-inst="${inst}" data-action="solo">S</button>
        </div>
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Volume</span>
          <span class="param-value">${data.volume}dB</span>
        </div>
        <input type="range" min="-40" max="10" value="${data.volume}" 
               data-inst="${inst}" data-param="volume">
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Pan</span>
          <span class="param-value">${data.pan > 0 ? 'R' : data.pan < 0 ? 'L' : 'C'}${Math.abs(data.pan)}</span>
        </div>
        <input type="range" min="-100" max="100" value="${data.pan}" 
               data-inst="${inst}" data-param="pan">
      </div>
    `;
    
    fragment.appendChild(channel);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- FX Rendering --------------------
function renderFX() {
  const grid = document.getElementById('fxGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(fxConfig).forEach(fx => {
    const config = fxConfig[fx];
    const unit = document.createElement('div');
    unit.className = 'fx-unit';
    
    const params = Object.keys(config).filter(k => k !== 'name' && k !== 'active');
    let paramsHTML = '';
    
    params.forEach(param => {
      const value = config[param];
      const display = formatFxDisplay(param, value);
      
      let sliderVal = 50;
      if (param === 'decay') {
        sliderVal = clamp(Math.round(value * 20), 0, 100);
      } else if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
        sliderVal = Math.round(value * 100);
      } else if (param === 'time') {
        const timeMap = { '16n': 0, '8n': 33, '4n': 66, '2n': 100 };
        sliderVal = timeMap[value] ?? 50;
      } else if (param === 'frequency') {
        sliderVal = Math.round((value - 100) / 79);
      } else if (param === 'octaves') {
        sliderVal = (value - 1) * 20;
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value">${display}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx="${fx}" data-param="${param}">
        </div>
      `;
    });
    
    unit.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${config.name}</div>
        <div class="fx-toggle ${config.active ? 'active' : ''}" data-fx="${fx}"></div>
      </div>
      ${paramsHTML}
    `;
    
    fragment.appendChild(unit);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- Harmony System --------------------
function renderHarmony() {
  const keySelect = document.getElementById('keySelect');
  keySelect.innerHTML = keysArr.map(k => 
    `<option value="${k}" ${k === state.key ? 'selected' : ''}>${k}</option>`
  ).join('');
  
  const scaleSelect = document.getElementById('scaleSelect');
  scaleSelect.innerHTML = Object.keys(scales).map(s => 
    `<option value="${s}" ${s === state.scale ? 'selected' : ''}>${s}</option>`
  ).join('');
  
  const octaveSelect = document.getElementById('octaveSelect');
  octaveSelect.innerHTML = [2, 3, 4, 5, 6].map(o => 
    `<option value="${o}" ${o === state.octave ? 'selected' : ''}>${o}</option>`
  ).join('');
  
  updateChords();
}

function updateChords() {
  const chordChips = document.getElementById('chordChips');
  const fragment = document.createDocumentFragment();
  
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  
  const chords = [];
  scaleIntervals.forEach((interval, i) => {
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(i + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    chords.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][i] });
  });
  
  chords.forEach(chord => {
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = `${chord.roman} - ${chord.root}${chord.type === 'minor' ? 'm' : chord.type === 'dim' ? '°' : ''}`;
    chip.addEventListener('click', () => {
      state.progression.push(chord);
      renderProgression();
    });
    fragment.appendChild(chip);
  });
  
  chordChips.innerHTML = '';
  chordChips.appendChild(fragment);
}

function renderProgression() {
  const wrap = document.getElementById('progressionChips');
  const fragment = document.createDocumentFragment();
  
  if (!state.progression.length) {
    wrap.innerHTML = '<div style="color: var(--text-muted); font-size: 0.9rem;">Click chords above to build progression</div>';
    return;
  }
  
  state.progression.forEach((chord, index) => {
    const chip = document.createElement('div');
    chip.className = 'chip active';
    chip.textContent = `${chord.roman} - ${chord.root}${chord.type === 'minor' ? 'm' : chord.type === 'dim' ? '°' : ''}`;
    chip.addEventListener('click', () => {
      state.progression.splice(index, 1);
      renderProgression();
    });
    fragment.appendChild(chip);
  });
  
  wrap.innerHTML = '';
  wrap.appendChild(fragment);
}

function generateProgression() {
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  const templates = [
    [0, 3, 4, 0],
    [0, 5, 3, 4],
    [1, 4, 0],
    [0, 4, 5, 3]
  ];
  
  const template = templates[Math.floor(Math.random() * templates.length)];
  state.progression = [];
  
  template.forEach(degree => {
    const interval = scaleIntervals[degree];
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(degree + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    state.progression.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][degree] });
  });
  
  renderProgression();
}

function loadProgressionTemplate(name) {
  const templates = {
    'ii-v-i': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'G', type: 'major', roman: 'V' },
      { root: 'C', type: 'major', roman: 'I' }
    ],
    'lofi': [
      { root: 'C', type: 'major', roman: 'I' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'F', type: 'major', roman: 'IV' },
      { root: 'G', type: 'major', roman: 'V' }
    ],
    'neosoul': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'E', type: 'minor', roman: 'III' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'D', type: 'minor', roman: 'II' }
    ],
    'modal': [
      { root: 'D', type: 'minor', roman: 'I' },
      { root: 'E', type: 'minor', roman: 'II' },
      { root: 'F', type: 'major', roman: 'III' },
      { root: 'G', type: 'major', roman: 'IV' }
    ]
  };
  
  state.progression = templates[name] || [];
  renderProgression();
}

// ==================== MULTITRACK RECORDING SYSTEM ====================

const multitrack = {
  tracks: [],
  nextTrackId: 1,
  recordingTracks: new Set(),
  currentFxTrackId: null,
  globalRecordStartTime: null,
  zoom: 100, // pixels per second
  snapEnabled: true,
  snapInterval: 0.25,
  loopEnabled: false,
  loopStart: null,
  loopEnd: null,
  currentTool: 'select'   // ✏️ timeline tool state
};

// === UNDO/REDO HISTORY SYSTEM ===
const multitrackHistory = {
  stack: [],
  currentIndex: -1,
  maxSize: 50,
  isRestoring: false, // Prevent recording during undo/redo
  
  captureState() {
    if (this.isRestoring) return; // Don't record during undo/redo
    
    // Serialize current multitrack state (without audio buffers to save memory)
    const state = {
      tracks: multitrack.tracks.map(t => ({
        id: t.id,
        name: t.name,
        instrument: t.instrument,
        isExternalAudio: t.isExternalAudio,
        volume: t.volume,
        pan: t.pan,
        muted: t.muted,
        soloed: t.soloed,
        armed: t.armed,
        selectedTakeIndex: t.selectedTakeIndex,
        takes: t.takes.map(take => ({
          id: take.id,
          duration: take.duration,
          startTime: take.startTime,
          muted: take.muted,
          timestamp: take.timestamp,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd
          // Note: We keep audio buffers in the actual track objects
        }))
      })),
      nextTrackId: multitrack.nextTrackId,
      zoom: multitrack.zoom,
      timestamp: Date.now()
    };
    
    // Remove any states after current index (branching timeline)
    this.stack = this.stack.slice(0, this.currentIndex + 1);
    
    // Add new state
    this.stack.push(state);
    
    // Limit stack size
    if (this.stack.length > this.maxSize) {
      this.stack.shift();
    } else {
      this.currentIndex++;
    }
    
    updateUndoRedoButtons();
  },
  
  undo() {
    if (!this.canUndo()) return;
    
    this.currentIndex--;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('↶ Undo', 'info');
  },
  
  redo() {
    if (!this.canRedo()) return;
    
    this.currentIndex++;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('↷ Redo', 'info');
  },
  
  canUndo() {
    return this.currentIndex > 0;
  },
  
  canRedo() {
    return this.currentIndex < this.stack.length - 1;
  },
  
  restoreState(state) {
    this.isRestoring = true;
    
    try {
      // Restore track metadata (preserve existing audio buffers)
      state.tracks.forEach(savedTrack => {
        const liveTrack = multitrack.tracks.find(t => t.id === savedTrack.id);
        
        if (liveTrack) {
          // Update existing track
          liveTrack.name = savedTrack.name;
          liveTrack.volume = savedTrack.volume;
          liveTrack.pan = savedTrack.pan;
          liveTrack.muted = savedTrack.muted;
          liveTrack.soloed = savedTrack.soloed;
          liveTrack.armed = savedTrack.armed;
          liveTrack.selectedTakeIndex = savedTrack.selectedTakeIndex;
          
          // Update audio routing
          if (liveTrack.channel) {
            liveTrack.channel.volume.value = liveTrack.volume;
            liveTrack.channel.pan.value = liveTrack.pan / 100;
          }
          
          // Restore take metadata (keep audio buffers)
          savedTrack.takes.forEach((savedTake, idx) => {
            if (liveTrack.takes[idx]) {
              liveTrack.takes[idx].startTime = savedTake.startTime;
              liveTrack.takes[idx].muted = savedTake.muted;
              liveTrack.takes[idx].trimStart = savedTake.trimStart;
              liveTrack.takes[idx].trimEnd = savedTake.trimEnd;
            }
          });
        }
      });
      
      // Remove tracks that don't exist in saved state
      multitrack.tracks = multitrack.tracks.filter(t => 
        state.tracks.some(st => st.id === t.id)
      );
      
      // Restore other properties
      multitrack.zoom = state.zoom;
      multitrack.nextTrackId = state.nextTrackId;
      
      renderMultitrack();
      
    } finally {
      this.isRestoring = false;
    }
  },
  
  clear() {
    this.stack = [];
    this.currentIndex = -1;
    updateUndoRedoButtons();
  }
};

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn) {
    undoBtn.disabled = !multitrackHistory.canUndo();
  }
  
  if (redoBtn) {
    redoBtn.disabled = !multitrackHistory.canRedo();
  }
}
  
// ==================== ENHANCED MULTITRACK WITH EXTERNAL AUDIO ====================

class AudioTrack {
  constructor(id, name = `Track ${id}`, instrument = null, isExternalAudio = false) {
    this.id = id;
    this.name = name;
    this.instrument = instrument || 'internal';
    this.isExternalAudio = isExternalAudio;
    this.takes = [];
    this.selectedTakeIndex = -1;
    this.armed = false;
    this.recording = false;
    this.muted = false;
    this.soloed = false;
    this.volume = 0;
    this.pan = 0;
    this.inputMonitoring = false;
    this.recordStartTime = null;

    // Audio routing
    this.channel = new Tone.Channel({ volume: 0, pan: 0 }).connect(master.fxIn);
    this.recorder = null;
    this.recordedChunks = [];
    this.fxChain = [];
    
    // Meter for visual feedback
    this.meter = new Tone.Meter();
    this.channel.connect(this.meter);
    
    // External audio setup
    this.mediaStream = null;
    this.mediaStreamSource = null;
    this.externalInput = null;
    
    if (!isExternalAudio && instrument !== 'external') {
      this.routeInstrument();
    }
  }
  
  rename(newName) {
    this.name = newName.trim() || `Track ${this.id}`;
    showToast(`✏️ Renamed to "${this.name}"`, 'info');
    renderMultitrack();
  }
  
  async setupExternalAudio() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000
        }
      });
      
      console.log(`🎤 Microphone access granted for track ${this.id}`);
      
      const audioContext = Tone.context.rawContext;
      this.mediaStreamSource = audioContext.createMediaStreamSource(this.mediaStream);
      
      this.externalInput = new Tone.Gain(1);
      this.mediaStreamSource.connect(this.externalInput.input);
      
      this.externalInput.connect(this.channel);
      this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      
      console.log(`✅ External audio routed for track ${this.id}`);
      
    } catch (err) {
      console.error(`❌ Failed to access microphone for track ${this.id}:`, err);
      showToast(`❌ Microphone access denied: ${err.message}`, 'error');
    }
  }

  toggleInputMonitoring() {
    if (!this.mediaStreamSource) return showToast('⚠️ No input available', 'warning');

    if (!this.isExternalAudio || !this.externalInput) return;
    
    this.inputMonitoring = !this.inputMonitoring;
    this.externalInput.gain.rampTo(this.inputMonitoring ? 1 : 0, 0.05);
    
    console.log(`🔊 Input monitoring ${this.inputMonitoring ? 'ON' : 'OFF'} for ${this.name}`);
    renderMultitrack();
  }
  
  routeInstrument() {
    // Internal audio tracks no longer route from a fixed instrument.
    // They simply exist as live audio buses (Tone.Channel → master).
    console.log(`🎚️ ${this.name} ready as internal track`);
  }

  
  addFx(type, params = {}) {
    let fx;
    params = { ...params };
  
    switch (type) {
      case 'reverb': {
        const decay = params.decay ?? 1.5;
        const wet = params.wet ?? 0.3;
        fx = new Tone.Reverb({ decay, wet });
        params.decay = decay;
        params.wet = wet;
        break;
      }
      case 'delay': {
        const time = params.time ?? '8n';
        const feedback = params.feedback ?? 0.3;
        const wet = params.wet ?? 0.3;
        fx = new Tone.FeedbackDelay({ delayTime: time, feedback, wet });
        params.time = time;
        params.feedback = feedback;
        params.wet = wet;
        break;
      }
      case 'chorus': {
        const frequency = params.frequency ?? 1.5;
        const delayTime = params.delayTime ?? 3.5;
        const depth = params.depth ?? 0.7;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Chorus({ frequency, delayTime, depth, wet }).start();
        params.frequency = frequency;
        params.delayTime = delayTime;
        params.depth = depth;
        params.wet = wet;
        break;
      }
      case 'distortion': {
        const amount = params.amount ?? 0.4;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Distortion({ distortion: amount, wet });
        params.amount = amount;
        params.wet = wet;
        break;
      }
      case 'filter': {
        const typeOpt = params.type ?? 'lowpass';
        const frequency = params.frequency ?? 5000;
        const q = params.q ?? 1;
        fx = new Tone.Filter({ type: typeOpt, frequency, Q: q });
        params.type = typeOpt;
        params.frequency = frequency;
        params.q = q;
        break;
      }
      case 'compressor': {
        const threshold = params.threshold ?? -24;
        const ratio = params.ratio ?? 4;
        const attack = params.attack ?? 0.003;
        const release = params.release ?? 0.25;
        fx = new Tone.Compressor({ threshold, ratio, attack, release });
        params.threshold = threshold;
        params.ratio = ratio;
        params.attack = attack;
        params.release = release;
        break;
      }
      case 'eq': {
        const low = params.low ?? 0;
        const mid = params.mid ?? 0;
        const high = params.high ?? 0;
        fx = new Tone.EQ3({ low, mid, high });
        params.low = low;
        params.mid = mid;
        params.high = high;
        break;
      }
      case 'bitcrusher': {
        const bits = params.bits ?? 4;
        fx = new Tone.BitCrusher({ bits });
        params.bits = bits;
        break;
      }
      default:
        return null;
    }
  
    const fxObj = {
      id: Date.now() + Math.random(),
      type,
      node: fx,
      params,
      enabled: true
    };
  
    this.fxChain.push(fxObj);
    this.reconnectFxChain();
  
    return fxObj;
  }
  
  removeFx(fxId) {
    const index = this.fxChain.findIndex(fx => fx.id === fxId);
    if (index === -1) return;
    
    const fx = this.fxChain[index];
    fx.node.disconnect();
    fx.node.dispose();
    
    this.fxChain.splice(index, 1);
    this.reconnectFxChain();
  }
  
  reconnectFxChain() {
    if (this.isExternalAudio && this.externalInput) {
      // Disconnect all first
      this.fxChain.forEach(fx => {
        if (fx.node && typeof fx.node.disconnect === 'function') {
          try {
            fx.node.disconnect();
          } catch (e) {
            console.warn('FX already disconnected:', e);
          }
        }
      });
      
      // CRITICAL: Disconnect input before reconnecting
      try {
        this.externalInput.disconnect();
      } catch (e) {
        console.warn('Input already disconnected:', e);
      }
      
      let lastNode = this.externalInput;
      
      this.fxChain.forEach(fx => {
        if (fx.enabled && fx.node) {
          lastNode.connect(fx.node);
          lastNode = fx.node;
        }
      });
      
      lastNode.connect(this.channel);
      
    } else {
      // Internal audio track logic (unchanged)
      const instSynth = synths[this.instrument];
      if (!instSynth) return;
      
      this.fxChain.forEach(fx => {
        if (fx.node && typeof fx.node.disconnect === 'function') {
          try {
            fx.node.disconnect();
          } catch (e) {}
        }
      });
      
      let sourceNode = null;
      
      if (typeof instSynth.disconnect === 'function') {
        try {
          instSynth.disconnect();
        } catch (e) {}
        sourceNode = instSynth;
      } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
        try {
          instSynth.gain.disconnect();
        } catch (e) {}
        sourceNode = instSynth.gain;
      }
      
      if (!sourceNode) return;
      
      let lastNode = sourceNode;
      
      this.fxChain.forEach(fx => {
        if (fx.enabled && fx.node) {
          lastNode.connect(fx.node);
          lastNode = fx.node;
        }
      });
      
      lastNode.connect(this.channel);
    }
  }
  
  updateFxParam(fxId, param, value) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.params[param] = value;
    const node = fx.node;
    
    // FIXED: Faster ramp time for more responsive feel
    const rampTime = 0.01; // Reduced from 0.05
    
    try {
      if (param === 'wet' && node.wet) {
        node.wet.rampTo(value, rampTime);
      } else if (param === 'decay' && node.decay !== undefined) {
        node.decay = value;
      } else if (param === 'time' && node.delayTime) {
        node.delayTime.value = Tone.Time(value);
      } else if (param === 'feedback' && node.feedback) {
        node.feedback.rampTo(value, rampTime);
      } else if (param === 'frequency') {
        if (node.frequency) {
          node.frequency.rampTo(value, rampTime);
        }
      } else if (param === 'delayTime' && node.delayTime && fx.type === 'chorus') {
        node.delayTime = value;
      } else if (param === 'depth' && node.depth !== undefined) {
        node.depth = value;
      } else if (param === 'amount' && node.distortion !== undefined) {
        node.distortion = value;
      } else if (param === 'threshold' && node.threshold) {
        node.threshold.rampTo(value, rampTime);
      } else if (param === 'ratio' && node.ratio) {
        node.ratio.rampTo(value, rampTime);
      } else if (param === 'attack' && node.attack) {
        node.attack.rampTo(value, rampTime);
      } else if (param === 'release' && node.release) {
        node.release.rampTo(value, rampTime);
      } else if (param === 'low' && node.low) {
        node.low.rampTo(value, rampTime);
      } else if (param === 'mid' && node.mid) {
        node.mid.rampTo(value, rampTime);
      } else if (param === 'high' && node.high) {
        node.high.rampTo(value, rampTime);
      } else if (param === 'bits' && node.bits !== undefined) {
        node.bits = Math.round(value);
      } else if (param === 'q' && node.Q) {
        node.Q.rampTo(value, rampTime);
      } else if (param === 'type' && node.type !== undefined) {
        node.type = value;
      }
      
      console.log(`🎛️ ${fx.type}.${param} = ${value}`);
    } catch (err) {
      console.warn(`⚠️ Could not update ${param}:`, err);
    }
  }
  
  toggleFx(fxId) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.enabled = !fx.enabled;
    this.reconnectFxChain();
  }
  
  async startRecording() {
    if (this.recording) return;
    await Tone.start();
    if (Tone.context.state !== 'running') await Tone.context.resume();
  
    // FIXED: Enable monitoring during recording
    if (this.isExternalAudio) {
      if (!this.mediaStreamSource) await this.setupExternalAudio();
      this.inputMonitoring = true; // Force monitoring ON
      if (this.externalInput) {
        this.externalInput.gain.value = 1; // Ensure we can hear input
      }
    }
    
    const ctx = Tone.getContext().rawContext;
    const dest = ctx.createMediaStreamDestination();
  
    if (!this.isExternalAudio) {
      master.fxIn.connect(dest);
    }
  
    this.channel.connect(dest);
    this.recordDest = dest;
    this.recordedChunks = [];
  
    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus'
      : 'audio/webm';
  
    this.recorder = new MediaRecorder(dest.stream, { mimeType });
    this.recorder.ondataavailable = e => e.data.size && this.recordedChunks.push(e.data);
    this.recorder.onstop = () => this.finishRecording();
  
    this.recorder.start(100);
    this.recording = true;
    
    showToast(`🎧 Recording ${this.name} (monitoring ${this.isExternalAudio ? 'ON' : 'OFF'})`, 'success');
  }
  
  stopRecording() {
    if (this.recording && this.recorder) {
      this.recorder.stop();
      this.recording = false;
      if (this.isExternalAudio && this.externalInput) {
        // Keep live monitoring on stop for feedback continuity
        this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      }
    }
  }
  
  async finishRecording() {
    if (this.recordedChunks.length === 0) {
      console.warn('⚠️ No audio data recorded');
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      showToast('⚠️ Recording was empty', 'warning'); 
      return;
    }
  
    const blob = new Blob(this.recordedChunks, {
      type: (this.recorder && this.recorder.mimeType) || 'audio/webm'
    });
  
    console.log(`💾 Processing ${blob.size} bytes`);
  
    if (blob.size < 1000) {
      console.error('❌ Recording too small, likely corrupted');
      showToast('❌ Recording failed - file too small', 'error');
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      return;
    }
  
    try {
      const arrayBuffer = await blob.arrayBuffer();
      if (arrayBuffer.byteLength === 0) {
        throw new Error('ArrayBuffer is empty');
      }
  
      const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
      if (!audioBuffer || audioBuffer.length === 0 || audioBuffer.numberOfChannels === 0) {
        throw new Error('Decoded buffer is invalid');
      }
  
      const duration = audioBuffer.duration;
  
      // 🔥 Compute timeline start based on global record start
      let startTime = 0;
      if (multitrack.globalRecordStartTime != null && this.recordStartTime != null) {
        startTime = Math.max(
          0,
          this.recordStartTime - multitrack.globalRecordStartTime
        );
      }
  
      const take = {
        id: Date.now(),
        buffer: audioBuffer,
        blob,
        duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime,   // <-- used by preview & bounce for alignment
        recordedAt: Date.now()
      };
  
      this.takes.push(take);
      this.selectedTakeIndex = this.takes.length - 1;
  
      console.log(
        `✅ Take ${this.takes.length} created: ${take.duration.toFixed(
          3
        )}s (start=${startTime.toFixed(3)}s)`
      );

      multitrackHistory.captureState();
      
      renderMultitrack();
      showToast(`✅ Recorded ${take.duration.toFixed(1)}s take`, 'success');
    } catch (err) {
      console.error('❌ Failed to decode audio:', err);
      showToast(`❌ Recording failed: ${err.message}`, 'error');
    } finally {
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
    }
  }
  
  selectTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.selectedTakeIndex = index;
    renderMultitrack();
  }

  toggleTakeMute(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.takes[index].muted = !this.takes[index].muted;
    renderMultitrack();
  }
  
  deleteTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    this.takes.splice(index, 1);
    
    if (this.selectedTakeIndex >= this.takes.length) {
      this.selectedTakeIndex = this.takes.length - 1;
    }
    
    renderMultitrack();
  }

  async playTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    if (take.muted) {
      showToast('❌ Take is muted', 'warning');
      return;
    }
    
    if (this.currentPlayer) {
      try {
        if (this.currentPlayer.state === 'started') {
          this.currentPlayer.stop();
        }
        this.currentPlayer.dispose();
      } catch (err) {
        console.warn('Error stopping previous player:', err);
      }
    }
    
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`❌ ${this.name}: Invalid or empty buffer`);
      showToast(`❌ ${this.name}: Take corrupted, cannot play`, 'error');
      return;
    }
    
    try {
      this.currentPlayer = new Tone.Player({
        buffer: take.buffer,
        fadeOut: 0.01
      }).connect(this.channel);
      
      await new Promise((resolve, reject) => {
        let attempts = 0;
        const checkReady = setInterval(() => {
          attempts++;
          
          if (this.currentPlayer.loaded) {
            clearInterval(checkReady);
            resolve();
          } else if (attempts > 50) {
            clearInterval(checkReady);
            reject(new Error('Buffer load timeout'));
          }
        }, 100);
        
        this.currentPlayer.onsuccess = () => {
          clearInterval(checkReady);
          resolve();
        };
      });
      
      await Tone.start();
      
      this.currentPlayer.start();
      
      const takeRegions = document.querySelectorAll('.take-region');
      takeRegions.forEach((region, idx) => {
        if (idx === index) {
          region.style.borderColor = 'var(--warning)';
          region.style.boxShadow = '0 0 20px var(--warning)';
        }
      });
      
      showToast(`▶️ Playing ${this.name} - Take ${index + 1}`, 'info');
      
      setTimeout(() => {
        if (this.currentPlayer) {
          try {
            if (this.currentPlayer.state === 'started') {
              this.currentPlayer.stop();
            }
            this.currentPlayer.dispose();
          } catch (err) {
            console.warn('Cleanup error:', err);
          }
          this.currentPlayer = null;
        }
        
        takeRegions.forEach(region => {
          region.style.borderColor = '';
          region.style.boxShadow = '';
        });
      }, take.duration * 1000 + 500);
      
    } catch (err) {
      console.error(`❌ Failed to play ${this.name}:`, err);
      showToast(`❌ Playback failed: ${err.message}`, 'error');
      
      if (this.currentPlayer) {
        this.currentPlayer.dispose();
        this.currentPlayer = null;
      }
    }
  }
  
  stopTake() {
    if (this.currentPlayer) {
      this.currentPlayer.stop();
      this.currentPlayer.dispose();
      this.currentPlayer = null;
    }
  }
  
  async exportTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    const url = URL.createObjectURL(take.blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.name.replace(/\s+/g, '_')}_take${index + 1}_${Date.now()}.webm`;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }
  
  dispose() {
    console.log('🗑️ Disposing track:', this.id);
    
    this.stopTake();
    
    if (this.recorder && this.recording) {
      this.stopRecording();
    }
    
    if (this.isExternalAudio) {
      if (this.mediaStreamSource) {
        this.mediaStreamSource.disconnect();
        this.mediaStreamSource = null;
      }
      
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }
      
      if (this.externalInput) {
        this.externalInput.disconnect();
        this.externalInput.dispose();
        this.externalInput = null;
      }
    } else {
      const instSynth = synths[this.instrument];
      if (instSynth && this.originalChannel) {
        if (typeof instSynth.disconnect === 'function') {
          instSynth.disconnect();
          instSynth.connect(this.originalChannel);
        } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
          instSynth.gain.disconnect();
          instSynth.gain.connect(this.originalChannel);
        }
      }
    }
    
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.dispose === 'function') {
        fx.node.disconnect();
        fx.node.dispose();
      }
    });
    
    if (this.meter && typeof this.meter.dispose === 'function') {
      this.meter.dispose();
    }
    
    if (this.channel && typeof this.channel.dispose === 'function') {
      this.channel.disconnect();
      this.channel.dispose();
    }
    
    console.log('✅ Track disposed:', this.id);
  }
}

// ==================== EXTERNAL STEM IMPORT ====================

// 1) Decode an uploaded file into an AudioBuffer
async function decodeFileToBuffer(file) {
  const arrayBuffer = await file.arrayBuffer();

  const audioCtx =
    (Tone && Tone.context && Tone.context.rawContext) ||
    (Tone && Tone.getContext && Tone.getContext().rawContext) ||
    (Tone && Tone.context) ||
    null;

  if (!audioCtx || !audioCtx.decodeAudioData) {
    throw new Error('AudioContext not available for decoding');
  }

  return new Promise((resolve, reject) => {
    audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
  });
}

// 2) Create a new multitrack track from an AudioBuffer
function addExternalAudioTrackFromBuffer(audioBuffer, fileName = 'Imported Stem') {
  const id = multitrack.nextTrackId++;
  const niceName = fileName.replace(/\.[^/.]+$/, ''); // strip extension

  // Create track marked as external audio
  const track = new AudioTrack(id, niceName, 'stem', true);

  // Single take covering whole buffer
  const take = {
    id: `take-${Date.now()}-${id}`,
    buffer: audioBuffer,
    startTime: 0,                 // starts at 0 in the session
    duration: audioBuffer.duration,
    muted: false,
    source: 'external',
    fileName
  };

  track.takes.push(take);
  track.selectedTakeIndex = 0;

  // Minimal routing: gain → master.fxIn
  // (Adjust if you already have a per-track channel system)
  const gain = new Tone.Gain(1);
  track.channel = gain;
  gain.connect(master.fxIn);

  multitrack.tracks.push(track);

  return track;
}

// 3) Wire up the "Import Stem" button
function setupStemImport() {
  const importBtn = document.getElementById('importStemBtn');
  if (!importBtn) {
    console.warn('⚠️ setupStemImport: #importStemBtn not found');
    return;
  }

  if (importBtn.dataset._wired) return; // avoid double binding
  importBtn.dataset._wired = 'true';

  importBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/webm';

    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      // Optional size guard
      if (file.size > 50 * 1024 * 1024) {
        showToast('❌ File too large (max 50MB)', 'error');
        return;
      }

      try {
        showToast(`⏳ Importing ${file.name}...`, 'info');
        const buffer = await decodeFileToBuffer(file);
        const track = addExternalAudioTrackFromBuffer(buffer, file.name);
        renderMultitrack(); // your existing UI refresh
        showToast(`✅ Imported stem: ${track.name}`, 'success');
      } catch (err) {
        console.error('Stem import failed:', err);
        showToast(`❌ Import failed: ${err.message}`, 'error');
      }
    };

    input.click();
  });
}
  
async function createTrack(instrument = null, isExternalAudio = false) {
  const isInternal = !isExternalAudio;
  const baseName = isExternalAudio
    ? `Mic/Ext ${multitrack.tracks.filter(t => t.isExternalAudio).length + 1}`
    : `Track ${multitrack.tracks.filter(t => !t.isExternalAudio).length + 1}`;

  const track = new AudioTrack(multitrack.nextTrackId++, baseName, instrument, isExternalAudio);

  if (isExternalAudio) {
    try {
      await track.setupExternalAudio();
    } catch (err) {
      console.error('❌ External audio setup failed:', err);
      showToast(`❌ Microphone access failed: ${err.message}`, 'error');
      return null;
    }
  }

  multitrack.tracks.push(track);
  multitrackHistory.captureState();
  renderMultitrack();
  showToast(`✅ ${isExternalAudio ? 'External' : 'Internal'} track added`, 'success');
  return track;
}

function removeTrack(trackId) {
  const index = multitrack.tracks.findIndex(t => t.id === trackId);
  if (index === -1) return;
  
  const track = multitrack.tracks[index];
  track.dispose();
  multitrack.tracks.splice(index, 1);
  multitrackHistory.captureState();
  renderMultitrack();
}

function drawTakeWaveform(canvasEl, audioBuffer) {
  const ctx = canvasEl.getContext('2d');
  const width = canvasEl.width;
  const height = canvasEl.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = audioBuffer.getChannelData(0);
  const step = Math.ceil(data.length / width);
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  ctx.beginPath();
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const datum = data[(i * step) + j];
      if (datum < min) min = datum;
      if (datum > max) max = datum;
    }
    
    const x = i;
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(x, yMin, 1, yMax - yMin);
  }
}

function renderTakes(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  let html = '<div style="display: flex; flex-direction: column; gap: var(--space-2); padding: var(--space-2);">';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    html += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}" 
           data-track-id="${track.id}" data-take-index="${idx}"
           style="cursor: pointer; position: relative;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: var(--space-2);">
          <div style="flex: 1;">
            <div style="font-size: var(--text-xs); font-weight: 700;">
              Take ${idx + 1} ${isSelected ? '★' : ''}
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
              ${take.duration.toFixed(1)}s
            </div>
          </div>
          <div style="display: flex; gap: var(--space-1);">
            <button class="region-action-btn" data-action="play-take" title="Play">▶️</button>
            <button class="region-action-btn" data-action="toggle-mute-take" title="Mute/Unmute">
              ${isMuted ? '🔇' : '🔊'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" 
                    data-track-id="${track.id}" data-take-index="${idx}" title="Edit Waveform">✂️</button>
            <button class="region-action-btn" data-action="delete-take" title="Delete">🗑️</button>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  
  return html;
}
  
// Enhanced track strip rendering
function createTrackStrip(track, timelineWidth) {
  const strip = document.createElement('div');
  strip.className = 'track-strip';
  strip.dataset.trackId = track.id;
  if (track.recording) strip.classList.add('recording');
  if (track.armed) strip.classList.add('armed');
  if (track.isExternalAudio) strip.classList.add('external-audio');
  
  const instData = track.isExternalAudio ? 
    { icon: '🎤', name: 'External' } : 
    instruments[track.instrument];
  
  const takesCount = track.takes.length;
  const duration = track.selectedTakeIndex >= 0 ? 
    track.takes[track.selectedTakeIndex].duration.toFixed(1) + 's' : 
    '0.0s';
  
  // Format pan display
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };
  
  strip.innerHTML = `
    <div class="track-header">
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || '🎚️'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-action="rec">
          ${track.recording ? '⏺️' : '⚪'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-action="arm">
          ${track.armed ? '🔴' : '⚪'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-action="monitor">
            ${track.inputMonitoring ? '🔊' : '🔇'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-action="fx">
          🎛️ FX
        </button>
        <button class="track-mini-btn" data-action="delete">
          🗑️
        </button>
      </div>

      <div class="track-fx-panel" style="display:none;">
        <div class="fx-chain-mini">
          <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
          <div class="fx-slots-inline"></div>
        </div>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" 
               class="track-volume-slider" data-param="volume" data-track-id="${track.id}">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" 
               class="track-pan-slider" data-param="pan" data-track-id="${track.id}">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    </div>
    
    <div class="track-canvas-area">
      <div class="track-canvas" style="width: ${timelineWidth}px; min-width: ${timelineWidth}px;">
        ${track.takes.length === 0 && !track.recording ? `
          <div class="track-empty-state">
            <div class="track-empty-state-icon">🎙️</div>
            <div>Arm and record to create takes</div>
          </div>
        ` : ''}
        ${track.recording ? `
          <div class="recording-indicator">
            <div class="recording-indicator-dot"></div>
            <span>Recording...</span>
          </div>
        ` : ''}
        ${renderTimelineRegions(track)}
      </div>
    </div>
  `;
  
  // Attach control listeners
  strip.querySelectorAll('.track-mini-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      handleTrackAction(track, action);
    });
  });
  
  // Volume slider
  const volumeSlider = strip.querySelector('.track-volume-slider');
  if (volumeSlider) {
    volumeSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      track.volume = value;
      
      if (track.channel && track.channel.volume) {
        track.channel.volume.rampTo(value, 0.05);
      }
      
      const label = strip.querySelector('.track-volume-value');
      if (label) label.textContent = value.toFixed(1) + 'dB';
    });
  }
  
  // Pan slider - FIXED
  const panSlider = strip.querySelector('.track-pan-slider');
  if (panSlider) {
    panSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      track.pan = value;
      
      if (track.channel && track.channel.pan) {
        track.channel.pan.rampTo(value / 100, 0.05);
      }
      
      const label = strip.querySelector('.track-pan-value');
      if (label) {
        label.textContent = formatPan(value);
      }
    });
  }
  
  setupRegionInteractions(strip, track);
  
  // Start meter animation
  if (track.meter) {
    const updateMeters = () => {
      const fills = strip.querySelectorAll(`[data-meter-track="${track.id}"]`);
      if (fills.length === 0 || !track.meter) return;
      
      const value = track.meter.getValue();
      const channels = Array.isArray(value) ? value : [value, value];
      
      fills.forEach((fill, idx) => {
        const db = channels[idx] || channels[0] || -60;
        const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
        fill.style.height = normalized + '%';
      });
      
      if (strip.isConnected) {
        requestAnimationFrame(updateMeters);
      }
    };
    
    requestAnimationFrame(updateMeters);
  }
  
  // Draw waveforms after DOM is ready
  requestAnimationFrame(() => {
    setTimeout(() => {
      track.takes.forEach((take, idx) => {
        const canvas = strip.querySelector(`canvas[data-take-id="${take.id}"]`);
        if (canvas && take.buffer) {
          if (canvas.width === 0 || canvas.height === 0) {
            canvas.width = Math.max(100, take.duration * (multitrack.zoom || 100));
            canvas.height = 20;
          }
          drawRegionWaveform(canvas, take.buffer);
        }
      });
    }, 100);
  });
  
  return strip;
}
  
function renderTimelineRegions(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  const zoom = multitrack.zoom || 100;
  let html = '';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    const startPos = (take.startTime || 0) * zoom;
    const width = take.duration * zoom;
    
    html += `
      <div class="audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}"
           data-track-id="${track.id}"
           data-take-index="${idx}"
           data-region-id="${take.id}"
           style="position: absolute; left: ${startPos}px; width: ${width}px; height: 80px; top: 0;">
        
        <div class="region-header">
          <div class="region-name">Take ${idx + 1}</div>
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">✂️</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? '🔇' : '🔊'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">✏️</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">🗑️</button>
          </div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      </div>
    `;
  });
  
  return html;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 100);
  return `${mins}:${String(secs).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
}

function setupRegionInteractions(stripEl, track) {
  // 💡 Work with either the old .track-canvas or the lane itself
  const canvas = stripEl.querySelector('.track-canvas') || stripEl;
  if (!canvas) return;
  
  let dragState = null;
  let isTouchDevice = 'ontouchstart' in window;
  
  // === CRITICAL: Use event delegation for action buttons ===
  canvas.addEventListener('click', (e) => {
    const btn = e.target.closest('.region-action-btn');
    if (!btn) return;
    
    e.stopPropagation(); // CRITICAL: Prevent drag logic
    e.preventDefault();
    
    const region = btn.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const action = btn.dataset.action;
    
    handleRegionAction(trackId, takeIndex, action, e);
  }, { capture: true }); // Use capture phase

  const startDrag = (e) => {
    if (e.target.closest('.region-action-btn')) return; // Skip buttons
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    
    const region = document.elementFromPoint(clientX, clientY)?.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const handle = e.target.closest('.region-resize-handle')?.dataset.handle || null;
    
    const track = multitrack.tracks.find(t => t.id === trackId);
    if (!track) return;
    
    const take = track.takes[takeIndex];
    if (!take) return;
    
    const zoom = multitrack.zoom || 100;
    
    dragState = {
      mode: handle ? `resize-${handle}` : 'move',
      trackId,
      takeIndex,
      startX: clientX,
      originalStart: take.startTime || 0,
      originalDuration: take.duration,
      minStart: 0,
      maxEnd: multitrack.projectDuration || (state.duration * 60)
    };
    
    region.classList.add('dragging');
  };
  
  const moveDrag = (e) => {
    if (!dragState) return;
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const zoom = multitrack.zoom || 100;
    const deltaX = clientX - dragState.startX;
    const deltaSeconds = deltaX / zoom;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (!track) return;
    
    const take = track.takes[dragState.takeIndex];
    if (!take) return;
    
    if (dragState.mode === 'move') {
      let newStart = dragState.originalStart + deltaSeconds;
      newStart = Math.max(dragState.minStart, Math.min(newStart, dragState.maxEnd - take.duration));
      take.startTime = newStart;
    } else if (dragState.mode === 'resize-left') {
      let newStart = dragState.originalStart + deltaSeconds;
      const maxStart = dragState.originalStart + dragState.originalDuration - 0.05;
      newStart = Math.max(dragState.minStart, Math.min(newStart, maxStart));
      
      const newDuration = (dragState.originalStart + dragState.originalDuration) - newStart;
      if (newDuration >= 0.05) {
        take.startTime = newStart;
        take.duration = newDuration;
      }
    } else if (dragState.mode === 'resize-right') {
      let newDuration = dragState.originalDuration + deltaSeconds;
      const maxDuration = dragState.maxEnd - dragState.originalStart;
      newDuration = Math.max(0.05, Math.min(newDuration, maxDuration));
      take.duration = newDuration;
    }
    
    renderMultitrack();
  };
  
  const endDrag = (e) => {
    if (!dragState) return;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (track) {
      const lane = document.querySelector(`.track-lane[data-track-id="${track.id}"]`);
      if (lane) {
        const regionEls = lane.querySelectorAll('.audio-region');
        regionEls.forEach(r => r.classList.remove('dragging'));
      }
    }
    
    multitrackHistory.captureState();
    dragState = null;
  };
  
  // Mouse + touch bindings
  if (isTouchDevice) {
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        startDrag(e);
      }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
      if (dragState) {
        e.preventDefault();
        moveDrag(e);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', endDrag, { passive: true });
    canvas.addEventListener('touchcancel', endDrag, { passive: true });
  } else {
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      startDrag(e);
    });
    
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
  }
}

  
function handleRegionAction(trackId, takeIndex, action, event) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take) {
    console.error('Take not found:', takeIndex);
    return;
  }
  
  console.log(`✅ Handling action: ${action}`);
  
  if (action === 'split-region') {
    openSplitDialog(track, takeIndex, event);
  } else if (action === 'toggle-mute-region') {
    take.muted = !take.muted;
    renderMultitrack();
    showToast(take.muted ? '🔇 Region muted' : '🔊 Region unmuted', 'info');
  } else if (action === 'edit-waveform') {
    openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete-region') {
    if (confirm('Delete this region?')) {
      track.takes.splice(takeIndex, 1);
      if (track.selectedTakeIndex >= track.takes.length) {
        track.selectedTakeIndex = track.takes.length - 1;
      }
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('🗑️ Region deleted', 'success');
    }
  } else {
    console.warn('Unknown action:', action);
  }
}

function openSplitDialog(track, takeIndex, event) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '600px';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">✂️ Split Region</div>
      <button class="modal-close">✕</button>
    </div>
    
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="splitPreviewCanvas" width="500" height="150"
                style="width: 100%; height: 150px; background: var(--glass-bg); border-radius: var(--radius-md); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="param-control">
        <div class="param-label">
          <span>Split Point</span>
          <span class="param-value" id="splitPointValue">0.00s</span>
        </div>
        <input type="range" id="splitPointSlider" min="0" max="100" value="50" step="0.1">
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); margin-top: var(--space-3);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          💡 <strong>Tip:</strong> Click on the waveform to set split point
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-split-btn">Cancel</button>
      <button class="btn btn-primary confirm-split-btn">✂️ Split</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('splitPreviewCanvas');
  const slider = document.getElementById('splitPointSlider');
  const valueLabel = document.getElementById('splitPointValue');
  
  let splitPoint = 0.5; // 0-1 normalized
  
  function drawSplitPreview() {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!take.buffer) return;
    
    // Draw waveform
    const data = take.buffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    for (let i = 0; i < width; i++) {
      let min = 1.0, max = -1.0;
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < data.length) {
          const datum = data[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw split line
    const splitX = splitPoint * width;
    ctx.strokeStyle = 'var(--error)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(splitX, 0);
    ctx.lineTo(splitX, height);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Labels
    ctx.fillStyle = 'var(--text-primary)';
    ctx.font = '12px var(--font-mono)';
    ctx.fillText('A', 10, 20);
    ctx.fillText('B', width - 20, 20);
  }
  
  function updateSplitPoint(newPoint) {
    splitPoint = Math.max(0.01, Math.min(0.99, newPoint));
    slider.value = splitPoint * 100;
    const timeInSeconds = splitPoint * take.duration;
    valueLabel.textContent = timeInSeconds.toFixed(2) + 's';
    drawSplitPreview();
  }
  
  slider.addEventListener('input', (e) => {
    updateSplitPoint(parseFloat(e.target.value) / 100);
  });
  
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const normalizedX = x / rect.width;
    updateSplitPoint(normalizedX);
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-split-btn').onclick = close;
  
  modal.querySelector('.confirm-split-btn').onclick = async () => {
    try {
      showToast('⏳ Splitting region...', 'info');
      
      const splitTime = splitPoint * take.duration;
      const buffer = take.buffer;
      
      // Create two new buffers
      const sampleRate = buffer.sampleRate;
      const splitSample = Math.floor(splitTime * sampleRate);
      
      const bufferA = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        splitSample,
        sampleRate
      );
      
      const bufferB = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length - splitSample,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const dataA = bufferA.getChannelData(c);
        const dataB = bufferB.getChannelData(c);
        
        for (let i = 0; i < splitSample; i++) {
          dataA[i] = original[i];
        }
        
        for (let i = splitSample; i < buffer.length; i++) {
          dataB[i - splitSample] = original[i];
        }
      }
      
      // Create blobs
      const wavA = bufferToWavImproved(bufferA);
      const wavB = bufferToWavImproved(bufferB);
      const blobA = new Blob([wavA], { type: 'audio/wav' });
      const blobB = new Blob([wavB], { type: 'audio/wav' });
      
      // Create new takes
      const takeA = {
        id: Date.now(),
        buffer: bufferA,
        blob: blobA,
        duration: bufferA.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: take.startTime || 0
      };
      
      const takeB = {
        id: Date.now() + 1,
        buffer: bufferB,
        blob: blobB,
        duration: bufferB.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: (take.startTime || 0) + splitTime
      };
      
      // Replace original take with split takes
      track.takes.splice(takeIndex, 1, takeA, takeB);
      
      if (track.selectedTakeIndex === takeIndex) {
        track.selectedTakeIndex = takeIndex; // Select first part
      } else if (track.selectedTakeIndex > takeIndex) {
        track.selectedTakeIndex++; // Adjust index
      }

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast('✅ Region split successfully!', 'success');
      
    } catch (err) {
      console.error('Split failed:', err);
      showToast(`❌ Split failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  updateSplitPoint(0.5);
  drawSplitPreview();
}

function drawRegionWaveform(canvas, buffer) {
  if (!canvas || !buffer) return;
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = buffer.getChannelData(0);
  const step = Math.max(1, Math.ceil(data.length / width));
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.5)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const index = (i * step) + j;
      if (index < data.length) {
        const sample = data[index];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
      }
    }
    
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
  }
}

function setupRegionContextMenu() {
  let contextMenu = null;
  let contextTarget = null;
  
  document.addEventListener('contextmenu', (e) => {
    const region = e.target.closest('.audio-region');
    if (!region) return;
    
    e.preventDefault();
    
    if (contextMenu) contextMenu.remove();
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    
    contextTarget = { trackId, takeIndex };
    
    contextMenu = document.createElement('div');
    contextMenu.className = 'region-context-menu';
    
    contextMenu.innerHTML = `
      <div class="region-context-item" data-action="split">✂️ Split at Playhead</div>
      <div class="region-context-item" data-action="duplicate">📋 Duplicate</div>
      <div class="region-context-item" data-action="reverse">↩️ Reverse</div>
      <div class="region-context-item" data-action="normalize">📊 Normalize</div>
      <div class="region-context-item" data-action="fade-in">📈 Fade In</div>
      <div class="region-context-item" data-action="fade-out">📉 Fade Out</div>
      <div class="region-context-item" data-action="export">💾 Export Region</div>
      <div style="height: 1px; background: var(--glass-border); margin: var(--space-2) 0;"></div>
      <div class="region-context-item danger" data-action="delete">🗑️ Delete</div>
    `;
    
    document.body.appendChild(contextMenu);
    
    // FIXED: Better positioning that accounts for scroll
    requestAnimationFrame(() => {
      const menuRect = contextMenu.getBoundingClientRect();
      const menuWidth = menuRect.width;
      const menuHeight = menuRect.height;
      
      // Start with click position
      let x = e.clientX;
      let y = e.clientY;
      
      // Right edge
      if (x + menuWidth > window.innerWidth) {
        x = window.innerWidth - menuWidth - 10;
      }
      // Bottom edge
      if (y + menuHeight > window.innerHeight) {
        y = window.innerHeight - menuHeight - 10;
      }
      // Left edge
      if (x < 10) x = 10;
      // Top edge
      if (y < 10) y = 10;
      
      contextMenu.style.position = 'fixed';
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.style.zIndex = '10000';
    });
    
    // Handle menu clicks
    contextMenu.addEventListener('click', async (e2) => {
      const item = e2.target.closest('.region-context-item');
      if (!item || !contextTarget) return;
      
      const action = item.dataset.action;
      const track = multitrack.tracks.find(t => t.id === contextTarget.trackId);
      if (!track) return;
      
      const take = track.takes[contextTarget.takeIndex];
      if (!take) return;
      
      contextMenu.remove();
      contextMenu = null;
      
      await handleContextAction(track, contextTarget.takeIndex, action);
    });

    // Close on click outside
    const closeHandler = (e3) => {
      if (contextMenu && !contextMenu.contains(e3.target)) {
        contextMenu.remove();
        contextMenu = null;
        document.removeEventListener('click', closeHandler);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeHandler);
    }, 0);
  }); // 🔚 close contextmenu listener


  // === LONG-PRESS SUPPORT (mobile / touch) ===
  let longPressTimer = null;
  let touchStartX = 0;
  let touchStartY = 0;
  const LONG_PRESS_MS = 550;
  const MOVE_TOLERANCE = 10; // px

  // Start tracking on touchstart
  document.addEventListener(
    'touchstart',
    (e) => {
      const region = e.target.closest('.audio-region');
      if (!region) return;

      if (e.touches.length !== 1) return; // ignore multi-touch

      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(() => {
        const fakeEvent = new MouseEvent('contextmenu', {
          bubbles: true,
          cancelable: true,
          clientX: touchStartX,
          clientY: touchStartY,
        });
        region.dispatchEvent(fakeEvent);
      }, LONG_PRESS_MS);
    },
    { passive: true }
  );

  // Cancel if the finger moves too far
  document.addEventListener(
    'touchmove',
    (e) => {
      if (!longPressTimer) return;

      const touch = e.touches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > MOVE_TOLERANCE) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    },
    { passive: true }
  );

  // Cancel on touchend / cancel
  const cancelLongPress = () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  };

  document.addEventListener('touchend', cancelLongPress, { passive: true });
  document.addEventListener('touchcancel', cancelLongPress, { passive: true });
}

async function handleContextAction(track, takeIndex, action) {
  const take = track.takes[takeIndex];
  
  switch(action) {
    case 'split':
      // Split at current playhead position
      const currentTime = Tone.Transport.seconds;
      const relativeTime = currentTime - (take.startTime || 0);
      
      if (relativeTime > 0 && relativeTime < take.duration) {
        const splitPoint = relativeTime / take.duration;
        openSplitDialog(track, takeIndex, { splitPoint });
      } else {
        showToast('⚠️ Playhead not within region', 'warning');
      }
      break;
      
    case 'duplicate':
      const duplicate = {
        ...take,
        id: Date.now(),
        startTime: (take.startTime || 0) + take.duration + 0.1
      };
      track.takes.splice(takeIndex + 1, 0, duplicate);
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('✅ Region duplicated', 'success');
      break;
      
    case 'reverse':
      await reverseRegion(track, takeIndex);
      break;
      
    case 'normalize':
      await normalizeRegion(track, takeIndex);
      break;
      
    case 'fade-in':
      openFadeDialog(track, takeIndex, 'in');
      break;
      
    case 'fade-out':
      openFadeDialog(track, takeIndex, 'out');
      break;
      
    case 'export':
      track.exportTake(takeIndex);
      break;
      
    case 'delete':
      if (confirm('Delete this region?')) {
        track.deleteTake(takeIndex);
        renderMultitrack();
        showToast('🗑️ Region deleted', 'success');
      }
      break;
  }
}

async function reverseRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('⏳ Reversing region...', 'info');
  
  try {
    const buffer = take.buffer;
    const reversed = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const reversedData = reversed.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        reversedData[i] = original[buffer.length - 1 - i];
      }
    }
    
    const wavData = bufferToWavImproved(reversed);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = reversed;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast('✅ Region reversed', 'success');
    
  } catch (err) {
    console.error('Reverse failed:', err);
    showToast(`❌ Reverse failed: ${err.message}`, 'error');
  }
}

async function normalizeRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('⏳ Normalizing region...', 'info');
  
  try {
    const buffer = take.buffer;
    
    // Find peak
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('⚠️ Region is silent', 'warning');
      return;
    }
    
    const normalized = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    const targetPeak = 0.891; // -1dB
    const gain = targetPeak / peak;
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const normalizedData = normalized.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        normalizedData[i] = original[i] * gain;
      }
    }
    
    const wavData = bufferToWavImproved(normalized);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = normalized;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast(`✅ Normalized (+${(20 * Math.log10(gain)).toFixed(1)}dB)`, 'success');
    
  } catch (err) {
    console.error('Normalize failed:', err);
    showToast(`❌ Normalize failed: ${err.message}`, 'error');
  }
}

function openFadeDialog(track, takeIndex, type) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  const fadeType = type === 'in' ? 'Fade In' : 'Fade Out';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">📈 ${fadeType}</div>
      <button class="modal-close">✕</button>
    </div>
    
    <div class="modal-body">
      <div class="param-control">
        <div class="param-label">
          <span>Duration</span>
          <span class="param-value" id="fadeDurationValue">100ms</span>
        </div>
        <input type="range" id="fadeDurationSlider" min="10" max="5000" value="100" step="10">
      </div>
      
      <div class="param-control" style="margin-top: var(--space-4);">
        <div class="param-label">
          <span>Curve Type</span>
        </div>
        <select id="fadeCurveSelect" style="width: 100%;">
          <option value="linear">Linear</option>
          <option value="exponential">Exponential</option>
          <option value="logarithmic">Logarithmic</option>
          <option value="sCurve">S-Curve</option>
        </select>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-fade-btn">Cancel</button>
      <button class="btn btn-primary apply-fade-btn">Apply ${fadeType}</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const slider = document.getElementById('fadeDurationSlider');
  const valueLabel = document.getElementById('fadeDurationValue');
  const curveSelect = document.getElementById('fadeCurveSelect');
  
  slider.addEventListener('input', (e) => {
    const ms = parseInt(e.target.value);
    valueLabel.textContent = ms + 'ms';
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-fade-btn').onclick = close;
  
  modal.querySelector('.apply-fade-btn').onclick = async () => {
    try {
      const duration = parseInt(slider.value) / 1000; // Convert to seconds
      const curve = curveSelect.value;
      
      showToast(`⏳ Applying ${fadeType.toLowerCase()}...`, 'info');
      
      const buffer = take.buffer;
      const sampleRate = buffer.sampleRate;
      const fadeSamples = Math.floor(duration * sampleRate);
      
      const processed = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const processedData = processed.getChannelData(c);
        
        for (let i = 0; i < buffer.length; i++) {
          let gain = 1.0;
          
          if (type === 'in' && i < fadeSamples) {
            const progress = i / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          } else if (type === 'out' && i >= buffer.length - fadeSamples) {
            const progress = (buffer.length - i) / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          }
          
          processedData[i] = original[i] * gain;
        }
      }
      
      const wavData = bufferToWavImproved(processed);
      const blob = new Blob([wavData], { type: 'audio/wav' });
      
      take.buffer = processed;
      take.blob = blob;

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast(`✅ ${fadeType} applied`, 'success');
      
    } catch (err) {
      console.error('Fade failed:', err);
      showToast(`❌ Fade failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

function applyFadeCurve(progress, curve) {
  switch(curve) {
    case 'exponential':
      return Math.pow(progress, 2);
    case 'logarithmic':
      return Math.sqrt(progress);
    case 'sCurve':
      return 0.5 - 0.5 * Math.cos(progress * Math.PI);
    default: // linear
      return progress;
  }
}

function setupTimelineCursor() {
  const wrapper = document.getElementById('dawArrangementScroll');
  const ruler   = document.getElementById('dawRuler');
  if (!wrapper || !ruler) return;

  ruler.addEventListener('click', (e) => {
    const zoom = multitrack.zoom || 100;

    const rect   = ruler.getBoundingClientRect();
    const clickX = e.clientX - rect.left;

    // account for horizontal scroll
    const timelineX = clickX + wrapper.scrollLeft;

    const projectDurationSeconds =
      multitrack.projectDuration || (state.duration * 60);

    let seconds = timelineX / zoom;
    if (!Number.isFinite(seconds)) seconds = 0;

    // clamp inside project range
    seconds = Math.max(0, Math.min(seconds, projectDurationSeconds));

    state.cursorSeconds = seconds;
    multitrack.playheadSeconds = seconds;

    // this already moves the playhead & updates timestamp
    updatePlayheadAndScroll(seconds);

    console.log('🕒 Cursor set to', seconds.toFixed(3), 's');
  });
}

  
function updateTimelineRuler() {
  const ruler   = document.getElementById('dawRuler');
  const markers = document.getElementById('dawRulerMarkers');
  if (!markers || !ruler) return;

  markers.innerHTML = '';

  const zoom = multitrack.zoom || 100;
  const durationMinutes = typeof state.duration === 'number' && state.duration > 0
    ? state.duration
    : 1;

  const projectDurationSeconds = durationMinutes * 60;
  const totalWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth   = totalWidth;
  document.documentElement.style.setProperty('--timeline-width', totalWidth + 'px');

  ruler.style.width    = totalWidth + 'px';
  ruler.style.minWidth = totalWidth + 'px';

  markers.style.width    = totalWidth + 'px';
  markers.style.minWidth = totalWidth + 'px';

  let interval = 1;
  if (zoom < 25) interval = 10;
  else if (zoom < 50) interval = 5;
  else if (zoom > 200) interval = 0.5;

  for (let t = 0; t <= projectDurationSeconds; t += interval) {
    const x = t * zoom;
    const isMajor = t % (interval * 4) === 0;

    const marker = document.createElement('div');
    marker.className = 'daw-ruler-marker' + (isMajor ? ' bar' : '');
    marker.style.left = x + 'px';

    if (isMajor) {
      const label = document.createElement('div');
      label.className = 'daw-ruler-label';
      const full = formatTime(t);
      label.textContent = full.split('.')[0]; // drop fractional seconds
      marker.appendChild(label);
    }

    markers.appendChild(marker);
  }
}
  
// Enhanced track action handler
async function handleTrackAction(track, action) {
  if (action === 'arm') {
    track.armed = !track.armed;
    renderMultitrack();
  } else if (action === 'monitor') {
    if (track.isExternalAudio) {
      track.toggleInputMonitoring();
    }
  } else if (action === 'rec') {
    await toggleRecordTrack(track.id);
  } else if (action === 'mute') {
    track.muted = !track.muted;
    track.channel.mute = track.muted;
    renderMultitrack();
  } else if (action === 'solo') {
    track.soloed = !track.soloed;
    
    const anySolo = multitrack.tracks.some(t => t.soloed);
    multitrack.tracks.forEach(t => {
      t.channel.mute = anySolo && !t.soloed;
    });
    
    renderMultitrack();
  } else if (action === 'fx') {
    openFxChainEditor(track.id);
  } else if (action === 'rename') {
    const newName = prompt('Rename track:', track.name);
    if (newName !== null) track.rename(newName);
  } else if (action === 'edit') {
    openTakeEditor(track.id);
  } else if (action === 'edit-waveform') {
  e.stopPropagation();
  openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete') {
    if (confirm(`Delete track "${track.name}"?`)) {
      removeTrack(track.id);
    }
  }
}

function showAddTrackDialog() {
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">➕ Add Track</div>
      <button class="modal-close">✕</button>
    </div>

    <div class="modal-body">
      <div style="display:grid; gap:var(--space-4);">

        <!-- 🏷️ Track Name -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Name
          </label>
          <input type="text" class="track-name-input"
                 placeholder="e.g., Vocals, Guitar, Drums..."
                 style="width:100%; padding:var(--space-3); font-size:var(--text-base);
                        border-radius:var(--radius-sm); border:1px solid var(--glass-border);
                        background:var(--glass-bg); color:var(--text-primary);">
        </div>

        <!-- 🎚️ Track Type -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Type
          </label>
          <select class="track-type-select" style="font-size:var(--text-base); padding:var(--space-3); width:100%;">
            <option value="internal">🎧 Internal Audio Track</option>
            <option value="external">🎤 External Audio (Mic / Line In)</option>
          </select>
        </div>

        <!-- 🎤 External Info -->
        <div class="external-info" style="display:none; padding:var(--space-4);
             background:var(--glass-bg); border-radius:var(--radius-md);
             border:1px solid var(--glass-border);">
          <div style="font-weight:700; margin-bottom:var(--space-2); color:var(--text-primary);">
            🎤 External Audio Input
          </div>
          <div style="font-size:var(--text-sm); color:var(--text-secondary); line-height:1.6;">
            <p style="margin-bottom:var(--space-2);">
              This will create a track that records from your microphone or audio interface.
            </p>
            <ul style="margin-left:var(--space-5); margin-bottom:var(--space-2);">
              <li>Real-time monitoring with effects</li>
              <li>Record vocals, guitar, or any external source</li>
              <li>Syncs perfectly with other tracks</li>
            </ul>
            <p style="font-size:var(--text-xs); color:var(--text-tertiary);">
              ⚠️ Your browser will request microphone access
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-secondary cancel-btn">Cancel</button>
      <button class="btn btn-primary confirm-btn">Add Track</button>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-btn').onclick = close;

  const nameInput = modal.querySelector('.track-name-input');
  const trackTypeSelect = modal.querySelector('.track-type-select');
  const externalInfo = modal.querySelector('.external-info');
  const confirmBtn = modal.querySelector('.confirm-btn');

  // Toggle external info panel
  trackTypeSelect.onchange = () => {
    const isExternal = trackTypeSelect.value === 'external';
    externalInfo.style.display = isExternal ? 'block' : 'none';
  };

  confirmBtn.onclick = async () => {
    const isExternal = trackTypeSelect.value === 'external';
    const userName = nameInput.value.trim();

    // 🧠 Smart default naming logic
    const countInternal = multitrack.tracks.filter(t => !t.isExternalAudio).length + 1;
    const countExternal = multitrack.tracks.filter(t => t.isExternalAudio).length + 1;
    const defaultName = isExternal ? `Mic ${countExternal}` : `Track ${countInternal}`;
    const name = userName || defaultName;

    confirmBtn.disabled = true;
    confirmBtn.textContent = isExternal ? 'Requesting access...' : 'Adding...';

    try {
      const track = await createTrack(null, isExternal);
      if (track) {
        track.rename(name);
        renderMultitrack();
        showToast(`✅ ${isExternal ? 'External' : 'Internal'} track "${track.name}" added!`, 'success');
        close();
      } else {
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Add Track';
      }
    } catch (err) {
      console.error('❌ Failed to add track:', err);
      showToast(`❌ Failed to add track: ${err.message}`, 'error');
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Add Track';
    }
  };

  backdrop.onclick = e => { if (e.target === backdrop) close(); };
}

// === PLAYHEAD FOLLOW + TIME DISPLAY ===

let playheadFollowActive = true;
let playheadUpdateInterval = null;

// Call this once after your DAW tab is ready
function initPlayheadFollow() {
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const playheadEl = document.getElementById('dawPlayhead');

  if (!playheadEl || !arrangementScroll) return;

  clearInterval(playheadUpdateInterval);

  playheadUpdateInterval = setInterval(() => {
    if (!multitrack.isPlaying) return;

    const ctx = Tone?.Transport || null;
    let seconds = multitrack.playheadSeconds || 0;

    // 🎛 For recording: follow the Transport clock if it's actually running
    if (ctx && ctx.state === 'started') {
      seconds = ctx.seconds;
    }

    updatePlayheadAndScroll(seconds);
  }, 50); // ~20fps is plenty
}


function formatTimecode(sec) {
  const ms = Math.floor((sec % 1) * 1000);
  const s = Math.floor(sec) % 60;
  const m = Math.floor(sec / 60) % 60;
  const h = Math.floor(sec / 3600);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
}

function formatBars(sec) {
  const bpm = parseFloat(document.getElementById('dawBpmInput')?.value) || 120;
  const beatDur = 60 / bpm;
  const beats = sec / beatDur;
  const bar = Math.floor(beats / 4) + 1;
  const beat = Math.floor(beats % 4) + 1;
  return `${bar}.${beat}.1`;
}

// Optionally toggle follow mode
function togglePlayheadFollow() {
  playheadFollowActive = !playheadFollowActive;
  showToast(playheadFollowActive ? '🎥 Follow Mode ON' : '🎥 Follow Mode OFF', 'info');
}

// Helper: ensure playhead stays visible when manually scrubbed
function updatePlayheadUI(seconds) {
  const playhead = document.getElementById('dawPlayhead');
  const projDur = multitrack.projectDuration || (state.duration * 60);
  const pct = Math.max(0, Math.min(1, seconds / projDur));
  playhead.style.left = `${pct * 100}%`;
}

function renderMultitrack() {
  // Force container visibility
  const container = document.getElementById('dawMainContainer') || 
                    document.querySelector('.daw-main-container');
  if (container) {
    container.style.display = 'grid';
    container.style.visibility = 'visible';
  }

  const trackHeaders = document.getElementById('dawTrackList');
  const arrangementGrid = document.getElementById('dawArrangementGrid');
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const rulerContainer = document.getElementById('dawRuler');

  if (!trackHeaders || !arrangementGrid) {
    console.warn('renderMultitrack: missing containers');
    return;
  }

  const durationMinutes = typeof state.duration === 'number' && state.duration > 0 ? state.duration : 1;
  const projectDurationSeconds = durationMinutes * 60;
  const zoom = multitrack.zoom || 100;
  const timelineWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth = timelineWidth;

  document.documentElement.style.setProperty('--timeline-width', timelineWidth + 'px');

  trackHeaders.innerHTML = '';
  arrangementGrid.innerHTML = '';

  arrangementGrid.style.width = timelineWidth + 'px';
  const ruler = rulerContainer?.querySelector('.daw-ruler');
  if (ruler) {
    ruler.style.width = timelineWidth + 'px';
  }

  // Format pan display helper
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };

  // Render each track
  multitrack.tracks.forEach(track => {
    const instData = track.isExternalAudio ? 
      { icon: '🎤', name: 'External' } : 
      instruments[track.instrument];
    
    // CREATE TRACK HEADER (LEFT SIDE)
    const headerDiv = document.createElement('div');
    headerDiv.className = 'track-header';
    if (track.recording) headerDiv.classList.add('recording');
    if (track.armed) headerDiv.classList.add('armed');
    if (track.isExternalAudio) headerDiv.classList.add('external-audio');
    
    headerDiv.innerHTML = `
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || '🎚️'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-track-id="${track.id}" data-action="rec">
          ${track.recording ? '⏺️' : '⚪'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-track-id="${track.id}" data-action="arm">
          ${track.armed ? '🔴' : '⚪'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-track-id="${track.id}" data-action="monitor">
            ${track.inputMonitoring ? '🔊' : '🔇'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-track-id="${track.id}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-track-id="${track.id}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="fx">
          🎛️ FX
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="delete">
          🗑️
        </button>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" step="0.1"
               class="track-volume-slider" data-track-id="${track.id}" data-param="volume">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" step="1"
               class="track-pan-slider" data-track-id="${track.id}" data-param="pan">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    `;
    
    trackHeaders.appendChild(headerDiv);
    
    // CREATE TRACK LANE (RIGHT SIDE)
    // CREATE TRACK LANE (RIGHT SIDE)
    const laneDiv = document.createElement('div');
    laneDiv.className = 'daw-track-lane';
    laneDiv.dataset.trackId = track.id;
    laneDiv.style.width = timelineWidth + 'px';

    
    // Add regions
    track.takes.forEach((take, idx) => {
      const isSelected = idx === track.selectedTakeIndex;
      const isMuted = take.muted;
      
      const startPos = (take.startTime || 0) * zoom;
      const width = take.duration * zoom;
      
      const regionDiv = document.createElement('div');
      regionDiv.className = `audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}`;
      regionDiv.dataset.trackId = track.id;
      regionDiv.dataset.takeIndex = idx;
      regionDiv.dataset.regionId = take.id;
      regionDiv.style.left = startPos + 'px';
      regionDiv.style.width = width + 'px';
      
      regionDiv.innerHTML = `
        <div class="region-header">
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">✂️</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? '🔇' : '🔊'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">✏️</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">🗑️</button>
          </div>
          <div class="region-name">Take ${idx + 1}</div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      `;
      
      laneDiv.appendChild(regionDiv);
    });
    
    // Empty state
    if (track.takes.length === 0 && !track.recording) {
      const emptyDiv = document.createElement('div');
      emptyDiv.className = 'track-empty-state';
      emptyDiv.innerHTML = `
        <div class="track-empty-state-icon">🎙️</div>
        <div>Arm and record to create takes</div>
      `;
      laneDiv.appendChild(emptyDiv);
    }
    
    // Recording indicator
    if (track.recording) {
      const recDiv = document.createElement('div');
      recDiv.className = 'recording-indicator';
      recDiv.innerHTML = `
        <div class="recording-indicator-dot"></div>
        <span>Recording...</span>
      `;
      laneDiv.appendChild(recDiv);
    }
    
    arrangementGrid.appendChild(laneDiv);
    
    // Attach control listeners
    headerDiv.querySelectorAll('.track-mini-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const action = btn.dataset.action;
        handleTrackAction(track, action);
      });
    });
    
    // Volume slider
    const volumeSlider = headerDiv.querySelector('.track-volume-slider');
    if (volumeSlider) {
      volumeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        track.volume = value;
        if (track.channel && track.channel.volume) {
          track.channel.volume.rampTo(value, 0.05);
        }
        const label = headerDiv.querySelector('.track-volume-value');
        if (label) label.textContent = value.toFixed(1) + 'dB';
      });
    }
    
    // Pan slider - WORKING VERSION
    const panSlider = headerDiv.querySelector('.track-pan-slider');
    if (panSlider) {
      panSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        track.pan = value;
        
        if (track.channel && track.channel.pan) {
          track.channel.pan.rampTo(value / 100, 0.05);
        }
        
        const label = headerDiv.querySelector('.track-pan-value');
        if (label) {
          label.textContent = formatPan(value);
        }
      });
    }
    
    // Setup region interactions
    setupRegionInteractions(laneDiv, track);
    
    // Start meter animation
    if (track.meter) {
      const updateMeters = () => {
        if (!track.meter) return;

        const fills = headerDiv.querySelectorAll(`[data-meter-track="${track.id}"]`);
        if (fills.length === 0) return;
        
        const value = track.meter.getValue();
        const channels = Array.isArray(value) ? value : [value, value];
        
        fills.forEach((fill, idx) => {
          const db = (idx < channels.length ? channels[idx] : channels[0]) ?? -60;
          const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
          fill.style.height = normalized + '%';
        });

        requestAnimationFrame(updateMeters);
      };

      requestAnimationFrame(updateMeters);
    }
  });

  if (typeof updateTimelineRuler === 'function') {
    updateTimelineRuler();
  }
}

function updatePlayheadAndScroll(currentSeconds) {
  const wrapper = document.getElementById('dawArrangementScroll');
  const playhead = document.getElementById('dawPlayhead');
  const timecodeEl = document.getElementById('dawTimecode');
  const barsEl = document.getElementById('dawBars');

  if (!wrapper || !playhead) return;

  const projDur = multitrack.projectDuration || (state.duration * 60);
  let sec = Number(currentSeconds);

  if (!Number.isFinite(sec) || sec < 0) sec = 0;
  if (projDur > 0) sec = Math.min(sec, projDur);

  // 🔑 Remember this globally so PAUSE / SKIM can use it
  multitrack.playheadSeconds = sec;
  state.cursorSeconds = sec;

  // Position playhead in pixels
  const zoom = multitrack.zoom || 100;
  const x = sec * zoom;
  playhead.style.left = x + 'px';

  // Auto-scroll to keep playhead visible
  const padding = 80;
  const visibleStart = wrapper.scrollLeft;
  const visibleEnd = visibleStart + wrapper.clientWidth;

  if (x < visibleStart + padding) {
    wrapper.scrollLeft = Math.max(0, x - padding);
  } else if (x > visibleEnd - padding) {
    wrapper.scrollLeft = x - wrapper.clientWidth + padding;
  }

  // ⏱️ Update transport displays
  if (timecodeEl) timecodeEl.textContent = formatTimecode(sec);
  if (barsEl) barsEl.textContent = formatBars(sec);
}


let playheadAnimationId = null;

function startPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
  }

  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.querySelector('dawArrangementScroll');

  if (!playhead || !wrapper) return;

  const animate = () => {
    if (!state.isPlaying) {
      playheadAnimationId = null;
      return;
    }

    const currentTime = Tone.Transport.seconds;
    state.cursorSeconds = currentTime;
    updatePlayheadAndScroll(currentTime);

    playheadAnimationId = requestAnimationFrame(animate);
  };

  playheadAnimationId = requestAnimationFrame(animate);
}

function stopPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
    playheadAnimationId = null;
    console.log('⏹️ Playhead animation stopped');
  }
}
  
let previewPlayheadId = null;
let previewStartTime = 0;

function startPreviewPlayhead(startOffset, duration) {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
  }
  
  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.getElementById('dawArrangementScroll');
  
  if (!playhead || !wrapper) {
    console.error('❌ Missing playhead or wrapper for preview');
    return;
  }
  
  previewStartTime = performance.now();
  
  const animate = () => {
    const elapsed = (performance.now() - previewStartTime) / 1000;
    
    if (elapsed >= duration) {
      previewPlayheadId = null;
      return;
    }
    
    const currentTime = startOffset + elapsed; // 🔑 real project time
    state.cursorSeconds = currentTime; 
    updatePlayheadAndScroll(currentTime);
    
    previewPlayheadId = requestAnimationFrame(animate);
  };
  
  previewPlayheadId = requestAnimationFrame(animate);
  console.log('✅ Preview playhead started at', startOffset, 'for', duration, 'seconds');
}

function stopPreviewPlayhead() {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
    previewPlayheadId = null;
    console.log('⏹️ Preview playhead stopped');
  }
}

function setupPreviewButton() {
  const btn = document.getElementById('previewMultitrackBtn');
  if (!btn) return;

  btn.addEventListener('click', () => {
    // Just call with no args → uses last cursor/playhead position
    previewMultitrack();
  });
}

// Make sure you have something like this in your global state:
/// const state = { duration: 3, isPlaying: false, cursorSeconds: 0 };

async function previewMultitrack(startAtSeconds) {
  // If no explicit start is passed, use the last playhead/cursor position
  const startFrom =
    typeof startAtSeconds === 'number'
      ? startAtSeconds
      : (typeof state.cursorSeconds === 'number' ? state.cursorSeconds : 0);

  const activeTracks = multitrack.tracks.filter(t =>
    t.selectedTakeIndex >= 0 && !t.muted
  );
  
  if (activeTracks.length === 0) {
    showToast('❌ No active takes to preview', 'error');
    return;
  }

  // 🧩 Stop any existing preview first
  stopMultitrackPreview();

  await Tone.start();
  if (Tone.context.state !== 'running') {
    await Tone.context.resume();
  }

  multitrack.previewPlayers = [];

  const projectDurationSeconds = multitrack.projectDuration || (state.duration * 60);
  
  // 🔑 Clamp start offset to project bounds
  const previewStart = Math.max(0, Math.min(startFrom, projectDurationSeconds));
  let previewEnd = previewStart;

  // Update cursor + visually move playhead to the preview start
  state.cursorSeconds = previewStart;
  updatePlayheadAndScroll(previewStart);

  showToast(`⏳ Loading takes (from ${previewStart.toFixed(2)}s)...`, 'info');

  for (const track of activeTracks) {
    const take = track.takes[track.selectedTakeIndex];
    if (!take || take.muted) continue;

    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`❌ ${track.name}: Invalid buffer`);
      continue;
    }

    const regionStart = take.startTime || 0;
    const regionEnd = regionStart + take.duration;

    if (regionEnd <= previewStart) continue;

    try {
      const player = new Tone.Player({
        context: Tone.context,
        loop: false,
        fadeOut: 0.01
      }).connect(track.channel);

      player.buffer = take.buffer;

      const relativeStart = Math.max(0, regionStart - previewStart);

      multitrack.previewPlayers.push({
        player,
        track,
        startTime: regionStart,
        relativeStart
      });

      if (regionEnd > previewEnd) previewEnd = regionEnd;

      console.log(
        `✅ ${track.name} ready: region ${regionStart.toFixed(3)}–${regionEnd.toFixed(3)}s, ` +
        `plays at +${relativeStart.toFixed(3)}s in preview`
      );

    } catch (err) {
      console.error(`❌ ${track.name} failed:`, err);
    }
  }

  if (!multitrack.previewPlayers.length) {
    showToast('⚠️ No regions overlap this preview range', 'warning');
    return;
  }

  const totalDuration = Math.max(0.1, previewEnd - previewStart);
  console.log(`▶️ Preview from ${previewStart.toFixed(3)}s for ${totalDuration.toFixed(3)}s`);

  const now = Tone.now() + 0.1;

  multitrack.previewPlayers.forEach(({ player, track, relativeStart }) => {
    try {
      player.start(now + relativeStart);
      console.log(`▶️ ${track.name} at +${relativeStart.toFixed(3)}s`);
    } catch (err) {
      console.error(`❌ Failed to start ${track.name}:`, err);
    }
  });

  showToast(
    `▶️ Previewing ${multitrack.previewPlayers.length} track(s) from ${previewStart.toFixed(2)}s`,
    'success'
  );

  // === 🧭 NEW: Activate playhead + follow mode ===
  multitrack.isPlaying = true;          // Let the UI know playback is active
  multitrack.playheadSeconds = previewStart;
  initPlayheadFollow();                 // Start updating timecode + scroll
  startPreviewPlayhead(previewStart, totalDuration); // Keeps your existing animation logic

  // === 🌀 LOOP SUPPORT (Selection or Full Project) ===
  multitrack.previewTimeout = setTimeout(async () => {
    stopMultitrackPreview();
    const btn = document.getElementById('previewMultitrackBtn');

    // If loop not enabled, end normally
    if (!multitrack.loopEnabled) {
      if (btn) btn.textContent = '▶️ Preview Mix';
      return;
    }

    // Figure out if there’s a defined selection
    const hasSelection =
      typeof multitrack.loopStart === 'number' &&
      typeof multitrack.loopEnd === 'number' &&
      multitrack.loopEnd > multitrack.loopStart;

    const restartAt = hasSelection ? multitrack.loopStart : 0;
    const endPoint = hasSelection
      ? multitrack.loopEnd
      : multitrack.projectDuration || state.duration * 60;

    console.log(
      hasSelection
        ? `🔁 Looping selected region: ${restartAt.toFixed(2)}s → ${endPoint.toFixed(2)}s`
        : '🔁 Looping entire project…'
    );

    // Reset playhead and restart playback
    multitrack.playheadSeconds = restartAt;
    await previewMultitrack(restartAt);
  }, (totalDuration + 0.25) * 1000);
}

function stopMultitrackPreview(resetOrOptions) {
  // Allow both: stopMultitrackPreview(true) and stopMultitrackPreview({ resetToZero: true })
  const resetToZero =
    typeof resetOrOptions === 'boolean'
      ? resetOrOptions
      : resetOrOptions && typeof resetOrOptions.resetToZero === 'boolean'
        ? resetOrOptions.resetToZero
        : false;

  if (multitrack.previewPlayers) {
    multitrack.previewPlayers.forEach(({ player }) => {
      try {
        if (player.state === 'started') player.stop();
        player.dispose();
      } catch (err) {
        console.warn('Error stopping preview player:', err);
      }
    });
    multitrack.previewPlayers = [];
    console.log('⏹️ Preview stopped');
  }

  // Stop playhead follow + display updates
  multitrack.isPlaying = false;
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  stopPreviewPlayhead();

  if (multitrack.previewTimeout) {
    clearTimeout(multitrack.previewTimeout);
    multitrack.previewTimeout = null;
  }

  // Remember where we stopped so PAUSE can resume
  let lastSeconds = 0;

  if (resetToZero) {
    lastSeconds = 0;
  } else if (
    typeof state.cursorSeconds === 'number' &&
    !Number.isNaN(state.cursorSeconds)
  ) {
    lastSeconds = state.cursorSeconds;
  } else if (
    typeof multitrack.playheadSeconds === 'number' &&
    !Number.isNaN(multitrack.playheadSeconds)
  ) {
    lastSeconds = multitrack.playheadSeconds;
  }

  multitrack.playheadSeconds = lastSeconds;
  // This updates playhead position, scroll, and timecode/bars
  updatePlayheadAndScroll(lastSeconds);
}

// 🔁 PURE WEB AUDIO MASTER CHAIN FOR OFFLINE BOUNCE
function createOfflineMasterChain(offlineContext) {
  // Entry point for all tracks
  const input = offlineContext.createGain();
  input.gain.value = 1.0; // 🔊 no pre-attenuation (was 0.25 ≈ -12 dB)

  // High-pass (low cut)
  const lowCut = offlineContext.createBiquadFilter();
  lowCut.type = 'highpass';
  lowCut.frequency.value = typeof state.lowCut === 'number' ? state.lowCut : 20;
  lowCut.Q.value = 0.707;

  // Low-pass (high cut)
  const highCut = offlineContext.createBiquadFilter();
  highCut.type = 'lowpass';
  highCut.frequency.value = typeof state.highCut === 'number' ? state.highCut : 20000;
  highCut.Q.value = 0.707;

  // Tape-style soft clip
  const tape = offlineContext.createWaveShaper();
  const satAmt = ((state.tapeSaturation || 0) / 100) * 0.8; // 0–0.8
  const curveLen = 4096;
  const curve = new Float32Array(curveLen);
  for (let i = 0; i < curveLen; i++) {
    const x = (i / (curveLen - 1)) * 2 - 1; // -1..1
    curve[i] = ((1 + satAmt) * x) / (1 + satAmt * Math.abs(x));
  }
  tape.curve = curve;

  // Bus compressor
  const comp = offlineContext.createDynamicsCompressor();
  comp.threshold.value =
    typeof state.compressor === 'number' ? state.compressor : -18; // a bit gentler than -24
  comp.ratio.value = 3;       // 3:1 instead of 4:1
  comp.attack.value = 0.005;
  comp.release.value = 0.2;

  // Limiter approximation
  const limiter = offlineContext.createDynamicsCompressor();
  limiter.threshold.value = -1;  // let it sit closer to 0 dBFS
  limiter.ratio.value = 20;
  limiter.attack.value = 0.001;
  limiter.release.value = 0.1;

  // Final output gain (makeup)
  const outGain = offlineContext.createGain();
  // 1.0 = no change. 1.4 ≈ +3 dB, 2.0 ≈ +6 dB
  outGain.gain.value = 1.6; // tweak to taste

  // Chain: input → lowCut → highCut → tape → comp → limiter → outGain → destination
  input.connect(lowCut);
  lowCut.connect(highCut);
  highCut.connect(tape);
  tape.connect(comp);
  comp.connect(limiter);
  limiter.connect(outGain);
  outGain.connect(offlineContext.destination);

  return input;
}

function createOfflineFxNode(fxDef, offlineContext) {
  const { type, params } = fxDef;
  
  switch (type) {
    case 'reverb':
      return new Tone.Reverb({ 
        decay: params.decay, 
        wet: params.wet,
        context: offlineContext 
      });
    
    case 'delay':
      return new Tone.FeedbackDelay({
        delayTime: params.time,
        feedback: params.feedback,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'chorus':
      return new Tone.Chorus({
        frequency: params.frequency,
        delayTime: params.delayTime,
        depth: params.depth,
        wet: params.wet,
        context: offlineContext
      }).start();
    
    case 'distortion':
      return new Tone.Distortion({
        distortion: params.amount,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'filter':
      return new Tone.Filter({
        type: params.type,
        frequency: params.frequency,
        Q: params.q,
        context: offlineContext
      });
    
    case 'compressor':
      return new Tone.Compressor({
        threshold: params.threshold,
        ratio: params.ratio,
        attack: params.attack,
        release: params.release,
        context: offlineContext
      });
    
    case 'eq':
      return new Tone.EQ3({
        low: params.low,
        mid: params.mid,
        high: params.high,
        context: offlineContext
      });
    
    case 'bitcrusher':
      return new Tone.BitCrusher({
        bits: params.bits,
        context: offlineContext
      });
    
    default:
      return null;
  }
}
  
async function bounceAllTracks() {
  const activeTracks = multitrack.tracks.filter(t => {
    if (t.muted) return false;

    if (t.selectedTakeIndex >= 0 && t.takes[t.selectedTakeIndex]) {
      const sel = t.takes[t.selectedTakeIndex];
      return sel.buffer && sel.buffer.length && !sel.muted;
    }

    if (t.takes && t.takes.length > 0) {
      return t.takes.some(tk => tk && tk.buffer && tk.buffer.length && !tk.muted);
    }

    return false;
  });

  if (activeTracks.length === 0) {
    showToast('❌ No tracks to bounce!', 'error');
    return;
  }

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">🎵 Bouncing Mix</div>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <div id="bounceStatus" style="font-weight: 700; margin-bottom: var(--space-2);">
          Preparing...
        </div>
        <div class="progress">
          <div class="progress-value" id="bounceProgress"
               style="width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="bounceDetails"
             style="font-size: var(--text-sm); color: var(--text-tertiary); margin-top: var(--space-2);">
        </div>
      </div>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const updateProgress = (percent, status, details = '') => {
    const prog = document.getElementById('bounceProgress');
    const stat = document.getElementById('bounceStatus');
    const det = document.getElementById('bounceDetails');
    if (prog) prog.style.width = percent + '%';
    if (stat) stat.textContent = status;
    if (det) det.textContent = details;
  };

  try {
    updateProgress(10, 'Analyzing tracks...', `${activeTracks.length} tracks to bounce`);

    // Find actual content boundaries
    let minStart = Infinity;
    let maxEnd = 0;
    
    activeTracks.forEach(track => {
      let take = null;
      if (track.selectedTakeIndex >= 0 && track.takes[track.selectedTakeIndex]) {
        take = track.takes[track.selectedTakeIndex];
      } else if (track.takes && track.takes.length > 0) {
        take = track.takes.find(tk => tk && tk.buffer && !tk.muted) || null;
      }
      
      if (take && take.buffer) {
        const start = take.startTime || 0;
        const end = start + take.duration;
        if (start < minStart) minStart = start;
        if (end > maxEnd) maxEnd = end;
      }
    });
    
    if (minStart === Infinity || maxEnd === 0) {
      backdrop.remove();
      showToast('❌ No audio content to bounce', 'error');
      return;
    }

    // Use actual content duration, not project duration
    const totalDuration = maxEnd - minStart;
    
    updateProgress(
      20,
      'Setting up renderer...',
      `Duration: ${totalDuration.toFixed(1)}s (trimmed)`
    );

    console.log(`🎬 Bouncing ${totalDuration.toFixed(2)}s (content from ${minStart.toFixed(2)}s to ${maxEnd.toFixed(2)}s)`);

    const sampleRate = Tone.context.sampleRate || 48000;
    const numFrames = Math.ceil(totalDuration * sampleRate);

    const offlineContext = new OfflineAudioContext({
      numberOfChannels: 2,
      length: numFrames,
      sampleRate
    });

    updateProgress(30, 'Creating audio chain...', 'Building master effects');

    const offlineMasterIn = createOfflineMasterChain(offlineContext);

    updateProgress(40, 'Scheduling tracks...', `Processing ${activeTracks.length} tracks`);

    for (const track of activeTracks) {
      let take = null;
      if (track.selectedTakeIndex >= 0 && track.takes[track.selectedTakeIndex]) {
        take = track.takes[track.selectedTakeIndex];
      } else if (track.takes && track.takes.length > 0) {
        take = track.takes.find(tk => tk && tk.buffer && !tk.muted) || null;
      }

      if (!take || !take.buffer || take.buffer.length === 0) continue;

      try {
        const ctx = offlineContext;
        const src = ctx.createBufferSource();
        src.buffer = take.buffer;

        const gainNode = ctx.createGain();
        gainNode.gain.value = Tone.dbToGain(track.volume || 0);

        const panNode = ctx.createStereoPanner();
        panNode.pan.value = (track.pan || 0) / 100;

        src.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(offlineMasterIn);

        const startTime = take.startTime || 0;
        const relStart = startTime - minStart;
        const safeStart = Math.max(0, relStart);

        src.start(safeStart);

        console.log(`✅ ${track.name}: renders at ${safeStart.toFixed(3)}s`);
      } catch (err) {
        console.error(`❌ Failed to schedule ${track.name}:`, err);
      }
    }

    updateProgress(50, 'Rendering audio...', 'This may take a moment');

    const progressInterval = setInterval(() => {
      const progEl = document.getElementById('bounceProgress');
      const currentProg = progEl
        ? parseFloat(progEl.style.width) || 50
        : 50;
      if (currentProg < 90) {
        updateProgress(
          currentProg + 2,
          'Rendering audio...',
          `${Math.round(currentProg - 50)}% complete`
        );
      }
    }, 200);

    const renderedBuffer = await offlineContext.startRendering();

    clearInterval(progressInterval);
    updateProgress(95, 'Converting to WAV...', 'Almost done');

    console.log(`✅ Rendered ${renderedBuffer.duration.toFixed(2)}s (trimmed from ${totalDuration.toFixed(2)}s)`);

    const wavData = bufferToWavImproved(renderedBuffer);
    const blob = new Blob([wavData], { type: 'audio/wav' });

    const projectName = document.getElementById('projectName')?.value || 'mix';
    const filename = `${projectName.replace(/\s+/g, '_')}_bounce_${Date.now()}.wav`;

    updateProgress(100, 'Complete!', `Downloading ${filename}`);

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    console.log(`✅ Bounce complete: ${filename} (${totalDuration.toFixed(1)}s)`);

    setTimeout(() => {
      backdrop.remove();
      showToast(`✅ Bounce complete! ${totalDuration.toFixed(1)}s exported (silence trimmed)`, 'success');
    }, 1000);
  } catch (err) {
    console.error('❌ Bounce failed:', err);
    backdrop.remove();
    showToast(`❌ Bounce failed: ${err.message}`, 'error');
  }
}
  
// Add this NEW function
async function validateAllArmedTracks() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const errors = [];
  
  for (const track of armedTracks) {
    // Check if drum samples are loaded
    if (!track.isExternalAudio && instruments[track.instrument]?.type === 'drum') {
      const synth = synths[track.instrument];
      if (synth && !synth.loaded) {
        errors.push(`${track.instrument} sample not loaded`);
      }
    }
    
    // Check external audio setup
    if (track.isExternalAudio && !track.mediaStream) {
      errors.push(`${track.name} has no audio input`);
    }
  }
  
  if (errors.length > 0) {
    throw new Error(errors.join('\n'));
  }
}
  
async function toggleRecordAllArmed() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const recordingTracks = multitrack.tracks.filter(t => t.recording);

  if (recordingTracks.length > 0) {
    recordingTracks.forEach(track => track.stopRecording());
    stopPlayheadAnimation(); // Stop scroll during recording
    showToast(`⏹️ Stopped recording ${recordingTracks.length} track(s)`, 'info');
    renderMultitrack();
    return;
  }

  if (armedTracks.length === 0) {
    showToast('❌ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`❌ Cannot record:\n${err.message}`, 'error');
    return;
  }

  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();

  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  console.log(`🎬 GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    await track.startRecording({ forcedStartTime: globalStart });
  }

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`🎙️ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`🎙️ Recording ${armedTracks.length} track(s)`, 'success');
  
  // Start playhead animation for recording
  startPlayheadAnimation();
  
  renderMultitrack();
}
  
// Toggle recording for a single track
async function toggleRecordTrack(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.recording) {
    track.stopRecording();
    showToast(`⏹️ Stopped recording ${track.name}`, 'info');
  } else {
    if (!track.armed) {
      track.armed = true;
    }

    if (!state.isPlaying) {
      await togglePlay();
    }

    await Tone.start();
    const start = Tone.now();
    await track.startRecording({ forcedStartTime: start });

    showToast(`🎙️ Recording ${track.name}...`, 'success');
  }
  
  renderMultitrack();
}

// Add these functions after the toggleRecordTrack function (around line 4630):

// Global recording control
async function startGlobalRecording() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  
  if (armedTracks.length === 0) {
    showToast('❌ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`❌ Cannot record:\n${err.message}`, 'error');
    return;
  }

  // Start transport if not playing
  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();
  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  multitrack.isPlaying = true;

  console.log(`🎬 GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    track.recordStartTime = globalStart;
    await track.startRecording();
  }

  // Start playhead animation
  initPlayheadFollow();

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`🎙️ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`🎙️ Recording ${armedTracks.length} track(s)`, 'success');
  
  renderMultitrack();
}

function stopGlobalRecording() {
  const recordingTracks = multitrack.tracks.filter(t => t.recording);
  
  if (recordingTracks.length === 0) return;

  recordingTracks.forEach(track => {
    track.stopRecording();
  });

  multitrack.globalRecordStartTime = null;
  multitrack.isPlaying = false;

  // Stop playhead
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  showToast(`⏹️ Stopped recording ${recordingTracks.length} track(s)`, 'info');
  renderMultitrack();
}

// BPM and time signature controls
function setBPM(newBpm) {
  const bpm = Math.max(30, Math.min(300, parseFloat(newBpm) || 120));
  state.bpm = bpm;
  Tone.Transport.bpm.value = bpm;
  
  const bpmSlider = document.getElementById('bpmSlider');
  const bpmValue = document.getElementById('bpmValue');
  if (bpmSlider) bpmSlider.value = bpm;
  if (bpmValue) bpmValue.textContent = bpm;
  
  console.log(`🎵 BPM set to ${bpm}`);
}

function setTimeSignature(timeSig) {
  const [beats, noteValue] = timeSig.split('/').map(n => parseInt(n));
  Tone.Transport.timeSignature = [beats, noteValue];
  console.log(`🎵 Time signature: ${timeSig}`);
  showToast(`⏱️ Time signature: ${timeSig}`, 'info');
}

// Session management
function newMultitrackSession() {
  if (!confirm('Create new session? Unsaved changes will be lost.')) return;
  
  // Stop everything
  if (state.isPlaying) stop();
  stopMultitrackPreview();
  
  // Clear all tracks
  multitrack.tracks.forEach(t => t.dispose());
  multitrack.tracks = [];
  multitrack.nextTrackId = 1;
  multitrack.globalRecordStartTime = null;
  
  // Reset state
  state.cursorSeconds = 0;
  multitrack.playheadSeconds = 0;

  multitrackHistory.clear();
  
  renderMultitrack();
  showToast('✅ New session created', 'success');
}

function saveMultitrackSession() {
  // Reuse the full project save
  saveProject();
}

function loadMultitrackSession() {
  // Reuse the full project load
  loadProject();
}

// Grid and automation toggles
function toggleGrid() {
  const gridBtn = document.getElementById('dawGridBtn');
  if (!gridBtn) return;
  
  const isActive = gridBtn.classList.toggle('active');
  
  // Toggle snap grid visibility
  document.querySelectorAll('.snap-grid').forEach(grid => {
    grid.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? '⊞ Grid: On' : '⊞ Grid: Off', 'info');
}

function toggleAutomationView() {
  const autoBtn = document.getElementById('dawAutomationBtn');
  if (!autoBtn) return;
  
  const isActive = autoBtn.classList.toggle('active');
  
  // Toggle automation lanes
  document.querySelectorAll('.automation-lane').forEach(lane => {
    lane.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? '📈 Automation: On' : '📈 Automation: Off', 'info');
}

// CPU and status monitoring
function updateDAWStatus() {
  const cpuEl = document.getElementById('dawCpuLoad');
  const latencyEl = document.getElementById('dawLatency');
  const trackCountEl = document.getElementById('dawTrackCount');
  const statusEl = document.getElementById('dawStatusMessage');
  
  if (cpuEl) {
    // Approximate CPU usage based on active tracks
    const activeTracks = multitrack.tracks.filter(t => !t.muted).length;
    const cpuPercent = Math.min(100, activeTracks * 3 + Math.random() * 5);
    cpuEl.textContent = cpuPercent.toFixed(0) + '%';
  }
  
  if (latencyEl) {
    const ctx = Tone.context.rawContext;
    const latencyMs = (ctx.baseLatency || 0) * 1000;
    latencyEl.textContent = latencyMs.toFixed(1) + 'ms';
  }
  
  if (trackCountEl) {
    trackCountEl.textContent = multitrack.tracks.length.toString();
  }
  
  if (statusEl && multitrack.isPlaying) {
    const recordingCount = multitrack.tracks.filter(t => t.recording).length;
    if (recordingCount > 0) {
      statusEl.textContent = `Recording ${recordingCount} track(s)...`;
    } else {
      statusEl.textContent = 'Playing';
    }
  } else if (statusEl) {
    statusEl.textContent = 'Ready';
  }
}
  
// Replace openFxChainEditor function (around line 3285)
function openFxChainEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  multitrack.currentFxTrackId = trackId;
  
  const panel = document.getElementById('fxChainPanel');
  if (!panel) return;
  
  document.getElementById('fxChainTrackName').textContent = track.name;
  
  renderFxChain(track);
  
  // Just show it - it's already positioned at the bottom in the HTML
  panel.style.display = 'block';
}

function renderFxChain(track) {
  const slots = document.getElementById('fxSlots');
  if (!slots) return;
  
  slots.innerHTML = '';
  
  if (track.fxChain.length === 0) {
    slots.innerHTML = `
      <div style="padding: var(--space-8); text-align: center; color: var(--text-tertiary);">
        <div style="font-size: var(--text-xl); margin-bottom: var(--space-2);">🎛️</div>
        <div>No effects on this track</div>
        <div style="font-size: var(--text-sm); margin-top: var(--space-2);">Click "Add Effect" above</div>
      </div>
    `;
    return;
  }
  
  track.fxChain.forEach((fx, idx) => {
    const fxSlot = document.createElement('div');
    fxSlot.className = 'fx-unit';
    fxSlot.style.opacity = fx.enabled ? '1' : '0.5';
    
    let paramsHTML = '';
    
    // Define parameter ranges for each FX type
    const paramConfig = {
      reverb: {
        decay: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 's' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      delay: {
        time: { min: 0, max: 3, options: ['16n', '8n', '4n', '2n', '1n'], default: '8n', format: (v) => v },
        feedback: { min: 0, max: 0.9, default: 0.3, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      chorus: {
        frequency: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 'Hz' },
        delayTime: { min: 2, max: 20, default: 3.5, format: (v) => v.toFixed(1) + 'ms' },
        depth: { min: 0, max: 1, default: 0.7, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      distortion: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      filter: {
        type: { options: ['lowpass', 'highpass', 'bandpass'], default: 'lowpass', format: (v) => v },
        frequency: { min: 20, max: 20000, default: 5000, format: (v) => Math.round(v) + 'Hz' },
        q: { min: 0.1, max: 10, default: 1, format: (v) => v.toFixed(1) }
      },
      compressor: {
        threshold: { min: -60, max: 0, default: -24, format: (v) => Math.round(v) + 'dB' },
        ratio: { min: 1, max: 20, default: 4, format: (v) => v.toFixed(1) + ':1' },
        attack: { min: 0.001, max: 1, default: 0.003, format: (v) => (v * 1000).toFixed(1) + 'ms' },
        release: { min: 0.01, max: 1, default: 0.25, format: (v) => (v * 1000).toFixed(0) + 'ms' }
      },
      eq: {
        low: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        mid: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        high: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' }
      },
      bitcrusher: {
        bits: { min: 1, max: 16, default: 4, format: (v) => Math.round(v) + ' bits' }
      }
    };
    
    const typeConfig = paramConfig[fx.type] || {};
    
    Object.entries(fx.params).forEach(([param, value]) => {
      const config = typeConfig[param] || { min: 0, max: 100, default: 50, format: (v) => v };
      
      let sliderVal = 50;
      let displayVal = value;
      
      // Handle special cases
      if (config.options) {
        // Discrete options (like delay time or filter type)
        const optIndex = config.options.indexOf(value);
        sliderVal = optIndex >= 0 ? (optIndex / (config.options.length - 1)) * 100 : 50;
      } else {
        // Continuous values
        sliderVal = ((value - config.min) / (config.max - config.min)) * 100;
        sliderVal = Math.max(0, Math.min(100, sliderVal));
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value" data-fx-id="${fx.id}" data-param="${param}">${config.format(value)}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx-id="${fx.id}" 
                 data-param="${param}"
                 data-fx-type="${fx.type}"
                 class="fx-param-slider">
        </div>
      `;
    });
    
    fxSlot.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${fx.type.toUpperCase()}</div>
        <div style="display: flex; gap: var(--space-2); align-items: center;">
          <div class="fx-toggle ${fx.enabled ? 'active' : ''}" data-fx-id="${fx.id}"></div>
          <button class="btn btn-ghost btn-sm" data-action="remove-fx" data-fx-id="${fx.id}">✕</button>
        </div>
      </div>
      ${paramsHTML}
    `;
    
    slots.appendChild(fxSlot);
  });
  
  // Attach listeners AFTER all DOM is ready
  setTimeout(() => {
    // Toggle switches
    slots.querySelectorAll('.fx-toggle').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const fxId = parseFloat(toggle.dataset.fxId);
        track.toggleFx(fxId);
        renderFxChain(track);
      });
    });
    
    // Remove buttons
    slots.querySelectorAll('[data-action="remove-fx"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const fxId = parseFloat(btn.dataset.fxId);
        if (confirm('Remove this effect?')) {
          track.removeFx(fxId);
          renderFxChain(track);
        }
      });
    });
    
    // Parameter sliders with proper mapping
    slots.querySelectorAll('.fx-param-slider').forEach(slider => {
      slider.addEventListener('input', (e) => {
        const fxId = parseFloat(e.target.dataset.fxId);
        const param = e.target.dataset.param;
        const fxType = e.target.dataset.fxType;
        const sliderPercent = parseInt(e.target.value, 10);
        
        const fx = track.fxChain.find(f => f.id === fxId);
        if (!fx) return;
        
        const typeConfig = {
          reverb: {
            decay: { min: 0.1, max: 10 },
            wet: { min: 0, max: 1 }
          },
          delay: {
            time: { options: ['16n', '8n', '4n', '2n', '1n'] },
            feedback: { min: 0, max: 0.9 },
            wet: { min: 0, max: 1 }
          },
          chorus: {
            frequency: { min: 0.1, max: 10 },
            delayTime: { min: 2, max: 20 },
            depth: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          distortion: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          filter: {
            type: { options: ['lowpass', 'highpass', 'bandpass'] },
            frequency: { min: 20, max: 20000 },
            q: { min: 0.1, max: 10 }
          },
          compressor: {
            threshold: { min: -60, max: 0 },
            ratio: { min: 1, max: 20 },
            attack: { min: 0.001, max: 1 },
            release: { min: 0.01, max: 1 }
          },
          eq: {
            low: { min: -24, max: 24 },
            mid: { min: -24, max: 24 },
            high: { min: -24, max: 24 }
          },
          bitcrusher: {
            bits: { min: 1, max: 16 }
          }
        };
        
        const config = typeConfig[fxType]?.[param];
        if (!config) return;
        
        let value;
        
        if (config.options) {
          // Discrete options
          const index = Math.round((sliderPercent / 100) * (config.options.length - 1));
          value = config.options[index];
        } else {
          // Continuous value
          value = config.min + (sliderPercent / 100) * (config.max - config.min);
        }
        
        track.updateFxParam(fxId, param, value);
        
        // Update display
        const label = e.target.closest('.param-control').querySelector('.param-value');
        if (label) {
          if (param === 'decay' || param === 'frequency' || param === 'delayTime') {
            label.textContent = typeof value === 'number' ? value.toFixed(1) : value;
            if (param === 'decay') label.textContent += 's';
            if (param === 'frequency') label.textContent += 'Hz';
            if (param === 'delayTime') label.textContent += 'ms';
          } else if (param === 'wet' || param === 'feedback' || param === 'depth' || param === 'amount') {
            label.textContent = Math.round(value * 100) + '%';
          } else if (param === 'threshold' || param === 'low' || param === 'mid' || param === 'high') {
            label.textContent = (value > 0 ? '+' : '') + Math.round(value) + 'dB';
          } else if (param === 'ratio') {
            label.textContent = value.toFixed(1) + ':1';
          } else if (param === 'attack' || param === 'release') {
            label.textContent = (value * 1000).toFixed(param === 'attack' ? 1 : 0) + 'ms';
          } else if (param === 'bits') {
            label.textContent = Math.round(value) + ' bits';
          } else if (param === 'q') {
            label.textContent = value.toFixed(1);
          } else {
            label.textContent = value.toString();
          }
        }
      });
    });
  }, 0);
}

// Open take editor for a track
function openTakeEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.takes.length === 0) {
    showToast('❌ No takes to edit', 'error');
    return;
  }
  
  // Create modal
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '700px';
  
  let takesHTML = '';
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    takesHTML += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${take.muted ? 'muted' : ''}" 
           style="margin-bottom: var(--space-3); padding: var(--space-4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="flex: 1;">
            <div style="font-weight: 800; font-size: var(--text-base); margin-bottom: var(--space-2);">
              Take ${idx + 1} ${isSelected ? '(Active)' : ''}
            </div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              ${take.duration.toFixed(2)}s • ${new Date(take.timestamp).toLocaleString()}
            </div>
          </div>
          <div style="display: flex; gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" data-action="play-take" data-index="${idx}">
              ▶️ Play
            </button>
            <button class="btn btn-secondary btn-sm" data-action="select-take" data-index="${idx}">
              ${isSelected ? '✓ Active' : 'Set Active'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="toggle-mute-take" data-index="${idx}">
              ${take.muted ? '🔇 Unmute' : '🔊 Mute'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="export-take" data-index="${idx}">
              💾
            </button>
            <button class="btn btn-ghost btn-sm" data-action="delete-take" data-index="${idx}">
              🗑️
            </button>
          </div>
        </div>
      </div>
    `;
  });
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">✂️ Edit Takes: ${track.name}</div>
      <button class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          <strong>${track.takes.length}</strong> take${track.takes.length !== 1 ? 's' : ''} recorded
        </div>
      </div>
      ${takesHTML}
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary close-btn">Close</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const close = () => {
    backdrop.remove();
    renderMultitrack();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.close-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  // Handle take actions
  modal.querySelectorAll('[data-action]').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      const index = parseInt(btn.dataset.index);
      
      if (action === 'play-take') {
        track.playTake(index);
      } else if (action === 'select-take') {
        track.selectTake(index);
        close();
      } else if (action === 'toggle-mute-take') {
        track.toggleTakeMute(index);
        close();
      } else if (action === 'export-take') {
        track.exportTake(index);
      } else if (action === 'delete-take') {
        if (confirm('Delete this take?')) {
          track.deleteTake(index);
          if (track.takes.length === 0) {
            close();
          } else {
            close();
          }
        }
      }
    });
  });
}

function openWaveformEditor(trackId, takeIndex) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) {
    console.error('Take or buffer not found');
    showToast('❌ Cannot edit: invalid take', 'error');
    return;
  }
  
  // Remove any existing modal
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '900px';
  modal.style.maxHeight = '90vh';
  
  const buffer = take.buffer;
  const duration = buffer.duration;
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">✂️ Waveform Editor: ${track.name} - Take ${takeIndex + 1}</div>
      <button class="modal-close">✕</button>
    </div>
    
    <div class="modal-body" style="overflow: visible;">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="waveformCanvas" 
                width="800" 
                height="200" 
                style="width: 100%; height: 200px; background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="grid grid-2" style="margin-bottom: var(--space-4);">
        <div class="param-control">
          <div class="param-label">
            <span>Trim Start</span>
            <span class="param-value" id="trimStartValue">0.00s</span>
          </div>
          <input type="range" id="trimStartSlider" min="0" max="100" value="0" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Trim End</span>
            <span class="param-value" id="trimEndValue">${duration.toFixed(2)}s</span>
          </div>
          <input type="range" id="trimEndSlider" min="0" max="100" value="100" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade In</span>
            <span class="param-value" id="fadeInValue">0ms</span>
          </div>
          <input type="range" id="fadeInSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade Out</span>
            <span class="param-value" id="fadeOutValue">0ms</span>
          </div>
          <input type="range" id="fadeOutSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Gain</span>
            <span class="param-value" id="gainValue">0dB</span>
          </div>
          <input type="range" id="gainSlider" min="-24" max="24" value="0" step="0.5">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Reverse</span>
            <span class="param-value"></span>
          </div>
          <label style="display: flex; align-items: center; gap: var(--space-2);">
            <input type="checkbox" id="reverseCheckbox">
            <span style="font-size: var(--text-sm);">Reverse audio</span>
          </label>
        </div>
      </div>
      
      <div style="display: flex; gap: var(--space-3); margin-bottom: var(--space-4); flex-wrap: wrap;">
        <button class="btn btn-secondary" id="previewEditBtn">▶️ Preview</button>
        <button class="btn btn-secondary" id="normalizeBtn">📊 Normalize</button>
        <button class="btn btn-ghost" id="resetEditsBtn">↻ Reset</button>
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); font-size: var(--text-sm); color: var(--text-tertiary);">
        <strong>Original:</strong> ${duration.toFixed(2)}s • 
        <strong>After edits:</strong> <span id="editedDurationLabel">${duration.toFixed(2)}s</span>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-edit-btn">Cancel</button>
      <button class="btn btn-success apply-edit-btn">✅ Apply Changes</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');
  
  // Editor state
  const editorState = {
    trimStart: 0,
    trimEnd: duration,
    fadeIn: 0,
    fadeOut: 0,
    gain: 0,
    reverse: false
  };
  
  // Draw waveform function
  function drawWaveform() {
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const channelData = buffer.getChannelData(0);
    const step = Math.ceil(channelData.length / width);
    const amp = height / 2;
    
    // Draw waveform
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    ctx.strokeStyle = 'rgb(124, 131, 255)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;
      
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < channelData.length) {
          const datum = channelData[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const x = i;
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      
      ctx.fillRect(x, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw trim markers
    const startX = (editorState.trimStart / duration) * width;
    const endX = (editorState.trimEnd / duration) * width;
    
    // Grayed out regions
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    if (startX > 0) ctx.fillRect(0, 0, startX, height);
    if (endX < width) ctx.fillRect(endX, 0, width - endX, height);
    
    // Trim lines
    ctx.strokeStyle = 'var(--warning)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, 0);
    ctx.lineTo(startX, height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(endX, 0);
    ctx.lineTo(endX, height);
    ctx.stroke();
    
    // Fade curves
    if (editorState.fadeIn > 0) {
      const fadeInDuration = editorState.fadeIn / 1000;
      const fadeInX = startX + (fadeInDuration / duration) * width;
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX, height);
      ctx.lineTo(Math.min(fadeInX, endX), 0);
      ctx.stroke();
    }
    
    if (editorState.fadeOut > 0) {
      const fadeOutDuration = editorState.fadeOut / 1000;
      const fadeOutX = endX - (fadeOutDuration / duration) * width;
      ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(Math.max(fadeOutX, startX), 0);
      ctx.lineTo(endX, height);
      ctx.stroke();
    }
  }
  
  // Initial draw
  setTimeout(() => drawWaveform(), 0);
  
  // Get controls
  const trimStartSlider = document.getElementById('trimStartSlider');
  const trimEndSlider = document.getElementById('trimEndSlider');
  const fadeInSlider = document.getElementById('fadeInSlider');
  const fadeOutSlider = document.getElementById('fadeOutSlider');
  const gainSlider = document.getElementById('gainSlider');
  const reverseCheckbox = document.getElementById('reverseCheckbox');
  
  function updateEditedDuration() {
    const newDuration = Math.max(0, editorState.trimEnd - editorState.trimStart);
    document.getElementById('editedDurationLabel').textContent = newDuration.toFixed(2) + 's';
  }
  
  // Trim start
  trimStartSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimStart = percent * duration;
    editorState.trimStart = Math.min(editorState.trimStart, editorState.trimEnd - 0.01);
    document.getElementById('trimStartValue').textContent = editorState.trimStart.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Trim end
  trimEndSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimEnd = percent * duration;
    editorState.trimEnd = Math.max(editorState.trimEnd, editorState.trimStart + 0.01);
    document.getElementById('trimEndValue').textContent = editorState.trimEnd.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Fade in
  fadeInSlider.addEventListener('input', (e) => {
    editorState.fadeIn = parseInt(e.target.value);
    document.getElementById('fadeInValue').textContent = editorState.fadeIn + 'ms';
    drawWaveform();
  });
  
  // Fade out
  fadeOutSlider.addEventListener('input', (e) => {
    editorState.fadeOut = parseInt(e.target.value);
    document.getElementById('fadeOutValue').textContent = editorState.fadeOut + 'ms';
    drawWaveform();
  });
  
  // Gain
  gainSlider.addEventListener('input', (e) => {
    editorState.gain = parseFloat(e.target.value);
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
  });
  
  // Reverse
  reverseCheckbox.addEventListener('change', (e) => {
    editorState.reverse = e.target.checked;
  });
  
  // Preview button
  let previewPlayer = null;
  document.getElementById('previewEditBtn').addEventListener('click', async () => {
    try {
      if (previewPlayer) {
        previewPlayer.stop();
        previewPlayer.dispose();
      }
      
      showToast('⏳ Rendering preview...', 'info');
      const editedBuffer = await applyEdits(buffer, editorState);
      
      previewPlayer = new Tone.Player(editedBuffer).toDestination();
      await Tone.start();
      previewPlayer.start();
      
      showToast('▶️ Previewing edits', 'info');
      
      setTimeout(() => {
        if (previewPlayer) {
          previewPlayer.stop();
          previewPlayer.dispose();
          previewPlayer = null;
        }
      }, editedBuffer.duration * 1000 + 100);
      
    } catch (err) {
      console.error('Preview failed:', err);
      showToast(`❌ Preview failed: ${err.message}`, 'error');
    }
  });
  
  // Normalize button
  document.getElementById('normalizeBtn').addEventListener('click', () => {
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('⚠️ Audio is silent, cannot normalize', 'warning');
      return;
    }
    
    const targetPeak = 0.891; // -1dB
    const gainDb = 20 * Math.log10(targetPeak / peak);
    
    gainSlider.value = gainDb.toFixed(1);
    editorState.gain = parseFloat(gainDb.toFixed(1));
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
    
    showToast(`✅ Normalized: ${gainDb.toFixed(1)}dB gain`, 'success');
  });
  
  // Reset button
  document.getElementById('resetEditsBtn').addEventListener('click', () => {
    editorState.trimStart = 0;
    editorState.trimEnd = duration;
    editorState.fadeIn = 0;
    editorState.fadeOut = 0;
    editorState.gain = 0;
    editorState.reverse = false;
    
    trimStartSlider.value = 0;
    trimEndSlider.value = 100;
    fadeInSlider.value = 0;
    fadeOutSlider.value = 0;
    gainSlider.value = 0;
    reverseCheckbox.checked = false;
    
    document.getElementById('trimStartValue').textContent = '0.00s';
    document.getElementById('trimEndValue').textContent = duration.toFixed(2) + 's';
    document.getElementById('fadeInValue').textContent = '0ms';
    document.getElementById('fadeOutValue').textContent = '0ms';
    document.getElementById('gainValue').textContent = '0dB';
    
    updateEditedDuration();
    drawWaveform();
    
    showToast('↻ Edits reset', 'info');
  });
  
  // Apply button
  document.querySelector('.apply-edit-btn').addEventListener('click', async () => {
    try {
      showToast('⏳ Processing audio...', 'info');
      
      const editedBuffer = await applyEdits(buffer, editorState);
      
      // Create new blob
      const offlineCtx = new OfflineAudioContext(
        editedBuffer.numberOfChannels,
        editedBuffer.length,
        editedBuffer.sampleRate
      );
      
      const source = offlineCtx.createBufferSource();
      source.buffer = editedBuffer;
      source.connect(offlineCtx.destination);
      source.start(0);
      
      const renderedBuffer = await offlineCtx.startRendering();
      const wavData = bufferToWavImproved(renderedBuffer);
      const newBlob = new Blob([wavData], { type: 'audio/wav' });
      
      // Update take
      take.buffer = editedBuffer;
      take.duration = editedBuffer.duration;
      take.blob = newBlob;
      
      backdrop.remove();
      renderMultitrack();
      showToast('✅ Waveform edited successfully!', 'success');
      
      console.log(`✅ Edited take ${takeIndex}: ${take.duration.toFixed(2)}s`);
      
    } catch (err) {
      console.error('Edit failed:', err);
      showToast(`❌ Edit failed: ${err.message}`, 'error');
    }
  });
  
  // Close handlers
  const close = () => {
    if (previewPlayer) {
      previewPlayer.stop();
      previewPlayer.dispose();
    }
    backdrop.remove();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-edit-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

async function applyEdits(buffer, edits) {
  const { trimStart, trimEnd, fadeIn, fadeOut, gain, reverse } = edits;
  
  const sampleRate = buffer.sampleRate;
  const numChannels = buffer.numberOfChannels;
  
  const startSample = Math.floor(trimStart * sampleRate);
  const endSample = Math.floor(trimEnd * sampleRate);
  const newLength = endSample - startSample;
  
  const newBuffer = Tone.context.rawContext.createBuffer(
    numChannels,
    newLength,
    sampleRate
  );
  
  const gainLinear = Tone.dbToGain(gain);
  const fadeInSamples = Math.floor((fadeIn / 1000) * sampleRate);
  const fadeOutSamples = Math.floor((fadeOut / 1000) * sampleRate);
  
  for (let c = 0; c < numChannels; c++) {
    const oldData = buffer.getChannelData(c);
    const newData = newBuffer.getChannelData(c);
    
    for (let i = 0; i < newLength; i++) {
      const oldIndex = reverse ? (endSample - 1 - i) : (startSample + i);
      let sample = oldData[oldIndex] || 0;
      
      // Apply gain
      sample *= gainLinear;
      
      // Apply fade in
      if (i < fadeInSamples) {
        sample *= (i / fadeInSamples);
      }
      
      // Apply fade out
      if (i > newLength - fadeOutSamples) {
        sample *= ((newLength - i) / fadeOutSamples);
      }
      
      newData[i] = sample;
    }
  }
  
  return newBuffer;
}

function setupArrangementDragScroll() {
  const scroll = document.getElementById('dawArrangementScroll');
  if (!scroll || scroll.dataset._dragScrollWired) return;
  scroll.dataset._dragScrollWired = 'true';

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let startScrollLeft = 0;
  let startScrollTop = 0;

  const onMouseDown = (e) => {
    // Only left button
    if (e.button !== 0) return;

    // Don't steal drags from regions / resize handles
    if (e.target.closest('.audio-region') || e.target.closest('.region-resize-handle')) {
      return;
    }

    isDragging = true;
    scroll.classList.add('drag-scroll-active');
    startX = e.clientX;
    startY = e.clientY;
    startScrollLeft = scroll.scrollLeft;
    startScrollTop = scroll.scrollTop;
  };

  const onMouseMove = (e) => {
    if (!isDragging) return;
    e.preventDefault(); // so you don't select text
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    scroll.scrollLeft = startScrollLeft - dx;
    scroll.scrollTop = startScrollTop - dy;
  };

  const endDrag = () => {
    if (!isDragging) return;
    isDragging = false;
    scroll.classList.remove('drag-scroll-active');
  };

  scroll.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', endDrag);
}
  
async function setupMultitrackListeners() {
  setupArrangementDragScroll();
  
  // === ADD TRACK BUTTON (DESKTOP) ===
  const addTrackBtn = document.getElementById('addTrackBtn');
  if (addTrackBtn && !addTrackBtn.dataset._wired) {
    addTrackBtn.dataset._wired = 'true';
    addTrackBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('🎚️ Add track clicked');
      showAddTrackDialog();
    });
  }

  // === ADD TRACK BUTTON (LEFT PANEL - MOBILE/DESKTOP) ===
  const addTrackBtnLeft = document.getElementById('addTrackBtnLeft');
  if (addTrackBtnLeft && !addTrackBtnLeft.dataset._wired) {
    addTrackBtnLeft.dataset._wired = 'true';
    addTrackBtnLeft.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('🎚️ Add track (left) clicked');
      showAddTrackDialog();
    });
  }

  // === ADD TRACK BUTTON (FLOATING - MOBILE) ===
  const addTrackBtnFloating = document.getElementById('addTrackBtnFloating');
  if (addTrackBtnFloating && !addTrackBtnFloating.dataset._wired) {
    addTrackBtnFloating.dataset._wired = 'true';
    addTrackBtnFloating.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('🎚️ Add track (floating) clicked');
      showAddTrackDialog();
    });
  }

  // === IMPORT STEM BUTTON ===
  const importBtn = document.getElementById('importStemBtn');
  if (importBtn && !importBtn.dataset._wired) {
    importBtn.dataset._wired = 'true';
    importBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('📁 Import stem clicked');
      
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/webm';

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        if (file.size > 50 * 1024 * 1024) {
          showToast('❌ File too large (max 50MB)', 'error');
          return;
        }

        try {
          showToast(`⏳ Importing ${file.name}...`, 'info');
          
          const arrayBuffer = await file.arrayBuffer();
          const audioCtx = Tone.context.rawContext;
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          
          const niceName = file.name.replace(/\.[^/.]+$/, '');
          const id = multitrack.nextTrackId++;
          
          // Create track
          const track = new AudioTrack(id, niceName, 'stem', false); // Not external audio
          
          // Create take
          const wavData = bufferToWavImproved(audioBuffer);
          const blob = new Blob([wavData], { type: 'audio/wav' });
          
          const take = {
            id: `take-${Date.now()}-${id}`,
            buffer: audioBuffer,
            blob: blob,
            startTime: 0,
            duration: audioBuffer.duration,
            muted: false,
            timestamp: new Date().toISOString(),
            source: 'external',
            fileName: file.name
          };
          
          track.takes.push(take);
          track.selectedTakeIndex = 0;
          
          multitrack.tracks.push(track);
          
          renderMultitrack();
          showToast(`✅ Imported: ${niceName} (${audioBuffer.duration.toFixed(1)}s)`, 'success');
          
        } catch (err) {
          console.error('Import failed:', err);
          showToast(`❌ Import failed: ${err.message}`, 'error');
        }
      };

      input.click();
    });
  }

  // === UNDO / REDO ===
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn && !undoBtn.dataset._wired) {
    undoBtn.dataset._wired = 'true';
    undoBtn.addEventListener('click', () => multitrackHistory.undo());
  }
  
  if (redoBtn && !redoBtn.dataset._wired) {
    redoBtn.dataset._wired = 'true';
    redoBtn.addEventListener('click', () => multitrackHistory.redo());
  }

  // === LEGACY BUTTONS ===
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) {
    previewBtn.onclick = async () => {
      if (previewBtn.textContent.includes('Stop')) {
        stopMultitrackPreview();
        previewBtn.textContent = '▶️ Preview Mix';
      } else {
        await previewMultitrack(multitrack.playheadSeconds || 0);
        previewBtn.textContent = '⏹️ Stop Preview';
      }
    };
  }

  const recordArmedBtn = document.getElementById('recordArmedBtn');
  if (recordArmedBtn) recordArmedBtn.onclick = async () => await toggleRecordAllArmed();

  // === DAW TRANSPORT CONTROLS ===
  const playBtn = document.getElementById('dawPlayBtn');
  const stopBtn = document.getElementById('dawStopBtn');
  const rewindBtn = document.getElementById('dawRewindBtn');
  const forwardBtn = document.getElementById('dawForwardBtn');
  const recordBtn = document.getElementById('dawRecordBtn');

  if (playBtn) {
    playBtn.onclick = async () => {
      if (playBtn.textContent.trim() === '▶️') {
        // PLAY → start / resume from current playhead
        playBtn.textContent = '⏸️';
        await previewMultitrack(multitrack.playheadSeconds || 0);
      } else {
        // PAUSE → stop audio but keep position
        playBtn.textContent = '▶️';
        stopMultitrackPreview(); // no resetToZero → resume later
      }
    };
  }
  
  if (stopBtn) {
    stopBtn.onclick = () => {
      // STOP → full reset to 0
      playBtn.textContent = '▶️';
      stopMultitrackPreview(true);      // resetToZero = true
      updatePlayheadAndScroll(0);       // visually + timecode reset
    };
  }

  
  if (rewindBtn) {
    rewindBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target = Math.max(0, current - 5);
  
      updatePlayheadAndScroll(target);
    };
  }
  
  if (forwardBtn) {
    forwardBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target = Math.min(projDur, current + 5);
  
      updatePlayheadAndScroll(target);
    };
  }


  if (recordBtn) {
    recordBtn.onclick = () => {
      recordBtn.classList.toggle('active');
      if (recordBtn.classList.contains('active')) {
        startGlobalRecording();
      } else {
        stopGlobalRecording();
      }
    };
  }

    // === LOOP / CLICK / COUNT ===
  const loopBtn = document.getElementById('dawLoopBtn');
  const clickBtn = document.getElementById('dawClickBtn');
  const countInBtn = document.getElementById('dawCountInBtn');

  // Make sure we have a loop flag in multitrack state
  if (typeof multitrack.loopEnabled === 'undefined') {
    multitrack.loopEnabled = false;
  }

  // 🔁 LOOP: just a flag + visual
  if (loopBtn) {
    // Initial state
    loopBtn.classList.toggle('active', !!multitrack.loopEnabled);

    loopBtn.onclick = () => {
      multitrack.loopEnabled = !multitrack.loopEnabled;
      loopBtn.classList.toggle('active', multitrack.loopEnabled);
      showToast(
        multitrack.loopEnabled ? '🔁 Loop Enabled (multitrack preview)' : '⏹️ Loop Disabled',
        'info'
      );
    };
  }

    // === LOOP REGION SELECTION (Select tool drag on empty timeline) ===
  const scroll = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');

  if (scroll && loopHighlight && !scroll.dataset._loopWired) {
    scroll.dataset._loopWired = 'true';

    let dragStartX = null;

    scroll.addEventListener('scroll', () => {
      updateLoopRegionHighlight();
    });
    
    scroll.addEventListener('mousedown', (e) => {
      // Only left-click + Select tool
      if (e.button !== 0) return;
      if (multitrack.currentTool !== 'select') return;

      // Ignore dragging on a region/clip
      if (e.target.closest('.audio-region') || e.target.closest('.daw-clip')) return;

      const rect = scroll.getBoundingClientRect();
      dragStartX = e.clientX - rect.left + scroll.scrollLeft;

      loopHighlight.style.display = 'block';
      loopHighlight.style.left = dragStartX + 'px';
      loopHighlight.style.width = '0px';
    });

    scroll.addEventListener('mousemove', (e) => {
      if (dragStartX === null) return;

      const rect = scroll.getBoundingClientRect();
      const currentX = e.clientX - rect.left + scroll.scrollLeft;
      const width = currentX - dragStartX;

      loopHighlight.style.width = Math.abs(width) + 'px';
      loopHighlight.style.left = (width < 0 ? currentX : dragStartX) + 'px';
    });

    const finishLoopDrag = (e) => {
      if (dragStartX === null) return;

      const rect = scroll.getBoundingClientRect();
      const dragEndX = e.clientX - rect.left + scroll.scrollLeft;
      const zoom = multitrack.zoom || 100;

      const startPx = Math.min(dragStartX, dragEndX);
      const endPx = Math.max(dragStartX, dragEndX);

      const startSec = startPx / zoom;
      const endSec = endPx / zoom;
      const dragLength = endSec - startSec;

      loopHighlight.style.display = 'none';
      dragStartX = null;

      if (dragLength > 0.25) {
        // Treat as loop selection
        setLoopRegion(startSec, endSec);
      } else {
        // Tiny click = clear loop
        clearLoopRegion();
      }
    };

    scroll.addEventListener('mouseup', finishLoopDrag);
    scroll.addEventListener('mouseleave', finishLoopDrag);
  }

  // 🥁 CLICK: sync with main metronome state
  if (clickBtn) {
    // Initial state from global metronome
    clickBtn.classList.toggle('active', !!state.metronomeEnabled);

    clickBtn.onclick = () => {
      state.metronomeEnabled = !state.metronomeEnabled;
      clickBtn.classList.toggle('active', state.metronomeEnabled);

      const mainMetBtn = document.getElementById('metronomeBtn');
      if (mainMetBtn) {
        mainMetBtn.textContent = state.metronomeEnabled
          ? '🥁 Click: On'
          : '🥁 Click: Off';
      }

      showToast(
        state.metronomeEnabled ? '🥁 Click ON (global)' : '🥁 Click OFF',
        'info'
      );
    };
  }

  // ⏱️ COUNT-IN: share the same countInBars as main transport
  if (countInBtn) {
    const labels = ['⏱️ Count: Off', '⏱️ Count: 1 bar', '⏱️ Count: 2 bars'];

    // Initialise label + active state from current countInBars
    const safeCount = Number.isInteger(state.countInBars) ? state.countInBars : 0;
    state.countInBars = safeCount;
    countInBtn.textContent = labels[state.countInBars];
    countInBtn.classList.toggle('active', state.countInBars > 0);

    countInBtn.onclick = () => {
      // 0 -> 1 -> 2 -> 0
      state.countInBars =
        state.countInBars === 1 ? 2 :
        state.countInBars === 2 ? 0 : 1;

      countInBtn.textContent = labels[state.countInBars];
      countInBtn.classList.toggle('active', state.countInBars > 0);

      const mainCountBtn = document.getElementById('countInBtn');
      if (mainCountBtn && mainCountBtn !== countInBtn) {
        mainCountBtn.textContent = labels[state.countInBars];
      }

      showToast(
        state.countInBars === 0
          ? '⏱️ Count-in OFF'
          : `⏱️ Count-in: ${state.countInBars} bar(s)`,
        'info'
      );
    };
  }

  // === BPM + TIME SIG ===
  const bpmInput = document.getElementById('dawBpmInput');
  const timeSigSelect = document.getElementById('dawTimeSigSelect');
  if (bpmInput) bpmInput.onchange = e => setBPM(parseFloat(e.target.value));
  if (timeSigSelect) timeSigSelect.onchange = e => setTimeSignature(e.target.value);

  // === ZOOM CONTROLS ===
  const zoomInBtn = document.getElementById('dawZoomInBtn') || document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('dawZoomOutBtn') || document.getElementById('zoomOutBtn');
  const zoomFitBtn = document.getElementById('dawZoomFitBtn') || document.getElementById('zoomFitBtn');

  const applyZoom = (factor) => {
    multitrack.zoom = Math.max(20, Math.min(500, multitrack.zoom * factor));
    renderMultitrack();
    showToast(`🔍 Zoom: ${Math.round(multitrack.zoom)}px/s`, 'info');
  };

  if (zoomInBtn) zoomInBtn.onclick = () => applyZoom(1.5);
  if (zoomOutBtn) zoomOutBtn.onclick = () => applyZoom(1 / 1.5);
  if (zoomFitBtn) zoomFitBtn.onclick = () => {
    let maxDuration = 0;
    multitrack.tracks.forEach(t => {
      t.takes.forEach(take => {
        const end = (take.startTime || 0) + take.duration;
        if (end > maxDuration) maxDuration = end;
      });
    });
    if (maxDuration > 0) {
      const canvasWidth = 800;
      multitrack.zoom = canvasWidth / maxDuration;
      renderMultitrack();
      showToast('✅ Zoom to fit', 'success');
    }
  };

    // === TOOL BUTTONS (Select / Pencil / Split / Fade) ===
  const toolButtons = document.querySelectorAll('.tool-btn');
  if (toolButtons.length) {
    toolButtons.forEach(btn => {
      if (btn.dataset._wired) return;
      btn.dataset._wired = 'true';

      btn.addEventListener('click', () => {
        const tool = btn.dataset.tool || 'select';
        multitrack.currentTool = tool;

        toolButtons.forEach(b =>
          b.classList.toggle('active', b === btn)
        );

        // Optional toast so you can see it’s doing something
        showToast(`✏️ Tool: ${tool}`, 'info');
      });
    });
  }

  // === SNAP ===
  const snapSelect = document.getElementById('dawSnapSelect');
  if (snapSelect && !snapSelect.dataset._wired) {
    snapSelect.dataset._wired = 'true';
  
    snapSelect.addEventListener('change', (e) => {
      const value = e.target.value;
      if (value === 'off') {
        multitrack.snapEnabled = false;
        showToast('🧲 Snap OFF', 'info');
      } else {
        multitrack.snapEnabled = true;
        const mapping = { bar: 4, beat: 1, '1/2': 0.5, '1/4': 0.25 };
        multitrack.snapInterval = mapping[value] ?? 1;
        showToast(`🧲 Snap: ${value}`, 'info');
      }
    });
  
    // Make sure we start with snap ON (e.g. to beats)
    if (!snapSelect.value) snapSelect.value = 'beat';
    snapSelect.dispatchEvent(new Event('change'));
  }


  // === SESSION MANAGEMENT ===
  const newBtn = document.getElementById('newSessionBtn');
  const saveBtn = document.getElementById('saveSessionBtn');
  const loadBtn = document.getElementById('loadSessionBtn');
  if (newBtn) newBtn.onclick = () => newMultitrackSession();
  if (saveBtn) saveBtn.onclick = () => saveMultitrackSession();
  if (loadBtn) loadBtn.onclick = () => loadMultitrackSession();

  // === GRID / AUTOMATION ===
  const gridBtn = document.getElementById('dawGridBtn');
  const autoBtn = document.getElementById('dawAutomationBtn');
  if (gridBtn) gridBtn.onclick = () => toggleGrid();
  if (autoBtn) autoBtn.onclick = () => toggleAutomationView();

  // === BOUNCE / CLEAR ===
  const bounceBtn = document.getElementById('bounceAllBtn');
  if (bounceBtn) bounceBtn.onclick = () => bounceAllTracks();

  const clearBtn = document.getElementById('clearAllTracksBtn');
  if (clearBtn) {
    clearBtn.onclick = () => {
      if (confirm('Delete all tracks? This cannot be undone.')) {
        multitrack.tracks.forEach(t => t.dispose());
        multitrack.tracks = [];
        multitrack.nextTrackId = 1;
        renderMultitrack();
      }
    };
  }

  // === FX CHAIN EDITOR ===
const fxAddBtn  = document.getElementById('fxAddBtn');
const fxAddMenu = document.getElementById('fxAddMenu');
const closeFxBtn = document.getElementById('closeFxPanelBtn');

// Only wire once
if (fxAddBtn && fxAddMenu && !fxAddMenu.dataset._wired) {
  fxAddMenu.dataset._wired = 'true';

    fxAddBtn.onclick = (e) => {
    e.stopPropagation();
    e.preventDefault();

    const isVisible = fxAddMenu.style.display === 'block';
    fxAddMenu.style.display = isVisible ? 'none' : 'block';
    // Placement is now purely handled by CSS (.fx-add-menu above the header)
  };

  // Close menu when clicking outside
  document.addEventListener('click', (e) => {
    if (!fxAddBtn.contains(e.target) && !fxAddMenu.contains(e.target)) {
      fxAddMenu.style.display = 'none';
    }
  });

  // FX type selection (unchanged logic)
  fxAddMenu.addEventListener('click', (e) => {
    const item = e.target.closest('.fx-add-item');
    if (!item) return;

    const fxType = item.dataset.fxType;
    if (!fxType) return;

    const trackId = Number(multitrack.currentFxTrackId);
    const track = multitrack.tracks.find(t => t.id === trackId);
    if (!track) {
      showToast('❌ No track selected', 'error');
      return;
    }

    const fxObj = track.addFx(fxType);
    if (!fxObj) {
      showToast(`❌ FX type "${fxType}" not recognized`, 'error');
      return;
    }

    renderFxChain(track);
    fxAddMenu.style.display = 'none';
    showToast(`✅ Added ${fxType} to ${track.name}`, 'success');
  });
}

// Track-level "+ Add FX" buttons still open the FX panel for that track
document.addEventListener('click', (e) => {
  if (e.target.classList.contains('add-fx-btn')) {
    const trackIndex = Array.from(document.querySelectorAll('.track-strip'))
      .indexOf(e.target.closest('.track-strip'));

    // Your existing function that opens the FX panel for that track
    showFXMenu(trackIndex, e.target);
  }
});

// Close FX panel button
if (closeFxBtn) {
  closeFxBtn.onclick = () => {
    const panel = document.getElementById('fxChainPanel');
    if (panel) panel.style.display = 'none';
    multitrack.currentFxTrackId = null;
  };
}

  // === TIMELINE + RULER ===
  setupTimelineCursor();
  updateTimelineRuler();
}

function addTrackFX(trackIndex, fxType) {
  const trackStrip = document.querySelectorAll('.track-strip')[trackIndex];
  let fxPanel = trackStrip.querySelector('.track-fx-panel');
  
  if (!fxPanel) {
    fxPanel = document.createElement('div');
    fxPanel.className = 'track-fx-panel';
    fxPanel.innerHTML = `
      <div class="fx-chain-mini">
        <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
        <div class="fx-slots-inline"></div>
      </div>
    `;
    trackStrip.appendChild(fxPanel);
  }
  
  fxPanel.style.display = 'block';
  
  const fxSlots = fxPanel.querySelector('.fx-slots-inline');
  const fxUnit = document.createElement('div');
  fxUnit.className = 'fx-unit-mini';
  fxUnit.innerHTML = `
    <span>${fxType}</span>
    <div class="fx-toggle" onclick="this.classList.toggle('active')"></div>
    <button class="fx-remove-btn" onclick="this.parentElement.remove()">×</button>
  `;
  
  fxSlots.appendChild(fxUnit);
}
  
// Utility
function updatePlayheadUI(seconds) {
  const el = document.getElementById('dawPlayhead');
  if (!el) return;
  const dur = multitrack.projectDuration || (state.duration * 60);
  el.style.left = `${(seconds / dur) * 100}%`;
}
  
// -------------------- Preset System --------------------
function renderPresets() {
  const grid = document.getElementById('sidebarPresets');
  const fragment = document.createDocumentFragment();
  
  Object.keys(genrePresets).forEach(genre => {
    const preset = genrePresets[genre];
    const div = document.createElement('div');
    div.className = 'sidebar-preset';
    div.innerHTML = `
      <div class="sidebar-preset-icon">${preset.icon}</div>
      <div class="sidebar-preset-name">${preset.name}</div>
    `;
    div.addEventListener('click', () => {
      loadPreset(genre);
      closeSidebar();
    });
    fragment.appendChild(div);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

function loadPreset(genre) {
  state.currentGenre = genre;
  document.querySelectorAll('.genre-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.genre === genre);
  });
  generateBeat();
}

function updateGenrePresets() {
  renderPresets();
}

// -------------------- Transport Controls --------------------
async function togglePlay() {
  try {
    // Ensure audio context is running
    await Tone.start();
    const raw = Tone.getContext().rawContext;
    if (raw.state !== 'running') await raw.resume();
  } catch (e) {
    console.error('Could not start audio:', e);
    alert('Could not start audio. Click anywhere on the page, then press Play again.');
    return;
  }

  if (state.isPlaying) {
    // 🟡 Pause
    Tone.Transport.pause();
    state.pausedAt = Tone.Transport.seconds; // remember position
    state.isPlaying = false;
    document.getElementById('playBtn').innerHTML = '▶️ Play';
    stopTimer();
    stopVisualizer();
    stopPlayheadAnimation();
    return;
  }

  // 🟢 If not playing, check for active steps
  const hasActive = Object.keys(patterns).some(inst =>
    patterns[inst].some(s => s.active)
  );
  if (!hasActive) {
    alert('No active notes — click "Generate Beat" or add steps.');
    return;
  }

  // 🟢 Resume from where you left off (or start fresh)
  const resumeTime = state.pausedAt || 0;
  Tone.Transport.seconds = resumeTime;
  Tone.Transport.start();

  state.isPlaying = true;
  state.startTime = performance.now() - (resumeTime * 1000); // keep timer in sync
  document.getElementById('playBtn').innerHTML = '⏸️ Pause';
  startTimer();
  startPlayheadAnimation();
  document.getElementById('vizOverlay').style.display = 'none';
  updateVisualizer();
}

function stop() {
  // 🔴 Fully stop and reset playback
  Tone.Transport.stop();
  state.isPlaying = false;
  state.pausedAt = 0;
  state.currentStep = 0;
  document.getElementById('playBtn').innerHTML = '▶️ Play';
  document.getElementById('timeDisplay').textContent = '00:00';
  document.getElementById('progressFill').style.width = '0%';
  document.querySelectorAll('.step').forEach(el => el.classList.remove('playing'));
  stopTimer();
  stopVisualizer();
  stopPlayheadAnimation();

  // Reset playhead to start
  const playhead = document.getElementById('dawPlayhead');
  if (playhead) playhead.style.left = '0px';

  // Stop multitrack preview
  stopMultitrackPreview();
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) previewBtn.textContent = '▶️ Preview Mix';
}


// -------------------- Timer System --------------------
let progressRAF = 0;

function startTimer() {
  cancelAnimationFrame(progressRAF);
  
  const totalSeconds = state.duration * 60;
  const updateProgress = throttle(() => {
    const seconds = Tone.Transport.seconds;
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    
    document.getElementById('timeDisplay').textContent = 
      String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    
    document.getElementById('progressFill').style.width = 
      Math.min(100, (seconds / totalSeconds) * 100) + '%';
  }, CONFIG.PROGRESS_UPDATE_MS);
  
  const tick = () => {
    updateProgress();
    progressRAF = requestAnimationFrame(tick);
  };
  
  progressRAF = requestAnimationFrame(tick);
}

function stopTimer() {
  cancelAnimationFrame(progressRAF);
  progressRAF = 0;
}

// -------------------- Visualizer System --------------------
let visualizerRAF = 0;
let lastVisualizerUpdate = 0;

function initVisualizerOnce() {
  const viz = document.getElementById('visualizer');
  if (viz.dataset.ready) return;
  
  viz.dataset.ready = '1';
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < CONFIG.VISUALIZER_BARS; i++) {
    const bar = document.createElement('div');
    bar.className = 'viz-bar';
    bar.style.left = (i * 100 / CONFIG.VISUALIZER_BARS) + '%';
    bar.style.height = '10%';
    fragment.appendChild(bar);
  }
  
  viz.appendChild(fragment);
}

function updateVisualizer() {
  if (visualizerRAF) return;
  
  const viz = document.getElementById('visualizer');
  const bars = viz ? viz.querySelectorAll('.viz-bar') : [];
  const barCount = bars.length || 0;
  
  const updateInterval = 1000 / CONFIG.VISUALIZER_FPS;
  
  const loop = (timestamp) => {
    visualizerRAF = requestAnimationFrame(loop);
    
    if (!lastVisualizerUpdate || (timestamp - lastVisualizerUpdate) >= updateInterval) {
      lastVisualizerUpdate = timestamp;
      
      let heights;
      if (master.analyser) {
        const values = master.analyser.getValue();
        heights = new Array(barCount).fill(0).map((_, i) => {
          const index = Math.floor((i / barCount) * values.length);
          const value = values[clamp(index, 0, values.length - 1)];
          
          if (master.analyser.type === 'fft') {
            const db = clamp(value, -100, 0);
            const normalized = (db + 100) / 100;
            return (5 + normalized * 90).toFixed(1) + '%';
          } else {
            const normalized = (value + 1) / 2;
            return (5 + normalized * 90).toFixed(1) + '%';
          }
        });
      } else {
        heights = Array.from({ length: barCount }, () => 
          (Math.random() * 60 + 10).toFixed(1) + '%'
        );
      }
      
      bars.forEach((bar, i) => {
        bar.style.height = heights[i];
        bar.style.transform = '';
      });
    }
  };
  
  visualizerRAF = requestAnimationFrame(loop);
}

function stopVisualizer() {
  cancelAnimationFrame(visualizerRAF);
  visualizerRAF = 0;
}

// -------------------- Project Management --------------------
function getSerializableInstruments() {
  const keep = ['name', 'icon', 'mute', 'solo', 'volume', 'pan', 'type', 'note'];
  const cleaned = {};
  
  Object.keys(instruments).forEach(key => {
    cleaned[key] = {};
    keep.forEach(field => {
      cleaned[key][field] = instruments[key][field];
    });
  });
  
  return cleaned;
}

async function saveProject() {
  const projectName = document.getElementById('projectName').value || 'Untitled';
  
  showToast('💾 Saving project (with all audio)...', 'info');
  
  // Serialize patterns
  const plainPatterns = {};
  Object.keys(patterns).forEach(inst => {
    plainPatterns[inst] = patterns[inst].map(step => ({
      active: !!step.active,
      velocity: step.velocity ?? 0.8,
      probability: step.probability ?? 100,
      note: step.note ?? instruments[inst].note ?? null,
      duration: step.duration ?? '8n'
    }));
  });
  
  // Serialize FX config
  const fxState = {};
  Object.keys(fxConfig).forEach(fx => {
    fxState[fx] = { ...fxConfig[fx] };
  });
  
  // Serialize multitrack WITH AUDIO
  const multitrackData = {
    tracks: [],
    nextTrackId: multitrack.nextTrackId,
    zoom: multitrack.zoom,
    snapEnabled: multitrack.snapEnabled,
    snapInterval: multitrack.snapInterval
  };
  
  // Convert audio blobs to base64 for each track
  for (const track of multitrack.tracks) {
    const trackData = {
      id: track.id,
      name: track.name,
      instrument: track.instrument,
      isExternalAudio: track.isExternalAudio,
      volume: track.volume,
      pan: track.pan,
      muted: track.muted,
      soloed: track.soloed,
      armed: track.armed,
      inputMonitoring: track.inputMonitoring,
      selectedTakeIndex: track.selectedTakeIndex,
      fxChain: track.fxChain.map(fx => ({
        type: fx.type,
        params: fx.params,
        enabled: fx.enabled
      })),
      takes: []
    };
    
    // Convert each take's audio blob to base64
    for (const take of track.takes) {
      try {
        const base64Audio = await blobToBase64(take.blob);
        
        trackData.takes.push({
          id: take.id,
          duration: take.duration,
          timestamp: take.timestamp,
          muted: take.muted,
          startTime: take.startTime,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd,
          recordedAt: take.recordedAt,
          audioData: base64Audio,
          mimeType: take.blob.type
        });
      } catch (err) {
        console.error(`Failed to encode take ${take.id}:`, err);
      }
    }
    
    multitrackData.tracks.push(trackData);
  }
  
  const project = {
    version: '2.1', // Increment for complete state save
    name: projectName,
    state: {
      bpm: state.bpm,
      swing: state.swing,
      duration: state.duration,
      complexity: state.complexity,
      humanize: state.humanize,
      sequenceLength: state.sequenceLength,
      resolution: state.resolution,
      currentGenre: state.currentGenre,
      key: state.key,
      scale: state.scale,
      octave: state.octave,
      progression: state.progression,
      masterVolume: state.masterVolume,
      tapeSaturation: state.tapeSaturation,
      vinylNoise: state.vinylNoise,
      lowCut: state.lowCut,
      highCut: state.highCut,
      compressor: state.compressor,
      metronomeEnabled: state.metronomeEnabled,
      metronomeVolume: state.metronomeVolume,
      countInBars: state.countInBars,
      aiMixing: state.aiMixing
    },
    patterns: plainPatterns,
    instruments: getSerializableInstruments(),
    fxConfig: fxState,
    multitrack: multitrackData,
    timestamp: Date.now(),
    savedVibe: document.body.getAttribute('data-vibe')
  };
  
  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  
  const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${projectName.replace(/\s+/g, '_')}_${Date.now()}.8beat.json`;
  link.click();
  
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  console.log(`💾 Full project saved: ${projectName} (${sizeMB}MB)`);
  showToast(`✅ Complete project saved! (${sizeMB}MB with ${multitrackData.tracks.length} tracks)`, 'success');
}

// Helper function to convert Blob to Base64
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // Remove the data URL prefix (e.g., "data:audio/webm;base64,")
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert Base64 back to Blob
function base64ToBlob(base64, mimeType) {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function applyLoadedInstruments(loaded) {
  Object.keys(loaded).forEach(inst => {
    const source = loaded[inst];
    if (!instruments[inst]) return;
    
    instruments[inst].mute = !!source.mute;
    instruments[inst].solo = !!source.solo;
    instruments[inst].volume = source.volume ?? instruments[inst].volume;
    instruments[inst].pan = source.pan ?? instruments[inst].pan;
    instruments[inst].note = source.note ?? instruments[inst].note;
    
    if (instruments[inst].channel) {
      instruments[inst].channel.volume.value = instruments[inst].volume;
      instruments[inst].channel.pan.value = (instruments[inst].pan || 0) / 100;
    }
  });
}

function loadProject() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.8beat.json';
  
  input.onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async ev => {
      try {
        const project = JSON.parse(ev.target.result);
        
        console.log('📂 Loading project:', project.name, 'version:', project.version);
        showToast('⏳ Loading complete project...', 'info');
        
        // Stop playback
        if (state.isPlaying) {
          stop();
        }
        
        // Load ALL state
        Object.assign(state, {
          ...state,
          ...project.state,
          isPlaying: false,
          currentStep: 0
        });
        
        // Load patterns
        Object.keys(patterns).forEach(k => delete patterns[k]);
        Object.assign(patterns, project.patterns || {});
        
        // Load instruments
        if (project.instruments) {
          applyLoadedInstruments(project.instruments);
        }
        
        // Load FX config
        if (project.fxConfig) {
          Object.assign(fxConfig, project.fxConfig);
        }
        
        // Load vibe/theme
        if (project.savedVibe) {
          applyVibe(project.savedVibe);
        }
        
        // Load multitrack
        if (project.multitrack) {
          multitrack.tracks.forEach(t => t.dispose());
          multitrack.tracks = [];
          
          multitrack.zoom = project.multitrack.zoom || 100;
          multitrack.snapEnabled = project.multitrack.snapEnabled ?? true;
          multitrack.snapInterval = project.multitrack.snapInterval || 0.25;
          
          for (const trackData of project.multitrack.tracks) {
            const track = new AudioTrack(
              trackData.id,
              trackData.name,
              trackData.instrument,
              trackData.isExternalAudio
            );
            
            track.volume = trackData.volume;
            track.pan = trackData.pan;
            track.muted = trackData.muted;
            track.soloed = trackData.soloed;
            track.armed = trackData.armed;
            track.inputMonitoring = trackData.inputMonitoring || false;
            track.selectedTakeIndex = trackData.selectedTakeIndex;
            
            track.channel.volume.value = track.volume;
            track.channel.pan.value = track.pan / 100;
            
            // Restore FX chain
            if (trackData.fxChain && trackData.fxChain.length > 0) {
              trackData.fxChain.forEach(fxData => {
                track.addFx(fxData.type, fxData.params);
                const fx = track.fxChain[track.fxChain.length - 1];
                if (fx) {
                  fx.enabled = fxData.enabled;
                }
              });
            }
            
            // Restore takes with audio
            if (trackData.takes && trackData.takes.length > 0) {
              showToast(`🎵 Restoring ${trackData.takes.length} take(s) for ${track.name}...`, 'info');
              
              for (const takeData of trackData.takes) {
                try {
                  const blob = base64ToBlob(takeData.audioData, takeData.mimeType);
                  const arrayBuffer = await blob.arrayBuffer();
                  const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
                  
                  const take = {
                    id: takeData.id,
                    buffer: audioBuffer,
                    blob: blob,
                    duration: takeData.duration,
                    timestamp: takeData.timestamp,
                    muted: takeData.muted,
                    startTime: takeData.startTime,
                    trimStart: takeData.trimStart,
                    trimEnd: takeData.trimEnd,
                    recordedAt: takeData.recordedAt
                  };
                  
                  track.takes.push(take);
                  console.log(`✅ Restored take ${take.id} (${take.duration.toFixed(2)}s)`);
                  
                } catch (err) {
                  console.error(`Failed to restore take ${takeData.id}:`, err);
                }
              }
            }
            
            multitrack.tracks.push(track);
          }
          
          multitrack.nextTrackId = project.multitrack.nextTrackId;
        }
        
        // Update ALL displays
        updateAllDisplays();
        ensurePatternLength(state.sequenceLength);
        
        // Set genre selector
        if (state.currentGenre) {
          document.querySelectorAll('.genre-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.genre === state.currentGenre);
          });
        }
        
        // Update BPM in transport
        Tone.Transport.bpm.value = state.bpm;
        Tone.Transport.swing = state.swing / 100;
        
        renderSequencer();
        renderMixer();
        renderFX();
        renderHarmony();
        renderMultitrack();
        
        document.getElementById('projectName').value = project.name || 'Untitled';
        
        const totalTakes = multitrack.tracks.reduce((sum, t) => sum + t.takes.length, 0);
        console.log('✅ Complete project loaded successfully');
        showToast(`✅ Project loaded: ${totalTakes} recording(s), ${multitrack.tracks.length} tracks!`, 'success');
        
      } catch (err) {
        console.error('❌ Load project error:', err);
        showToast('❌ Error loading project: ' + err.message, 'error');
      }
    };
    
    reader.readAsText(file);
  };
  
  input.click();
}
  
function updateAllDisplays() {
  state.bpm = Math.min(CONFIG.MAX_BPM, state.bpm);
  
  document.getElementById('bpmSlider').value = state.bpm;
  document.getElementById('bpmValue').textContent = state.bpm;
  document.getElementById('swingSlider').value = state.swing;
  document.getElementById('swingValue').textContent = state.swing + '%';
  document.getElementById('durSlider').value = state.duration;
  document.getElementById('durValue').textContent = state.duration + ' min';
  document.getElementById('durationDisplay').textContent = 
    '/ ' + String(state.duration).padStart(2, '0') + ':00';
  document.getElementById('complexSlider').value = state.complexity;
  document.getElementById('complexValue').textContent = 
    ['Simple', 'Medium', 'Complex'][state.complexity - 1];
  document.getElementById('humanSlider').value = state.humanize;
  document.getElementById('humanValue').textContent = state.humanize + 'ms';
  
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';
}

// -------------------- Audio Export --------------------
function bufferToWav(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = clamp(channels[c][i], -1, 1);
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

async function exportAudio() {
  // Live recording only - captures real-time output
  await exportLiveRecording();
}

// Improved WAV converter with peak normalization
function bufferToWavImproved(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  
  // Find peak for normalization
  let peak = 0;
  for (let c = 0; c < numChannels; c++) {
    const channelData = audioBuffer.getChannelData(c);
    for (let i = 0; i < numFrames; i++) {
      const abs = Math.abs(channelData[i]);
      if (abs > peak) peak = abs;
    }
  }
  
  // Calculate normalization factor (leave 1dB headroom)
  const targetPeak = 0.891; // -1dB
  const normFactor = peak > 0 ? Math.min(targetPeak / peak, 1) : 1;
  
  console.log(`🎚️ Normalizing: peak=${peak.toFixed(3)}, factor=${normFactor.toFixed(3)}`);
  
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples with normalization
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = channels[c][i] * normFactor;
      sample = Math.max(-1, Math.min(1, sample)); // Hard clip
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

// Live recording - captures what you hear in real-time
async function exportLiveRecording() {
  // if we're already recording, this call means "stop & download"
  if (master.mediaRecorder && master.mediaRecorder.state === 'recording') {
    master.mediaRecorder.stop();
    return;
  }

  await Tone.start();

  const stream = master.mediaDest?.stream;
  if (!stream) {
    alert('❌ No recording stream available.');
    return;
  }

  let mimeType = '';
  if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
    mimeType = 'audio/webm;codecs=opus';
  } else if (MediaRecorder.isTypeSupported('audio/webm')) {
    mimeType = 'audio/webm';
  }

  master.recordedChunks = [];
  const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
  master.mediaRecorder = rec;

  rec.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) {
      master.recordedChunks.push(e.data);
    }
  };

  rec.onstop = () => {
    const blob = new Blob(master.recordedChunks, {
      type: rec.mimeType || 'audio/webm'
    });

    const name = (document.getElementById('projectName')?.value || 'live_mix')
      .replace(/\s+/g, '_') + `_${Date.now()}`;

    let ext = 'webm';
    if ((rec.mimeType || '').includes('ogg')) ext = 'ogg';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.${ext}`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    const btn = document.getElementById('exportBtn');
    if (btn) btn.textContent = '🎧 DJ Export';
    
    showToast('✅ Live mix exported!', 'success');
  };

  rec.start();

  const btn = document.getElementById('exportBtn');
  if (btn) btn.textContent = '⏹️ Stop Recording';
  
  showToast('🎙️ Recording live output...', 'info');
}

function updateLoopRegionHighlight() {
  const scroll = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');
  if (!scroll || !loopHighlight) return;

  const zoom = multitrack.zoom || 100;
  const { loopStart, loopEnd } = multitrack;

  const hasRegion =
    typeof loopStart === 'number' &&
    typeof loopEnd === 'number' &&
    loopEnd > loopStart;

  if (!hasRegion) {
    loopHighlight.style.display = 'none';
    return;
  }

  const startPx = loopStart * zoom;
  const widthPx = (loopEnd - loopStart) * zoom;

  loopHighlight.style.display = 'block';
  // because loopHighlight lives inside the scroll container,
  // we compensate for scrollLeft so it lines up with content
  loopHighlight.style.left = (startPx - scroll.scrollLeft) + 'px';
  loopHighlight.style.width = widthPx + 'px';
}

function setLoopRegion(startSeconds, endSeconds) {
  if (typeof startSeconds !== 'number' || typeof endSeconds !== 'number') {
    showToast('⚠️ Invalid loop region.', 'warning');
    return;
  }
  if (endSeconds <= startSeconds) {
    showToast('⚠️ Loop end must be after start.', 'warning');
    return;
  }
  multitrack.loopStart = startSeconds;
  multitrack.loopEnd = endSeconds;
  updateLoopRegionHighlight();
  showToast(`🔁 Loop set: ${startSeconds.toFixed(2)}s → ${endSeconds.toFixed(2)}s`, 'info');
}

function clearLoopRegion() {
  multitrack.loopStart = null;
  multitrack.loopEnd = null;
  updateLoopRegionHighlight();
  showToast('⏹️ Loop region cleared.', 'info');
}

// -------------------- PWA Installation --------------------
let deferredPrompt;

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').hidden = false;
});

document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  
  if (outcome === 'accepted') {
    document.getElementById('installBtn').hidden = true;
  }
  
  deferredPrompt = null;
});

function checkSamplesLoaded() {
  const drumInsts = Object.keys(instruments).filter(k => instruments[k].type === 'drum');
  const totalDrums = drumInsts.length;
  let loadedCount = 0;
  let lastLoggedCount = -1;
  
  const checkInterval = setInterval(() => {
    loadedCount = 0;
    const statusList = [];
    
    drumInsts.forEach(inst => {
      const synth = synths[inst];
      if (synth && synth.loaded) {
        loadedCount++;
        statusList.push(`✅ ${inst}`);
      } else {
        statusList.push(`⏳ ${inst}`);
      }
    });
    
    // Only log when count changes
    if (loadedCount !== lastLoggedCount) {
      console.log(`📦 Drum samples: ${loadedCount}/${totalDrums}`);
      console.log(statusList.join(', '));
      lastLoggedCount = loadedCount;
    }
    
    if (loadedCount === totalDrums) {
      clearInterval(checkInterval);
      console.log('✅ All drum samples ready!');
      document.getElementById('vizOverlay').textContent = 'All Samples Loaded - Generate & Press Play';
    }
  }, 500);
  
  // Stop checking after 15 seconds
  setTimeout(() => {
    clearInterval(checkInterval);
    if (loadedCount < totalDrums) {
      console.warn(`⚠️ Only ${loadedCount}/${totalDrums} samples loaded after timeout`);
      console.warn('Missing samples:', drumInsts.filter(inst => !synths[inst]?.loaded));
    }
  }, 15000);
}

// -------------------- Sidebar Controls --------------------
function openSidebar() {
  document.getElementById('sidebarNav').classList.add('open');
  document.getElementById('sidebarBackdrop').classList.add('open');
  document.body.style.overflow = 'hidden';
}

function closeSidebar() {
  document.getElementById('sidebarNav').classList.remove('open');
  document.getElementById('sidebarBackdrop').classList.remove('open');
  document.body.style.overflow = '';
}

function toggleSidebar() {
  const nav = document.getElementById('sidebarNav');
  if (nav.classList.contains('open')) {
    closeSidebar();
  } else {
    openSidebar();
  }
}

const LICENSE_API_URL = 'https://script.google.com/macros/s/AKfycbxvYwLDd0frF6GraU1RSX6q6xnxtVU3FwcVoeTVTsNNtf1C2zEm-DeAeVgCm1c4TbLh/exec'; // no query string

function isPro() {
  return localStorage.getItem('8beat.pro') === 'true';
}

function getSavedLicenseKey() {
  return localStorage.getItem('8beat.licenseKey') || '';
}

async function validateLicenseKey(key) {
  const adminKeys = [
    '8BEAT-ADMIN-BKEY',  // <-- your admin key(s)
    '8BEAT-ADMIN-TEST'
  ];

  // If it's one of your admin keys, instant unlock
  if (adminKeys.includes(key.trim())) {
    console.log('🛠️ Admin key accepted');
    return true;
  }
  const url = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(key.trim())}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Network error');
  const data = await res.json();
  return data.valid === true;
}

function enableProFeatures() {
  document.body.classList.add('pro');

  // Unlock sidebar tabs
  document.querySelectorAll('.sidebar-tab.locked').forEach(btn => {
    btn.classList.remove('locked');
  });

  // Remove "pro-locked" overlays on content panels
  document.querySelectorAll('.pro-locked').forEach(el => {
    el.classList.remove('pro-locked');
  });
}

function initLicenseUI() {
  const unlockBtn = document.getElementById('unlockProBtn');
  const modal = document.getElementById('unlockModal');
  const input = document.getElementById('licenseInput');
  const status = document.getElementById('licenseStatus');
  const confirmBtn = document.getElementById('confirmLicenseBtn');
  const cancelBtn = document.getElementById('cancelLicenseBtn');

  if (!unlockBtn || !modal) return;

  function openModal() {
    modal.classList.remove('hidden');
    status.textContent = '';
    const savedKey = getSavedLicenseKey();
    if (savedKey) input.value = savedKey;
    input.focus();
  }

  function closeModal() {
    modal.classList.add('hidden');
  }

  unlockBtn.addEventListener('click', openModal);
  cancelBtn.addEventListener('click', closeModal);

  confirmBtn.addEventListener('click', async () => {
    const key = input.value.trim();
    if (!key) {
      status.textContent = 'Please paste your license key.';
      return;
    }
    status.textContent = 'Checking key…';

    try {
      const valid = await validateLicenseKey(key);
      if (valid) {
        localStorage.setItem('8beat.licenseKey', key);
        localStorage.setItem('8beat.pro', 'true');
        enableProFeatures();
        status.textContent = '✅ Pro unlocked! Enjoy.';
        setTimeout(closeModal, 800);
      } else {
        status.textContent = '❌ Invalid or inactive license key.';
      }
    } catch (err) {
      console.error(err);
      status.textContent = '❌ Error contacting license server.';
    }
  });

  // On load, auto-unlock if already Pro
  if (isPro()) {
    enableProFeatures();
  }
}

function gateTabsForFreeUsers() {
  // Tabs free for all users
  const freeTabs = ['generate', 'sequencer', 'mixer'];

  if (!isPro()) {
    document.querySelectorAll('.sidebar-tab').forEach(btn => {
      const tab = btn.getAttribute('data-tab');
      if (!freeTabs.includes(tab)) {
        btn.classList.add('locked');
      } else {
        btn.classList.remove('locked');
      }
    });

    // Lock only note editing inside sequencer
    const seqGrid = document.querySelector('#tab-sequencer .seq-grid');
    if (seqGrid) {
      seqGrid.classList.add('pro-locked');
    }
  } else {
    // Pro users get everything unlocked
    document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.remove('locked'));
    const seqGrid = document.querySelector('#tab-sequencer .seq-grid');
    if (seqGrid) seqGrid.classList.remove('pro-locked');
  }
}


// === Splash / Initialization UI ===
const splash = {
  el: null,
  messageEl: null,
  barEl: null
};

function initSplash() {
  splash.el = document.getElementById('splashOverlay');
  splash.messageEl = document.getElementById('splashMessage');
  splash.barEl = document.getElementById('splashBar');

  if (!splash.el) return;
  splash.el.classList.remove('hidden');
  // Start at a tiny bit of progress so the bar isn't empty
  if (splash.barEl) splash.barEl.style.width = '8%';
}

function updateSplash(message, percent) {
  if (!splash.el) return;

  if (message && splash.messageEl) {
    splash.messageEl.textContent = message;
  }
  if (typeof percent === 'number' && splash.barEl) {
    const clamped = Math.max(0, Math.min(100, percent));
    splash.barEl.style.width = `${clamped}%`;
  }
}

function hideSplash() {
  if (!splash.el) return;
  splash.el.classList.add('hidden');
}
  
// -------------------- Initialization --------------------
function init() {
  // === 0. Splash: start ===
  initSplash();
  updateSplash('Preparing license system…', 10);

  // === 1. Licensing & UI gating ===
  initLicenseUI();          // sets up modal + auto-unlock if localStorage says Pro
  gateTabsForFreeUsers();   // lock non-generate tabs for free users
  if (isPro()) {
    enableProFeatures();    // ensure UI is fully unlocked if already Pro
  }

  updateSplash('Starting audio engine…', 35);

  // === 2. Core audio systems ===
  initAudioContext();
  initAudio();
  ensurePatternLength(state.sequenceLength);

  updateSplash('Wiring controls & multitrack…', 55);

  // === 3. Event wiring ===
  setupEventListeners();
  setupMultitrackListeners();
  setupRegionContextMenu();

  updateSplash('Rendering interface…', 75);

  // === 4. UI rendering ===
  renderSequencer();
  renderMixer();
  renderFX();
  renderHarmony();
  renderPresets();
  renderMultitrack();
  updateAllDisplays();

  updateSplash('Finalizing visualizer & samples…', 90);

  // === 5. Final touches ===
  initVisualizerOnce();
  unlockAudioOnce();
  checkAudioPermissions();
  checkSamplesLoaded();
  loadSavedVibe();
  setupStemImport();
  setupPreviewButton();
  updateUndoRedoButtons();

  updateSplash('Ready! Have fun ✨', 100);

  setInterval(updateDAWStatus, 500);
  initPlayheadFollow();
  // Small delay so the user sees "Ready!" before it disappears
  setTimeout(hideSplash, 3000);
}
  
// -------------------- Entry Point --------------------
document.addEventListener('DOMContentLoaded', init);
</script>

</body>
</html>
