<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <!-- ðŸŒˆ Theming -->
  <meta name="theme-color" content="#7c83ff" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <!-- ðŸ§  Title -->
  <title>8-Beat Studio</title>

  <!-- ðŸ“± PWA Manifest -->
  <link rel="manifest" href="./manifest.json">

  <!-- ðŸŽ¨ App Icons (unified: 8beat1-7.png) -->
  <link rel="apple-touch-icon" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./8beat1-7.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./8beat1-7.png">

  <!-- ðŸ’¬ Open Graph (Discord / Facebook / Messenger) -->
  <meta property="og:title" content="8-Beat Studio â€” Browser-Based DAW">
  <meta property="og:description"
        content="Create, record, mix, and master â€” all inside your browser. A full digital audio workstation built by hand.">
  <meta property="og:image"
        content="https://braemonk.github.io/beat-maker/8beat1-7.png">
  <meta property="og:url" content="https://braemonk.github.io/beat-maker/">
  <meta property="og:type" content="website">

  <!-- ðŸ¦ Twitter Card (X / mobile previews) -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="8-Beat Studio â€” Browser-Based DAW">
  <meta name="twitter:description"
        content="A full digital audio workstation that runs entirely in your browser.">
  <meta name="twitter:image"
        content="https://braemonk.github.io/beat-maker/8beat1-7.png">
  <style>
/* =========================================================
   8-BEAT STUDIO â€” PROFESSIONAL RESPONSIVE REDESIGN
   Premium glassmorphic design with advanced micro-interactions
   Full mobile/tablet/desktop support â€¢ PWA optimized
========================================================= */

/* Professional Font Stack */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;600;700&display=swap');

/* -------- Design System Tokens -------- */
:root {
  /* Typography Scale */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --font-mono: 'JetBrains Mono', 'Courier New', monospace;
  
  --text-xs: clamp(0.7rem, 0.65rem + 0.25vw, 0.75rem);
  --text-sm: clamp(0.8rem, 0.75rem + 0.25vw, 0.875rem);
  --text-base: clamp(0.9rem, 0.85rem + 0.25vw, 1rem);
  --text-lg: clamp(1rem, 0.95rem + 0.25vw, 1.125rem);
  --text-xl: clamp(1.125rem, 1rem + 0.5vw, 1.25rem);
  --text-2xl: clamp(1.25rem, 1.125rem + 0.625vw, 1.5rem);
  --text-3xl: clamp(1.5rem, 1.25rem + 1vw, 2rem);
  --text-4xl: clamp(1.875rem, 1.5rem + 1.5vw, 2.5rem);

  /* Spacing System */
  --space-1: 0.25rem;
  --space-2: 0.5rem;
  --space-3: 0.75rem;
  --space-4: 1rem;
  --space-5: 1.25rem;
  --space-6: 1.5rem;
  --space-7: 1.75rem;
  --space-8: 2rem;
  --space-10: 2.5rem;
  --space-12: 3rem;
  --space-16: 4rem;
  --space-20: 5rem;
  
  /* Layout */
  --container-max: 1800px;
  --gutter: clamp(1rem, 3vw, 2rem);
  --sidebar-width: clamp(280px, 18vw, 340px);
  
  /* Border Radius System */
  --radius-xs: 6px;
  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 18px;
  --radius-xl: 24px;
  --radius-2xl: 32px;
  --radius-full: 9999px;

  /* Professional Shadow System */
  --shadow-xs: 0 1px 2px rgba(0,0,0,.05);
  --shadow-sm: 0 2px 8px rgba(0,0,0,.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,.12);
  --shadow-lg: 0 8px 32px rgba(0,0,0,.16);
  --shadow-xl: 0 12px 48px rgba(0,0,0,.22);
  --shadow-2xl: 0 20px 64px rgba(0,0,0,.32);
  --shadow-inner: inset 0 2px 8px rgba(0,0,0,.08);
  
  /* Glow Effects */
  --glow-sm: 0 0 20px;
  --glow-md: 0 0 40px;
  --glow-lg: 0 0 60px;

  /* Component Heights */
  --header-h: clamp(68px, 8vh, 80px);
  --tabs-h: clamp(52px, 6vh, 60px);
  --transport-h: clamp(88px, 10vh, 104px);

  /* Focus Ring */
  --ring-w: 3px;
  --ring-offset: 2px;
  --ring: rgba(180,190,255,.6);
  
  /* Glass Effects */
  --glass-border: rgba(255,255,255,.12);
  --glass-border-strong: rgba(255,255,255,.2);
  --glass-bg: rgba(255,255,255,.04);
  --glass-bg-strong: rgba(255,255,255,.08);

  /* Safe Areas */
  --inset-top: env(safe-area-inset-top, 0px);
  --inset-right: env(safe-area-inset-right, 0px);
  --inset-bottom: env(safe-area-inset-bottom, 0px);
  --inset-left: env(safe-area-inset-left, 0px);

  /* Animation Curves */
  --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
  --ease-elastic: cubic-bezier(0.68, -0.6, 0.32, 1.6);
  
  /* Transition Durations */
  --duration-fast: 150ms;
  --duration-base: 200ms;
  --duration-slow: 300ms;
  --duration-slower: 500ms;

  /* Default Theme */
  --bg-primary: #0a0e1a;
  --bg-secondary: #0f1420;
  --bg-tertiary: #141824;
  
  --text-primary: #e9ecff;
  --text-secondary: #c8ccff;
  --text-tertiary: #9aa0c7;
  --text-muted: #6b7199;
  
  --accent-primary: #7c83ff;
  --accent-secondary: #8d6cff;
  --accent-tertiary: #9f7eff;
  
  --success: #22c55e;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;

  --surface: linear-gradient(135deg, rgba(255,255,255,.08) 0%, rgba(255,255,255,.04) 100%);
  --surface-elevated: linear-gradient(135deg, rgba(255,255,255,.12) 0%, rgba(255,255,255,.06) 100%);
}

/* -------- Premium Vibe Palettes -------- */

/* Cool, deep studio night */
body[data-vibe="moon"] {
  --bg-primary: #070b16;
  --bg-secondary: #0b1020;
  --bg-tertiary: #111728;
  --accent-primary: #7c83ff;
  --accent-secondary: #5ea8ff;
  --accent-tertiary: #8fa2ff;
  --text-primary: #e9ecff;
  --text-secondary: #cfd4ff;
  --text-tertiary: #a6acd6;
}

/* Soft pink sunrise / lo-fi morning */
body[data-vibe="dawn"] {
  --bg-primary: #190d13;
  --bg-secondary: #21131a;
  --bg-tertiary: #2a1822;
  --accent-primary: #ff8fb1;
  --accent-secondary: #ffb385;
  --accent-tertiary: #ffd4a8;
  --text-primary: #fff4f8;
  --text-secondary: #ffdfe9;
  --text-tertiary: #f2cbd8;
}

/* Cosmic purples & cyan sparks */
body[data-vibe="nebula"] {
  --bg-primary: #060816;
  --bg-secondary: #0c081d;
  --bg-tertiary: #150f26;
  --accent-primary: #9a6bff;
  --accent-secondary: #33d1ff;
  --accent-tertiary: #66e0ff;
  --text-primary: #eaf5ff;
  --text-secondary: #cfe7ff;
  --text-tertiary: #a6c9e6;
}

/* Mossy forest synth den */
body[data-vibe="forest"] {
  --bg-primary: #04100d;
  --bg-secondary: #071716;
  --bg-tertiary: #0b1f1f;
  --accent-primary: #5de6a4;
  --accent-secondary: #86f7c1;
  --accent-tertiary: #a0ffd0;
  --text-primary: #e7fff5;
  --text-secondary: #c9ffe9;
  --text-tertiary: #a1d4c2;
}

/* Golden-hour studio glow */
body[data-vibe="sunset"] {
  --bg-primary: #1a0e0f;
  --bg-secondary: #221215;
  --bg-tertiary: #2b171b;
  --accent-primary: #ff7a59;
  --accent-secondary: #ffb86b;
  --accent-tertiary: #ffd699;
  --text-primary: #fff1eb;
  --text-secondary: #ffd9c9;
  --text-tertiary: #ffc6ae;
}

/* --- NEW VIBES --- */

/* Deep ocean / underwater club */
body[data-vibe="ocean"] {
  --bg-primary: #040b12;
  --bg-secondary: #05121c;
  --bg-tertiary: #071a25;
  --accent-primary: #42c5ff;
  --accent-secondary: #2ee6d6;
  --accent-tertiary: #6af5ff;
  --text-primary: #e5f7ff;
  --text-secondary: #c8eaff;
  --text-tertiary: #9dbed4;
}

/* Charcoal & lava â€“ late-night rock / metal */
body[data-vibe="ember"] {
  --bg-primary: #100607;
  --bg-secondary: #18090b;
  --bg-tertiary: #210e12;
  --accent-primary: #ff5540;
  --accent-secondary: #ff9140;
  --accent-tertiary: #ffb36b;
  --text-primary: #ffeceb;
  --text-secondary: #ffd1ca;
  --text-tertiary: #f2a89a;
}

/* Northern lights â€“ dreamy & floaty */
body[data-vibe="aurora"] {
  --bg-primary: #040b14;
  --bg-secondary: #04111b;
  --bg-tertiary: #061a24;
  --accent-primary: #68ffb5;
  --accent-secondary: #7fe0ff;
  --accent-tertiary: #d597ff;
  --text-primary: #eafff7;
  --text-secondary: #c8f7eb;
  --text-tertiary: #9fd5c7;
}

/* Neon cyber/synthwave */
body[data-vibe="cyber"] {
  --bg-primary: #070812;
  --bg-secondary: #0a0b18;
  --bg-tertiary: #101322;
  --accent-primary: #ff64c2;
  --accent-secondary: #42f5ff;
  --accent-tertiary: #ffe35b;
  --text-primary: #f9efff;
  --text-secondary: #e2d4ff;
  --text-tertiary: #b6a5e6;
}

/* Desert night / warm neutral â€œfocusâ€ mode */
body[data-vibe="sandstorm"] {
  --bg-primary: #120f0a;
  --bg-secondary: #18140d;
  --bg-tertiary: #211a10;
  --accent-primary: #f7c979;
  --accent-secondary: #ffdf9b;
  --accent-tertiary: #ffe9b8;
  --text-primary: #fff7e8;
  --text-secondary: #f2ddbc;
  --text-tertiary: #c9b38e;
}

/* -------- Splash Screen -------- */
#splashOverlay {
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-6);
  background:
    radial-gradient(circle at top, rgba(148, 163, 253, 0.3), transparent 60%),
    radial-gradient(circle at bottom, rgba(45, 212, 191, 0.25), transparent 60%),
    rgba(3, 7, 18, 0.95);
  backdrop-filter: blur(10px);
}

#splashOverlay.hidden {
  display: none;
}

#splashOverlay .splash-inner {
  background: var(--surface-elevated);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  border: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-2xl);
  max-width: 420px;
  width: 100%;
  text-align: center;
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
}

#splashOverlay .splash-logo {
  font-size: var(--text-2xl);
  font-weight: 900;
  margin-bottom: var(--space-4);
  letter-spacing: 0.08em;
  text-transform: uppercase;
  background: linear-gradient(135deg, #a5b4fc, #f97316);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#splashOverlay .splash-message {
  font-size: var(--text-base);
  color: var(--text-primary);
  margin-bottom: var(--space-4);
}

#splashOverlay .splash-progress {
  width: 100%;
  height: 0.5rem;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.85);
  border: 1px solid var(--glass-border);
  overflow: hidden;
  margin-bottom: var(--space-3);
}

#splashOverlay .splash-progress-bar {
  height: 100%;
  width: 0%;
  border-radius: inherit;
  background: linear-gradient(90deg, #22d3ee, #a855f7, #f97316);
  transition: width 220ms var(--ease-smooth);
}

#splashOverlay .splash-sub {
  font-size: var(--text-xs);
  color: var(--text-muted);
  opacity: 0.85;
}

/* -------- Global Canvas -------- */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 16px;
  height: 100%;
  scroll-behavior: smooth;
}

body {
  min-height: 100%;
  font-family: var(--font-sans);
  font-size: var(--text-base);
  font-weight: 400;
  line-height: 1.6;
  color: var(--text-primary);
  background: 
    radial-gradient(ellipse 1200px 800px at 15% -5%, 
      color-mix(in oklab, var(--accent-primary) 15%, transparent), 
      transparent 65%),
    radial-gradient(ellipse 1000px 700px at 85% 105%, 
      color-mix(in oklab, var(--accent-secondary) 12%, transparent), 
      transparent 65%),
    radial-gradient(ellipse 800px 600px at 50% 50%, 
      color-mix(in oklab, var(--accent-tertiary) 6%, transparent), 
      transparent 70%),
    linear-gradient(135deg, 
      var(--bg-primary) 0%, 
      var(--bg-secondary) 50%, 
      var(--bg-tertiary) 100%);
  background-attachment: fixed;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  
  padding:
    calc(var(--space-4) + var(--inset-top))
    calc(var(--space-4) + var(--inset-right))
    calc(var(--space-4) + var(--inset-bottom))
    calc(var(--space-4) + var(--inset-left));
}

@media (display-mode: standalone) {
  body { 
    min-height: 100dvh;
    padding-top: calc(var(--space-6) + var(--inset-top));
  }
}

/* -------- App Container -------- */
.app {
  max-width: var(--container-max);
  margin: 0 auto;
  display: grid;
  gap: var(--gutter);
  padding: clamp(var(--space-4), 2vw, var(--space-8));
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--bg-secondary) 85%, transparent) 0%, 
      color-mix(in oklab, var(--bg-primary) 70%, transparent) 100%);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-2xl);
  box-shadow: 
    var(--shadow-2xl),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 -1px 0 rgba(0,0,0,.2);
  backdrop-filter: blur(32px) saturate(140%);
  position: relative;
  overflow: hidden;
  
  grid-template-columns: 1fr;
  grid-template-areas:
    "header"
    "transport"
    "main"
    "footer";
}

.app::before {
  content: '';
  position: absolute;
  inset: -50%;
  background: 
    radial-gradient(circle at 20% 30%, 
      color-mix(in oklab, var(--accent-primary) 8%, transparent), 
      transparent 40%),
    radial-gradient(circle at 80% 70%, 
      color-mix(in oklab, var(--accent-secondary) 6%, transparent), 
      transparent 40%);
  opacity: 0.6;
  animation: ambientPulse 8s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes ambientPulse {
  0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
  50% { transform: scale(1.1) rotate(5deg); opacity: 0.4; }
}

.app > * {
  position: relative;
  z-index: 1;
}

header { grid-area: header; }
.transport { grid-area: transport; }
section.section { grid-area: main; }
footer.footer { grid-area: footer; }

/* -------- Header -------- */
header {
  position: sticky;
  top: var(--space-4);
  z-index: 50;
  height: auto;
  min-height: var(--header-h);
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-4);
  align-items: center;
  padding: var(--space-4) var(--space-5);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: 
    var(--shadow-lg),
    inset 0 1px 0 rgba(255,255,255,.1);
  backdrop-filter: blur(24px) saturate(150%);
  transition: all var(--duration-base) var(--ease-smooth);
}

header:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent),
    inset 0 1px 0 rgba(255,255,255,.15);
}

.logo-section {
  display: flex;
  gap: var(--space-3);
  align-items: center;
}

.logo {
  width: clamp(48px, 6vw, 56px);
  height: clamp(48px, 6vw, 56px);
  border-radius: var(--radius-md);
  display: grid;
  place-items: center;
  font-size: var(--text-2xl);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  font-weight: 900;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  position: relative;
  overflow: hidden;
  transition: transform var(--duration-base) var(--ease-bounce);
}

.logo::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.2) 50%, transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
}

.logo:hover {
  transform: scale(1.05) rotate(5deg);
}

.logo:hover::before {
  transform: translateX(100%);
}

h1 {
  margin: 0;
  font-size: var(--text-2xl);
  font-weight: 900;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.tagline {
  font-size: var(--text-sm);
  color: var(--text-tertiary);
  font-weight: 500;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  margin-top: calc(-1 * var(--space-1));
}

/* Genre Selector */
.genre-selector {
  display: flex;
  gap: var(--space-2);
  flex-wrap: wrap;
  justify-content: center;
}

.genre-btn {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  letter-spacing: 0.01em;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.genre-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.genre-btn > span {
  position: relative;
  z-index: 1;
}

.genre-btn:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.genre-btn:hover::before {
  opacity: 0.1;
}

.genre-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  transform: translateY(-2px);
}

.genre-btn.active::before {
  opacity: 0;
}

.genre-btn:active {
  transform: translateY(0);
}

.header-actions {
  display: flex;
  gap: var(--space-2);
}

/* -------- Sidebar Navigation -------- */
.sidebar-toggle {
  position: fixed;
  top: calc(var(--space-4) + var(--inset-top));
  left: calc(var(--space-4) + var(--inset-left));
  z-index: 9995;
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  backdrop-filter: blur(12px) saturate(130%);
  color: var(--text-primary);
  font-size: var(--text-2xl);
  cursor: pointer;
  display: grid;
  place-items: center;
  box-shadow: var(--shadow-lg);
  transition: all var(--duration-base) var(--ease-smooth);
}

.sidebar-toggle:hover {
  background: var(--glass-bg-strong);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent);
  transform: scale(1.05);
}

.sidebar-toggle:active {
  transform: scale(0.95);
}

.sidebar-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  z-index: 9997;
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
}

.sidebar-backdrop.open {
  opacity: 1;
  visibility: visible;
}

.sidebar-nav {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  width: min(85vw, 380px);
  background: var(--surface-elevated);
  border-right: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-2xl);
  backdrop-filter: blur(32px) saturate(150%);
  z-index: 9998;
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  padding: calc(var(--space-20) + var(--inset-top)) var(--space-4) calc(var(--space-4) + var(--inset-bottom)) var(--space-4);
}

.sidebar-nav.open {
  transform: translateX(0);
}

.sidebar-section {
  margin-bottom: var(--space-8);
}

.sidebar-section-title {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 2px solid var(--glass-border);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.sidebar-tabs {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.sidebar-tab {
  padding: var(--space-4) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-base);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  text-align: left;
  display: flex;
  align-items: center;
  gap: var(--space-3);
  border: 1px solid transparent;
}

.sidebar-tab:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: translateX(4px);
}

.sidebar-tab.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 35%, transparent);
  transform: translateX(8px);
}

.sidebar-presets {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-3);
}

.sidebar-preset {
  padding: var(--space-4);
  border-radius: var(--radius-md);
  cursor: pointer;
  text-align: center;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.sidebar-preset::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.sidebar-preset > * {
  position: relative;
  z-index: 1;
}

.sidebar-preset:hover {
  transform: translateY(-2px);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  box-shadow: var(--shadow-md);
}

.sidebar-preset:hover::before {
  opacity: 0.08;
}

.sidebar-preset-icon {
  font-size: var(--text-3xl);
  line-height: 1;
}

.sidebar-preset-name {
  font-size: var(--text-sm);
  color: var(--text-secondary);
  transition: color var(--duration-base) var(--ease-smooth);
}

.sidebar-preset:hover .sidebar-preset-name {
  color: var(--text-primary);
}

/* -------- Transport Bar -------- */
.transport {
  position: sticky;
  top: calc(var(--header-h) + var(--space-4) + var(--space-2));
  z-index: 48;
  padding: var(--space-5) var(--space-6);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: 
    var(--shadow-lg),
    inset 0 1px 0 rgba(255,255,255,.08);
  backdrop-filter: blur(24px) saturate(140%);
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-6);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
}

.transport:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 12%, transparent),
    inset 0 1px 0 rgba(255,255,255,.12);
}

.transport-controls {
  display: flex;
  gap: var(--space-2);
  align-items: center;
  flex-wrap: wrap;
}

.progress-area {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  min-width: 0;
  flex: 1;
}

.time-info {
  display: flex;
  gap: var(--space-3);
  justify-content: space-between;
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-sm);
  font-family: var(--font-mono);
  letter-spacing: 0.05em;
}

.progress-bar {
  height: 14px;
  border-radius: var(--radius-full);
  overflow: hidden;
  background: 
    linear-gradient(90deg, 
      rgba(255,255,255,.06) 0%, 
      rgba(255,255,255,.08) 50%, 
      rgba(255,255,255,.06) 100%);
  border: 1px solid rgba(255,255,255,.1);
  box-shadow: var(--shadow-inner);
  position: relative;
}

.progress-bar::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    90deg,
    transparent 0px,
    transparent 4px,
    rgba(255,255,255,.03) 4px,
    rgba(255,255,255,.03) 8px
  );
  pointer-events: none;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
  width: 0%;
  transition: width 120ms linear;
  box-shadow: 
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 0 0 1px rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.progress-fill::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255,255,255,.3) 50%, 
    transparent 100%);
  animation: progressShimmer 2s linear infinite;
}

@keyframes progressShimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.transport-params {
  display: grid;
  grid-auto-flow: column;
  gap: var(--space-4);
  align-items: center;
}

/* -------- Button System -------- */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  letter-spacing: 0.01em;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  white-space: nowrap;
  text-decoration: none;
  outline: none;
  position: relative;
  overflow: hidden;
  transform: translateY(0);
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,.15) 50%, transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slow) var(--ease-smooth);
}

.btn:hover::before {
  transform: translateX(100%);
}

.btn-sm {
  padding: var(--space-2) var(--space-4);
  font-size: var(--text-xs);
  border-radius: var(--radius-sm);
}

.btn:active {
  transform: translateY(1px) scale(0.98);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

.btn:focus-visible {
  box-shadow: 
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.2);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent),
    inset 0 1px 0 rgba(255,255,255,.25);
}

.btn-secondary {
  background: var(--surface);
  color: var(--text-primary);
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-sm);
}

.btn-secondary:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  background: var(--surface-elevated);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn-ghost {
  background: transparent;
  color: var(--text-secondary);
  border: 1px solid transparent;
}

.btn-ghost:hover {
  background: var(--glass-bg-strong);
  border-color: var(--glass-border);
  color: var(--text-primary);
}

.btn-success {
  background: linear-gradient(135deg, var(--success), color-mix(in oklab, var(--success) 70%, #ffffff));
  color: #042013;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--success) 35%, transparent);
}

.btn-success:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--success) 30%, transparent);
}

#generateSongBtn {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.05); opacity: 0.9; }
}

/* -------- Sections & Panels -------- */
.section {
  display: none;
}

.section.active {
  display: grid;
  gap: var(--gutter);
  margin-top: var(--space-2);
  animation: sectionFadeIn var(--duration-slow) var(--ease-smooth) both;
}

@keyframes sectionFadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.panel {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  padding: var(--space-6);
  box-shadow: 
    var(--shadow-md),
    inset 0 1px 0 rgba(255,255,255,.04);
  position: relative;
  overflow: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
}

.panel:hover::before {
  opacity: 0.6;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 1px solid var(--glass-border);
  flex-wrap: wrap;
  gap: var(--space-3);
}

.panel-title {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: var(--space-3);
  letter-spacing: -0.01em;
}

/* -------- Input Controls -------- */
.param-control {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.param-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  color: var(--text-secondary);
  font-weight: 600;
  font-size: var(--text-sm);
}

.param-value {
  color: var(--text-primary);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  padding: var(--space-1) var(--space-2);
  background: var(--glass-bg);
  border-radius: var(--radius-xs);
}

input[type="range"] {
  width: 100%;
  height: 12px;
  border-radius: var(--radius-full);
  appearance: none;
  -webkit-appearance: none;
  cursor: pointer;
  background: 
    linear-gradient(90deg, 
      rgba(255,255,255,.06) 0%, 
      rgba(255,255,255,.08) 50%, 
      rgba(255,255,255,.06) 100%);
  border: 1px solid rgba(255,255,255,.1);
  box-shadow: var(--shadow-inner);
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

input[type="range"]:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, rgba(255,255,255,.1));
}

input[type="range"]:focus-visible {
  box-shadow: 
    var(--shadow-inner),
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.3);
  border: 2px solid rgba(255,255,255,.4);
  cursor: grab;
  transition: all var(--duration-fast) var(--ease-smooth);
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.1);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.4);
}

input[type="range"]::-webkit-slider-thumb:active {
  cursor: grabbing;
  transform: scale(0.95);
}

input[type="range"]::-moz-range-thumb {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent),
    inset 0 1px 0 rgba(255,255,255,.3);
  border: 2px solid rgba(255,255,255,.4);
  cursor: grab;
  transition: all var(--duration-fast) var(--ease-smooth);
}

input[type="range"]::-moz-range-thumb:hover {
  transform: scale(1.1);
}

input[type="range"]::-moz-range-thumb:active {
  cursor: grabbing;
  transform: scale(0.95);
}

/* Text and number inputs - use text cursor */
input[type="text"],
input[type="email"],
input[type="number"] {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: text; /* Changed from pointer to text */
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

/* Select dropdown - keep pointer cursor */
select {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: pointer; /* Pointer is correct for dropdowns */
  outline: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="number"]:focus,
select:focus {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
  background: var(--glass-bg-strong);
  box-shadow: 
    var(--shadow-sm),
    0 0 0 var(--ring-offset) var(--bg-primary),
    0 0 0 calc(var(--ring-offset) + var(--ring-w)) var(--ring);
}

input[type="text"]::placeholder {
  color: var(--text-muted);
  font-weight: 500;
}

select {
  background-image: 
    linear-gradient(45deg, transparent 50%, var(--text-tertiary) 50%),
    linear-gradient(135deg, var(--text-tertiary) 50%, transparent 50%);
  background-position: 
    calc(100% - 16px) calc(50% - 2px),
    calc(100% - 11px) calc(50% - 2px);
  background-size: 5px 5px, 5px 5px;
  background-repeat: no-repeat;
  padding-right: var(--space-8);
  cursor: pointer;
}

/* -------- Chips & Tags -------- */
.chips {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.chip {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  cursor: pointer;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-secondary);
  font-weight: 700;
  font-size: var(--text-sm);
  transition: all var(--duration-fast) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.chip::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.chip > * {
  position: relative;
  z-index: 1;
}

.chip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.chip:hover::before {
  opacity: 0.1;
}

.chip.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  border-color: transparent;
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.chip.active::before {
  opacity: 0;
}

/* -------- Preset Grid -------- */
.preset-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: var(--space-4);
}

.preset {
  padding: var(--space-5);
  border-radius: var(--radius-md);
  cursor: pointer;
  text-align: center;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  align-items: center;
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

.preset::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

.preset > * {
  position: relative;
  z-index: 1;
}

.preset:hover {
  transform: translateY(-4px);
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  box-shadow: 
    var(--shadow-lg),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

.preset:hover::before {
  opacity: 0.08;
}

.preset:active {
  transform: translateY(-2px);
}

.preset-icon {
  font-size: var(--text-3xl);
  line-height: 1;
  filter: drop-shadow(0 2px 8px rgba(0,0,0,.3));
}

.preset-name {
  font-size: var(--text-sm);
  color: var(--text-secondary);
  transition: color var(--duration-base) var(--ease-smooth);
}

.preset:hover .preset-name {
  color: var(--text-primary);
}

.preset.active {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.25);
  transform: scale(1.03);
}

.preset.active .preset-icon {
  filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.4));
}

/* -------- Visualizer -------- */
.visualizer {
  height: clamp(160px, 20vh, 220px);
  border-radius: var(--radius-lg);
  position: relative;
  background:
    linear-gradient(135deg, 
      color-mix(in oklab, var(--accent-primary) 10%, transparent), 
      color-mix(in oklab, var(--accent-secondary) 8%, transparent)),
    linear-gradient(180deg, rgba(0,0,0,.2), transparent 70%);
  border: 1px solid var(--glass-border-strong);
  overflow: hidden;
  box-shadow: 
    var(--shadow-md),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 0 0 1px rgba(255,255,255,.03);
}

.visualizer::before {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    repeating-linear-gradient(
      0deg,
      transparent 0px,
      rgba(255,255,255,.01) 1px,
      transparent 2px,
      transparent 20px
    );
  pointer-events: none;
  z-index: 1;
}

.viz-bar {
  position: absolute;
  bottom: 0;
  width: 5px;
  border-radius: 3px 3px 0 0;
  opacity: 0.9;
  background: linear-gradient(
    to top, 
    var(--accent-primary) 0%,
    var(--accent-secondary) 50%,
    var(--accent-tertiary) 100%
  );
  transition: height 80ms ease-out;
  will-change: height;
  box-shadow: 
    0 -4px 12px color-mix(in oklab, var(--accent-primary) 30%, transparent),
    inset 0 0 0 1px rgba(255,255,255,.15);
  filter: brightness(1.1);
}

.viz-overlay {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  background: 
    linear-gradient(180deg, 
      color-mix(in oklab, var(--bg-primary) 40%, transparent), 
      color-mix(in oklab, var(--bg-secondary) 50%, transparent));
  backdrop-filter: blur(4px);
  font-weight: 800;
  font-size: var(--text-lg);
  color: var(--text-tertiary);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  pointer-events: none;
  z-index: 2;
}

/* -------- Sequencer Grid -------- */
.sequencer {
  overflow-x: auto;
  overflow-y: visible;
  scrollbar-width: thin;
  padding-bottom: var(--space-2);
}

.seq-grid {
  display: grid;
  gap: var(--space-3);
  min-width: 900px;
  position: relative;
}

.seq-grid::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: var(--radius-md);
  background:
    repeating-linear-gradient(
      to right,
      transparent 0,
      transparent calc(100% / 16 - 1px),
      rgba(255,255,255,.04) calc(100% / 16 - 1px),
      rgba(255,255,255,.04) calc(100% / 16)
    );
  pointer-events: none;
  z-index: 0;
}

.seq-row {
  display: grid;
  grid-template-columns: 180px repeat(16, 1fr);
  gap: var(--space-2);
  align-items: center;
  position: relative;
  z-index: 1;
}

.seq-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-3) var(--space-4);
  background: var(--surface);
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border);
  font-weight: 700;
  font-size: var(--text-sm);
  transition: all var(--duration-base) var(--ease-smooth);
}

.seq-icon[data-action="play"] {
  display: none;
}

.seq-label:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
  background: var(--surface-elevated);
}

.seq-icons {
  display: flex;
  gap: var(--space-1);
}

.seq-icon {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-xs);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.seq-icon:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: scale(1.05);
}

.seq-icon.active {
  background: var(--error);
  color: #fff;
  box-shadow: var(--shadow-sm);
}

.step {
  aspect-ratio: 1 / 1;
  min-height: 48px;
  width: 100%;
  border-radius: var(--radius-md);
  cursor: pointer;
  background: 
    linear-gradient(135deg, 
      rgba(255,255,255,.06), 
      rgba(255,255,255,.04));
  border: 1px solid var(--glass-border);
  position: relative;
  display: grid;
  place-items: center;
  transition: all var(--duration-fast) var(--ease-smooth);
  overflow: hidden;
}

.step::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0;
  transition: opacity var(--duration-fast) var(--ease-smooth);
}

.step:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.step:hover::before {
  opacity: 0.1;
}

.step:active {
  transform: translateY(0) scale(0.97);
}

.step.active {
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--accent-primary) 75%, transparent), 
      color-mix(in oklab, var(--accent-secondary) 80%, transparent));
  border-color: color-mix(in oklab, var(--accent-primary) 70%, transparent);
  box-shadow: 
    var(--shadow-sm),
    0 0 16px color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.2);
}

.step.active::before {
  opacity: 0;
}

.step.playing {
  animation: stepPulse 280ms ease-out;
  box-shadow: 
    var(--shadow-md),
    0 0 28px var(--warning),
    0 0 48px color-mix(in oklab, var(--warning) 25%, transparent);
  border-color: var(--warning);
}

@keyframes stepPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.12); }
}

.step-prob {
  position: absolute;
  top: var(--space-1);
  right: var(--space-1);
  font-size: var(--text-xs);
  background: rgba(0,0,0,.6);
  padding: 2px var(--space-2);
  border-radius: var(--radius-xs);
  color: #fff;
  font-weight: 800;
  pointer-events: none;
  z-index: 2;
  font-family: var(--font-mono);
  backdrop-filter: blur(4px);
}

.step-vel {
  position: absolute;
  bottom: var(--space-1);
  left: var(--space-1);
  right: var(--space-1);
  height: 6px;
  background: rgba(255,255,255,.15);
  border-radius: var(--radius-full);
  overflow: hidden;
  z-index: 2;
}

.step-vel-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
  opacity: 0.95;
  transition: width 200ms var(--ease-smooth);
  box-shadow: 0 0 8px color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

.playhead {
  position: sticky;
  left: 0;
  top: 0;
  height: 100%;
  width: 0;
  pointer-events: none;
  z-index: 10;
}

.playhead::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  border-radius: var(--radius-xs);
  background: linear-gradient(
    to bottom,
    var(--warning),
    color-mix(in oklab, var(--warning) 20%, transparent)
  );
  box-shadow: 
    0 0 16px color-mix(in oklab, var(--warning) 50%, transparent),
    0 0 32px color-mix(in oklab, var(--warning) 25%, transparent);
  transform: translateX(-2px);
}

/* -------- Mixer Channels -------- */
#mixerGrid {
  display: grid;
  gap: var(--space-4);
  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
}

.mixer-channel {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  transition: all var(--duration-base) var(--ease-smooth);
}

.mixer-channel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.channel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: var(--space-2);
  border-bottom: 1px solid var(--glass-border);
}

.channel-name {
  font-weight: 800;
  font-size: var(--text-sm);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.channel-btns {
  display: flex;
  gap: var(--space-1);
}

.channel-btn {
  width: 34px;
  height: 34px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  font-weight: 800;
  font-size: var(--text-xs);
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.channel-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
  transform: scale(1.05);
}

.channel-btn.active {
  color: #fff;
}

.channel-btn.mute.active {
  background: var(--error);
  box-shadow: var(--shadow-sm);
}

.channel-btn.solo.active {
  background: var(--warning);
  box-shadow: var(--shadow-sm);
}

/* -------- FX Units -------- */
#fxGrid {
  display: grid;
  gap: var(--space-4);
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
}

.fx-unit {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  padding: var(--space-5);
  box-shadow: var(--shadow-md);
  transition: all var(--duration-base) var(--ease-smooth);
}

.fx-unit:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.fx-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 1px solid var(--glass-border);
}

.fx-name {
  font-weight: 800;
  font-size: var(--text-base);
  color: var(--text-primary);
}

.fx-toggle {
  width: 60px;
  height: 32px;
  border-radius: var(--radius-full);
  cursor: pointer;
  background: color-mix(in oklab, var(--bg-secondary) 60%, transparent);
  border: 2px solid var(--glass-border);
  position: relative;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-inner);
}

.fx-toggle::after {
  content: '';
  position: absolute;
  left: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: var(--text-muted);
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
}

.fx-toggle:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
}

.fx-toggle.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  border-color: transparent;
  box-shadow: 
    var(--shadow-sm),
    0 0 16px color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.fx-toggle.active::after {
  left: calc(100% - 26px);
  background: var(--bg-primary);
}

/* -------- Footer -------- */
.footer {
  padding: var(--space-5) var(--space-6);
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  text-align: center;
  color: var(--text-secondary);
  font-size: var(--text-sm);
  line-height: 1.8;
  box-shadow: var(--shadow-sm);
}

.footer strong {
  color: var(--text-primary);
  font-weight: 800;
}

kbd {
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  padding: var(--space-1) var(--space-2);
  border-radius: var(--radius-xs);
  font-weight: 700;
  font-size: var(--text-xs);
  color: var(--text-primary);
  font-family: var(--font-mono);
  box-shadow: 
    var(--shadow-xs),
    inset 0 -1px 0 rgba(0,0,0,.2);
}

/* -------- Grid System -------- */
.grid {
  display: grid;
  gap: var(--space-4);
}

.grid-2 {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

.grid-3 {
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}

.grid-4 {
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
}

.grid-5 {
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
}

/* -------- Flex Utilities -------- */
.flex {
  display: flex;
  gap: var(--space-3);
  align-items: center;
  flex-wrap: wrap;
}

.flex-col {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

/* -------- Spacing -------- */
.mb-2 { margin-bottom: var(--space-2); }
.mb-3 { margin-bottom: var(--space-3); }
.mb-4 { margin-bottom: var(--space-4); }
.mt-2 { margin-top: var(--space-2); }
.mt-3 { margin-top: var(--space-3); }
.mt-4 { margin-top: var(--space-4); }

/* -------- Badge -------- */
.badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-1) var(--space-3);
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: 800;
  letter-spacing: 0.02em;
  text-transform: uppercase;
  line-height: 1;
}

.badge-primary {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.badge-success {
  background: var(--success);
  color: #042013;
}

.badge-warning {
  background: var(--warning);
  color: #451a03;
}

.badge-error {
  background: var(--error);
  color: #fff;
}

.badge-ghost {
  background: var(--glass-bg-strong);
  color: var(--text-secondary);
  border: 1px solid var(--glass-border);
}

/* -------- Scrollbars -------- */
* {
  scrollbar-color: 
    color-mix(in oklab, var(--accent-primary) 50%, transparent) 
    transparent;
  scrollbar-width: thin;
}

*::-webkit-scrollbar {
  height: 10px;
  width: 10px;
}

*::-webkit-scrollbar-track {
  background: transparent;
}

*::-webkit-scrollbar-thumb {
  background: linear-gradient(
    135deg, 
    color-mix(in oklab, var(--accent-primary) 85%, #fff), 
    color-mix(in oklab, var(--accent-secondary) 85%, #fff)
  );
  border-radius: var(--radius-xs);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

*::-webkit-scrollbar-corner {
  background: transparent;
}

/* -------- Selection -------- */
::selection {
  background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  text-shadow: none;
}

::-moz-selection {
  background: color-mix(in oklab, var(--accent-primary) 40%, transparent);
  color: var(--text-primary);
  text-shadow: none;
}

/* -------- Loading States -------- */
.loading {
  position: relative;
  pointer-events: none;
  opacity: 0.6;
}

.loading::after {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    linear-gradient(
      90deg,
      transparent 0%,
      color-mix(in oklab, var(--accent-primary) 15%, transparent) 50%,
      transparent 100%
    );
  animation: shimmer 2s infinite;
  border-radius: inherit;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.spinner {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 4px solid var(--glass-border);
  border-top-color: var(--accent-primary);
  animation: spin 0.8s linear infinite;
  margin: var(--space-4) auto;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* -------- Toast Notifications -------- */
.toast-container {
  position: fixed;
  bottom: calc(var(--space-4) + var(--inset-bottom));
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-width: 90vw;
  width: min(400px, 90vw);
  pointer-events: none;
  align-items: center;
}

.toast {
  padding: var(--space-2) var(--space-4);
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-full);
  box-shadow: 
    var(--shadow-md),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 15%, transparent);
  backdrop-filter: blur(24px) saturate(150%);
  display: inline-flex;
  gap: var(--space-2);
  align-items: center;
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--text-primary);
  animation: toastSlideUp var(--duration-base) var(--ease-smooth);
  pointer-events: auto;
  position: relative;
  overflow: hidden;
  white-space: nowrap;
  max-width: 400px;
}

.toast.success {
  border-color: rgba(34, 197, 94, 0.5);
  box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
}

.toast.error {
  border-color: rgba(239, 68, 68, 0.5);
  box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
}

.toast.warning {
  border-color: rgba(245, 158, 11, 0.5);
  box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
}

.toast.info {
  border-color: rgba(59, 130, 246, 0.5);
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
}

@keyframes toastSlideUp {
  from {
    transform: translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.toast-icon {
  font-size: var(--text-base);
  line-height: 1;
}

.toast-close {
  margin-left: var(--space-2);
  width: 20px;
  height: 20px;
  border: none;
  border-radius: var(--radius-xs);
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-xs);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.toast-close:hover {
  background: rgba(255, 255, 255, 0.2);
  color: var(--text-primary);
  transform: scale(1.1);
}

/* -------- Modal/Dialog -------- */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(8px);
  z-index: 999;
  display: grid;
  place-items: center;
  padding: var(--space-4);
  animation: backdropFadeIn var(--duration-base) var(--ease-smooth);
}

@keyframes backdropFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-2xl);
  padding: var(--space-8);
  max-width: 600px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
  position: relative;
}

@keyframes modalSlideIn {
  from {
    transform: translateY(40px) scale(0.95);
    opacity: 0;
  }
  to {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-5);
  padding-bottom: var(--space-4);
  border-bottom: 1px solid var(--glass-border);
}

.modal-title {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  background: linear-gradient(135deg, var(--text-primary), var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-close {
  width: 40px;
  height: 40px;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  cursor: pointer;
  display: grid;
  place-items: center;
  font-size: var(--text-lg);
  font-weight: 800;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.modal-close:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: scale(1.05);
}

.modal-body {
  color: var(--text-secondary);
  line-height: 1.7;
}

.modal-footer {
  display: flex;
  gap: var(--space-3);
  justify-content: flex-end;
  margin-top: var(--space-6);
  padding-top: var(--space-4);
  border-top: 1px solid var(--glass-border);
}

/* -------- Dropdown Menu -------- */
.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-menu {
  position: absolute;
  top: calc(100% + var(--space-2));
  right: 0;
  min-width: 220px;
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xl);
  backdrop-filter: blur(24px) saturate(150%);
  padding: var(--space-2);
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all var(--duration-base) var(--ease-smooth);
}

.dropdown.open .dropdown-menu {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.dropdown-item {
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-sm);
  cursor: pointer;
  color: var(--text-secondary);
  font-weight: 600;
  font-size: var(--text-sm);
  display: flex;
  align-items: center;
  gap: var(--space-3);
  transition: all var(--duration-fast) var(--ease-smooth);
  border: 1px solid transparent;
}

.dropdown-item:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  border-color: var(--glass-border);
}

.dropdown-item.active {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 20%, transparent),
    color-mix(in oklab, var(--accent-secondary) 15%, transparent));
  color: var(--text-primary);
  border-color: color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.dropdown-divider {
  height: 1px;
  background: var(--glass-border);
  margin: var(--space-2) 0;
}

/* -------- Tooltip -------- */
[data-tooltip] {
  position: relative;
  cursor: help;
}

[data-tooltip]::before {
  content: attr(data-tooltip);
  position: absolute;
  bottom: calc(100% + var(--space-2));
  left: 50%;
  transform: translateX(-50%) translateY(-5px);
  padding: var(--space-2) var(--space-3);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-size: var(--text-xs);
  font-weight: 600;
  white-space: nowrap;
  box-shadow: var(--shadow-lg);
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
  pointer-events: none;
  z-index: 200;
  backdrop-filter: blur(12px);
}

[data-tooltip]::after {
  content: '';
  position: absolute;
  bottom: calc(100% + var(--space-1));
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: var(--glass-border-strong);
  opacity: 0;
  visibility: hidden;
  transition: all var(--duration-base) var(--ease-smooth);
  pointer-events: none;
  z-index: 200;
}

[data-tooltip]:hover::before,
[data-tooltip]:hover::after {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(0);
}

/* -------- Context Menu -------- */
.context-menu {
  position: fixed;
  min-width: 200px;
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-2xl);
  backdrop-filter: blur(24px) saturate(150%);
  padding: var(--space-2);
  z-index: 9999;
  animation: contextMenuAppear var(--duration-fast) var(--ease-smooth);
}

@keyframes contextMenuAppear {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* -------- Progress Indicator -------- */
.progress {
  height: 8px;
  background: var(--glass-bg);
  border-radius: var(--radius-full);
  overflow: hidden;
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-inner);
}

.progress-value {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
  border-radius: inherit;
  transition: width var(--duration-base) var(--ease-smooth);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

/* -------- Accordion -------- */
.accordion-item {
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  margin-bottom: var(--space-3);
  transition: all var(--duration-base) var(--ease-smooth);
}

.accordion-item:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
}

.accordion-header {
  padding: var(--space-4) var(--space-5);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 700;
  color: var(--text-primary);
  transition: all var(--duration-base) var(--ease-smooth);
}

.accordion-header:hover {
  background: var(--glass-bg);
}

.accordion-icon {
  transition: transform var(--duration-base) var(--ease-smooth);
}

.accordion-item.open .accordion-icon {
  transform: rotate(180deg);
}

.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height var(--duration-slow) var(--ease-smooth);
}

.accordion-item.open .accordion-content {
  max-height: 1000px;
}

.accordion-body {
  padding: var(--space-4) var(--space-5);
  color: var(--text-secondary);
  line-height: 1.7;
}

/* -------- Pro Feature Lock -------- */
.pro-locked {
  position: relative;
  opacity: 0.65;
  pointer-events: none;
}

.pro-locked::after {
  content: "ðŸ”’ Pro Feature â€” Unlock 8-Beat Studio Pro";
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  font-weight: 600;
  font-size: 1rem;
  text-align: center;
  border-radius: var(--radius-md);
  padding: 1rem;
  pointer-events: all;
  z-index: 50;
}

body.pro .pro-locked {
  opacity: 1;
  pointer-events: auto;
}

body.pro .pro-locked::after {
  display: none;
}

.sidebar-tab.locked {
  opacity: 0.5;
  pointer-events: none;
}

#unlockProBtn {
  padding: var(--space-4) var(--space-5);
  border: none;
  border-radius: var(--radius-md);
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
  color: #451a03;
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: var(--text-base);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  box-shadow: 
    var(--shadow-md),
    0 0 20px color-mix(in oklab, #f59e0b 40%, transparent);
  margin-top: var(--space-4);
}

#unlockProBtn:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    0 0 30px color-mix(in oklab, #f59e0b 50%, transparent);
}

#unlockProBtn:active {
  transform: translateY(0);
}

.sidebar-tab.locked::after {
  content: 'ðŸ”’';
  margin-left: var(--space-2);
  font-size: var(--text-sm);
}

#unlockModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(8px);
  padding: var(--space-4);
  align-items: center;
  justify-content: center;
}

#unlockModal:not(.hidden) {
  display: flex;
}

#unlockModal .pro-modal-inner {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  padding: var(--space-8);
  max-width: 500px;
  width: 100%;
  box-shadow: var(--shadow-2xl);
  animation: modalSlideIn var(--duration-slow) var(--ease-bounce);
  height: auto;
  min-height: auto;
  max-height: calc(100vh - 4rem);
  align-self: center;
}

#unlockModal h2 {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  background: linear-gradient(135deg, var(--text-primary), #fbbf24);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#unlockModal p {
  color: var(--text-secondary);
  margin-bottom: var(--space-4);
  line-height: 1.6;
}

#unlockModal input {
  width: 100%;
  padding: var(--space-4);
  font-family: var(--font-mono);
  font-size: var(--text-base);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  transition: all var(--duration-base) var(--ease-smooth);
}

#unlockModal input:focus {
  outline: none;
  border-color: #fbbf24;
  box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
}

#unlockModal .modal-actions {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: var(--space-3);
  margin-top: var(--space-4);
}

#unlockModal .modal-actions > * {
  width: 100%;
}

#unlockModal .modal-actions form {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#unlockModal #confirmLicenseBtn,
#unlockModal #cancelLicenseBtn {
  width: 100%;
  justify-content: center;
}

#unlockModal .status {
  margin-top: var(--space-4);
  padding: var(--space-3);
  border-radius: var(--radius-sm);
  font-size: var(--text-sm);
  font-weight: 600;
  text-align: center;
}

#unlockModal .status:not(:empty) {
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
}

/* -------- Sample Browser -------- */
.sample-item {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
}

.sample-item:hover {
  background: var(--glass-bg-strong);
  border-color: var(--accent-primary);
  transform: translateX(4px);
}

.sample-item.active {
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
  border-color: var(--accent-primary);
}

.sample-icon {
  font-size: var(--text-2xl);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
}

.sample-info {
  flex: 1;
}

.sample-name {
  font-weight: 600;
  margin-bottom: var(--space-1);
}

.sample-meta {
  font-size: var(--text-xs);
  color: var(--text-tertiary);
}

.sample-actions {
  display: flex;
  gap: var(--space-2);
}

.sample-action-btn {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: var(--text-sm);
}

.sample-action-btn:hover {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
  transform: scale(1.1);
}

/* ==================== MULTITRACK DAW STYLES ==================== */

.daw-wrapper {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 180px);
  min-height: 600px;
  background: var(--bg-primary);
  position: relative;
  overflow: hidden;
}

.daw-transport-bar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: var(--space-4);
  padding: var(--space-4) var(--space-5);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  margin-bottom: var(--space-4);
  box-shadow: var(--shadow-md);
  flex-shrink: 0;
}

.transport-section {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.transport-btn {
  width: 44px;
  height: 44px;
  border: none;
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  color: var(--text-primary);
  font-size: var(--text-xl);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.transport-btn:hover {
  background: var(--glass-bg-strong);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.transport-btn:active {
  transform: translateY(0);
}

.transport-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-md), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

.transport-display {
  padding: var(--space-2) var(--space-4);
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-base);
  color: var(--text-primary);
  min-width: 120px;
  text-align: center;
}

.daw-main-container {
  display: grid;
  grid-template-columns: 280px 1fr 320px;
  grid-template-rows: 1fr auto;
  gap: var(--space-4);
  flex: 1;
  min-height: 0;
  overflow: hidden;
}

.daw-track-list {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  grid-row: 1 / 3;
  min-height: 70vh;
  max-height: 90vh;
}

.daw-section-header {
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  font-weight: 800;
  font-size: var(--text-sm);
  color: var(--text-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.daw-track-list-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-3);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  min-height: 0;
}

.daw-track-strip {
  padding: var(--space-4);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  background: var(--surface);
  box-shadow: var(--shadow-sm);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  flex-shrink: 0;
}

.daw-track-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

.daw-track-strip.selected {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 12%, var(--surface)),
    var(--surface));
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 25%, transparent);
}

.daw-track-strip.recording {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--error) 12%, var(--surface)),
    var(--surface));
  border-color: var(--error);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--error) 30%, transparent);
  animation: recordPulse 1s ease-in-out infinite;
}

@keyframes recordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.track-strip-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-2);
}

.track-strip-name {
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}

.track-strip-controls {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
}

.track-strip-btn {
  width: 32px;
  height: 32px;
  min-width: 32px;
  min-height: 32px;
  border: none;
  border-radius: var(--radius-xs);
  background: var(--glass-bg);
  color: var(--text-tertiary);
  font-size: var(--text-xs);
  font-weight: 800;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.track-strip-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: scale(1.05);
}

.track-strip-btn.active {
  background: var(--error);
  color: white;
  box-shadow: var(--shadow-sm);
}

.track-strip-btn.solo.active {
  background: var(--warning);
}

.track-strip-meters {
  display: flex;
  gap: var(--space-1);
  height: 40px;
  margin: var(--space-2) 0;
}

.track-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.4);
  border-radius: var(--radius-xs);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.track-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 50ms linear;
  will-change: height;
}

.track-strip-fader {
  width: 100%;
  height: 80px;
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

.daw-timeline-container {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  min-height: 0;
  grid-row: 1;
}

.daw-timeline-container:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-timeline-toolbar {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
}

.tool-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  flex-shrink: 0;
  border: none;
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-lg);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  display: grid;
  place-items: center;
}

.tool-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.tool-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-sm);
}

.daw-ruler {
  position: relative;
  height: 48px;
  background: linear-gradient(180deg, var(--bg-secondary), var(--bg-tertiary));
  border-bottom: 2px solid var(--glass-border-strong);
  overflow: hidden;
  flex-shrink: 0;
}

.daw-ruler-markers {
  position: relative;
  height: 100%;
  width: var(--timeline-width, 100%);
  min-width: var(--timeline-width, 100%);
}

.daw-ruler-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 1px;
  background: rgba(255, 255, 255, 0.15);
}

.daw-ruler-marker.bar {
  width: 2px;
  background: rgba(255, 255, 255, 0.3);
}

.daw-ruler-label {
  position: absolute;
  top: 4px;
  left: 4px;
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  pointer-events: none;
}

.daw-playhead {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--error);
  pointer-events: none;
  z-index: 100;
  box-shadow: 0 0 12px var(--error);
}

.daw-playhead::before {
  content: '';
  position: absolute;
  top: -6px;
  left: -5px;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 8px solid var(--error);
}

.daw-loop-region {
  position: absolute;
  top: 0;
  bottom: 0;
  background: rgba(124, 131, 255, 0.12);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 50;
  box-shadow: inset 0 0 20px rgba(124, 131, 255, 0.15);
}

.loop-region-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 12px;
  cursor: ew-resize;
  z-index: 60;
  pointer-events: auto;
  background: rgba(124, 131, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.loop-region-handle:hover {
  background: rgba(124, 131, 255, 0.3);
}

.loop-region-handle.left {
  left: -6px;
}

.loop-region-handle.right {
  right: -6px;
}

.daw-arrangement-scroll {
  flex: 1;
  overflow: auto;
  background: var(--bg-primary);
  position: relative;
  scrollbar-width: thin;
  min-height: 0;
  cursor: grab;
}

.daw-arrangement-scroll.drag-scroll-active {
  cursor: grabbing;
}

.daw-arrangement-scroll::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

.daw-arrangement-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
}

.daw-arrangement-scroll::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 85%, #fff), 
    color-mix(in oklab, var(--accent-secondary) 85%, #fff));
  border-radius: var(--radius-xs);
  box-shadow: var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

.daw-arrangement-grid {
  position: relative;
  width: var(--timeline-width, 3200px);
  min-width: var(--timeline-width, 3200px);
  min-height: 100%;
  background-image: 
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      transparent 1px,
      transparent 100px),
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.08) 0px,
      rgba(255, 255, 255, 0.08) 2px,
      transparent 2px,
      transparent 400px);
}

.loop-region-highlight {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(124, 131, 255, 0.08);
  border-left: 2px solid var(--accent-primary);
  border-right: 2px solid var(--accent-primary);
  pointer-events: none;
  z-index: 5;
  display: none;
}

.loop-region-highlight.active {
  display: block;
}

.daw-track-lane {
  position: relative;
  height: 80px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  transition: background var(--duration-fast) var(--ease-smooth);
}

.daw-track-lane:hover {
  background: rgba(255, 255, 255, 0.02);
}

.daw-track-lane.selected {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--accent-primary) 8%, transparent),
    transparent);
}

.daw-track-lane.recording {
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--error) 8%, transparent),
    transparent);
  animation: laneRecordPulse 1s ease-in-out infinite;
}

@keyframes laneRecordPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

.daw-clip {
  position: absolute;
  top: 8px;
  bottom: 8px;
  border-radius: var(--radius-md);
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 60%, transparent),
    color-mix(in oklab, var(--accent-secondary) 50%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 70%, transparent);
  cursor: move;
  overflow: hidden;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
  display: flex;
  flex-direction: column;
}

.daw-clip:hover {
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-md), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  transform: translateY(-1px);
  z-index: 10;
}

.daw-clip.selected {
  border-color: var(--warning);
  box-shadow: var(--shadow-md), 0 0 16px color-mix(in oklab, var(--warning) 40%, transparent);
  z-index: 15;
}

.daw-clip.dragging {
  opacity: 0.7;
  cursor: grabbing;
  z-index: 100;
}

.clip-header {
  padding: var(--space-2) var(--space-3);
  background: rgba(0, 0, 0, 0.4);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  backdrop-filter: blur(8px);
}

.clip-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.clip-waveform {
  flex: 1;
  position: relative;
  overflow: hidden;
  padding: var(--space-1);
  background: rgba(0, 0, 0, 0.2);
}

.clip-waveform canvas {
  width: 100%;
  height: 100%;
  display: block;
  image-rendering: crisp-edges;
}

.clip-resize-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 10px;
  cursor: ew-resize;
  background: rgba(255, 255, 255, 0);
  transition: background var(--duration-fast) var(--ease-smooth);
  z-index: 20;
}

.clip-resize-handle.left {
  left: 0;
}

.clip-resize-handle.right {
  right: 0;
}

.clip-resize-handle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.audio-region {
  position: absolute;
  height: 64px;
  top: 8px;
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 40%, transparent),
    color-mix(in oklab, var(--accent-secondary) 30%, transparent));
  border: 1px solid color-mix(in oklab, var(--accent-primary) 60%, transparent);
  border-radius: var(--radius-md);
  cursor: move;
  overflow: visible;
  display: flex;
  flex-direction: column;
  transition: all var(--duration-fast) var(--ease-smooth);
  box-shadow: var(--shadow-md);
  user-select: none;
}

.audio-region:hover {
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-lg), var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  transform: translateY(-1px);
}

.audio-region.selected {
  border-color: var(--warning);
  box-shadow: var(--shadow-lg), 0 0 16px color-mix(in oklab, var(--warning) 40%, transparent);
}

.region-header {
  position: sticky;
  top: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-2) var(--space-3);
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(12px);
  z-index: 200;
  border-radius: var(--radius-md) var(--radius-md) 0 0;
  gap: var(--space-2);
  min-height: 32px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.region-name {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-primary);
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.region-actions {
  display: flex;
  gap: var(--space-1);
  flex-shrink: 0;
  z-index: 201;
}

.region-action-btn {
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  border: none;
  border-radius: var(--radius-xs);
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  cursor: pointer;
  font-size: 14px;
  display: grid;
  place-items: center;
  transition: all var(--duration-fast) var(--ease-smooth);
  padding: 0;
  backdrop-filter: blur(4px);
}

.region-action-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.15);
}

.audio-region.dragging .region-action-btn {
  pointer-events: none;
}

.audio-region:not(.dragging) .region-action-btn {
  pointer-events: auto;
}

.region-context-menu {
  position: fixed;
  min-width: 220px;
  max-width: 260px;
  padding: 4px 0;
  background: var(--surface-elevated);
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border-strong);
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.7), 0 0 0 1px rgba(255, 255, 255, 0.02);
  z-index: 10000;
  backdrop-filter: blur(16px);
  font-size: var(--text-sm);
  color: var(--text-primary);
  animation: contextMenuFadeIn 0.12s var(--ease-smooth);
}

.region-context-item {
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  transition: background var(--duration-fast) var(--ease-smooth);
}

.region-context-item:hover {
  background: color-mix(in oklab, var(--accent-primary) 12%, transparent);
}

.region-context-item.danger {
  color: #fecaca;
}

.region-context-item.danger:hover {
  background: color-mix(in oklab, #ef4444 18%, transparent);
  color: #fee2e2;
}

@keyframes contextMenuFadeIn {
  from {
    opacity: 0;
    transform: translateY(-4px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.daw-inspector {
  display: flex;
  flex-direction: column;
  background: var(--surface);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  overflow: hidden;
  min-height: 0;
  grid-row: 1 / 3;
}

.daw-inspector:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
  box-shadow: var(--shadow-lg);
}

.daw-inspector-tabs {
  display: flex;
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  padding: var(--space-2);
  gap: var(--space-2);
  overflow-x: auto;
  scrollbar-width: thin;
}

.inspector-tab {
  flex: 1;
  padding: var(--space-3);
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  background: transparent;
  color: var(--text-tertiary);
  font-weight: 700;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
  white-space: nowrap;
}

.inspector-tab:hover {
  color: var(--text-primary);
  background: var(--glass-bg-strong);
  border-color: var(--glass-border);
}

.inspector-tab.active {
  color: var(--bg-primary);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  border-color: transparent;
  box-shadow: var(--shadow-sm);
}

.daw-inspector-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-5);
  min-height: 0;
}

.inspector-section {
  margin-bottom: var(--space-6);
  padding: var(--space-4);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
}

.inspector-section:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 20%, var(--glass-border));
}

.inspector-section-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
  padding-bottom: var(--space-3);
  border-bottom: 2px solid var(--glass-border);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.inspector-param {
  margin-bottom: var(--space-3);
}

.inspector-param-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-2);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  font-weight: 600;
}

.inspector-param-value {
  font-family: var(--font-mono);
  font-weight: 700;
  color: var(--text-primary);
}

.inspector-param input[type="range"] {
  width: 100%;
}

.inspector-param select,
.inspector-param input[type="text"],
.inspector-param input[type="number"] {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  color: var(--text-primary);
  font-size: var(--text-sm);
}

.daw-master-strip {
  padding: var(--space-4);
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: var(--space-4);
  align-items: center;
  grid-row: 2;
}

.daw-master-strip:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border-strong));
  box-shadow: var(--shadow-lg);
}

.master-strip-title {
  font-size: var(--text-sm);
  font-weight: 800;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.daw-meters {
  display: flex;
  gap: var(--space-2);
  height: 100px;
}

.daw-meter-bar {
  flex: 1;
  background: rgba(0, 0, 0, 0.6);
  border-radius: var(--radius-sm);
  position: relative;
  overflow: hidden;
  border: 1px solid var(--glass-border);
  min-width: 24px;
}

.daw-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top,
    var(--success) 0%,
    var(--success) 60%,
    var(--warning) 75%,
    var(--error) 90%);
  transition: height 30ms linear;
  box-shadow: 0 0 10px currentColor;
  will-change: height;
}

#masterFader {
  width: 100%;
  height: 100px;
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
  cursor: ns-resize;
}

.daw-fader-label {
  text-align: center;
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
}

.track-fx-panel {
  margin-top: var(--space-2);
  padding: var(--space-3);
  border-radius: var(--radius-md);
  border: 1px dashed var(--glass-border);
  background: color-mix(in oklab, var(--surface) 70%, rgba(148, 163, 184, 0.12));
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.track-fx-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: var(--text-xs);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-secondary);
}

.fx-chain-mini {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
  flex-wrap: wrap;
}

.fx-slots-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.fx-chip {
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.5);
  background: rgba(15, 23, 42, 0.9);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--text-primary);
}

.fx-chip.disabled {
  opacity: 0.5;
}

.fx-chain-panel {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-height: 50vh;
  background: #2b2b2b;
  border-top: 2px solid #3a3a3a;
  box-shadow: var(--shadow-2xl);
  backdrop-filter: none;
  z-index: 9500;
  display: none;
  flex-direction: column;
  overflow: visible;
  color: #f0f0f0;
}

.fx-chain-panel.open {
  display: flex;
}

.fx-chain-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-4) var(--space-5);
  background: var(--glass-bg-strong);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  position: relative;
}

.fx-add-menu {
  position: absolute;
  top: 100%;
  right: var(--space-4);
  margin-top: var(--space-2);
  bottom: auto;
  z-index: 10;
  
  min-width: 220px;
  max-height: 260px;
  overflow-y: auto;
  
  background: var(--surface-elevated);
  border-radius: var(--radius-lg);
  border: 1px solid var(--glass-border-strong);
  box-shadow: var(--shadow-xl);
  padding: var(--space-3);
}

.fx-add-menu h4 {
  font-size: var(--text-xs);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-tertiary);
  margin-bottom: var(--space-2);
}

.fx-add-menu button {
  width: 100%;
  text-align: left;
  margin-bottom: var(--space-1);
}
.fx-add-menu button:last-child {
  margin-bottom: 0;
}

.fx-chain-body {
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.fx-add-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  flex-wrap: wrap;
  padding: var(--space-3);
  border-radius: var(--radius-md);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
}

.fx-add-label {
  font-size: var(--text-sm);
  font-weight: 600;
  color: var(--text-secondary);
}

.fx-add-list {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.fx-pill {
  padding: var(--space-1) var(--space-3);
  border-radius: var(--radius-full);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg-strong);
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: var(--space-1);
  transition: all var(--duration-fast) var(--ease-smooth);
}

.fx-pill:hover,
.fx-pill:focus-visible {
  border-color: var(--accent-primary);
  color: var(--text-primary);
  background: color-mix(in oklab, var(--accent-primary) 12%, var(--glass-bg-strong));
  box-shadow: var(--shadow-sm);
}

.fx-chain-slots {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-height: 220px;
  overflow-y: auto;
}

.track-meters {
  display: flex;
  align-items: center;
  gap: 4px;
  height: 24px;
}

.track-meter {
  position: relative;
  flex: 1;
  height: 100%;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.9);
  overflow: hidden;
  border: 1px solid rgba(30, 64, 175, 0.7);
}

.track-meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 0;
  background: linear-gradient(180deg, #22c55e, #f97316 60%, #ef4444 100%);
  transform-origin: bottom;
  transition: height 0.06s linear;
}

.daw-fab {
  position: fixed;
  bottom: calc(1.5rem + env(safe-area-inset-bottom));
  right: calc(1.5rem + env(safe-area-inset-right));
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  font-size: var(--text-2xl);
  border: none;
  box-shadow: var(--shadow-lg), var(--glow-md) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  z-index: 999;
  cursor: pointer;
  display: none;
  transition: all var(--duration-base) var(--ease-smooth);
}

.daw-fab:hover {
  transform: scale(1.05) rotate(90deg);
  box-shadow: var(--shadow-xl), var(--glow-lg) color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

.daw-fab:active {
  transform: scale(0.95);
}

.song-builder-status {
  margin-top: 4px;
  font-size: 0.8rem;
  min-height: 1em;
  color: var(--text-muted);
}

.song-builder-status.active {
  color: var(--accent, #7dd3fc);
}

.song-builder-status .dot {
  display: inline-block;
  width: 0.4em;
  height: 0.4em;
  border-radius: 999px;
  margin-right: 0.4em;
  background: currentColor;
  animation: sb-pulse 0.9s ease-in-out infinite;
}

@keyframes sb-pulse {
  0%   { transform: scale(0.9); opacity: 0.4; }
  50%  { transform: scale(1.2); opacity: 1; }
  100% { transform: scale(0.9); opacity: 0.4; }
}

/* ==================== RESPONSIVE BREAKPOINTS ==================== */

/* TABLET: 1024px - 768px */
@media (max-width: 1024px) {
  :root {
    --space-4: 0.875rem;
    --space-5: 1rem;
    --space-6: 1.25rem;
    --space-8: 1.5rem;
  }
  
  body {
    padding: var(--space-3);
  }
  
  .app {
    padding: clamp(var(--space-3), 1.5vw, var(--space-6));
    gap: var(--space-4);
  }
  
  header {
    grid-template-columns: auto 1fr;
    gap: var(--space-3);
    padding: var(--space-3) var(--space-4);
  }
  
  .header-actions {
    grid-column: 1 / -1;
    justify-content: center;
  }
  
  h1 {
    font-size: var(--text-xl);
  }
  
  .tagline {
    font-size: var(--text-xs);
  }
  
  .logo {
    width: 44px;
    height: 44px;
  }
  
  .genre-selector {
    justify-content: flex-start;
  }
  
  .genre-btn {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .sidebar-nav {
    width: min(90vw, 340px);
  }
  
  .sidebar-toggle {
    width: 52px;
    height: 52px;
    font-size: var(--text-xl);
  }
  
  .transport {
    grid-template-columns: 1fr;
    gap: var(--space-4);
    padding: var(--space-4);
  }
  
  .transport-controls {
    justify-content: center;
  }
  
  .transport-params {
    grid-auto-flow: row;
    gap: var(--space-3);
  }
  
  .panel {
    padding: var(--space-4);
  }
  
  .panel-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .grid-2 {
    grid-template-columns: 1fr;
  }
  
  .grid-3 {
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  }
  
  .grid-4 {
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  }
  
  .grid-5 {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  }
  
  .preset-grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: var(--space-3);
  }
  
  .seq-grid {
    min-width: 800px;
  }
  
  .seq-row {
    grid-template-columns: 150px repeat(16, 1fr);
    gap: var(--space-1);
  }
  
  .step {
    min-height: 40px;
  }
  
  #mixerGrid {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--space-3);
  }
  
  .mixer-channel {
    padding: var(--space-3);
  }
  
  #fxGrid {
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: var(--space-3);
  }
  
  .fx-unit {
    padding: var(--space-4);
  }
  
  .visualizer {
    height: clamp(140px, 18vh, 180px);
  }
  
  .sample-item {
    padding: var(--space-2);
    gap: var(--space-2);
  }
  
  .sample-icon {
    width: 40px;
    height: 40px;
    font-size: var(--text-xl);
  }
  
  .daw-main-container {
    grid-template-columns: 240px 1fr 280px;
    gap: var(--space-3);
  }
}

/* MOBILE LANDSCAPE: 900px - 768px */
@media (max-width: 900px) {
  :root {
    --space-4: 0.75rem;
    --space-5: 0.875rem;
    --space-6: 1rem;
    --space-8: 1.25rem;
  }
  
  body {
    padding: var(--space-2);
  }
  
  .app {
    padding: var(--space-3);
    gap: var(--space-3);
    border-radius: var(--radius-xl);
  }
  
  header {
    position: relative;
    top: 0;
    grid-template-columns: 1fr;
    gap: var(--space-2);
    padding: var(--space-3);
    min-height: auto;
  }
  
  .logo-section {
    justify-content: center;
  }
  
  .logo {
    width: 40px;
    height: 40px;
    font-size: var(--text-xl);
  }
  
  h1 {
    font-size: var(--text-lg);
  }
  
  .tagline {
    display: none;
  }
  
  .genre-selector {
    order: 3;
    width: 100%;
    justify-content: center;
  }
  
  .genre-btn {
    padding: var(--space-1) var(--space-3);
    font-size: 11px;
  }
  
  .header-actions {
    order: 2;
    justify-content: center;
    width: 100%;
  }
  
  .sidebar-toggle {
    top: var(--space-3);
    left: var(--space-3);
    width: 48px;
    height: 48px;
    font-size: var(--text-lg);
  }
  
  .sidebar-nav {
    padding-top: calc(var(--space-16) + var(--inset-top));
  }
  
  .sidebar-presets {
    grid-template-columns: 1fr;
  }
  
  .transport {
    position: relative;
    top: 0;
    grid-template-columns: 1fr;
    padding: var(--space-3);
    gap: var(--space-3);
  }
  
  .transport-controls {
    justify-content: center;
    order: 1;
  }
  
  .progress-area {
    order: 2;
  }
  
  .transport-params {
    order: 3;
    grid-auto-flow: row;
    justify-items: stretch;
  }
  
  .btn {
    padding: var(--space-2) var(--space-4);
  }
  
  .btn-sm {
    padding: var(--space-1) var(--space-3);
  }
  
  .section.active {
    gap: var(--space-3);
  }
  
  .panel {
    padding: var(--space-3);
  }
  
  .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-2);
  }
  
  .panel-title {
    font-size: var(--text-base);
  }
  
  .grid,
  .grid-2,
  .grid-3,
  .grid-4,
  .grid-5 {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .preset-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-2);
  }
  
  .preset {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  .preset-icon {
    font-size: var(--text-2xl);
  }
  
  .preset-name {
    font-size: var(--text-xs);
  }
  
  .sequencer {
    padding-bottom: var(--space-1);
  }
  
  .seq-grid {
    min-width: 700px;
    gap: var(--space-2);
  }
  
  .seq-row {
    grid-template-columns: 120px repeat(16, 1fr);
  }
  
  .seq-label {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .seq-icon {
    width: 28px;
    height: 28px;
    font-size: 10px;
  }
  
  .step {
    min-height: 36px;
  }
  
  .step-prob,
  .step-vel {
    display: none;
  }
  
  #mixerGrid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-3);
  }
  
  .mixer-channel {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  #fxGrid {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .fx-unit {
    padding: var(--space-4);
  }

  .fx-add-menu {
    left: var(--space-3);
    right: var(--space-3);
    min-width: auto;
  }
  
  .visualizer {
    height: 120px;
  }
  
  .viz-bar {
    width: 4px;
  }
  
  .sample-item {
    flex-direction: row;
  }
  
  .sample-icon {
    width: 36px;
    height: 36px;
  }
  
  .sample-action-btn {
    width: 28px;
    height: 28px;
  }
  
  .chips {
    gap: var(--space-1);
  }
  
  .chip {
    padding: var(--space-1) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .modal {
    padding: var(--space-6);
    max-width: 90vw;
  }
  
  .modal-title {
    font-size: var(--text-xl);
  }
  
  .toast-container {
    width: min(360px, 85vw);
  }
  
  .footer {
    padding: var(--space-4);
    font-size: var(--text-xs);
  }
  
  /* DAW Responsive */
  .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto;
    gap: var(--space-3);
  }
  
  .daw-track-list,
  .daw-timeline-container,
  .daw-inspector {
    grid-row: auto;
    grid-column: 1;
  }

  .daw-track-list {
    min-height: 60vh;
    max-height: 80vh;
  }
  
  .daw-track-list-scroll {
    max-height: 200px;
  }
  
  .daw-timeline-container {
    min-height: 300px;
  }
  
  .daw-transport-bar {
    grid-template-columns: 1fr;
    gap: var(--space-3);
  }
  
  .transport-section {
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .daw-master-strip {
    grid-template-columns: 1fr;
    gap: var(--space-3);
    text-align: center;
  }
}

/* MOBILE PORTRAIT: 768px and below */
@media (max-width: 768px) {
  :root {
    --text-base: 0.875rem;
    --text-lg: 1rem;
    --text-xl: 1.125rem;
    --text-2xl: 1.25rem;
    --text-3xl: 1.5rem;
    
    --space-3: 0.625rem;
    --space-4: 0.75rem;
    --space-5: 0.875rem;
    --space-6: 1rem;
  }
  
  body {
    padding: var(--space-2);
  }
  
  .app {
    padding: var(--space-3);
    gap: var(--space-3);
    border-radius: var(--radius-lg);
  }
  
  header {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-2);
  }
  
  .logo {
    width: 36px;
    height: 36px;
    font-size: var(--text-lg);
  }
  
  h1 {
    font-size: var(--text-base);
  }
  
  .genre-selector {
    gap: var(--space-1);
  }
  
  .genre-btn {
    padding: 4px 8px;
    font-size: 10px;
    border-radius: var(--radius-sm);
  }
  
  .btn {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .btn-sm {
    padding: 4px 8px;
    font-size: 10px;
  }
  
  .sidebar-toggle {
    width: 44px;
    height: 44px;
    top: var(--space-2);
    left: var(--space-2);
  }
  
  .sidebar-nav {
    width: min(85vw, 320px);
    padding: calc(var(--space-12) + var(--inset-top)) var(--space-3) calc(var(--space-3) + var(--inset-bottom)) var(--space-3);
  }
  
  .sidebar-section {
    margin-bottom: var(--space-6);
  }
  
  .sidebar-section-title {
    font-size: var(--text-base);
    margin-bottom: var(--space-3);
  }
  
  .sidebar-tab {
    padding: var(--space-3) var(--space-4);
    font-size: var(--text-sm);
  }
  
  .sidebar-presets {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .sidebar-preset {
    padding: var(--space-3);
  }
  
  .transport {
    padding: var(--space-3);
    gap: var(--space-2);
  }
  
  .transport-controls {
    gap: var(--space-1);
  }
  
  .transport-controls .btn {
    width: auto;
    height: auto;
    padding: var(--space-2) var(--space-4);
    border-radius: var(--radius-full);
  }
  
  .time-info {
    font-size: var(--text-xs);
  }
  
  .progress-bar {
    height: 10px;
  }
  
  .transport-params {
    gap: var(--space-2);
  }
  
  .param-control {
    gap: var(--space-1);
  }
  
  .param-label {
    font-size: var(--text-xs);
  }
  
  .param-value {
    font-size: var(--text-xs);
    padding: 2px var(--space-1);
  }
  
  input[type="range"] {
    height: 10px;
  }
  
  input[type="range"]::-webkit-slider-thumb {
    width: 18px;
    height: 18px;
  }
  
  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
  }
  
  .section.active {
    gap: var(--space-2);
    margin-top: var(--space-1);
  }
  
  .panel {
    padding: var(--space-3);
    border-radius: var(--radius-md);
  }
  
  .panel-header {
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
  }
  
  .panel-title {
    font-size: var(--text-sm);
    gap: var(--space-2);
  }
  
  .grid,
  .grid-2,
  .grid-3,
  .grid-4,
  .grid-5 {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .preset-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-2);
  }
  
  .preset {
    padding: var(--space-3);
  }
  
  .preset-icon {
    font-size: var(--text-2xl);
  }
  
  .preset-name {
    font-size: 10px;
  }
  
  .seq-grid {
    min-width: 600px;
  }
  
  .seq-row {
    grid-template-columns: 100px repeat(16, 1fr);
    gap: 4px;
  }
  
  .seq-label {
    padding: var(--space-2);
    font-size: 10px;
  }
  
  .seq-icon {
    width: 24px;
    height: 24px;
    font-size: 9px;
  }
  
  .step {
    min-height: 32px;
    border-radius: var(--radius-sm);
  }
  
  .step-prob,
  .step-vel {
    display: none;
  }
  
  #mixerGrid {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .mixer-channel {
    padding: var(--space-3);
  }
  
  .channel-header {
    padding-bottom: var(--space-1);
  }
  
  .channel-name {
    font-size: var(--text-xs);
  }
  
  .channel-btn {
    width: 30px;
    height: 30px;
    font-size: 10px;
  }
  
  #fxGrid {
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }
  
  .fx-unit {
    padding: var(--space-3);
  }
  
  .fx-header {
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
  }
  
  .fx-name {
    font-size: var(--text-sm);
  }
  
  .fx-toggle {
    width: 52px;
    height: 28px;
  }
  
  .fx-toggle::after {
    width: 20px;
    height: 20px;
  }
  
  .visualizer {
    height: 100px;
    border-radius: var(--radius-md);
  }
  
  .viz-bar {
    width: 3px;
  }
  
  .viz-overlay {
    font-size: var(--text-base);
  }
  
  .sample-item {
    padding: var(--space-2);
    gap: var(--space-2);
  }
  
  .sample-icon {
    width: 32px;
    height: 32px;
    font-size: var(--text-lg);
  }
  
  .sample-name {
    font-size: var(--text-xs);
  }
  
  .sample-meta {
    font-size: 10px;
  }
  
  .sample-action-btn {
    width: 28px;
    height: 28px;
    font-size: var(--text-xs);
  }
  
  .chip {
    padding: 4px 8px;
    font-size: 10px;
  }
  
  input[type="text"],
  input[type="email"],
  input[type="number"],
  select {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-sm);
  }
  
  .modal {
    padding: var(--space-4);
    border-radius: var(--radius-lg);
  }
  
  .modal-header {
    margin-bottom: var(--space-4);
    padding-bottom: var(--space-3);
  }
  
  .modal-title {
    font-size: var(--text-lg);
  }
  
  .modal-close {
    width: 36px;
    height: 36px;
  }
  
  .modal-footer {
    margin-top: var(--space-4);
    padding-top: var(--space-3);
    gap: var(--space-2);
    flex-direction: column;
  }
  
  .modal-footer .btn {
    width: 100%;
  }
  
  .dropdown-menu {
    min-width: 180px;
  }
  
  .dropdown-item {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-xs);
  }
  
  .toast-container {
    width: min(320px, 90vw);
    bottom: calc(var(--space-3) + var(--inset-bottom));
  }
  
  .toast {
    padding: var(--space-2) var(--space-3);
    font-size: 11px;
  }
  
  .toast-icon {
    font-size: var(--text-sm);
  }
  
  .footer {
    padding: var(--space-3);
    font-size: 11px;
    line-height: 1.6;
  }
  
  kbd {
    padding: 2px 4px;
    font-size: 10px;
  }
  
  .badge {
    padding: 2px 6px;
    font-size: 9px;
  }
  
  .accordion-item {
    margin-bottom: var(--space-2);
  }
  
  .accordion-header {
    padding: var(--space-3);
    font-size: var(--text-sm);
  }
  
  .accordion-body {
    padding: var(--space-3);
    font-size: var(--text-xs);
  }
  
  #unlockModal .pro-modal-inner {
    padding: var(--space-6);
    max-width: 90vw;
  }
  
  #unlockModal h2 {
    font-size: var(--text-xl);
    margin-bottom: var(--space-3);
  }
  
  #unlockModal p {
    font-size: var(--text-sm);
    margin-bottom: var(--space-3);
  }
  
  #unlockModal input {
    padding: var(--space-3);
    font-size: var(--text-sm);
  }
  
  #unlockProBtn {
    padding: var(--space-3) var(--space-4);
    font-size: var(--text-sm);
  }
  
  .transport-btn {
    width: 48px;
    height: 48px;
    font-size: var(--text-xl);
    border-radius: var(--radius-full);
  }

  #unlockModal.modal-portal {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    background: rgba(0,0,0,0.5);
  }

  #unlockModal.modal-portal.hidden {
    display: none;
  }

    /* === Toolbar button fixes for mobile/tablet === */
  .tool-btn {
    width: 36px;
    height: 36px;
    min-width: 36px;
    flex-shrink: 0;
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border: 1px solid var(--bg-secondary);
    transition: background 0.2s ease, transform 0.1s ease;
  }

  .tool-btn:active {
    transform: scale(0.95);
  }

  .tool-btn svg {
    width: 18px;
    height: 18px;
  }

  .multitrack-toolbar {
    flex-wrap: wrap;
    justify-content: center;
  }

  /* === Prevent horizontal overflow on smaller screens === */
  .multitrack-wrapper {
    overflow-x: auto;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch;
  }

  /* === Responsive zoom controls === */
  .zoom-controls {
    display: flex;
    gap: var(--space-1);
    justify-content: center;
    align-items: center;
  }

  .zoom-controls button {
    flex: 0 0 36px;
    height: 36px;
    border-radius: var(--radius-sm);
  }

} /* closes @media (max-width: 768px) */

/* ==================== DAW TRANSPORT INPUT POLISH ==================== */

.daw-transport-bar input[type="number"],
.daw-transport-bar select {
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--bg-tertiary);
  color: var(--text-primary);
  font-size: var(--text-xs);
  padding: var(--space-1) var(--space-2);
  line-height: 1.2;
  min-width: 64px;
}

.daw-transport-bar input[type="number"]:focus,
.daw-transport-bar select:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-primary) 45%, transparent);
}

/* === MULTITRACK: TRACK HEADER & CONTROLS === */

/* Main track header container (left column + inline version) */
.track-header {
  padding: var(--space-3) var(--space-3);
  border-bottom: 1px solid var(--glass-border);
  background: color-mix(in oklab, var(--surface) 80%, var(--bg-secondary));
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  border-radius: var(--radius-md);
}

/* Recording / armed state tint */
.track-header.recording {
  box-shadow: var(--shadow-md),
    0 0 0 1px color-mix(in oklab, var(--error) 40%, transparent);
}

.track-header.armed:not(.recording) {
  box-shadow: var(--shadow-sm),
    0 0 0 1px color-mix(in oklab, var(--accent-secondary) 40%, transparent);
}

/* Top row: icon + editable name */
.track-header-top {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.track-icon {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-md);
  background: var(--glass-bg-strong);
  display: grid;
  place-items: center;
  font-size: var(--text-lg);
  box-shadow: var(--shadow-sm);
  flex-shrink: 0;
}

.track-name {
  flex: 1;
  font-weight: 700;
  font-size: var(--text-sm);
  color: var(--text-primary);
  outline: none;
  border-radius: var(--radius-sm);
  padding: 2px 6px;
  border: 1px solid transparent;
  background: transparent;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.track-name:focus {
  border-color: var(--accent-primary);
  background: color-mix(in oklab, var(--surface) 85%, var(--accent-primary) 15%);
  box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-primary) 40%, transparent);
}

/* Track meters in header (re-use existing meter fill) */
.track-meters {
  display: flex;
  gap: var(--space-1);
  height: 28px;
  margin-top: var(--space-1);
}

.track-meter {
  flex: 1;
  background: rgba(0, 0, 0, 0.45);
  border-radius: var(--radius-xs);
  position: relative;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

/* We already have .track-meter-fill defined, so this just uses it */

/* === Track header button grid (REC / ARM / M / S / FX / ðŸ—‘) === */

.track-controls-grid {
  margin-top: var(--space-2);
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: var(--space-2);
}

.track-mini-btn {
  width: 100%;
  min-height: 32px;
  padding: 4px 6px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--glass-border);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-xs);
  font-weight: 700;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.track-mini-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.track-mini-btn:active {
  transform: translateY(0) scale(0.97);
}

/* Generic "on" state */
.track-mini-btn.active {
  background: linear-gradient(135deg,
    color-mix(in oklab, var(--accent-primary) 60%, var(--accent-secondary)),
    var(--accent-secondary));
  color: var(--bg-primary);
  border-color: color-mix(in oklab, var(--accent-primary) 60%, var(--accent-secondary));
  box-shadow: var(--shadow-sm);
}

/* Special cases so you can read state at a glance */
.track-mini-btn.rec.active {
  background: linear-gradient(135deg, var(--error), color-mix(in oklab, var(--error) 70%, #ffb0b0));
  border-color: var(--error);
}

.track-mini-btn.arm.active {
  background: linear-gradient(135deg, var(--warning), var(--accent-secondary));
  border-color: var(--warning);
}

.track-mini-btn.mute.active {
  background: color-mix(in oklab, var(--bg-tertiary) 70%, #000);
  color: color-mix(in oklab, var(--text-secondary) 60%, #aaa);
  border-color: rgba(255, 255, 255, 0.08);
}

.track-mini-btn.solo.active {
  background: linear-gradient(135deg, var(--success), var(--warning));
  color: #02040a;
}

/* FX + Delete â€“ keep them a bit more icon-y */
.track-mini-btn[data-action="fx"] {
  font-size: var(--text-sm);
}

.track-mini-btn[data-action="delete"] {
  background: rgba(255, 76, 76, 0.12);
  border-color: rgba(255, 76, 76, 0.35);
  color: color-mix(in oklab, var(--error) 70%, #fff);
}

.track-mini-btn[data-action="delete"]:hover {
  background: rgba(255, 76, 76, 0.2);
}

/* Volume / pan block under header */

.track-volume-control {
  margin-top: var(--space-2);
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.track-volume-control label {
  font-size: var(--text-xs);
  color: var(--text-tertiary);
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

.track-volume-control input[type="range"] {
  width: 100%;
}

.track-volume-value,
.track-pan-value {
  font-family: var(--font-mono);
  font-size: var(--text-xs);
  color: var(--text-secondary);
  opacity: 0.9;
}

/* Canvas area: keep the timeline lane visually focused */
.track-canvas-area {
  background: radial-gradient(circle at top left,
      color-mix(in oklab, var(--accent-primary) 12%, transparent),
      transparent 55%);
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
  padding: var(--space-2) 0 var(--space-2) var(--space-1);
}

.track-canvas {
  position: relative;
}

/* === TIMELINE TOOLBAR: FORCE HORIZONTAL LAYOUT === */

/* Desktop + mobile: tools stay on one line, scroll if needed */
.daw-timeline-toolbar {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-4);
  background: var(--glass-bg);
  border-bottom: 1px solid var(--glass-border);
  flex-shrink: 0;
  flex-wrap: nowrap;        /* key: no wrapping */
  overflow-x: auto;         /* scroll instead */
  scrollbar-width: thin;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding-right: var(--space-3);
  border-right: 1px solid var(--glass-border);
  flex: 0 0 auto;           /* keep groups inline, don't squeeze */
}

.toolbar-group:last-child {
  border-right: none;
}

/* Tools themselves: nice touch targets + consistent shape */
.tool-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  min-height: 40px;
  flex-shrink: 0;
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  color: var(--text-secondary);
  font-size: var(--text-lg);
  display: grid;
  place-items: center;
  cursor: pointer;
  transition: all var(--duration-fast) var(--ease-smooth);
}

.tool-btn:hover {
  background: var(--glass-bg-strong);
  color: var(--text-primary);
  transform: translateY(-1px);
}

.tool-btn:active {
  transform: translateY(0) scale(0.96);
}

.tool-btn.active {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow-sm);
}

@media (max-width: 768px) {
  /* Timeline is the star on mobile */
  .daw-timeline-container {
    order: 2;
    min-height: 280px;
    border-width: 2px;
    border-color: color-mix(in oklab, var(--accent-primary) 50%, var(--glass-border));
    box-shadow:
      var(--shadow-lg),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 30%, transparent);
  }

  /* Slightly tighter header to save vertical space */
  .track-header {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-1);
  }

  .track-controls-grid {
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: var(--space-1);
  }

  .track-mini-btn {
    min-height: 32px;
    font-size: 10px;
    padding: 3px 4px;
  }

  /* Toolbar: even more clearly a single row you can swipe */
  .daw-timeline-toolbar {
    padding: var(--space-2) var(--space-3);
    gap: var(--space-1);
    justify-content: flex-start;
  }
}

/* ==========================================================================
   MULTITRACK: ACCESSIBLE MOBILE LAYOUT + INSPECTOR STYLES
   Paste this near the end of your <style> block so it overrides earlier rules
   ========================================================================== */

/* 1) Friendlier mobile layout for the multitrack tab */
@media (max-width: 900px) {
  #tab-multitrack .daw-wrapper {
    height: auto;
    min-height: 0;
  }

  #tab-multitrack .daw-main-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto minmax(280px, 1fr);
    gap: var(--space-3);
  }

  #tab-multitrack .daw-track-list {
    order: 1;
    min-height: auto;
    max-height: 220px;
  }

  #tab-multitrack .daw-track-list-scroll {
    max-height: 180px;
    overflow-y: auto;
  }

  #tab-multitrack .daw-timeline-container {
    order: 2;
    min-height: 280px;
  }

  #tab-multitrack .daw-master-strip {
    order: 3;
  }

  #tab-multitrack .daw-inspector {
    order: 4;
  }
}

@media (max-width: 768px) {
  #tab-multitrack .daw-main-container {
    grid-template-rows: auto minmax(260px, 1fr);
  }

  #tab-multitrack .daw-track-list {
    max-height: 190px;
  }

  #tab-multitrack .daw-timeline-container {
    min-height: 260px;
  }

  /* Hide the master strip on very small screens â€“
     you can still access master from the mixer tab */
  #tab-multitrack .daw-master-strip {
    display: none;
  }

  /* Turn the inspector into a bottom sheet on phones */
  #tab-multitrack .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    margin: 0;
    max-height: 70vh;
    transform: translateY(100%);
    transition: transform var(--duration-base) var(--ease-smooth);
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    box-shadow: 0 -16px 40px rgba(0,0,0,.6);
    z-index: 9600;
  }

  #tab-multitrack .daw-inspector.inspector-open {
    transform: translateY(0);
  }
}

/* 4) FX chain panel: scroll instead of overlapping the footer */
.fx-chain-panel {
  max-height: min(60vh, calc(100vh - 80px));
  overflow-y: auto;
  padding-bottom: calc(var(--space-4) + var(--inset-bottom));
}

/* 2) Track header selection state (what's currently in the inspector) */
#tab-multitrack .track-header.selected {
  border-color: color-mix(in oklab, var(--accent-primary) 50%, var(--glass-border-strong));
  box-shadow:
    0 0 0 1px color-mix(in oklab, var(--accent-primary) 35%, transparent),
    0 0 0 1px rgba(15,23,42,.9),
    var(--shadow-lg);
  background:
    radial-gradient(circle at top left,
      color-mix(in oklab, var(--accent-primary) 16%, transparent),
      transparent 65%),
    var(--surface-elevated);
}

/* 3) Inspector micro layout tweaks */
.daw-inspector-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
}

#inspectorTitle {
  font-size: var(--text-sm);
  font-weight: 700;
  color: var(--text-secondary);
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.inspector-section-title {
  font-size: var(--text-xs);
  font-weight: 700;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.inspector-param-label span:first-child {
  font-weight: 600;
}

.inspector-toggle-row {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

/* ==================== MULTITRACK MOBILE SIGNATURE LAYOUT ==================== */
/* Replaces generic mobile DAW styles with purpose-built multitrack UI */

@media (max-width: 900px) {
  /* Kill the rigid grid, embrace natural flow */
  #tab-multitrack .daw-wrapper {
    height: auto;
    min-height: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    padding-bottom: calc(var(--space-8) + var(--inset-bottom));
  }

  /* Transport becomes a floating command bar */
  #tab-multitrack .daw-transport-bar {
    position: sticky;
    top: calc(var(--header-h) + var(--space-6));
    z-index: 100;
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--bg-secondary) 95%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 90%, transparent));
    backdrop-filter: blur(20px) saturate(160%);
    border: 1px solid var(--glass-border-strong);
    border-radius: var(--radius-xl);
    padding: var(--space-3) var(--space-4);
    box-shadow: 
      var(--shadow-xl),
      0 0 0 1px rgba(255,255,255,.04);
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: var(--space-3);
    align-items: center;
  }

  /* Main container: track list on top, timeline hero, inspector slides up */
  #tab-multitrack .daw-main-container {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    min-height: 0;
  }

  /* Track list: compact horizontal carousel */
  #tab-multitrack .daw-track-list {
    order: 1;
    max-height: 140px;
    border-radius: var(--radius-xl);
    overflow: hidden;
    background: var(--surface-elevated);
    border: 1px solid var(--glass-border);
  }

  #tab-multitrack .daw-track-list-scroll {
    display: flex;
    flex-direction: row;
    gap: var(--space-3);
    padding: var(--space-4);
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }

  #tab-multitrack .daw-track-list-scroll::-webkit-scrollbar {
    display: none;
  }

  #tab-multitrack .daw-track-strip {
    flex: 0 0 240px;
    scroll-snap-align: start;
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
    padding: var(--space-3);
    background: var(--surface);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    min-width: 240px;
  }

  /* Timeline becomes the visual anchor */
  #tab-multitrack .daw-timeline-container {
    order: 2;
    min-height: 420px;
    border-width: 2px;
    border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border));
    box-shadow:
      var(--shadow-2xl),
      var(--glow-md) color-mix(in oklab, var(--accent-primary) 20%, transparent),
      inset 0 1px 0 rgba(255,255,255,.08);
    border-radius: var(--radius-2xl);
    overflow: hidden;
  }

  /* Master strip: simplified horizontal */
  #tab-multitrack .daw-master-strip {
    order: 3;
    grid-template-columns: 1fr auto;
    padding: var(--space-4);
  }

  /* Inspector: slide-up modal on demand */
  #tab-multitrack .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    order: 4;
    max-height: 75vh;
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
    border-bottom: none;
    box-shadow: 0 -20px 60px rgba(0,0,0,.7);
    z-index: 9600;
    transform: translateY(100%);
    transition: transform var(--duration-slow) cubic-bezier(0.32, 0.72, 0, 1);
  }

  #tab-multitrack .daw-inspector.inspector-open {
    transform: translateY(0);
  }

  /* Add pull handle */
  #tab-multitrack .daw-inspector::before {
    content: '';
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 48px;
    height: 5px;
    border-radius: 999px;
    background: var(--text-muted);
    opacity: 0.4;
  }
}

/* ==================== MOBILE TIMELINE TOOLBAR: SWIPEABLE COMMAND BAR ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-timeline-toolbar {
    position: sticky;
    top: 0;
    z-index: 10;
    padding: var(--space-3);
    background: linear-gradient(180deg,
      color-mix(in oklab, var(--bg-secondary) 96%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 92%, transparent));
    backdrop-filter: blur(16px) saturate(140%);
    border-bottom: 2px solid var(--glass-border-strong);
    display: flex;
    gap: var(--space-2);
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x proximity;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
  }

  .toolbar-group {
    display: flex;
    gap: var(--space-2);
    padding: 0 var(--space-2);
    border-right: 1px solid rgba(255,255,255,.08);
    flex-shrink: 0;
  }

  .toolbar-group:last-child {
    border-right: none;
    padding-right: var(--space-4);
  }

  .tool-btn {
    width: 48px;
    height: 48px;
    min-width: 48px;
    border-radius: var(--radius-md);
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--glass-bg-strong) 90%, transparent),
      var(--glass-bg));
    border: 1px solid var(--glass-border);
    font-size: var(--text-xl);
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
  }

  .tool-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center,
      color-mix(in oklab, var(--accent-primary) 20%, transparent),
      transparent 70%);
    opacity: 0;
    transition: opacity var(--duration-fast) var(--ease-smooth);
  }

  .tool-btn:active::before {
    opacity: 1;
  }

  .tool-btn.active {
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    border-color: transparent;
    box-shadow:
      var(--shadow-md),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
    transform: scale(0.95);
  }

  /* Zoom controls: grouped pill design */
  .zoom-controls {
    display: flex;
    background: var(--glass-bg-strong);
    border-radius: var(--radius-full);
    padding: var(--space-1);
    gap: var(--space-1);
    border: 1px solid var(--glass-border);
  }

  .zoom-controls .tool-btn {
    width: 40px;
    height: 40px;
    min-width: 40px;
    border-radius: var(--radius-full);
    font-size: var(--text-lg);
  }
}

/* ==================== MOBILE TRACK CARDS: SWIPEABLE OVERVIEW ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-track-strip {
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--surface) 95%, transparent),
      color-mix(in oklab, var(--bg-tertiary) 90%, transparent));
    border: 1px solid var(--glass-border);
    box-shadow: var(--shadow-md);
    transition: all var(--duration-base) var(--ease-smooth);
  }

  #tab-multitrack .daw-track-strip.selected {
    border-width: 2px;
    border-color: var(--accent-primary);
    box-shadow:
      var(--shadow-lg),
      0 0 0 3px color-mix(in oklab, var(--accent-primary) 20%, transparent);
    transform: scale(1.02);
  }

  #tab-multitrack .daw-track-strip.recording {
    border-color: var(--error);
    box-shadow:
      var(--shadow-lg),
      0 0 0 3px color-mix(in oklab, var(--error) 25%, transparent);
    animation: cardRecordPulse 1.2s ease-in-out infinite;
  }

  @keyframes cardRecordPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.85; }
  }

  .track-strip-header {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding-bottom: var(--space-2);
    border-bottom: 1px solid var(--glass-border);
  }

  .track-strip-name {
    flex: 1;
    font-size: var(--text-sm);
    font-weight: 800;
    color: var(--text-primary);
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .track-strip-controls {
    display: flex;
    gap: 4px;
  }

  .track-strip-btn {
    width: 36px;
    height: 36px;
    border-radius: var(--radius-sm);
    background: var(--glass-bg);
    border: 1px solid var(--glass-border);
    font-size: var(--text-xs);
    font-weight: 800;
    display: grid;
    place-items: center;
    cursor: pointer;
    transition: all var(--duration-fast) var(--ease-smooth);
  }

  .track-strip-btn:active {
    transform: scale(0.9);
  }

  .track-strip-btn.active {
    background: var(--error);
    color: white;
    border-color: transparent;
    box-shadow: 0 0 12px color-mix(in oklab, var(--error) 40%, transparent);
  }

  .track-strip-btn.solo.active {
    background: var(--warning);
  }

  /* Compact meters */
  .track-strip-meters {
    display: flex;
    gap: 4px;
    height: 32px;
    margin: var(--space-2) 0;
  }

  .track-meter-bar {
    flex: 1;
    background: rgba(0,0,0,.5);
    border-radius: var(--radius-xs);
    border: 1px solid rgba(255,255,255,.06);
  }
}

/* ==================== PHONE PORTRAIT: MINIMAL CHROME, MAXIMUM CONTENT ==================== */

@media (max-width: 768px) {
  #tab-multitrack .daw-wrapper {
    gap: var(--space-3);
  }

  /* Transport: ultra-compact */
  #tab-multitrack .daw-transport-bar {
    padding: var(--space-2) var(--space-3);
    grid-template-columns: 1fr;
    gap: var(--space-2);
  }

  .transport-section {
    justify-content: center;
  }

  .transport-btn {
    width: 52px;
    height: 52px;
    border-radius: var(--radius-full);
    font-size: var(--text-2xl);
    box-shadow: var(--shadow-lg);
  }

  .transport-display {
    padding: var(--space-2) var(--space-3);
    font-size: var(--text-sm);
  }

  /* Track list: tighter cards */
  #tab-multitrack .daw-track-list {
    max-height: 120px;
  }

  #tab-multitrack .daw-track-list-scroll {
    padding: var(--space-3);
    gap: var(--space-2);
  }

  #tab-multitrack .daw-track-strip {
    flex: 0 0 200px;
    min-width: 200px;
    padding: var(--space-2);
  }

  .track-strip-name {
    font-size: var(--text-xs);
  }

  .track-strip-btn {
    width: 32px;
    height: 32px;
    font-size: 10px;
  }

  /* Timeline: hero element with breathing room */
  #tab-multitrack .daw-timeline-container {
    min-height: 380px;
    border-radius: var(--radius-xl);
  }

  #tab-multitrack .daw-timeline-toolbar {
    padding: var(--space-2);
    gap: var(--space-1);
  }

  .tool-btn {
    width: 44px;
    height: 44px;
    min-width: 44px;
    font-size: var(--text-lg);
  }

  .zoom-controls .tool-btn {
    width: 36px;
    height: 36px;
    min-width: 36px;
  }

  /* Ruler: readable but compact */
  #tab-multitrack .daw-ruler {
    height: 40px;
  }

  #tab-multitrack .daw-ruler-label {
    font-size: 10px;
  }

  /* Arrangement: prioritize vertical scroll */
  #tab-multitrack .daw-arrangement-scroll {
    min-height: 280px;
  }

  /* Master strip: hide or ultra-minimal */
  #tab-multitrack .daw-master-strip {
    display: none; /* Access via mixer tab instead */
  }

  /* Inspector: full-screen modal feel */
  #tab-multitrack .daw-inspector {
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  }

  #tab-multitrack .daw-inspector-content {
    padding: var(--space-4);
  }

  .inspector-section {
    padding: var(--space-3);
    margin-bottom: var(--space-3);
  }

  .inspector-param {
    margin-bottom: var(--space-2);
  }
}

/* ==================== MOBILE REGION MANIPULATION: FAT FINGERS WELCOME ==================== */

@media (max-width: 900px) {
  .audio-region {
    height: 72px;
    top: 4px;
    border-width: 2px;
    touch-action: none; /* Prevent scroll interference */
  }

  .region-header {
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    background: rgba(0,0,0,.95);
    -webkit-backdrop-filter: blur(20px);
    backdrop-filter: blur(20px);
  }

  .region-name {
    font-size: var(--text-sm);
    font-weight: 800;
  }

  .region-action-btn {
    width: 40px;
    height: 40px;
    min-width: 40px;
    min-height: 40px;
    border-radius: var(--radius-full);
    font-size: var(--text-base);
    background: rgba(255,255,255,.15);
    -webkit-backdrop-filter: blur(8px);
    backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0,0,0,.4);
  }

  .region-action-btn:active {
    transform: scale(0.88);
    box-shadow: 0 1px 4px rgba(0,0,0,.5);
  }

  /* Resize handles: bigger hit targets */
  .clip-resize-handle {
    width: 20px;
    background: linear-gradient(90deg,
      transparent,
      rgba(255,255,255,.1),
      transparent);
  }

  .clip-resize-handle.left {
    left: -10px;
  }

  .clip-resize-handle.right {
    right: -10px;
  }

  .clip-resize-handle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px;
    height: 24px;
    border-radius: 2px;
    background: rgba(255,255,255,.3);
    box-shadow: 0 0 8px rgba(0,0,0,.5);
  }
}

/* ==================== MOBILE FX CHAIN: SLIDE-UP PANEL ==================== */

@media (max-width: 900px) {
  .fx-chain-panel {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    top: auto;
    max-height: 70vh;
    border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
    border-bottom: none;
    box-shadow: 0 -16px 48px rgba(0,0,0,.75);
    background: var(--surface-elevated);
    backdrop-filter: blur(32px) saturate(150%);
    z-index: 9700;
    transform: translateY(100%);
    transition: transform var(--duration-slow) cubic-bezier(0.32, 0.72, 0, 1);
  }

  .fx-chain-panel.open {
    transform: translateY(0);
  }

  /* Pull indicator */
  .fx-chain-panel::before {
    content: '';
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 48px;
    height: 5px;
    border-radius: 999px;
    background: var(--text-muted);
    opacity: 0.5;
  }

  .fx-chain-header {
    padding: var(--space-5) var(--space-4) var(--space-4);
    border-bottom: 1px solid var(--glass-border);
  }

  .fx-chain-body {
    padding: var(--space-4);
    max-height: calc(70vh - 80px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .fx-add-menu {
    position: relative;
    top: auto;
    right: auto;
    margin-top: var(--space-3);
    max-height: none;
    border: 1px solid var(--glass-border);
  }

  .fx-pill {
    padding: var(--space-2) var(--space-4);
    font-size: var(--text-sm);
    min-height: 44px;
    border-radius: var(--radius-md);
  }
}

/* ==================== MOBILE INSPECTOR: FOCUSED EDITING SURFACE ==================== */

@media (max-width: 900px) {
  #tab-multitrack .daw-inspector-tabs {
    padding: var(--space-3);
    gap: var(--space-2);
    background: linear-gradient(180deg,
      var(--glass-bg-strong),
      var(--glass-bg));
    border-bottom: 2px solid var(--glass-border-strong);
  }

  .inspector-tab {
    flex: 1;
    min-width: 0;
    padding: var(--space-3);
    font-size: var(--text-sm);
    border-radius: var(--radius-md);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .inspector-tab.active {
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    color: var(--bg-primary);
    box-shadow:
      var(--shadow-md),
      var(--glow-sm) color-mix(in oklab, var(--accent-primary) 40%, transparent);
  }

  #tab-multitrack .daw-inspector-content {
    padding: var(--space-4);
    padding-bottom: calc(var(--space-8) + var(--inset-bottom));
  }

  .inspector-section {
    padding: var(--space-4);
    margin-bottom: var(--space-4);
    border-radius: var(--radius-lg);
    background: linear-gradient(135deg,
      color-mix(in oklab, var(--glass-bg) 90%, transparent),
      var(--glass-bg));
    border: 1px solid var(--glass-border);
  }

  .inspector-section-title {
    font-size: var(--text-sm);
    margin-bottom: var(--space-3);
    padding-bottom: var(--space-2);
    border-bottom: 2px solid var(--glass-border-strong);
  }

  .inspector-param {
    margin-bottom: var(--space-3);
  }

  .inspector-param-label {
    margin-bottom: var(--space-2);
    font-size: var(--text-sm);
  }

  .inspector-param input[type="range"] {
    height: 14px;
  }

  .inspector-param input[type="range"]::-webkit-slider-thumb {
    width: 24px;
    height: 24px;
  }

  .inspector-param select,
  .inspector-param input[type="text"],
  .inspector-param input[type="number"] {
    padding: var(--space-3);
    font-size: var(--text-base);
    border-radius: var(--radius-md);
    min-height: 48px;
  }
}

/* ==================== MOBILE FAB: QUICK ACCESS HUB ==================== */

@media (max-width: 900px) {
  .daw-fab {
    position: fixed;
    bottom: calc(var(--space-5) + var(--inset-bottom));
    left: 50%;
    transform: translateX(-50%);
    width: 64px;
    height: 64px;
    border-radius: var(--radius-full);
    background: linear-gradient(135deg,
      var(--accent-primary),
      var(--accent-secondary));
    color: var(--bg-primary);
    font-size: var(--text-3xl);
    font-weight: 300;
    border: none;
    box-shadow:
      var(--shadow-2xl),
      var(--glow-lg) color-mix(in oklab, var(--accent-primary) 45%, transparent);
    z-index: 9001;
    cursor: pointer;
    display: grid;
    place-items: center;
    transition: all var(--duration-base) cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .daw-fab:active {
    transform: translateX(-50%) scale(0.88);
  }

  .daw-fab.open {
    transform: translateX(-50%) rotate(135deg);
    background: linear-gradient(135deg,
      var(--error),
      color-mix(in oklab, var(--error) 80%, #ff6b6b));
  }

  .daw-fab::before {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: inherit;
    background: inherit;
    opacity: 0.3;
    filter: blur(12px);
    animation: fabPulse 2s ease-in-out infinite;
    z-index: -1;
  }

  @keyframes fabPulse {
    0%, 100% { transform: scale(1); opacity: 0.3; }
    50% { transform: scale(1.15); opacity: 0.5; }
  }

  .daw-fab-backdrop {
    position: fixed;
    inset: 0;
    background: transparent;
    backdrop-filter: none;
    z-index: 8900;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--duration-base) var(--ease-smooth),
                visibility 0s var(--duration-base);
    pointer-events: none;
  }

  .daw-fab-backdrop.open {
    opacity: 1;
    visibility: visible;
    transition: opacity var(--duration-base) var(--ease-smooth),
                visibility 0s 0s;
    pointer-events: auto;
  }

  .daw-fab,
  .daw-fab-menu {
    position: fixed;
    isolation: isolate;
    z-index: 10000;
  }

  .daw-fab-backdrop {
    z-index: 9500;
  }

  .daw-fab-menu {
    position: fixed;
    bottom: calc(var(--space-5) + var(--inset-bottom) + 32px);
    left: 50%;
    transform: translateX(-50%);
    z-index: 9002;
    pointer-events: none;
  }

  .daw-fab-menu.open {
    pointer-events: auto;
  }

  .daw-fab-menu-item {
    position: absolute;
    width: 56px;
    height: 56px;
    border-radius: var(--radius-full);
    background: var(--surface-elevated);
    border: 1px solid var(--glass-border-strong);
    color: var(--text-primary);
    font-size: var(--text-2xl);
    box-shadow: var(--shadow-lg);
    display: grid;
    place-items: center;
    cursor: pointer;
    opacity: 0;
    transform: scale(0);
    transform-origin: center center; /* ADD THIS */
    transition: all var(--duration-base) cubic-bezier(0.68, -0.55, 0.265, 1.55);
    backdrop-filter: none;
  }

  /* === Smooth, symmetric half-circle above FAB === */
  .daw-fab-menu.open .daw-fab-menu-item {
    opacity: 1;
  }
  
  /* Clean, symmetric semi-circle above the centered FAB */
  .daw-fab-menu.open .daw-fab-menu-item:nth-child(1) {
    transform: translate(-95px, -60px) scale(1);
    transition-delay: 50ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(2) {
    transform: translate(-55px, -110px) scale(1);
    transition-delay: 100ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(3) {
    transform: translate(0px, -140px) scale(1);
    transition-delay: 150ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(4) {
    transform: translate(55px, -110px) scale(1);
    transition-delay: 200ms;
  }

  .daw-fab-menu.open .daw-fab-menu-item:nth-child(5) {
    transform: translate(95px, -60px) scale(1);
    transition-delay: 250ms;
  }

  .daw-fab-menu-item:active {
    transform: scale(0.9);
    box-shadow: var(--shadow-sm);
  }

  .daw-inspector {
    position: fixed;
    left: 0;
    right: 0;
    bottom: -60vh;
    max-height: 60vh;
    z-index: 9800;
    transition: bottom var(--duration-base) var(--ease-smooth);
  }

  .daw-inspector.inspector-open {
    bottom: 0;
  }
}

@media (min-width: 901px) {
  .daw-fab,
  .daw-fab-menu,
  .daw-fab-backdrop {
    display: none;
  }
}
    
/* === MOBILE: COMPLETELY HIDE MULTITRACK INSPECTOR === */
@media (max-width: 900px) {
  #tab-multitrack .daw-inspector,
  .daw-inspector {
    display: none !important;
  }
}

/* === Mobile keyboard safety mode for inspector === */
@media (max-width: 900px) {
  #tab-multitrack .daw-inspector.inspector-keyboard-open {
    position: static !important;
    transform: none !important;
    max-height: none;
    top: auto;
    bottom: auto;
    margin: 0;
    border-radius: 0;
    box-shadow: none;
    z-index: auto;
  }
}

/* =========================================================
   MULTITRACK LAYOUT FIXES
   - Make track header controls fully accessible
   - Keep bottom panels/menus sitting above footer
========================================================= */

/* 1) Let the track list breathe on tablet/mobile
   (removes the harsh 200px cap so the header buttons aren't cramped) */
@media (max-width: 1024px) {
  #tab-multitrack .daw-track-list {
    /* Still feels like a column, but not overly constrained */
    min-height: 60vh;
    max-height: none;
  }

  #tab-multitrack .daw-track-list-scroll {
    max-height: none;   /* overrides the old 200px cap */
    min-height: 0;
  }
}

/* 2) Make sure "opening" UI (FX panel, menus, etc.) sits above the footer */

.modal-backdrop,
.region-context-menu,
#fxChainPanel,
.daw-fab-menu,
.toast-container {
  z-index: 11000; /* safely above main app content + footer */
}

/* 3) Nudge the FX chain panel up slightly so it feels "above" the footer,
   not like itâ€™s glued directly to the very bottom */
#fxChainPanel {
  bottom: calc(var(--space-4) + var(--inset-bottom));
}

/* (Optional but nice) â€“ if you ever want the region context menu
   to never collide with the footer visually, you can give it a small
   bottom margin via JS or here as a visual hint: */

.region-context-menu {
  /* keep existing styles, just ensure we never visually hug the bottom */
  max-height: calc(100vh - 64px);
}

/* ==================== SONG BUILDER TAB: PREMIUM STYLING ==================== */

#tab-songbuilder {
  /* Special hero gradient background */
  background: 
    radial-gradient(ellipse 800px 600px at 20% 10%, 
      color-mix(in oklab, var(--accent-primary) 18%, transparent), 
      transparent 60%),
    radial-gradient(ellipse 700px 500px at 80% 90%, 
      color-mix(in oklab, var(--accent-secondary) 15%, transparent), 
      transparent 60%),
    linear-gradient(135deg, 
      var(--bg-secondary) 0%, 
      var(--bg-primary) 50%, 
      var(--bg-tertiary) 100%);
  border-radius: var(--radius-2xl);
  padding: var(--space-6);
  position: relative;
  overflow: hidden;
}

#tab-songbuilder::before {
  content: '';
  position: absolute;
  inset: -100%;
  background: 
    radial-gradient(circle at 30% 40%, 
      color-mix(in oklab, var(--accent-tertiary) 12%, transparent), 
      transparent 50%),
    radial-gradient(circle at 70% 60%, 
      color-mix(in oklab, var(--accent-secondary) 10%, transparent), 
      transparent 50%);
  animation: songBuilderAmbient 12s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes songBuilderAmbient {
  0%, 100% { transform: rotate(0deg) scale(1); opacity: 0.5; }
  50% { transform: rotate(10deg) scale(1.15); opacity: 0.3; }
}

#tab-songbuilder > * {
  position: relative;
  z-index: 1;
}

/* Main panel styling */
#tab-songbuilder .panel {
  background: var(--surface-elevated);
  border: 1px solid var(--glass-border-strong);
  border-radius: var(--radius-xl);
  padding: var(--space-6);
  box-shadow: 
    var(--shadow-xl),
    inset 0 1px 0 rgba(255,255,255,.08),
    inset 0 -1px 0 rgba(0,0,0,.15);
  backdrop-filter: blur(24px) saturate(150%);
  transition: all var(--duration-base) var(--ease-smooth);
  position: relative;
  overflow: hidden;
}

#tab-songbuilder .panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    var(--accent-primary), 
    var(--accent-secondary), 
    var(--accent-tertiary));
  opacity: 0;
  transition: opacity var(--duration-base) var(--ease-smooth);
}

#tab-songbuilder .panel:hover::before {
  opacity: 1;
  box-shadow: var(--glow-md) color-mix(in oklab, var(--accent-primary) 35%, transparent);
}

#tab-songbuilder .panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 35%, var(--glass-border-strong));
  box-shadow: 
    var(--shadow-2xl),
    var(--glow-sm) color-mix(in oklab, var(--accent-primary) 20%, transparent),
    inset 0 1px 0 rgba(255,255,255,.12);
  transform: translateY(-2px);
}

/* Nested panels (steps 1-4) */
#tab-songbuilder .panel .panel {
  background: 
    linear-gradient(135deg, 
      color-mix(in oklab, var(--glass-bg-strong) 95%, transparent),
      color-mix(in oklab, var(--glass-bg) 90%, transparent));
  border: 1px solid var(--glass-border);
  padding: var(--space-5);
  box-shadow: var(--shadow-md);
}

#tab-songbuilder .panel .panel:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 25%, var(--glass-border));
  transform: translateY(-1px);
}

/* Panel header with badge */
#tab-songbuilder .panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-5);
  padding-bottom: var(--space-4);
  border-bottom: 2px solid var(--glass-border-strong);
  gap: var(--space-4);
  flex-wrap: wrap;
}

#tab-songbuilder .panel-title {
  font-size: var(--text-2xl);
  font-weight: 900;
  color: var(--text-primary);
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, 
    var(--text-primary), 
    var(--accent-primary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

#tab-songbuilder .panel-subtitle {
  font-size: var(--text-sm);
  color: var(--text-tertiary);
  font-weight: 500;
  line-height: 1.6;
  margin-top: var(--space-1);
}

#tab-songbuilder .badge-ghost {
  background: var(--glass-bg-strong);
  color: var(--text-secondary);
  border: 1px solid var(--glass-border-strong);
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  font-size: var(--text-xs);
  font-weight: 800;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  box-shadow: var(--shadow-sm);
}

/* Step headers */
#tab-songbuilder .panel .panel > div:first-child {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-4);
  gap: var(--space-3);
}

#tab-songbuilder .panel .panel > div:first-child > div:first-child > div:first-child {
  font-size: var(--text-lg);
  font-weight: 800;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

#tab-songbuilder .panel .panel > div:first-child > div:first-child > div:first-child::before {
  content: '';
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  box-shadow: 0 0 12px color-mix(in oklab, var(--accent-primary) 50%, transparent);
}

/* Template selector styling */
#songTemplateSelect {
  width: 100%;
  max-width: 280px;
  padding: var(--space-3) var(--space-4);
  border-radius: var(--radius-md);
  background: var(--glass-bg-strong);
  border: 1px solid var(--glass-border-strong);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 700;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: var(--shadow-sm);
}

#songTemplateSelect:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 40%, var(--glass-border-strong));
  background: var(--surface);
  box-shadow: var(--shadow-md);
}

#songTemplateSelect:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 
    var(--shadow-md),
    0 0 0 3px color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

/* Sections table styling */
#tab-songbuilder table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  font-size: var(--text-sm);
  background: var(--glass-bg);
  border-radius: var(--radius-md);
  overflow: hidden;
  box-shadow: var(--shadow-inner);
}

#tab-songbuilder thead {
  background: linear-gradient(135deg, 
    color-mix(in oklab, var(--accent-primary) 15%, var(--glass-bg-strong)),
    var(--glass-bg-strong));
}

#tab-songbuilder thead tr {
  border-bottom: 2px solid var(--glass-border-strong);
}

#tab-songbuilder th {
  padding: var(--space-3) var(--space-4);
  text-align: left;
  font-weight: 800;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: var(--text-xs);
}

#tab-songbuilder tbody tr {
  transition: all var(--duration-fast) var(--ease-smooth);
  border-bottom: 1px solid var(--glass-border);
}

#tab-songbuilder tbody tr:last-child {
  border-bottom: none;
}

#tab-songbuilder tbody tr:hover {
  background: color-mix(in oklab, var(--accent-primary) 8%, transparent);
}

#tab-songbuilder tbody td {
  padding: var(--space-3) var(--space-4);
  color: var(--text-secondary);
  font-weight: 600;
}

/* Scroll container for table */
#tab-songbuilder .scroll-x {
  overflow-x: auto;
  margin: 0 calc(-1 * var(--space-1));
  padding: 0 var(--space-1);
  scrollbar-width: thin;
}

/* Fill select styling */
#songFillEverySelect {
  width: 100%;
  max-width: 160px;
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-sm);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: var(--text-sm);
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
}

#songFillEverySelect:hover {
  border-color: color-mix(in oklab, var(--accent-primary) 30%, var(--glass-border));
  background: var(--glass-bg-strong);
}

#songFillEverySelect:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent-primary) 20%, transparent);
}

/* Total bars label */
#songTotalBarsLabel {
  font-family: var(--font-mono);
  font-weight: 800;
  color: var(--accent-primary);
  font-size: var(--text-base);
  padding: var(--space-1) var(--space-3);
  background: color-mix(in oklab, var(--accent-primary) 12%, transparent);
  border-radius: var(--radius-sm);
  display: inline-block;
  box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--accent-primary) 30%, transparent);
}

/* Build button - HERO TREATMENT */
#songBuildBtn {
  padding: var(--space-4) var(--space-6);
  border-radius: var(--radius-lg);
  background: linear-gradient(135deg, 
    var(--accent-primary), 
    var(--accent-secondary),
    var(--accent-tertiary));
  color: var(--bg-primary);
  font-family: var(--font-sans);
  font-weight: 900;
  font-size: var(--text-base);
  letter-spacing: 0.02em;
  border: none;
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-bounce);
  box-shadow: 
    var(--shadow-xl),
    var(--glow-md) color-mix(in oklab, var(--accent-primary) 45%, transparent),
    inset 0 1px 0 rgba(255,255,255,.25);
  position: relative;
  overflow: hidden;
  animation: songBuildPulse 3s ease-in-out infinite;
}

@keyframes songBuildPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

#songBuildBtn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, 
    transparent 30%, 
    rgba(255,255,255,.3) 50%, 
    transparent 70%);
  transform: translateX(-100%);
  transition: transform var(--duration-slower) var(--ease-smooth);
}

#songBuildBtn:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: 
    var(--shadow-2xl),
    var(--glow-lg) color-mix(in oklab, var(--accent-primary) 55%, transparent),
    inset 0 1px 0 rgba(255,255,255,.35);
}

#songBuildBtn:hover::before {
  transform: translateX(100%);
}

#songBuildBtn:active {
  transform: translateY(-1px) scale(0.98);
}

/* Send to Multitrack button */
#songBuilderToMultitrackBtn {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-md);
  background: linear-gradient(135deg, 
    var(--success), 
    color-mix(in oklab, var(--success) 75%, #5eead4));
  color: #042f2e;
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: var(--text-sm);
  border: none;
  cursor: pointer;
  transition: all var(--duration-base) var(--ease-smooth);
  box-shadow: 
    var(--shadow-md),
    0 0 20px color-mix(in oklab, var(--success) 35%, transparent);
}

#songBuilderToMultitrackBtn:hover {
  transform: translateY(-2px);
  box-shadow: 
    var(--shadow-lg),
    0 0 30px color-mix(in oklab, var(--success) 45%, transparent);
}

#songBuilderToMultitrackBtn:active {
  transform: translateY(0);
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  #tab-songbuilder {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel-title {
    font-size: var(--text-xl);
  }
}

@media (max-width: 768px) {
  #tab-songbuilder {
    padding: var(--space-3);
  }

  #tab-songbuilder .panel {
    padding: var(--space-4);
  }

  #tab-songbuilder .panel .panel {
    padding: var(--space-3);
  }

  #tab-songbuilder .panel-header {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--space-2);
  }

  #tab-songbuilder .panel-title {
    font-size: var(--text-lg);
  }

  #tab-songbuilder table {
    font-size: var(--text-xs);
  }

  #tab-songbuilder th,
  #tab-songbuilder td {
    padding: var(--space-2) var(--space-3);
  }

  #songBuildBtn {
    width: 100%;
    padding: var(--space-3) var(--space-5);
  }

  #songBuilderToMultitrackBtn {
    width: 100%;
  }
}

/* ==================== MOBILE CENTERING FIXES ==================== */

@media (max-width: 768px) {
  /* Center all button containers */
  .transport-controls,
  .header-actions,
  .panel-header,
  .modal-footer,
  .fx-chain-header,
  .toolbar-group {
    justify-content: center !important;
    text-align: center;
  }
  
  /* Center visualizer overlay text */
  .viz-overlay {
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  /* Center genre selector buttons */
  .genre-selector {
    justify-content: center !important;
  }
  
  /* Center any button groups */
  .flex,
  .flex-col {
    justify-content: center;
    align-items: center;
  }
  
  /* Center track controls */
  .track-strip-controls,
  .track-controls-grid,
  .channel-btns {
    justify-content: center;
  }
  
  /* Center panel action buttons */
  .panel-header > div:last-child {
    margin-left: auto;
    margin-right: auto;
  }
  
  /* Center inspector tabs */
  .daw-inspector-tabs {
    justify-content: center;
  }
  
  /* Center song builder buttons */
  #tab-songbuilder .panel-header {
    justify-content: center;
    text-align: center;
  }
}

/* ============================
   HEADER BALANCE FIX (No Genre Buttons)
   ============================ */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-2) var(--space-3);
  gap: var(--space-2);
}

/* Center logo + transport nicely when middle (genre) section is gone */
@media (max-width: 900px) {
  header {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  header .logo-section {
    justify-content: center;
    margin-bottom: var(--space-2);
  }

  header .header-actions,
  .transport-controls {
    justify-content: center !important;
  }
}

:root{
  --simple-bg:#0b0d11; --simple-surface:#121620; --simple-line:#1c2230;
  --simple-text:#e8ecf3; --simple-sub:#9aa3b2; --simple-accent:#6cf;
  --simple-r:14px; --simple-pad:14px; --simple-gap:12px;
}
body.simple-ui{background:var(--simple-bg); color:var(--simple-text)}
body.simple-ui .sidebar-nav,
body.simple-ui .sidebar-toggle,
body.simple-ui .sidebar-backdrop,
body.simple-ui header .header-actions,
body.simple-ui .footer,
body.simple-ui .transport{ display:none !important; }
body.simple-ui header{
  position:sticky; top:0; z-index:50;
  backdrop-filter:blur(8px) saturate(140%);
  background:rgba(10,14,20,.6); border-bottom:1px solid var(--simple-line);
}
#simpleShell{ max-width:1200px; margin:0 auto; padding:var(--simple-pad) var(--simple-pad) 24px }
.simple-hero{ display:grid; grid-template-columns:1fr; gap:20px; margin:18px 0 10px }
.simple-hero .card{ background:var(--simple-surface); border:1px solid var(--simple-line); border-radius:var(--simple-r); padding:18px }
.simple-hero h1{ margin:0 0 6px; font-size:20px }
.simple-hero p{ margin:0; color:var(--simple-sub); font-size:14px }
.simple-transport{ 
  background:var(--simple-surface); 
  border:1px solid var(--simple-line); 
  border-radius:var(--simple-r); 
  padding:16px;
  display:grid;
  grid-template-columns: auto 1fr auto;
  gap:20px;
  align-items:center;
}
.simple-transport-controls{ display:flex; gap:8px; align-items:center }
.simple-transport-progress{ display:flex; flex-direction:column; gap:6px; min-width:200px }
.simple-transport-time{ font-size:14px; font-weight:600; color:var(--simple-text) }
.simple-progress-bar{ 
  width:100%; 
  height:6px; 
  background:rgba(255,255,255,0.1); 
  border-radius:3px; 
  overflow:hidden;
  position:relative;
  flex: 1 1 auto;
  min-width: 0;       /* âœ… prevents overflow */
  overflow: hidden;   /* âœ… hides any tiny spill */
}
.simple-progress-fill{ 
  height:100%; 
  background:var(--simple-accent); 
  border-radius:3px; 
  transition:width 0.1s linear;
}
.simple-transport-params{ display:flex; gap:16px; align-items:center }
.simple-param{ display:flex; flex-direction:column; gap:4px }
.simple-param-label{ font-size:11px; color:var(--simple-sub); text-transform:uppercase; letter-spacing:0.05em }
.simple-param input[type="number"]{ 
  width:70px; 
  padding:6px 8px; 
  background:#0e131c; 
  border:1px solid var(--simple-line); 
  border-radius:8px; 
  color:var(--simple-text);
  font-size:14px;
  font-weight:600;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  min-width: 0;        /* âœ… allows proper shrink */
  width: 100%;         /* âœ… keeps inside container */
  box-sizing: border-box;
}
.simple-param input[type="range"]{ 
  height:6px;
  width: 100%;
  max-width: 100%;     /* âœ… sliders stay inside */
  box-sizing: border-box;
}
.simple-steps{ display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:var(--simple-gap); margin:14px 0 18px }
.simple-step{ background:var(--simple-surface); border:1px solid var(--simple-line); border-radius:var(--simple-r); padding:12px; cursor:pointer; display:flex; flex-direction:column; gap:4px; transition:all .2s; text-align:center; position:relative }
.simple-step .icon{ font-size:24px; margin-bottom:4px }
.simple-step .title{ font-weight:800; font-size:13px }
.simple-step .desc{ color:var(--simple-sub); font-size:11px; line-height:1.3 }
.simple-step.active{ outline:2px solid var(--simple-accent); background:rgba(102,204,255,.08) }
.simple-step:hover{ background:rgba(102,204,255,.05); transform:translateY(-1px) }
.simple-step.locked{ opacity:0.5; cursor:not-allowed }
.simple-step.locked::after{ content:'ðŸ”’'; position:absolute; top:8px; right:8px; font-size:12px }
.simple-main{ background:var(--simple-surface); border:1px solid var(--simple-line); border-radius:var(--simple-r); overflow:hidden }
.simple-content{ padding:0; min-height:400px }
.simple-note{ padding:10px 12px; color:var(--simple-sub); border-top:1px dashed var(--simple-line); font-size:13px; line-height:1.5 }
body.simple-ui .section{ display:none !important; }
body.simple-ui .section.simple-mounted{ display:block !important; border:none; background:transparent; box-shadow:none; border-radius:0; padding:12px }
@media (max-width: 900px){
  .simple-transport{ grid-template-columns:1fr; gap:12px }
  .simple-steps{ grid-template-columns: repeat(2, minmax(0, 1fr)) }
}

  </style>
</head>
<body>
  
  <div id="splashOverlay">
    <div class="splash-inner">
      <div class="splash-logo">8-Beat Studio</div>
      <div class="splash-message" id="splashMessage">
        Initializing engineâ€¦
      </div>
      <div class="splash-progress">
        <div class="splash-progress-bar" id="splashBar"></div>
      </div>
      <div class="splash-sub">
        This should only take a moment âœ¨
      </div>
    </div>
  </div>
  <!-- Sidebar Toggle Button -->
  <button class="sidebar-toggle" id="sidebarToggle" aria-label="Menu">
    ðŸ§­
  </button>
  
  <!-- Sidebar Backdrop -->
  <div class="sidebar-backdrop" id="sidebarBackdrop"></div>
  
  <!-- Sidebar Navigation -->
  <nav class="sidebar-nav" id="sidebarNav">
    <div class="sidebar-section">
      <div class="sidebar-section-title">...</div>
      <div class="sidebar-tabs" id="sidebarTabs">
        <button class="sidebar-tab active" data-tab="generate">ðŸŽ² Generate</button>
        <button class="sidebar-tab" data-tab="sequencer">ðŸŽ¹ Sequencer</button>
        <button class="sidebar-tab" data-tab="mixer">ðŸŽšï¸ Mixer</button>
        <button class="sidebar-tab" data-tab="fx">ðŸŽ›ï¸ Effects</button>
        <button class="sidebar-tab" data-tab="harmony">ðŸŽ¼ Harmony</button>
        <button class="sidebar-tab" data-tab="songbuilder">ðŸ§± Song Builder</button>
        <button class="sidebar-tab" data-tab="multitrack">ðŸŽ™ï¸ Multitrack</button>
        <button class="sidebar-tab" data-tab="samples">ðŸ“‚ Samples</button>
        <button id="unlockProBtn">ðŸ”“ Unlock Pro</button>

        <div id="unlockModal" class="hidden">
          <div class="pro-modal-inner">
            <h2>ðŸ”“ Unlock 8-Beat Studio Pro</h2>
            <p>Paste your license key to unlock all features.</p>
            <input id="licenseInput" type="text" inputmode="text" placeholder="8BEAT-XXXX-XXXX-XXXX">
            <div class="modal-actions">
              <div>
                <style>.pp-58FUHY8RYFPP2{text-align:center;border:none;border-radius:0.25rem;min-width:11.625rem;padding:0 2rem;height:2.625rem;font-weight:bold;background-color:#FFD140;color:#000000;font-family:"Helvetica Neue",Arial,sans-serif;font-size:1rem;line-height:1.25rem;cursor:pointer;}</style>
                <form action="https://www.paypal.com/ncp/payment/58FUHY8RYFPP2" method="post" target="_blank" style="display:inline-grid;justify-items:center;align-content:start;gap:0.5rem;">
                  <input class="pp-58FUHY8RYFPP2" type="submit" value="Buy Now" />
                  <img src=https://www.paypalobjects.com/images/Debit_Credit_APM.svg alt="cards" />
                  <section style="font-size: 0.75rem;"> Powered by <img src="https://www.paypalobjects.com/paypal-ui/logos/svg/paypal-wordmark-color.svg" alt="paypal" style="height:0.875rem;vertical-align:middle;"/></section>
                </form>
              </div>
              <button id="confirmLicenseBtn" class="btn btn-primary">Confirm</button>
              <button id="cancelLicenseBtn" class="btn btn-secondary">Cancel</button>
            </div>
            <p id="licenseStatus" class="status"></p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="sidebar-section">
      <div class="sidebar-section-title">ðŸŽ¨ Genre Presets</div>
      <div class="sidebar-presets" id="sidebarPresets">
        <!-- Presets will be rendered here by JS -->
      </div>
    </div>
    <div style="margin-top: auto; padding: 1rem; font-size: 0.7rem; color: #6b7199; text-align: center; line-height: 1.4;">
      Â© 2025 8-Beat Studio. All Rights Reserved.<br>
      Unauthorized copying, distribution, or modification is prohibited.
    </div>
  </nav>
  <div class="app">
    <header>
      <div class="logo-section">
        <div class="logo">ðŸŽ¹</div>
        <div>
          <h1>8-Beat Studio</h1>
          <div class="tagline">Fun With Noise</div>
        </div>
      </div>
           
      <div class="header-actions">
        <button class="btn btn-secondary btn-sm" id="installBtn" hidden>ðŸ“± Install</button>
        <button class="btn btn-secondary btn-sm" id="vibeBtn">ðŸŒˆ Vibe: Moon</button>
      </div>
    </header>
    
    <div class="transport">
      <div class="transport-controls">
        <button class="btn btn-primary" id="playBtn">â–¶ï¸ Play</button>
        <button class="btn btn-secondary" id="stopBtn">â¹ï¸ Stop</button>
        <button class="btn btn-secondary" id="exportBtn">ðŸŽ§ DJ (Live Export)</button>
      </div>
      
      <div class="progress-area">
        <div class="time-info">
          <span class="time-display" id="timeDisplay">00:00</span>
          <span id="durationDisplay">/ 05:00</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      
      <div class="transport-params">
        <div class="param-control">
          <div class="param-label">
            <span>BPM</span>
            <span class="param-value" id="bpmValue">120</span>
          </div>
          <input type="range" id="bpmSlider" min="60" max="200" value="120">
        </div>
        <div class="param-control">
          <div class="param-label">
            <span>Swing</span>
            <span class="param-value" id="swingValue">0%</span>
          </div>
          <input type="range" id="swingSlider" min="0" max="100" value="0">
        </div>
      </div>
      <div class="flex" style="gap: var(--space-2);">
        <button class="btn btn-secondary btn-sm" id="metronomeBtn">
          ðŸ¥ Click: Off
        </button>
        <button class="btn btn-secondary btn-sm" id="countInBtn">
          â±ï¸ Count: 1 bar
        </button>
        <!-- Add to header-actions or sidebar -->
        <button class="btn btn-secondary btn-sm" id="switchToSimpleBtn">ðŸ“± Simple Mode</button>
      </div>
    </div>
    
    <section class="section active" id="tab-generate">
      <div class="panel">
        <div class="visualizer" id="visualizer">
          <div class="viz-overlay" id="vizOverlay">Generate & Press Play</div>
        </div>
      </div>
      
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">âš™ï¸ Project Settings</div>
          </div>
          
          <div class="grid grid-3 mb-3">
            <div class="param-control">
              <div class="param-label">
                <span>Duration</span>
                <span class="param-value" id="durValue">5 min</span>
              </div>
              <input type="range" id="durSlider" min="1" max="20" value="5">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Complexity</span>
                <span class="param-value" id="complexValue">Medium</span>
              </div>
              <input type="range" id="complexSlider" min="1" max="3" value="2">
            </div>
            <div class="param-control">
              <div class="param-label">
                <span>Humanize</span>
                <span class="param-value" id="humanValue">10ms</span>
              </div>
              <input type="range" id="humanSlider" min="0" max="30" value="10">
            </div>           
          </div>
          
          
          <div class="flex">
            <button class="btn btn-primary" id="generateBtn">ðŸŽ² Generate Beat</button>
            <button id="generateSongBtn" class="btn btn-primary btn-sm">ðŸŽµ Generate Song!</button>
            <button class="btn btn-primary" id="generateRhythmBtn">ðŸ¥ Generate Rhythm</button>
            <button class="btn btn-secondary" id="randomVelBtn">ðŸŽ¯ Random Velocity</button>
            <button class="btn btn-secondary" id="randomProbBtn">ðŸŽ² Random Prob</button>
            <button class="btn btn-ghost" id="clearBtn">ðŸ§¹ Clear</button>
          </div>
          
          <!-- NEW: AI Generation Section -->
          <div class="panel-header" style="margin-top: var(--space-6);">
            <div class="panel-title">ðŸ¤– AI Beat Generator</div>
          </div>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); margin-bottom: var(--space-3);">
            <div style="font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6;">
              AI analyzes your current pattern and creates intelligent variations using music theory and production techniques.
            </div>
          </div>
          
          <div class="flex">
            <button class="btn btn-primary" id="aiVariationBtn">
              ðŸ¤– AI Drum Variation
            </button>
            <button class="btn btn-primary" id="aiMelodicBtn">
              ðŸŽ¹ AI Melodic Variation
            </button>
          </div>
          
          <div class="panel-header" style="margin-top: var(--space-4);">
            <div class="panel-title">Groove Templates</div>
          </div>
          
          <div class="grid grid-4">
            <button class="preset groove-template-btn" data-template="shuffle">
              <div class="preset-icon">ðŸŽµ</div>
              <div class="preset-name">Shuffle</div>
            </button>
            <button class="preset groove-template-btn" data-template="halfTime">
              <div class="preset-icon">ðŸŒ</div>
              <div class="preset-name">Half-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="doubleTime">
              <div class="preset-icon">âš¡</div>
              <div class="preset-name">Double-Time</div>
            </button>
            <button class="preset groove-template-btn" data-template="breakbeat">
              <div class="preset-icon">ðŸ’¥</div>
              <div class="preset-name">Breakbeat</div>
            </button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸ’¾ Projects</div>
          </div>
          
          <div class="flex-col">
            <div class="flex">
              <button class="btn btn-success" id="saveBtn">ðŸ’¾ Save Project</button>
              <button class="btn btn-secondary" id="loadBtn">ðŸ“‚ Load Project</button>
            </div>
            <div class="flex">
              <input type="text" id="projectName" placeholder="Project Name" 
                style="flex:1; padding:10px; background:var(--glass-bg); border:1px solid var(--glass-border); border-radius:var(--radius-sm); color:var(--text-primary); font-family:inherit">
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <section class="section" id="tab-sequencer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ¹ Pattern Sequencer</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="lenDecBtn">âˆ’ Length</button>
            <button class="btn btn-secondary btn-sm" id="lenIncBtn">+ Length</button>
            <select id="resSelect">
              <option value="16n" selected>1/16</option>
              <option value="8n">1/8</option>
              <option value="32n">1/32</option>
            </select>
            <button class="btn btn-secondary btn-sm" id="euclidBtn">âˆ· Euclidean</button>
            <button class="btn btn-secondary btn-sm" id="ghostBtn">ðŸ‘» Ghost Notes</button>
          </div>
        </div>
        
        <div class="sequencer">
          <div class="seq-grid" id="seqGrid"></div>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-mixer">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽšï¸ Channel Mixer</div>
        </div>
        <div class="grid grid-4" id="mixerGrid"></div>
      </div>
      
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ›ï¸ Master Bus</div>
        </div>
        
        <div class="grid grid-3">
          <div class="param-control">
            <div class="param-label">
              <span>Master Volume</span>
              <span class="param-value" id="masterVolValue">0dB</span>
            </div>
            <input type="range" id="masterVolSlider" min="-40" max="10" value="-6">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Tape Saturation</span>
              <span class="param-value" id="tapeValue">25%</span>
            </div>
            <input type="range" id="tapeSlider" min="0" max="100" value="25">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Vinyl Noise</span>
              <span class="param-value" id="vinylValue">15%</span>
            </div>
            <input type="range" id="vinylSlider" min="0" max="100" value="15">
          </div>
        </div>
        
        <div class="grid grid-3 mt-3">
          <div class="param-control">
            <div class="param-label">
              <span>Low Cut</span>
              <span class="param-value" id="lowCutValue">30Hz</span>
            </div>
            <input type="range" id="lowCutSlider" min="20" max="200" value="30">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>High Cut</span>
              <span class="param-value" id="highCutValue">16kHz</span>
            </div>
            <input type="range" id="highCutSlider" min="4000" max="20000" value="16000">
          </div>
          <div class="param-control">
            <div class="param-label">
              <span>Compressor</span>
              <span class="param-value" id="compValue">-18dB</span>
            </div>
            <input type="range" id="compSlider" min="-40" max="0" value="-18">
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸ¤– AI Mixing & Mastering</div>
          <button class="btn btn-secondary btn-sm" id="toggleAIMixingBtn">
            <span id="aiMixingStatus">Enable AI</span>
          </button>
        </div>
        
        <div class="grid grid-2" style="margin-bottom: var(--space-4);">
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoGainCheckbox" checked>
            <span style="font-weight: 600;">Auto Gain Staging</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoPanCheckbox" checked>
            <span style="font-weight: 600;">Auto Panning</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoEQCheckbox" checked>
            <span style="font-weight: 600;">Auto EQ</span>
          </label>
          
          <label style="display: flex; align-items: center; gap: var(--space-2); cursor: pointer;">
            <input type="checkbox" id="autoCompCheckbox" checked>
            <span style="font-weight: 600;">Auto Compression</span>
          </label>
        </div>
        
        <button class="btn btn-primary" id="applyAIMixBtn" disabled>
          ðŸŽšï¸ Apply AI Mix
        </button>
        
        <div class="panel-header" style="margin-top: var(--space-6);">
          <div class="panel-title">Mastering Presets</div>
        </div>
        
        <div class="grid grid-4">
          <button class="preset" data-master-preset="gentle">
            <div class="preset-icon">ðŸŒ™</div>
            <div class="preset-name">Gentle</div>
          </button>
          <button class="preset" data-master-preset="modern">
            <div class="preset-icon">ðŸŽ§</div>
            <div class="preset-name">Modern</div>
          </button>
          <button class="preset" data-master-preset="aggressive">
            <div class="preset-icon">ðŸ”¥</div>
            <div class="preset-name">Aggressive</div>
          </button>
          <button class="preset" data-master-preset="lofi">
            <div class="preset-icon">ðŸ“»</div>
            <div class="preset-name">Lo-Fi</div>
          </button>
        </div>
      </div>
    </section>
    
    <section class="section pro-locked" id="tab-fx">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ›ï¸ Effects Rack</div>
        </div>
        <div class="grid grid-3" id="fxGrid"></div>
      </div>
    </section>
    
    <section class="section" id="tab-harmony">
      <div class="grid grid-2">
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸŽ¼ Key & Scale</div>
          </div>
          
          <div class="flex mb-3">
            <label style="display:flex; align-items:center; gap:8px">
              Key: <select id="keySelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Scale: <select id="scaleSelect"></select>
            </label>
            <label style="display:flex; align-items:center; gap:8px">
              Octave: <select id="octaveSelect"></select>
            </label>
          </div>
          
          <div class="panel-header">
            <div class="panel-title">Available Chords</div>
            <button class="btn btn-secondary btn-sm" id="genProgBtn">â†» Generate</button>
          </div>
          <div class="chips" id="chordChips"></div>
        </div>
        
        <div class="panel">
          <div class="panel-header">
            <div class="panel-title">ðŸŽµ Chord Progression</div>
            <button class="btn btn-ghost btn-sm" id="clearProgBtn">Clear</button>
          </div>
          
          <div class="chips mb-3" id="progressionChips"></div>
          
          <div class="panel-header">
            <div class="panel-title">Progression Templates</div>
          </div>
          <div class="grid grid-4">
            <button class="preset" data-prog="ii-v-i">
              <div class="preset-icon">ðŸŽ·</div>
              <div class="preset-name">II-V-I</div>
            </button>
            <button class="preset" data-prog="lofi">
              <div class="preset-icon">ðŸ˜Œ</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-prog="neosoul">
              <div class="preset-icon">ðŸŽ¹</div>
              <div class="preset-name">Neo-Soul</div>
            </button>
            <button class="preset" data-prog="modal">
              <div class="preset-icon">ðŸŒ™</div>
              <div class="preset-name">Modal</div>
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- ==================== SONG BUILDER TAB ==================== -->
    <section class="section pro-locked" id="tab-songbuilder">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="panel-title">ðŸ§± Song Builder</div>
            <div class="panel-subtitle">
              Step-by-step pipeline from empty grid â†’ full, structured song.
            </div>
          </div>
          <div class="badge badge-ghost">Vibes Â· v1.8</div>
        </div>
    
        <div class="panel-body" style="display:flex; flex-direction:column; gap:var(--space-4);">
    
          <!-- STEP 1: Pick a template -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">1. Song Form</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Choose a structure: intro, verses, choruses, bridge, outro.
                </div>
              </div>
            </div>
          
            <div style="display:flex; flex-wrap:wrap; gap:var(--space-3); align-items:center;">
              <label style="font-size:var(--text-xs); text-transform:uppercase; letter-spacing:0.08em; color:var(--text-tertiary);">
                Template
              </label>
              <select id="songTemplateSelect" class="input" style="min-width:220px;">
                <option value="intro-verse-chorus">Pop / Rock</option>
                <option value="short-edm-rise-drop">EDM / House</option>
                <option value="hiphop-lofi">Hip-Hop / Lo-Fi</option>
                <option value="metal-hardcore">Metal / Hardcore</option>
                <option value="ambient-flow">Ambient / Downtempo</option>
                <option value="loop-jam">Loop Jam</option>
                <option value="trap-banger">Trap / Modern Hip-Hop</option>
                <option value="progressive-house">Progressive House / Trance</option>
                <option value="funk-groove">Funk / Disco</option>
                <option value="jazz-standard">Jazz / Fusion</option>
                <option value="dubstep-wobble">Dubstep / Bass Music</option>
                <option value="reggae-dub">Reggae / Dub</option>
              </select>
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); margin-left:auto;">
                Powered by your current key, scale & progression (Harmony tab)
              </div>
            </div>

            <label style="font-size:var(--text-xs); text-transform:uppercase; letter-spacing:0.08em; color:var(--text-tertiary); display:block; margin-bottom:var(--space-2);">
              Mood
            </label>
            <select id="moodSelect" class="input" style="min-width:220px;">
              <option value="default">Default / Neutral</option>
              <option value="dark">Dark</option>
              <option value="sad">Sad / Melancholy</option>
              <option value="tense">Tense / Aggressive</option>
              <option value="mellow">Soft / Chill</option>
              <option value="dreamy">Dreamy / Floaty</option>
            </select>

            <label for="songDurationSelect">Duration</label>
            <select id="songDurationSelect" class="input">
              <option value="1">~ 1 minute</option>
              <option value="2">~ 2 minutes</option>
              <option value="3">~ 3 minutes</option>
              <option value="4">~ 4 minutes</option>
            </select>

            <!-- Randomize now lives here -->
            <div style="
                display:flex;
                justify-content:flex-end;
                margin-top:var(--space-3);
            ">
              <button
                id="songRandomizeSectionsBtn"
                class="btn btn-secondary btn-sm"
                type="button"
              >
                ðŸŽ² Randomize sections
              </button>
            </div>
          </div>
    
          <!-- STEP 2: Edit sections -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">2. Sections & Energy</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Tweak length, energy and instrumentation for each section. MOBILE USERS: Landscape is recommended!
                </div>
              </div>
            </div>
    
            <div class="scroll-x" style="overflow-x:auto;">
              <table style="width:100%; border-collapse:collapse; font-size:var(--text-xs); min-width:560px;">
                <thead>
                  <tr style="text-align:left; border-bottom:1px solid var(--glass-border);">
                    <th style="padding:6px 4px;">Section</th>
                    <th style="padding:6px 4px; width:70px;">Bars</th>
                    <th style="padding:6px 4px; width:160px;">Energy</th>
                    <th style="padding:6px 4px;">Instruments</th>
                  </tr>
                </thead>
                <tbody id="songSectionsTable">
                  <!-- Filled by JS -->
                </tbody>
              </table>
            </div>
          </div>
    
          <!-- STEP 3: Fills & groove -->
          <div class="panel" style="padding:var(--space-4);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:var(--space-2);">
              <div>
                <div style="font-weight:600; margin-bottom:4px;">3. Fills & Groove</div>
                <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Light automation for drum fills and intensity.
                </div>
              </div>
            </div>
    
            <div style="display:flex; flex-wrap:wrap; gap:var(--space-4); align-items:center;">
              <div style="display:flex; flex-direction:column; gap:4px;">
                <label for="songFillEverySelect" style="font-size:var(--text-xs); color:var(--text-tertiary);">
                  Drum fill everyâ€¦
                </label>
                <select id="songFillEverySelect" class="input" style="min-width:120px;">
                  <option value="0">Never</option>
                  <option value="4" selected>4 bars</option>
                  <option value="8">8 bars</option>
                  <option value="16">16 bars</option>
                </select>
              </div>
    
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); max-width:260px;">
                Fills are only added in higher-energy sections (verses / choruses / drops).
              </div>
            </div>
          </div>
    
          <!-- STEP 4: Build -->
          <div class="panel" style="padding:var(--space-4); display:flex; flex-wrap:wrap; justify-content:center; align-items:center; text-align:center; gap:var(--space-4);">
            <div>
              <div style="font-weight:600; margin-bottom:4px;">4. Build full song</div>
              <div style="font-size:var(--text-xs); color:var(--text-tertiary); max-width:360px;">
                Uses your current genre, tempo, and harmony guardrails to generate
                drums, bass, keys and lead for the whole structure.
              </div>
            </div>
    
            <div style="display:flex; flex-direction:column; gap:var(--space-2); align-items:center;">
              <button id="songBuildBtn" class="btn btn-primary">
                ðŸŽ¼ Build structured song
              </button>
              <div id="songBuilderStatus" class="song-builder-status"></div>
              <!--<button id="songBuilderToMultitrackBtn" class="btn btn-success btn-sm">
                â¬‡ï¸ Send to Multitrack
              </button>-->
              <div style="font-size:var(--text-xs); color:var(--text-tertiary);">
                Result shows up in the Sequencer / Generate view.
              </div>
            </div>
          </div>
    
        </div>
      </div>
    </section>

    
    <!-- Replace the entire <section class="section pro-locked" id="tab-multitrack"> block with this -->

    <section class="section pro-locked" id="tab-multitrack">
      <div class="panel">
        <!-- Professional DAW Header -->
        <div class="panel-header">
          <div class="panel-title">ðŸŽ™ï¸ Multitrack DAW</div>
          <div class="flex" style="gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" id="newSessionBtn">ðŸ“„ New</button>
            <button class="btn btn-secondary btn-sm" id="saveSessionBtn">ðŸ’¾ Save</button>
            <button class="btn btn-secondary btn-sm" id="loadSessionBtn">ðŸ“‚ Load</button>
        
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
        
            <button class="btn btn-secondary btn-sm" id="undoBtn" disabled>â†¶ Undo</button>
            <button class="btn btn-secondary btn-sm" id="redoBtn" disabled>â†· Redo</button>
        
            <!-- ðŸ”Š Mixdown / housekeeping -->
            <div style="border-left: 1px solid var(--glass-border); height: 24px; margin: 0 var(--space-2);"></div>
            <button class="btn btn-success btn-sm" id="bounceAllBtn">ðŸ“¦ Bounce</button>
            <button class="btn btn-secondary btn-sm" id="clearAllTracksBtn">ðŸ§¹ Clear</button>
          </div>
        </div>

    
        <!-- Transport Controls Bar -->
        <div class="daw-transport-bar">
          <div class="transport-section">
            <button class="transport-btn" id="dawRewindBtn" title="Rewind">â®ï¸</button>
            <button class="transport-btn" id="dawPlayBtn" title="Play/Pause">â–¶ï¸</button>
            <button class="transport-btn" id="dawStopBtn" title="Stop">â¹ï¸</button>
            <button class="transport-btn" id="dawRecordBtn" title="Record Armed">âºï¸</button>
            <button class="transport-btn" id="dawForwardBtn" title="Fast Forward">â­ï¸</button>
          </div>
    
          <div class="transport-section">
            <div class="transport-display" id="dawTimecode">00:00:00.000</div>
            <div class="transport-display" id="dawBars">1.1.1</div>
          </div>
    
          <div class="transport-section">
            <button class="btn btn-secondary btn-sm" id="dawLoopBtn">ðŸ” Loop</button>
            <button class="btn btn-secondary btn-sm" id="dawClickBtn">ðŸ¥ Click</button>
            <button class="btn btn-secondary btn-sm" id="dawCountInBtn">â±ï¸ Count</button>
          </div>
    
          <div class="transport-section" style="margin-left: auto;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">BPM</label>
            <input type="number" id="dawBpmInput" value="120" min="30" max="300" 
                   style="width: 60px; padding: var(--space-2); text-align: center;">
            <label style="font-size: var(--text-xs); color: var(--text-tertiary);">Time Sig</label>
            <select id="dawTimeSigSelect" style="padding: var(--space-2);">
              <option value="4/4" selected>4/4</option>
              <option value="3/4">3/4</option>
              <option value="6/8">6/8</option>
              <option value="5/4">5/4</option>
              <option value="7/8">7/8</option>
            </select>
          </div>
        </div>
    
        <!-- Main DAW Layout: 3-Column Professional View -->
        <div class="daw-main-container">
          
          <!-- LEFT: Track List / Mixer Column -->
          <div class="daw-track-list">
            <div class="daw-section-header">
              <span>ðŸ“‹ Tracks</span>
              <button class="btn btn-ghost btn-sm" id="addTrackBtnLeft">âž•</button>
            </div>
            
            <div class="daw-track-list-scroll" id="dawTrackList">
              <!-- Track strips will be dynamically inserted here -->
            </div>
          </div>
          
          <div class="daw-master-strip">
            <div class="daw-section-header">Master</div>
            <div class="daw-meters">
              <div class="daw-meter-bar" id="masterMeterL"></div>
              <div class="daw-meter-bar" id="masterMeterR"></div>
            </div>
            <input type="range" orient="vertical" id="masterFader" min="-60" max="6" value="0" step="0.1">
            <div class="daw-fader-label" id="masterFaderLabel">0.0 dB</div>
          </div>
    
          <!-- CENTER: Timeline / Arrangement View -->
          <div class="daw-timeline-container">
            <!-- Toolbar -->
            <div class="daw-timeline-toolbar">
              <div class="toolbar-group">
                <button class="tool-btn active" data-tool="select" title="Select Tool">â†–ï¸</button>
                <button class="tool-btn" data-tool="pencil" title="Pencil Tool">âœï¸</button>
                <button class="tool-btn" data-tool="split" title="Split Tool">âœ‚ï¸</button>
                <button class="tool-btn" data-tool="fade" title="Fade Tool">ðŸ“‰</button>
              </div>

              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="importStemBtn">ðŸ“ Import Audio</button>
              </div>
    
              <div class="toolbar-group">
                <span class="toolbar-label">Snap:</span>
                <select id="dawSnapSelect" style="padding: var(--space-1) var(--space-2);">
                  <option value="off">Off</option>
                  <option value="bar" selected>Bar</option>
                  <option value="beat">Beat</option>
                  <option value="1/8">1/8</option>
                  <option value="1/16">1/16</option>
                  <option value="1/32">1/32</option>
                </select>
              </div>
    
              <div class="toolbar-group">
                <button class="btn btn-secondary btn-sm" id="dawZoomInBtn">ðŸ”+</button>
                <span id="dawZoomLevel">100%</span>
                <button class="btn btn-secondary btn-sm" id="dawZoomOutBtn">ðŸ”-</button>
                <button class="btn btn-secondary btn-sm" id="dawZoomFitBtn">âŠ¡ Fit</button>
              </div>
    
              <div class="toolbar-group" style="margin-left: auto;">
                <button class="btn btn-secondary btn-sm" id="dawGridBtn">âŠž Grid</button>
                <button class="btn btn-secondary btn-sm" id="dawAutomationBtn">ðŸ“ˆ Auto</button>
              </div>
            </div>
    
            <!-- Ruler with measures/beats -->
            <div class="daw-ruler" id="dawRuler">
              <div class="daw-ruler-markers" id="dawRulerMarkers"></div>
              <div class="daw-playhead" id="dawPlayhead"></div>
              <div class="daw-loop-region" id="dawLoopRegion" style="display: none;"></div>
            </div>
    
            <!-- Scrollable arrangement view -->
            <div class="daw-arrangement-scroll" id="dawArrangementScroll">
              <div id="loopRegionHighlight" class="loop-region-highlight" style="display:none;"></div>
              <div class="daw-arrangement-grid" id="dawArrangementGrid">
                <!-- Track lanes will be rendered here -->
              </div>
            </div>
          </div>
    
          <!-- RIGHT: Inspector / Properties Panel -->
          <div class="daw-inspector">
            <div class="daw-section-header">
              <span id="inspectorTitle">ðŸŽ›ï¸ Inspector</span>
              <button class="btn btn-ghost btn-sm" id="closeInspectorBtn">âœ•</button>
            </div>
    
            <div class="daw-inspector-content" id="inspectorContent">
              <!-- Content changes based on selection -->
              <div class="inspector-placeholder">
                <div style="text-align: center; padding: var(--space-8); color: var(--text-tertiary);">
                  <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">ðŸŽšï¸</div>
                  <div>Select a track or region</div>
                  <div style="font-size: var(--text-sm); margin-top: var(--space-2);">to view properties</div>
                </div>
              </div>
            </div>
          </div>
    
        </div>
        
        <!-- ðŸŽ› FX Chain Panel -->
        <!-- Bottom FX Chain Panel -->
        <div id="fxChainPanel" class="fx-chain-panel" aria-hidden="true">
          <div class="fx-chain-header">
            <div class="fx-chain-title">
              <span class="fx-chain-icon">âœ¨</span>
              <div>
                <div class="fx-chain-title-main">Track FX Chain</div>
                <div class="fx-chain-title-sub" id="fxChainTrackLabel">
                  No track selected
                </div>
              </div>
            </div>
            <button class="btn btn-ghost btn-xs" id="closeFxPanelBtn" type="button">
              âœ•
            </button>
          </div>

          <div class="fx-chain-body">
            <!-- INLINE ADD FX STRIP (no modal / menu) -->
            <div class="fx-add-row">
              <span class="fx-add-label">Add effect</span>
              <div class="fx-add-list" id="fxAddList">
                <button type="button" class="fx-pill" data-fx="eq">ðŸŽš EQ</button>
                <button type="button" class="fx-pill" data-fx="compressor">ðŸ«§ Comp</button>
                <button type="button" class="fx-pill" data-fx="delay">â± Delay</button>
                <button type="button" class="fx-pill" data-fx="reverb">ðŸŒ« Reverb</button>
                <button type="button" class="fx-pill" data-fx="saturation">ðŸ”¥ Sat</button>
                <button type="button" class="fx-pill" data-fx="filter">ðŸª„ Filter</button>
              </div>
            </div>

            <!-- Where each track's FX chain gets rendered -->
            <div class="fx-chain-slots" id="fxChainSlots">
              <!-- renderFxChain(track) populates this -->
            </div>
          </div>
        </div>
        
        <!-- Bottom: Status Bar -->
        <div class="daw-status-bar">
          <span id="dawStatusMessage">Ready</span>
          <div style="margin-left: auto; display: flex; gap: var(--space-4); font-size: var(--text-xs);">
            <span>Sample Rate: <strong id="dawSampleRate">48000 Hz</strong></span>
            <span>Latency: <strong id="dawLatency">0ms</strong></span>
            <span>CPU: <strong id="dawCpuLoad">0%</strong></span>
            <span>Tracks: <strong id="dawTrackCount">0</strong></span>
          </div>
        </div>
      </div>
      <!-- Mobile quick actions FAB -->
      <!--<button id="dawFab" class="daw-fab" type="button" aria-label="Quick actions">
        <span id="dawFabIcon">+</span>
      </button>
      
      <div id="dawFabMenu" class="daw-fab-menu" aria-label="Multitrack quick actions">
        <button class="daw-fab-menu-item" data-action="add-track" title="Add Track">
          ðŸŽµ
        </button>
        <button class="daw-fab-menu-item" data-action="toggle-inspector" title="Inspector">
          ðŸŽ›ï¸
        </button>
        <button class="daw-fab-menu-item" data-action="toggle-fx" title="FX Chain">
          âœ¨
        </button>
        <button class="daw-fab-menu-item" data-action="record-arm" title="Quick Record">
          âºï¸
        </button>
        <button class="daw-fab-menu-item" data-action="undo" title="Undo">
          â†¶
        </button>
      </div>-->
    </section>

    <section class="section pro-locked" id="tab-samples">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸ“‚ Sample Library</div>
          <div class="flex">
            <button class="btn btn-secondary btn-sm" id="refreshSamplesBtn">â†» Refresh</button>
            <button class="btn btn-success btn-sm" id="loadKitBtn">ðŸ“¥ Load Kit to Sequencer</button>
            <button id="defaultKitBtn" class="btn btn-secondary btn-sm">â†º Default</button>
          </div>
        </div>
    
        <!-- Kit Selector -->
        <div style="margin-bottom: var(--space-6);">
          <div style="font-weight: 600; margin-bottom: var(--space-3); color: var(--text-secondary);">
            ðŸŽ›ï¸ Sample Kits
          </div>
          <div class="grid grid-5" id="kitSelector">
            <button class="preset active" data-kit="lofi">
              <div class="preset-icon">ðŸ“»</div>
              <div class="preset-name">Lo-Fi</div>
            </button>
            <button class="preset" data-kit="metal">
              <div class="preset-icon">ðŸ¤˜</div>
              <div class="preset-name">Metal</div>
            </button>
            <button class="preset" data-kit="hiphop">
              <div class="preset-icon">ðŸŽ¤</div>
              <div class="preset-name">Hip-Hop</div>
            </button>
            <button class="preset" data-kit="trap">
              <div class="preset-icon">ðŸ”¥</div>
              <div class="preset-name">Trap</div>
            </button>
            <button class="preset" data-kit="house">
              <div class="preset-icon">ðŸ </div>
              <div class="preset-name">House</div>
            </button>
            <button class="preset" data-kit="techno">
              <div class="preset-icon">âš¡</div>
              <div class="preset-name">Techno</div>
            </button>
            <button class="preset" data-kit="dnb">
              <div class="preset-icon">ðŸ¥</div>
              <div class="preset-name">DnB</div>
            </button>
            <button class="preset" data-kit="ambient">
              <div class="preset-icon">ðŸŒ™</div>
              <div class="preset-name">Ambient</div>
            </button>
            <button class="preset" data-kit="rock">
              <div class="preset-icon">ðŸŽ¸</div>
              <div class="preset-name">Rock</div>
            </button>
            <button class="preset" data-kit="jazz">
              <div class="preset-icon">ðŸŽ·</div>
              <div class="preset-name">Jazz</div>
            </button>
            <button class="preset" data-kit="vintage">
              <div class="preset-icon">ðŸ“¼</div>
              <div class="preset-name">Vintage</div>
            </button>
            <!--<button class="preset" data-kit="instruments">
              <div class="preset-icon">ðŸŽ¹</div>
              <div class="preset-name">Instruments</div>
            </button>-->
          </div>
        </div>
    
        <!-- Sample Browser Grid -->
        <div class="grid grid-2" style="gap: var(--space-4);">
          
          <!-- Left: Sample List -->
          <div class="panel">
            <div class="panel-header">
              <div class="panel-title">ðŸŽµ Samples</div>
              <div class="badge badge-primary" id="sampleCount">8 sounds</div>
            </div>
            
            <div id="sampleList" style="display: flex; flex-direction: column; gap: var(--space-2); max-height: 500px; overflow-y: auto;">
              <!-- Sample items will be generated here -->
            </div>
          </div>
    
          <!-- Right: Sample Editor -->
          <div class="panel">
            <div class="panel-header">
              <div class="panel-title">ðŸŽšï¸ Sample Editor</div>
              <button class="btn btn-ghost btn-sm" id="resetSampleBtn">Reset</button>
            </div>
    
            <div id="sampleEditor">
              <!-- Waveform Preview -->
              <div style="margin-bottom: var(--space-4);">
                <div style="font-weight: 600; margin-bottom: var(--space-2); color: var(--text-secondary); font-size: var(--text-sm);">
                  Waveform
                </div>
                <div style="background: var(--bg-secondary); border-radius: var(--radius-md); padding: var(--space-4); height: 80px; display: flex; align-items: center; justify-content: center;">
                  <canvas id="sampleWaveform" width="400" height="60"></canvas>
                </div>
              </div>
    
              <!-- Sample Info -->
              <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
                <div style="font-weight: 600; margin-bottom: var(--space-2);" id="selectedSampleName">Select a sample</div>
                <div style="font-size: var(--text-sm); color: var(--text-tertiary);" id="selectedSampleInfo">Click any sample to edit</div>
              </div>
    
              <!-- Synthesis Parameters -->
              <div style="display: flex; flex-direction: column; gap: var(--space-4);">
                
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŽ›ï¸ Pitch</span>
                    <span class="param-value" id="samplePitchValue">0</span>
                  </div>
                  <input type="range" id="samplePitch" min="-12" max="12" value="0" step="0.1">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ“ Decay</span>
                    <span class="param-value" id="sampleDecayValue">0.2s</span>
                  </div>
                  <input type="range" id="sampleDecay" min="0.05" max="2" value="0.2" step="0.01">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŽšï¸ Tone</span>
                    <span class="param-value" id="sampleToneValue">50%</span>
                  </div>
                  <input type="range" id="sampleTone" min="0" max="100" value="50">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸŒŠ Noise</span>
                    <span class="param-value" id="sampleNoiseValue">30%</span>
                  </div>
                  <input type="range" id="sampleNoise" min="0" max="100" value="30">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>âš¡ Attack</span>
                    <span class="param-value" id="sampleAttackValue">0.001s</span>
                  </div>
                  <input type="range" id="sampleAttack" min="0.001" max="0.1" value="0.001" step="0.001">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ”Š Volume</span>
                    <span class="param-value" id="sampleVolumeValue">0dB</span>
                  </div>
                  <input type="range" id="sampleVolume" min="-24" max="6" value="0" step="0.5">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>ðŸ“» Lo-Fi</span>
                    <span class="param-value" id="sampleLofiValue">0%</span>
                  </div>
                  <input type="range" id="sampleLofi" min="0" max="100" value="0">
                </div>
    
                <div class="param-control">
                  <div class="param-label">
                    <span>âš¡ Distortion</span>
                    <span class="param-value" id="sampleDistValue">0%</span>
                  </div>
                  <input type="range" id="sampleDist" min="0" max="100" value="0">
                </div>
    
              </div>
    
              <!-- Action Buttons -->
              <div class="flex" style="margin-top: var(--space-4);">
                <button class="btn btn-primary" id="previewSampleBtn">â–¶ï¸ Preview</button>
                <button class="btn btn-secondary" id="saveSampleBtn">ðŸ’¾ Save</button>
                <button class="btn btn-secondary" id="exportSampleBtn">ðŸ“¥ Export WAV</button>
                <button class="btn btn-secondary btn-sm" id="sendSampleToMultitrackBtn">â†— To Multitrack</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    
      <!-- Sample Pack Generator -->
      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">ðŸŽ² Sample Pack Generator</div>
        </div>
    
        <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); margin-bottom: var(--space-4);">
          <div style="font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6; margin-bottom: var(--space-3);">
            Generate entire custom sample packs with AI-powered sound design. Choose your style and let the algorithm create unique, cohesive drum sounds.
          </div>
        </div>
    
        <div class="grid grid-3" style="margin-bottom: var(--space-4);">
          <div class="param-control">
            <div class="param-label">
              <span>Character</span>
              <span class="param-value" id="genCharacterValue">Warm</span>
            </div>
            <input type="range" id="genCharacter" min="0" max="100" value="50">
          </div>
    
          <div class="param-control">
            <div class="param-label">
              <span>Variation</span>
              <span class="param-value" id="genVariationValue">Medium</span>
            </div>
            <input type="range" id="genVariation" min="0" max="100" value="50">
          </div>
    
          <div class="param-control">
            <div class="param-label">
              <span>Lo-Fi Amount</span>
              <span class="param-value" id="genLofiValue">25%</span>
            </div>
            <input type="range" id="genLofi" min="0" max="100" value="25">
          </div>
        </div>
    
        <div class="flex">
          <button class="btn btn-success" id="generatePackBtn">ðŸŽ² Generate Pack</button>
          <button class="btn btn-secondary" id="downloadPackBtn">ðŸ“¦ Download Pack (.zip)</button>
        </div>
      </div>
    </section>
    
    <footer class="footer">
      <div style="max-width: 1400px; margin: 0 auto;">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--space-6); margin-bottom: var(--space-4);">
          
          <!-- Transport & Playback -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>â–¶ï¸</span> Transport
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Space</kbd> Play/Pause</div>
              <div><kbd>S</kbd> Stop</div>
              <div><kbd>E</kbd> DJ Export</div>
            </div>
          </div>
          
          <!-- Multitrack DAW -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸŽ™ï¸</span> Multitrack
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Ctrl</kbd>+<kbd>Z</kbd> Undo</div>
              <div><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> Redo</div>
              <div><kbd>X</kbd> Split at Playhead</div>
              <div><kbd>Ctrl</kbd>+<kbd>D</kbd> Duplicate Region</div>
              <div><kbd>Delete</kbd> Delete Region</div>
              <div><kbd>Ctrl</kbd>+<kbd>=</kbd> Zoom In</div>
              <div><kbd>Ctrl</kbd>+<kbd>-</kbd> Zoom Out</div>
            </div>
          </div>
          
          <!-- Sequencer -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸŽ¹</span> Sequencer
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Click</kbd> Toggle Step</div>
              <div><kbd>Alt</kbd>+<kbd>Click</kbd> Accent Velocity</div>
              <div><kbd>Shift</kbd>+<kbd>Click</kbd> Inc. Probability</div>
              <div><kbd>Ctrl</kbd>+<kbd>Click</kbd> Edit Note</div>
            </div>
          </div>
          
          <!-- Navigation -->
          <div>
            <div style="font-weight: 800; color: var(--accent-primary); margin-bottom: var(--space-3); display: flex; align-items: center; gap: var(--space-2);">
              <span>ðŸ§­</span> Navigation
            </div>
            <div style="display: flex; flex-direction: column; gap: var(--space-2); font-size: var(--text-sm);">
              <div><kbd>Esc</kbd> Close Sidebar</div>
              <div><kbd>Tab</kbd> Next Control</div>
            </div>
          </div>
          
        </div>
        
        <!-- Studio Info Bar -->
        <div style="padding-top: var(--space-4); border-top: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
          <div style="display: flex; align-items: center; gap: var(--space-4);">
            <strong style="background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: var(--text-lg);">8-Beat Studio</strong>
            <span style="color: var(--text-tertiary);">â€¢</span>
            <span style="color: var(--text-secondary);">Hand Crafted Multitrack DAW</span>
          </div>
          
          <div style="display: flex; align-items: center; gap: var(--space-3); font-size: var(--text-sm); color: var(--text-tertiary);">
            <div class="badge badge-ghost">Vibes v1.8</div>
            <span>Made with â¤ï¸ for producers</span>
          </div>
        </div>
      </div>
    </footer>
  </div>
  
  <div id="simpleShell" hidden>
    <div class="simple-hero">
      <div class="card">
        <h1>8-Beat Studio â€” Simple Mode</h1>
        <p>All features, simplified navigation. Jump between tabs instantly.</p>
      </div>
    </div>
  
    <!-- Simple Transport -->
    <div class="simple-transport">
      <div class="simple-transport-controls">
        <button id="simpPlay" class="btn btn-primary">â–¶ï¸Ž Play</button>
        <button id="simpStop" class="btn btn-secondary">â–  Stop</button>
        <button id="simpToggleMode" class="btn btn-secondary btn-sm">Pro Mode</button>
        <button id="simpUnlockProBtn" class="btn btn-primary" data-visible-if="!pro">
          <span>Unlock Pro</span>
        </button>
      </div>
      
      <div class="simple-transport-progress">
        <div class="simple-transport-time" id="simpTime">00:00</div>
        <div class="simple-progress-bar">
          <div class="simple-progress-fill" id="simpProgress"></div>
        </div>
      </div>
      
      <div class="simple-transport-params">
        <div class="simple-param">
          <label class="simple-param-label">BPM</label>
          <input id="simpBpm" type="number" min="40" max="220" step="1" value="120" />
        </div>
        <div class="simple-param">
          <label class="simple-param-label">BPM</label>
          <input id="simpBpmSlider" type="range" min="60" max="200" value="120" />
        </div>
        <div class="simple-param">
          <label class="simple-param-label">Swing</label>
          <input id="simpSwing" type="range" min="0" max="100" value="0" />
        </div>
      </div>
    </div>
  
    <div class="simple-steps" role="tablist">
      <button class="simple-step" data-go="generate" role="tab">
        <span class="icon">ðŸŽ²</span>
        <span class="title">Generate</span>
        <span class="desc">Beats & AI</span>
      </button>
      <button class="simple-step" data-go="sequencer" role="tab">
        <span class="icon">ðŸŽ¹</span>
        <span class="title">Sequencer</span>
        <span class="desc">Step editor</span>
      </button>
      <button class="simple-step" data-go="mixer" role="tab">
        <span class="icon">ðŸŽšï¸</span>
        <span class="title">Mixer</span>
        <span class="desc">Levels & master</span>
      </button>
      <button class="simple-step" data-go="fx" role="tab">
        <span class="icon">ðŸŽ›ï¸</span>
        <span class="title">Effects</span>
        <span class="desc">FX rack</span>
      </button>
      <button class="simple-step" data-go="harmony" role="tab">
        <span class="icon">ðŸŽ¼</span>
        <span class="title">Harmony</span>
        <span class="desc">Keys & chords</span>
      </button>
      <button class="simple-step" data-go="songbuilder" role="tab">
        <span class="icon">ðŸ§±</span>
        <span class="title">Song Builder</span>
        <span class="desc">Full structures</span>
      </button>
      <button class="simple-step" data-go="multitrack" role="tab">
        <span class="icon">ðŸŽ™ï¸</span>
        <span class="title">Multitrack</span>
        <span class="desc">DAW mode</span>
      </button>
      <button class="simple-step" data-go="samples" role="tab">
        <span class="icon">ðŸ“‚</span>
        <span class="title">Samples</span>
        <span class="desc">Library & editor</span>
      </button>
    </div>
  
    <div class="simple-main">
      <div class="simple-content" id="simpleMount"></div>
      <div class="simple-note" id="simpleNote">Select a tab to get started</div>
    </div>
  </div>

  <!-- Add before closing </body> tag -->
  <div id="waveformEditorModal" style="display: none;"></div>
<script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
// ========================================
// 8-Beat Studio - Fully Optimized JS
// Performance: Debounced events, RAF throttling, object pooling
// Memory: Weak references, proper cleanup, no leaks
// Audio: Low-latency graph, stable connections, no crackles
// ========================================

'use strict';

// -------------------- Configuration --------------------
// Detect mobile device once
const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);

// Global config
const CONFIG = {
  MAX_BPM: 200,
  MAX_SEQUENCE_LENGTH: isMobile ? 1024 : 2048, // âœ… use colon here
  MIN_SEQUENCE_LENGTH: 8,
  VISUALIZER_BARS: 32,
  VISUALIZER_FPS: 30,
  PROGRESS_UPDATE_MS: 16,
  DEBOUNCE_MS: 80,
  STORAGE_KEY: 'prostudio.vibe'
};

const VIBES = ['moon', 'dawn', 'nebula', 'forest', 'sunset', 'ocean', 'ember', 'aurora', 'cyber', 'sandstorm'];

// -------------------- State Management --------------------
const state = {
  currentGenre: 'lofi',
  currentTab: 'generate',
  isPlaying: false,
  bpm: 120,
  swing: 0,
  duration: 5,
  complexity: 2,
  humanize: 10,
  sequenceLength: 32,  // CHANGED FROM 16
  resolution: '16n',
  currentStep: 0,
  cursorSeconds: 0,
  // ... rest stays the same
  key: 'C',
  scale: 'major',
  octave: 4,
  progression: [],
  masterVolume: 0,
  tapeSaturation: 25,
  vinylNoise: 15,
  lowCut: 30,
  highCut: 16000,
  compressor: -18,
  metronomeEnabled: false,
  metronomeVolume: -6,
  countInBars: 1,
  // AI Mixing
  aiMixing: {
    enabled: false,
    autoGain: true,
    autoPan: true,
    autoEQ: true,
    autoCompression: true,
    referenceLevel: -14, // LUFS target
    lastAnalysis: null
  }
};

// Has the main Tone.Sequence been set up at least once?
let sequencerInitialized = false;
  
// Metronome system
const metronome = {
  synth: null,
  enabled: false,
  loop: null
};
  
async function checkAudioPermissions() {
  try {
    const permissions = await navigator.permissions.query({ name: 'microphone' });
    
    if (permissions.state === 'denied') {
      console.warn('âš ï¸ Microphone permission denied');
      showToast('âš ï¸ Microphone access denied. External audio tracks will not work.', 'warning');
    } else if (permissions.state === 'prompt') {
      console.log('â„¹ï¸ Microphone permission will be requested when adding external audio track');
    } else {
      console.log('âœ… Microphone permission granted');
    }
    
    permissions.addEventListener('change', () => {
      console.log('ðŸ”„ Microphone permission changed:', permissions.state);
    });
    
  } catch (err) {
    // Permissions API not supported or microphone not in query list
    console.log('â„¹ï¸ Cannot query microphone permissions, will request on demand');
  }
}
  
// -------------------- Data Structures --------------------
const instruments = {
  kick: { name: 'Kick', icon: 'ðŸ¥', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  snare: { name: 'Snare', icon: 'ðŸŽ¤', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  hihat: { name: 'Hi-Hat', icon: 'ðŸŽ©', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  clap: { name: 'Clap', icon: 'ðŸ‘', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  rimshot: { name: 'Rimshot', icon: 'ðŸ”Š', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  tom: { name: 'Tom', icon: 'ðŸª˜', mute: false, solo: false, volume: 0, pan: 0, type: 'drum' },
  crash: { name: 'Crash', icon: 'ðŸ’¥', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  ride: { name: 'Ride', icon: 'ðŸŒŠ', mute: false, solo: false, volume: -3, pan: 0, type: 'drum' },
  
  // NEW ATMOSPHERIC INSTRUMENTS
  fx: { name: 'FX', icon: 'âœ¨', mute: false, solo: false, volume: -6, pan: 0, type: 'atmospheric' },
  riser: { name: 'Riser', icon: 'ðŸ“ˆ', mute: false, solo: false, volume: -8, pan: 0, type: 'atmospheric' },
  ambience: { name: 'Ambience', icon: 'ðŸŒ«ï¸', mute: false, solo: false, volume: -10, pan: 0, type: 'atmospheric' },
  
  bass: { name: 'Bass', icon: 'ðŸŽ¸', mute: false, solo: false, volume: -3, pan: 0, type: 'melodic', note: 'C2' },
  guitar: { name: 'Guitar', icon: 'ðŸŽ¸', mute: false, solo: false, volume: -5, pan: 20, type: 'melodic', note: 'C3' },
  keys: { name: 'Keys', icon: 'ðŸŽ¹', mute: false, solo: false, volume: -6, pan: 0, type: 'melodic', note: 'C4' },
  lead: { name: 'Lead', icon: 'ðŸŽº', mute: false, solo: false, volume: -8, pan: 0, type: 'melodic', note: 'C5' }
};

const patterns = {};
const synths = {};
const effects = {};
const master = {};

// Initialize patterns with proper structure
Object.keys(instruments).forEach(inst => {
  patterns[inst] = Array(32).fill(null).map(() => ({  // CHANGED FROM 16
    active: false,
    velocity: 0.8,
    probability: 100,
    note: instruments[inst].note,
    duration: '8n'
  }));
});



// -------------------- Genre Presets --------------------
const genrePresets = {
  lofi: {
    name: 'Lo-Fi Hip-Hop', icon: 'ðŸ˜Œ', bpm: 85, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','G2','G2','C2','C2','C2','C2','D2','D2','D2','D2','D#2','D#2','D#2','D#2','G2','G2','A2','A2'],
      guitar: ['C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','G3','D4','F3','G3','C3','D#3','G3','C3','D3','F3','A#3','D3','D#3','G3','A#3','D#3','C4','D4','F4','G4'],
      keys: ['C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','G3','A#3','D4','F4','C3','D#3','G3','A#3','D3','F3','A#3','D4','D#3','G3','A#3','D#4','C4','D4','F4','G4'],
      lead: ['G4','A#4','D5','C5','A#4','G4','F4','D#4','G4','A#4','D5','C5','A#4','G4','F4','D#4']
    }
  },
  
  hiphop: {
    name: 'Hip-Hop', icon: 'ðŸŽ¤', bpm: 90, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],
      hihat:   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1],
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0],
      bass:    [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','G2','A1','A1','A1','A1','C2','C2','C2','D2','D2','D2','F2','F2','F2','G2','G2','A1','A1'],
      guitar: ['A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','G3','B2','A2','C3','E3','A2','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','G3'],
      keys: ['A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','F3','B3','A2','C3','E3','G3','C3','E3','D3','F3','A3','D3','F3','G2','B2','D3','E3','A3'],
      lead: ['E4','G4','A4','C5','B4','A4','G4','E4','E4','G4','A4','C5','D5','C5','B4','A4']
    }
  },
  
  postpunk: {
    name: 'Post-Punk', icon: 'ðŸ–¤', bpm: 100, swing: 0,
    patterns: {
      kick:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0],
      rimshot: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      bass:    [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0],
      guitar:  [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
      lead:    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0]
    },
    notes: {
      bass: ['E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','D2','D1','E1','E1','E2','E1','G1','G1','G2','G1','A1','A1','A2','A1','D2','D2','E2','E1'],
      guitar: ['E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','F3','A3','D3','E2','G2','B2','E2','G2','B2','D3','G2','A2','C3','E3','A2','D3','E3','G3','B3'],
      keys: ['E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','F3','A3','C4','E2','G2','B2','D3','G2','B2','D3','F3','A2','C3','E3','G3','D3','E3','G3','B3'],
      lead: ['B3','D4','E4','G4','F4','E4','D4','B3','B3','D4','E4','G4','A4','G4','F4','E4']
    }
  },
  
  rnb: {
    name: 'R&B', icon: 'ðŸ’«', bpm: 75, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1],
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1],
      rimshot: [0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0],
      bass:    [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0]
    },
    notes: {
      bass: ['F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','C3','C3','F2','F2','F2','F2','G2','G2','G2','G2','A2','A2','A2','A2','C3','C3','D3','D3'],
      guitar: ['F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','G3','C3','F2','A2','C3','F2','G2','B2','D3','G2','A2','C3','E3','A2','C3','E3','F3','A3'],
      keys: ['F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','C4','F2','A2','C3','E3','G2','B2','D3','F3','A2','C3','E3','A3','C3','E3','G3','A3'],
      lead: ['C4','E4','F4','A4','G4','F4','E4','C4','C4','E4','F4','A4','G4','A4','C5','E5']
    }
  },
  
  ambient: {
    name: 'Ambient', icon: 'ðŸŒŒ', bpm: 60, swing: 0,
    patterns: {
      kick:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      snare:   [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      hihat:   [0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0],
      bass:    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      guitar:  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      keys:    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      lead:    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0]
    },
    notes: {
      bass: ['C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','A#1','A#1','A#1','A#1','C2','C2','C2','C2','C2','C2','C2','C2','A#1','A#1','A#1','A#1','G#1','G#1','G#1','G#1'],
      guitar: ['C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','D3','F3','A#3','D3','C2','D#2','G2','C2','D#2','G2','A#2','D#3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      keys: ['C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','D3','F3','A#3','D4','C2','D#2','G2','A#2','D#2','G2','A#2','D3','A#1','D2','F2','A#2','G#2','C3','D#3','G#3'],
      lead: ['G3','A#3','D4','F4','D#4','D4','A#3','G3','G3','A#3','D4','F4','D#4','D4','C4','A#3']
    }
  },

  dazecore: {
    name: 'Dazecore', icon: 'â˜€ï¸', bpm: 95, swing: 0,
    patterns: {
      // Warm, inviting kick - but the timing is slightly off
      kick:    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      
      // Soft, jazzy snare - comforting but distant
      snare:   [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1],
      
      // Lounge hi-hats with subtle glitches
      hihat:   [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1],
      
      // Intimate claps - inviting you in
      clap:    [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0],
      
      // Dial-up nostalgia - warm but uncanny
      rimshot: [0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,0,1],
      
      // Rare tom fills - something stirring beneath
      tom:     [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      
      // Deep, warm bass - comforting rumble with wrong notes
      bass:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,0],
      
      // Lush guitar chords - too beautiful, almost sickly sweet
      guitar:  [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0],
      
      // Dreamy keys - lounge jazz piano with dissonant undertones
      keys:    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,1,0],
      
      // Warm melody - beckoning, seductive, slightly wrong
      lead:    [0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0],
      
      // Vinyl crackle and tape warble - nostalgic texture
      fx:      [1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1],
      
      // Subtle riser - the room is shifting around you
      riser:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
      
      // Warm ambient pad - the "off" feeling underneath everything
      ambience:[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
    },
    notes: {
      // Warm bass with chromatic "wrong" notes
      bass: ['D2','D2','D2','F2','F2','F2','A2','A2','A2','C3','C3','C3','D3','D3','D#3','D2','D2','D2','F2','F2','F2','A2','A2','C3','C3','C3','D3','D#3','D3','C3','A2','F2'],
      
      // Lush major 7th chords with occasional dissonance
      guitar: ['D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','A3','C#4','E4','A3','D3','F#3','A3','C#4','F#3','A3','C#4','F#3','A3','C#4','E4','G#4','B3','D4','F#4','A4'],
      
      // Jazzy extended chords - warm but unsettling
      keys: ['D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','G#4','C#4','E4','G#4','B4','D3','F#3','A3','C#4','F#3','A3','C#4','E4','A3','C#4','E4','A4','C#4','E4','G#4','C#5'],
      
      // Nostalgic melody - familiar but you can't place it
      lead: ['A4','C#5','D5','F#5','E5','D5','C#5','A4','F#4','A4','C#5','E5','D5','C#5','B4','A4','A4','C#5','D5','F#5','E5','D5','C#5','B4','A4','C#5','E5','F#5','G#5','A5','C#6','D6']
    }
  }
};
  
// -------------------- Music Theory --------------------
const keysArr = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const scales = {
  // â€”â€”â€”â€”â€” Diatonic Modes â€”â€”â€”â€”â€”
  major:       [0,2,4,5,7,9,11],   // same as major
  dorian:       [0,2,3,5,7,9,10],
  phrygian:     [0,1,3,5,7,8,10],
  lydian:       [0,2,4,6,7,9,11],
  mixolydian:   [0,2,4,5,7,9,10],
  minor:      [0,2,3,5,7,8,10],   // same as natural minor
  locrian:      [0,1,3,5,6,8,10],

  // â€”â€”â€”â€”â€” Pentatonics â€”â€”â€”â€”â€”
  pentatonic:        [0,2,4,7,9],   // major pent
  minorPentatonic:   [0,3,5,7,10],
  egyptian:          [0,2,5,7,10],  // super smooth, lofi/ambient gold

  // â€”â€”â€”â€”â€” Blues â€”â€”â€”â€”â€”
  blues:          [0,3,5,6,7,10],   // hexatonic blues
  majorBlues:     [0,2,3,4,7,9],    // happier blues

  // â€”â€”â€”â€”â€” Harmonic Families â€”â€”â€”â€”â€”
  harmonicMinor:  [0,2,3,5,7,8,11],
  melodicMinor:   [0,2,3,5,7,9,11],

  // â€”â€”â€”â€”â€” Exotic but usable â€”â€”â€”â€”â€”
  hungarianMinor:     [0,2,3,6,7,8,11],  // INSANE for dark jazz/fusion/metal
  phrygianDominant:   [0,1,4,5,7,8,10],  // Middle Eastern / metal
  arabian:            [0,2,4,5,6,8,10],  // perfect cinematic tension

  // â€”â€”â€”â€”â€” Whole/Half Systems â€”â€”â€”â€”â€”
  wholeTone:     [0,2,4,6,8,10],   // dream sequences, vaporwave
  diminished:    [0,2,3,5,6,8,9,11], // symmetrical diminished scale (octatonic)

  // â€”â€”â€”â€”â€” Modal / Lofi / Ambient Favourites â€”â€”â€”â€”â€”
  inSen:         [0,1,5,7,10],     // Japanese â€” BEAUTIFUL for ambient
  hirajoshi:     [0,2,3,7,8],      // Japanese â€” perfect for lofi/jazz
  kumoi:         [0,2,3,7,9],      // soft and melodic

  // â€”â€”â€”â€”â€” EDM / Trap Friendly â€”â€”â€”â€”â€”
  altered:       [0,1,3,4,6,8,10], // jazz "super-locrian", wild tension
  doubleHarmonic:[0,1,4,5,7,8,11], // Egyptian/Arabic flavor

  // â€”â€”â€”â€”â€” Synthetic / Modern â€”â€”â€”â€”â€”
  chromatic:     [0,1,2,3,4,5,6,7,8,9,10,11], // full set
  wholeHalf:     [0,2,3,5,6,8,9,11], // alt diminished
};

// -------------------- FX Configuration --------------------
const fxConfig = {
  reverb: { name: 'Reverb', active: false, decay: 1, wet: 0.2 },
  delay: { name: 'Delay', active: false, time: '4n', feedback: 0.2 },
  chorus: { name: 'Chorus', active: false, frequency: 1.5, depth: 0.7 },
  flanger: { name: 'Flanger', active: false, frequency: 0.5, depth: 0.5 },
  distortion: { name: 'Distortion', active: false, amount: 0.5 },
  filter: { name: 'Filter', active: false, frequency: 5000, type: 'lowpass' },
  phaser: { name: 'Phaser', active: false, frequency: 0.5, octaves: 3 },
  bitcrusher: { name: 'Bitcrusher', active: false, bits: 8, frequency: 4000 }
};

// -------------------- Utilities --------------------
const debounce = (fn, ms) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), ms);
  };
};

const throttle = (fn, ms) => {
  let lastRun = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastRun >= ms) {
      lastRun = now;
      fn(...args);
    }
  };
};

const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

// -------------------- Audio Context Setup --------------------
function initAudioContext() {
  if (Tone.getContext && Tone.getContext().rawContext) return;

  const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
  
  const ctx = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: isMobile ? 'balanced' : 'interactive',
    sampleRate: 48000
  });
  
  Tone.setContext(new Tone.Context(ctx));
  
  // CRITICAL: Desktop needs LESS lookahead to avoid timing issues
  Tone.context.lookAhead = isMobile ? 0.05 : 0.015; // Reduced from 0.02
  Tone.context.updateInterval = isMobile ? 0.03 : 0.008; // Reduced from 0.01
  
  console.log('ðŸŽ§ Device:', isMobile ? 'Mobile' : 'Desktop');
  console.log('ðŸŽµ Lookahead:', Tone.context.lookAhead.toFixed(3) + 's');
  console.log('ðŸŽµ Update:', Tone.context.updateInterval.toFixed(3) + 's');
}
  
function unlockAudioOnce() {
  const unlock = async () => {
    try {
      await Tone.start();
      await Tone.getContext().rawContext.resume();
      window.__audioUnlocked = true;
      console.log('ðŸ”“ Audio unlocked:', Tone.getContext().rawContext.state);

      // ðŸ” Resume playback if restoreSessionIfAny() marked pending
      if (state.pendingResume && typeof play === 'function') {
        state.pendingResume = false;
        play();
        console.log('â–¶ï¸ Resumed playback after unlock');
      }
    } catch (e) {
      console.warn('Unlock failed:', e);
    } finally {
      ['pointerdown', 'keydown', 'touchstart'].forEach(evt => {
        window.removeEventListener(evt, unlock);
      });
    }
  };

  window.addEventListener('pointerdown', unlock, { once: true });
  window.addEventListener('keydown', unlock, { once: true });
  window.addEventListener('touchstart', unlock, { once: true, passive: true });
}

// -------------------- Audio Graph Initialization --------------------
function initAudio() {
  // CRITICAL: Much lower gain + slower ramps for desktop stability
  master.fxIn = new Tone.Gain(0.25); // Reduced from 0.18
  
  // Master bus filters with SLOWER frequency ramps
  master.lowCutFilter = new Tone.Filter({
    type: 'highpass',
    frequency: state.lowCut,
    rolloff: -12
  });
  
  master.highCutFilter = new Tone.Filter({
    type: 'lowpass',
    frequency: state.highCut,
    rolloff: -12
  });
  
  // Tape saturation (subtle warm distortion)
  master.tapeDistortion = new Tone.Distortion({
    distortion: state.tapeSaturation / 100 * 0.2, // Reduced from 0.3
    wet: state.tapeSaturation / 100 * 0.6 // Reduced wet mix
  });
  
  // Vinyl noise (pink noise layer) - QUIETER
  master.vinylNoise = new Tone.Noise('pink');
  master.vinylNoise.volume.value = -50 + (state.vinylNoise / 100 * 15); // Quieter
  master.vinylNoise.start();
  master.vinylNoise.connect(master.fxIn);
  
  // Effects with MUCH gentler settings for desktop
  effects.filter = new Tone.Filter(fxConfig.filter.frequency, fxConfig.filter.type);
  effects.distortion = new Tone.Distortion(0.01); // Half strength
  effects.chorus = new Tone.Chorus(1.5, 2.5, 0.1).start(); // Reduced depth
  effects.flanger = new Tone.Chorus({
    frequency: 0.5,
    delayTime: 2,
    depth: 0.3, // Reduced from 0.5
    type: 'sine',
    spread: 0
  }).start();
  effects.phaser = new Tone.Phaser({
    frequency: 0.3, // Slower modulation
    octaves: 2, // Reduced from 3
    baseFrequency: 350
  });
  effects.bitcrusher = new Tone.BitCrusher(10); // Less crushing (was 8)
  effects.delay = new Tone.FeedbackDelay(fxConfig.delay.time, 0.08); // Less feedback
  effects.reverb = new Tone.Reverb({ decay: 0.6, wet: 0.1 }); // Drier reverb
  
  master.comp = new Tone.Compressor({
    threshold: state.compressor,
    ratio: 4, // More compression = more consistent volume
    attack: 0.003,
    release: 0.15
  });
  master.limiter = new Tone.Limiter(-2); // Safety limiter catches peaks
  
  // Connect master bus chain
  master.fxIn.chain(
    master.lowCutFilter,
    master.highCutFilter,
    master.tapeDistortion,
    effects.filter,
    effects.distortion,
    effects.bitcrusher,
    effects.chorus,
    effects.flanger,
    effects.phaser,
    effects.delay,
    effects.reverb,
    master.comp,
    master.limiter
  );
  
  master.limiter.toDestination();
  
  // Clip detection meter
  master.meter = new Tone.Meter();
  master.limiter.connect(master.meter);
  
  // Visualizer tap
  master.analyser = new Tone.Analyser('fft', 64);
  master.limiter.connect(master.analyser);
  
  // Recording tap
  const raw = Tone.getContext().rawContext;
  master.mediaDest = raw.createMediaStreamDestination();
  master.limiter.connect(master.mediaDest);
  master.mediaRecorder = null;
  master.recordedChunks = [];
  
  // Start FX states from fxConfig
  Object.keys(fxConfig).forEach(name => {
    applyFxActiveState(name, fxConfig[name].active);
  });
  
  // Create synths and channels
  Object.keys(instruments).forEach(inst => createInstrumentChain(inst));
  
  // Transport setup
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Initialize metronome
  metronome.synth = new Tone.MembraneSynth({
    pitchDecay: 0.008,
    octaves: 2,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
  }).toDestination();
  
  metronome.synth.volume.value = state.metronomeVolume;

  // Optimize instrument levels for better mix (dB-ish values)
  const MIX_PRESET = {
    // Drums
    kick:   0,    // anchor
    snare: -2,
    clap:  -3,
    hihat: -8,
    perc:  -8,
    tom:   -4,
    crash: -6,

    // Low end
    bass:  -4,

    // Harmony / chords
    keys:  -6,    // or 'piano' / 'chords' depending on your naming
    pads:  -8,

    // Melodic top
    lead:  -1,    // a bit louder so melodies stand out

    // FX / transitions
    fx:    -10,
    riser: -6,    // present but not nuking the mix
    sweep: -8
  };

  Object.entries(MIX_PRESET).forEach(([name, vol]) => {
    if (instruments[name]) {
      instruments[name].volume = vol;
    }
  });
  
  metronome.loop = new Tone.Loop((time) => {
    const step = Math.floor(Tone.Transport.position.split(':')[1]);
    const isDownbeat = step === 0;
    const pitch = isDownbeat ? 'C5' : 'C4';
    const velocity = isDownbeat ? 1 : 0.6;
    
    if (state.metronomeEnabled) {
      metronome.synth.triggerAttackRelease(pitch, '32n', time, velocity);
    }
  }, '4n');
  
  metronome.loop.start(0);
  
  // CRITICAL: Batch note triggers to reduce message handler load
  const noteQueue = [];
  let batchTimeout = null;
  
  const flushNoteQueue = (time) => {
    if (noteQueue.length === 0) return;
    
    // Sort by time to maintain order
    noteQueue.sort((a, b) => a.time - b.time);
    
    // Trigger all notes at their scheduled times
    noteQueue.forEach(({ inst, step, time: noteTime }) => {
      playStep(inst, step, noteTime);
    });
    
    noteQueue.length = 0;
  };
  
  // Main sequencer loop - DYNAMIC LENGTH
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);
  
    const activeInsts = Object.keys(instruments).filter(inst => 
      patterns[inst][step]?.active
    );
  
    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');
  
    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });
  
    melodicInsts.forEach((inst, idx) => { 
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002;
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });
  
    updateVisualizer();
  }, 
  Array.from({ length: state.sequenceLength }, (_, i) => i), 
  state.resolution);
  
  loop.loop = true;
  loop.loopEnd = state.sequenceLength;
  
  Tone.Transport.loop = true;
  Tone.Transport.loopEnd = state.sequenceLength * Tone.Time(state.resolution).toSeconds();
  
  loop.start(0);
  window.mainLoop = loop; // Store reference for disposal
  
  sequencerInitialized = true;
}

// -------------------- Lightweight Sequencer Rebuild --------------------
function initAudioLight() {
  // Reuse the existing master bus, FX, instruments, metronome, etc.
  // Only rebuild the main sequencer loop + Transport timing.

  // Kill the old loop if it exists
  if (window.mainLoop) {
    try {
      window.mainLoop.stop();
      window.mainLoop.dispose();
    } catch (e) {
      console.warn('Error disposing mainLoop (light):', e);
    }
    window.mainLoop = null;
  }

  // Transport timing based on current state
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';

  // Main sequencer loop - DYNAMIC LENGTH (same logic as in initAudio)
  const loop = new Tone.Sequence((time, step) => {
    state.currentStep = step;
    updateStepVisuals(step);

    const activeInsts = Object.keys(instruments).filter(inst =>
      patterns[inst][step]?.active
    );

    const drumInsts = activeInsts.filter(inst => instruments[inst].type === 'drum');
    const melodicInsts = activeInsts.filter(inst => instruments[inst].type !== 'drum');

    drumInsts.forEach(inst => {
      playStep(inst, step, time);
    });

    melodicInsts.forEach((inst, idx) => {
      const offset = (idx / Math.max(1, melodicInsts.length - 1)) * 0.002;
      setTimeout(() => playStep(inst, step, time + offset), 0);
    });

    updateVisualizer();
  },
  Array.from({ length: state.sequenceLength }, (_, i) => i),
  state.resolution);

  loop.loop = true;
  loop.loopEnd = state.sequenceLength;

  Tone.Transport.loop = true;
  Tone.Transport.loopEnd =
    state.sequenceLength * Tone.Time(state.resolution).toSeconds();

  loop.start(0);
  window.mainLoop = loop;

  sequencerInitialized = true;
}

// In createInstrumentChain function (around line ~676), replace with:
function createInstrumentChain(inst) {
  const instData = instruments[inst];
  
  if (instData.type === 'drum') {
    synths[inst] = createDrumSynth(inst);
  } else if (instData.type === 'atmospheric') {
    synths[inst] = createFallbackDrumSynth(inst); // Use synths for atmospheric
    synths[inst].volume = { value: instData.volume };
  } else {
    synths[inst] = createMelodicSynth(inst);
    synths[inst].volume.value = instData.volume;
  }
  
  // Create channel - completely dry, no reverb sends
  const channel = new Tone.Channel({
    pan: 0,
    volume: instData.volume
  }).connect(master.fxIn);
  
  instData.channel = channel;
  synths[inst].connect(channel);
}
  
// ============ DRUM SAMPLE SYSTEM ============
const DRUM_SAMPLES = {
  kick: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/kick.mp3',
  snare: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3',
  hihat: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3',
  tom: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/tom1.mp3',
  
  // FIXED: Using working CR78 samples
  clap: 'https://tonejs.github.io/audio/drum-samples/CR78/clap.mp3',
  rimshot: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3', // Using snare as fallback
  crash: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  ride: 'https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3', // Using hihat as fallback
  
  // NEW INSTRUMENTS - using Tone.js built-in sounds since we need synths anyway
  fx: null, // Will use synth
  riser: null, // Will use synth
  ambience: null // Will use synth
};

// Immutable copy of factory drum samples (for "Default" reset)
const DEFAULT_DRUM_SAMPLES = { ...DRUM_SAMPLES };

// ====================================================
// ðŸŽ¹ MUSIC-THEORY AWARE INSTRUMENT VARIATION SYSTEM
// ====================================================

// Use Tonal.js for proper theory (itâ€™s already in your project)
function getScaleNotes(baseKey = 'C', scaleType = 'minor', octave = 3) {
  try {
    const scale = Tonal.Scale.get(`${baseKey} ${scaleType}`);
    return scale.notes.map(n => `${n}${octave}`);
  } catch (err) {
    console.warn('Scale generation failed, falling back to C minor', err);
    return ['C3','D3','Eb3','F3','G3','Ab3','Bb3'];
  }
}

// If your Harmony tab defines a chord progression array like: 
// state.progression = [ ['C', 'E', 'G'], ['A', 'C', 'E'], ... ]
function getChordForBar(barIndex = 0) {
  if (!state.progression || !state.progression.length) return null;
  return state.progression[barIndex % state.progression.length];
}

// Return a note appropriate for instrument & current harmony
function getInstrumentNote(instName, stepIndex = 0, currentChord = null) {
  if (currentChord && Array.isArray(currentChord)) {
    const note = currentChord[Math.floor(Math.random() * currentChord.length)];
    const octave = instName === 'bass' ? state.octave - 2 : state.octave;
    return `${note.replace(/\d/, '')}${octave}`;
  }

  const scaleNotes = Tonal.Scale.get(`${state.key} ${state.scale}`).notes.map(n => `${n}${state.octave}`);
  return scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
}


// Convert note to pitch shift
function getPlaybackRateForNote(note) {
  const semitones = Tone.Frequency(note).toMidi() - Tone.Frequency('C4').toMidi();
  return Math.pow(2, semitones / 12);
}

// Wrapper for triggering a sample with key variation
function triggerSampleWithVariation(instName, time) {
  const player = samplePlayers?.[instName];
  if (!player) return;

  if (INSTRUMENT_VARIATIONS[instName]) {
    const note = getInstrumentNote(instName);
    const rate = getPlaybackRateForNote(note);
    player.playbackRate = rate;
  } else {
    player.playbackRate = 1; // drums stay neutral
  }

  player.start(time);
}

function createDrumSynth(inst) {
  const sampleUrl = DRUM_SAMPLES[inst];

  if (!sampleUrl) {
    console.warn(`No sample for ${inst}, using fallback synth`);
    return createFallbackDrumSynth(inst);
  }

  // Use Tone.Player for single-shot samples
  const player = new Tone.Player({
    url: sampleUrl,
    fadeOut: 0.01,
    onload: () => console.log(`âœ… ${inst} loaded`),
    onerror: (err) => {
      console.error(`âŒ ${inst} failed to load:`, err);
      // Replace with fallback after short delay
      setTimeout(() => {
        if (!player.loaded) {
          synths[inst] = createFallbackDrumSynth(inst);
          console.log(`ðŸ”„ Using fallback synth for ${inst}`);
        }
      }, 3000);
    }
  });

  // Per-player gain
  const BASE_GAIN = 0.6; // ~-4 dB
  const playerGain = new Tone.Gain(BASE_GAIN);
  player.connect(playerGain);

  return {
    // ==========================================================
    // Trigger with pitch variation for instruments
    // ==========================================================
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      if (!player.loaded) return;
    
      player.stop(time);
      const safeVel = Math.min(velocity, 0.9);
      playerGain.gain.setValueAtTime(BASE_GAIN * safeVel, time);
    
      // ðŸŽ¹ Apply music-theory-based pitch variation
      if (['piano','guitar','bass','synth','strings','pad','lead'].includes(inst)) {
        const noteName = getInstrumentNote(inst, 0, state.currentChord || state.progression[0]);
        const rate = getPlaybackRateForNote(noteName);
        player.playbackRate = rate;
      } else {
        player.playbackRate = 1; // keep drums neutral
      }
    
      player.start(time);
    },

    connect: (node) => {
      playerGain.disconnect();
      playerGain.connect(node);
      return playerGain;
    },

    toDestination: () => playerGain.toDestination(),
    dispose: () => {
      player.dispose();
      playerGain.dispose();
    },
    get loaded() {
      return player.loaded;
    },
    player,
    gain: playerGain
  };
}

// Add this new function after createDrumSynth
function createFallbackDrumSynth(inst) {
  let synth;
  
  switch(inst) {
    case 'kick':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
      });
      break;
      
    case 'snare':
      synth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
      });
      break;
      
    case 'hihat':
      synth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'crash':
      synth = new Tone.MetalSynth({
        frequency: 100,
        envelope: { attack: 0.001, decay: 1.4, release: 2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'ride':
      synth = new Tone.MetalSynth({
        frequency: 150,
        envelope: { attack: 0.001, decay: 0.8, release: 0.5 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
      });
      break;
      
    case 'clap':
      // Layered noise bursts for clap sound
      const clap = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      const clap2 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.015, decay: 0.03, sustain: 0 }
      });
      const clap3 = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.025, decay: 0.02, sustain: 0 }
      });
      
      // Merge into one synth
      const clapGain = new Tone.Gain(1);
      clap.connect(clapGain);
      clap2.connect(clapGain);
      clap3.connect(clapGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          clap.triggerAttackRelease(duration, time, velocity);
          clap2.triggerAttackRelease(duration, time + 0.015, velocity * 0.7);
          clap3.triggerAttackRelease(duration, time + 0.025, velocity * 0.5);
        },
        connect: (node) => clapGain.connect(node),
        toDestination: () => clapGain.toDestination(),
        dispose: () => {
          clap.dispose();
          clap2.dispose();
          clap3.dispose();
          clapGain.dispose();
        },
        loaded: true
      };
      
    case 'rimshot':
      synth = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
      });
      break;
      
    case 'tom':
      synth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.3, sustain: 0.1, release: 0.8 }
      });
      break;
      
    // NEW ATMOSPHERIC SYNTHS
    case 'fx':
      // Glitchy stutter effect
      const fxSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
        harmonicity: 12,
        modulationIndex: 50,
        resonance: 2000,
        octaves: 0.5
      });
      const fxGain = new Tone.Gain(0.2);
      fxSynth.connect(fxGain);
      
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          fxSynth.triggerAttackRelease('32n', time, velocity * 0.3);
        },
        connect: (node) => fxGain.connect(node),
        toDestination: () => fxGain.toDestination(),
        dispose: () => {
          fxSynth.dispose();
          fxGain.dispose();
        },
        loaded: true
      };
      
    case 'riser':
      // Sweeping frequency riser
      synth = new Tone.FMSynth({
        harmonicity: 3,
        modulationIndex: 10,
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 2, decay: 0.1, sustain: 0.1, release: 0.5 },
        modulation: { type: 'square' },
        modulationEnvelope: { attack: 2, decay: 0.2, sustain: 0.5, release: 0.3 }
      });
      break;
      
    case 'ambience':
      // Dark atmospheric pad
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sine' },
        envelope: { attack: 1, decay: 1, sustain: 0.5, release: 2 }
      });
      
      // Add reverb for atmosphere
      const ambReverb = new Tone.Reverb({
        decay: 8,
        wet: 0.7
      });
      ambReverb.generate();
      synth.connect(ambReverb);
      return {
        triggerAttackRelease: (note, duration, time, velocity = 1) => {
          synth.triggerAttackRelease(note, duration, time, velocity);
        },
        connect: (node) => {
          ambReverb.disconnect();
          ambReverb.connect(node);
          return ambReverb;
        },
        toDestination: () => ambReverb.toDestination(),
        dispose: () => {
          synth.dispose();
          ambReverb.dispose();
        },
        loaded: true
      };
      
    default:
      synth = new Tone.MembraneSynth();
  }
  
  return {
    triggerAttackRelease: (note, duration, time, velocity = 1) => {
      synth.triggerAttackRelease(note, duration, time, velocity);
    },
    connect: (node) => synth.connect(node),
    toDestination: () => synth.toDestination(),
    dispose: () => synth.dispose(),
    loaded: true
  };
}

function playDrumNote(inst, time, velocity) {
  const synth = synths[inst];
  if (!synth) {
    console.warn(`No synth for ${inst}`);
    return;
  }
  
  // Check if sample is loaded
  if (!synth.loaded) {
    console.warn(`${inst} sample not loaded yet`);
    return;
  }
  
  // All drums trigger at same pitch - sample handles the sound
  synth.triggerAttackRelease('C2', '8n', time, velocity * 0.9);
}

// Melodic instrument samples using Tone.Sampler
const MELODIC_SAMPLES = {
  bass: {
    'C2': 'https://tonejs.github.io/audio/salamander/C2.mp3',
    'D#2': 'https://tonejs.github.io/audio/salamander/Ds2.mp3',
    'F#2': 'https://tonejs.github.io/audio/salamander/Fs2.mp3',
    'A2': 'https://tonejs.github.io/audio/salamander/A2.mp3'
  },
  guitar: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3'
  },
  keys: {
    'C3': 'https://tonejs.github.io/audio/salamander/C3.mp3',
    'D#3': 'https://tonejs.github.io/audio/salamander/Ds3.mp3',
    'F#3': 'https://tonejs.github.io/audio/salamander/Fs3.mp3',
    'A3': 'https://tonejs.github.io/audio/salamander/A3.mp3',
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3'
  },
  lead: {
    'C4': 'https://tonejs.github.io/audio/salamander/C4.mp3',
    'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
    'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
    'A4': 'https://tonejs.github.io/audio/salamander/A4.mp3',
    'C5': 'https://tonejs.github.io/audio/salamander/C5.mp3',
    'D#5': 'https://tonejs.github.io/audio/salamander/Ds5.mp3',
    'F#5': 'https://tonejs.github.io/audio/salamander/Fs5.mp3',
    'A5': 'https://tonejs.github.io/audio/salamander/A5.mp3'
  }
};

function createMelodicSynth(inst) {
  const samples = MELODIC_SAMPLES[inst];
  
  if (!samples) {
    console.warn(`No samples for ${inst}, using fallback synth`);
    return new Tone.PolySynth(Tone.Synth);
  }
  
  const sampler = new Tone.Sampler({
    urls: samples,
    release: 2, // Longer release = more dreamy
    onload: () => {
      console.log(`âœ… ${inst} samples loaded`);
    }
  });

  sampler.volume.value = -6;
  
  switch (inst) {
    case 'bass':
      const bassComp = new Tone.Compressor(-30, 3);
      const bassDist = new Tone.Distortion(0.1);
      sampler.chain(bassDist, bassComp);
      return sampler;
      
    case 'guitar':
      // MORE reverb and chorus for dreamier sound
      const guitarReverb = new Tone.Reverb({
        decay: 3,
        wet: 0.4
      });
      guitarReverb.generate();
      
      const guitarChorus = new Tone.Chorus({
        frequency: 0.5, // Slower = dreamier
        delayTime: 3.5,
        depth: 0.3,
        type: 'sine',
        spread: 180
      }).start();
      
      sampler.chain(guitarChorus, guitarReverb);
      return sampler;
      
    case 'keys':
      // Dark pad sound
      const keysReverb = new Tone.Reverb({
        decay: 4,
        wet: 0.5
      });
      keysReverb.generate();
      
      const keysChorus = new Tone.Chorus(0.3, 4, 0.4).start();
      
      sampler.chain(keysChorus, keysReverb);
      return sampler;
      
    case 'lead':
      // Ethereal lead
      const leadReverb = new Tone.Reverb({
        decay: 5,
        wet: 0.6
      });
      leadReverb.generate();
      
      const leadDelay = new Tone.FeedbackDelay({
        delayTime: '8n',
        feedback: 0.4,
        wet: 0.3
      });
      
      sampler.chain(leadDelay, leadReverb);
      return sampler;
      
    default:
      return sampler;
  }
}

function playStep(inst, step, time) {
  const instPattern = patterns[inst];
  if (!instPattern) return;

  const stepData = instPattern[step];
  if (!stepData || !stepData.active) return;
  
  const instData = instruments[inst];
  if (instData.mute) return;
  
  const anySolo = Object.values(instruments).some(i => i.solo);
  if (anySolo && !instData.solo) return;
  
  if (Math.random() * 100 > stepData.probability) return;
  
  // ðŸ”¥ FIX: Check if sample is loaded before playing
  const synth = synths[inst];
  if (instData.type === 'drum' && synth && !synth.loaded) {
    console.warn(`âš ï¸ ${inst} sample not loaded, skipping step`);
    return;
  }
  
  // Per-instrument humanization scaling
  const humanizeScale = {
    kick: 0.5,
    snare: 0.7,
    hihat: 1.2,
    bass: 0.6,
    guitar: 1.0,
    keys: 0.8,
    lead: 0.9,
    fx: 0.3,
    riser: 0.1,
    ambience: 0.2
  };
  
  const scale = humanizeScale[inst] || 1.0;
  const humanize = (Math.random() - 0.5) * (state.humanize / 1000) * scale;
  
  let velocity = stepData.velocity;
  if (instData.type === 'drum') {
    velocity *= (0.95 + Math.random() * 0.1);
  }
  
  if (instData.type === 'drum') {
    playDrumNote(inst, time + humanize, velocity);
  } else if (instData.type === 'atmospheric') {
    playAtmosphericNote(inst, time + humanize, stepData);
  } else {
    playMelodicNote(inst, time + humanize, stepData);
  }
}

function playMelodicNote(inst, time, stepData) {
  const note = stepData.note || instruments[inst].note || 'C4';
  const duration = stepData.duration || '8n';
  synths[inst].triggerAttackRelease(note, duration, time, stepData.velocity);
}

function playAtmosphericNote(inst, time, stepData) {
  const duration = stepData.duration || '1n'; // Longer by default
  const velocity = stepData.velocity || 0.5;
  
  if (inst === 'fx') {
    // Glitchy FX - random pitch
    const pitch = ['C4', 'D#4', 'F#4', 'A#4'][Math.floor(Math.random() * 4)];
    synths[inst].triggerAttackRelease(pitch, '8n', time, velocity);
  } else if (inst === 'riser') {
    // Rising frequency sweep
    synths[inst].triggerAttackRelease('C2', '2n', time, velocity);
    // Add frequency sweep
    if (synths[inst].frequency) {
      synths[inst].frequency.exponentialRampTo('C6', '2n', time);
    }
  } else if (inst === 'ambience') {
    // Dark ambient chord
    const notes = ['C2', 'D#2', 'G2', 'A#2'];
    synths[inst].triggerAttackRelease(notes, duration, time, velocity * 0.4);
  }
}
  
// -------------------- Vibe System --------------------
function nextVibe() {
  const currentVibe = document.body.getAttribute('data-vibe') || 'moon';
  const currentIndex = VIBES.indexOf(currentVibe);
  const nextIndex = (currentIndex + 1) % VIBES.length;
  return VIBES[nextIndex];
}

function applyVibe(vibe) {
  document.body.setAttribute('data-vibe', vibe);
  try {
    localStorage.setItem(CONFIG.STORAGE_KEY, vibe);
    console.log('ðŸ’¾ Saved vibe:', vibe);
  } catch (e) {
    console.warn('localStorage unavailable:', e);
  }
  
  const label = vibe.charAt(0).toUpperCase() + vibe.slice(1);
  const btn = document.getElementById('vibeBtn');
  if (btn) btn.textContent = `ðŸŒˆ Vibe: ${label}`;
}

function loadSavedVibe() {
  try {
    const savedVibe = localStorage.getItem(CONFIG.STORAGE_KEY);
    if (savedVibe && VIBES.includes(savedVibe)) {
      applyVibe(savedVibe);
      console.log('âœ… Loaded saved vibe:', savedVibe);
    } else {
      applyVibe('moon');
    }
  } catch (e) {
    console.warn('Could not load vibe:', e);
    applyVibe('moon');
  }
}

function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      const next = nextVibe();
      applyVibe(next);
      console.log('ðŸŒˆ Switched to:', next);
    });
  }
}

// ==================== SONG BUILDER ENGINE ====================

// 16 steps per bar (your existing grid resolution)
const STEPS_PER_BAR = 16;

const SONG_TEMPLATES = {
  // --- POP / ROCK ---
  'intro-verse-chorus': [
    { id:'intro', label:'Intro', bars:4, energy:0.3, density:0.4, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.6, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus 1', bars:8, energy:0.9, density:0.8, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'bridge', label:'Bridge', bars:4, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.4, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'sustained', melodyStyle:'scale-run' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.6, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- EDM / HOUSE ---
  'short-edm-rise-drop': [
    { id:'intro', label:'Intro', bars:4, energy:0.4, density:0.5, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'build', label:'Build', bars:8, energy:0.7, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'break', label:'Break', bars:4, energy:0.5, density:0.4, swing:0, filterCutoff:0.8, reverb:0.6, variation:'a', drums:false, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drop2', label:'Drop 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.6, reverb:0.7, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- HIP-HOP / LOFI ---
  'hiphop-lofi': [
    { id:'intro', label:'Intro', bars:4, energy:0.3, density:0.4, swing:30, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:16, energy:0.6, density:0.5, swing:30, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'syncopated', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'hook', label:'Hook', bars:8, energy:0.8, density:0.7, swing:30, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'verse2', label:'Verse 2', bars:16, energy:0.7, density:0.5, swing:30, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'syncopated', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'hook2', label:'Hook 2', bars:8, energy:0.9, density:0.8, swing:30, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:30, filterCutoff:0.7, reverb:0.6, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- METAL / HARDCORE ---
  'metal-hardcore': [
    { id:'intro', label:'Intro Riff', bars:4, energy:0.7, density:0.7, swing:0, filterCutoff:1.0, reverb:0.2, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.2, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus 1', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.9, density:0.8, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'solo', label:'Solo', bars:8, energy:1.0, density:0.8, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'scale-run' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.6, density:0.5, swing:0, filterCutoff:0.8, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- AMBIENT / DOWNTEMPO ---
  'ambient-flow': [
    { id:'drift1', label:'Drift A', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.9, reverb:0.8, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drift2', label:'Drift B', bars:8, energy:0.4, density:0.4, swing:0, filterCutoff:0.95, reverb:0.7, variation:'b', drums:false, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'drift3', label:'Drift C', bars:8, energy:0.5, density:0.5, swing:0, filterCutoff:1.0, reverb:0.6, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'fade', label:'Fade', bars:8, energy:0.2, density:0.2, swing:0, filterCutoff:0.7, reverb:0.9, variation:'a', drums:false, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- JAM / IMPROV LOOP ---
  'loop-jam': [
    { id:'a1', label:'A1', bars:8, energy:0.6, density:0.6, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'a2', label:'A2', bars:8, energy:0.7, density:0.7, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'b', label:'B', bars:8, energy:0.9, density:0.8, swing:10, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'a3', label:'A3', bars:8, energy:0.7, density:0.7, swing:10, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' }
  ],

  // --- TRAP / MODERN HIP-HOP ---
  'trap-banger': [
    { id:'intro', label:'Intro', bars:4, energy:0.5, density:0.5, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'prechorus1', label:'Pre-Chorus', bars:4, energy:0.8, density:0.7, swing:0, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:1.0, density:0.8, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.6, swing:0, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'trap', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'bridge', label:'Bridge/Half-time', bars:8, energy:0.6, density:0.5, swing:0, filterCutoff:0.9, reverb:0.6, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:true, bass:true, chords:false, lead:false, drumPattern:'trap', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- PROGRESSIVE HOUSE / TRANCE ---
  'progressive-house': [
    { id:'intro', label:'Intro', bars:8, energy:0.3, density:0.4, swing:0, filterCutoff:0.8, reverb:0.5, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup1', label:'Build 1', bars:8, energy:0.6, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup2', label:'Build 2', bars:8, energy:0.7, density:0.8, swing:0, filterCutoff:0.95, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'arpeggiated', melodyStyle:'scale-run' },
    { id:'drop2', label:'Drop 2', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.6, reverb:0.8, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- FUNK / DISCO ---
  'funk-groove': [
    { id:'intro', label:'Intro', bars:4, energy:0.5, density:0.6, swing:20, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:8, energy:0.7, density:0.7, swing:20, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:0.9, density:0.8, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'verse2', label:'Verse 2', bars:8, energy:0.7, density:0.7, swing:20, filterCutoff:1.0, reverb:0.3, variation:'b', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.6, density:0.5, swing:20, filterCutoff:0.9, reverb:0.5, variation:'c', drums:false, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus 2', bars:8, energy:1.0, density:0.9, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'dense' },
    { id:'outro', label:'Vamp Out', bars:8, energy:0.8, density:0.7, swing:20, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'motif' }
  ],

  // --- JAZZ / FUSION ---
  'jazz-standard': [
    { id:'head-in', label:'Head In', bars:16, energy:0.6, density:0.6, swing:50, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'solo1', label:'Solo Section 1', bars:16, energy:0.7, density:0.7, swing:50, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'scale-run' },
    { id:'solo2', label:'Solo Section 2', bars:16, energy:0.8, density:0.8, swing:50, filterCutoff:1.0, reverb:0.4, variation:'c', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'dense' },
    { id:'head-out', label:'Head Out', bars:16, energy:0.7, density:0.6, swing:50, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'arpeggiated', melodyStyle:'motif' },
    { id:'tag', label:'Tag', bars:4, energy:0.5, density:0.4, swing:50, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'breakbeat', bassPattern:'walking', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- DUBSTEP / BASS MUSIC ---
  'dubstep-wobble': [
    { id:'intro', label:'Intro', bars:8, energy:0.4, density:0.4, swing:0, filterCutoff:0.8, reverb:0.5, variation:'a', drums:true, bass:false, chords:true, lead:true, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup', label:'Build Up', bars:8, energy:0.7, density:0.7, swing:0, filterCutoff:0.9, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'drop1', label:'Drop 1', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:false, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'breakdown', label:'Breakdown', bars:8, energy:0.3, density:0.3, swing:0, filterCutoff:0.6, reverb:0.8, variation:'a', drums:false, bass:false, chords:true, lead:true, drumPattern:'half-time', bassPattern:'pedal', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'buildup2', label:'Build 2', bars:4, energy:0.8, density:0.8, swing:0, filterCutoff:0.95, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'rhythmic', melodyStyle:'scale-run' },
    { id:'drop2', label:'Drop 2', bars:16, energy:1.0, density:0.9, swing:0, filterCutoff:1.0, reverb:0.3, variation:'a', drums:true, bass:true, chords:false, lead:true, drumPattern:'half-time', bassPattern:'syncopated', chordPattern:'staccato', melodyStyle:'dense' },
    { id:'outro', label:'Outro', bars:4, energy:0.4, density:0.3, swing:0, filterCutoff:0.7, reverb:0.7, variation:'a', drums:true, bass:false, chords:true, lead:false, drumPattern:'half-time', bassPattern:'root-fifth', chordPattern:'sustained', melodyStyle:'sparse' }
  ],

  // --- REGGAE / DUB ---
  'reggae-dub': [
    { id:'intro', label:'Intro Skank', bars:8, energy:0.5, density:0.5, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:false, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'sparse' },
    { id:'verse1', label:'Verse 1', bars:16, energy:0.6, density:0.5, swing:10, filterCutoff:1.0, reverb:0.4, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'chorus1', label:'Chorus', bars:8, energy:0.8, density:0.7, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' },
    { id:'verse2', label:'Verse 2', bars:16, energy:0.6, density:0.5, swing:10, filterCutoff:1.0, reverb:0.4, variation:'b', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'staccato', melodyStyle:'motif' },
    { id:'dub-section', label:'Dub Drop', bars:16, energy:0.7, density:0.6, swing:10, filterCutoff:0.8, reverb:0.8, variation:'c', drums:true, bass:true, chords:false, lead:false, drumPattern:'four-floor', bassPattern:'syncopated', chordPattern:'sustained', melodyStyle:'sparse' },
    { id:'chorus2', label:'Chorus Out', bars:8, energy:0.8, density:0.7, swing:10, filterCutoff:1.0, reverb:0.5, variation:'a', drums:true, bass:true, chords:true, lead:true, drumPattern:'four-floor', bassPattern:'root-fifth', chordPattern:'rhythmic', melodyStyle:'motif' }
  ]
};

// ==================== TEMPLATE â†’ GENRE AUTO-LINK ====================

const TEMPLATE_TO_GENRE = {
  // --- Core mappings (auto-detected by templateId) ---
  'intro-verse-chorus'   : 'poprock',
  'short-edm-rise-drop'  : 'edm',
  'hiphop-lofi'          : 'lofi',
  'metal-hardcore'       : 'metal',
  'ambient-flow'         : 'ambient',
  'loop-jam'             : 'lofi',
  'trap-banger'          : 'trap',
  'progressive-house'    : 'edm',
  'funk-groove'          : 'funk',
  'jazz-standard'        : 'jazz',
  'dubstep-wobble'       : 'dubstep',
  'reggae-dub'           : 'reggae'
};

const GENRE_PROFILES = {
  lofi:   { keys:['A','B','C','D','E','F','G'], scales:['minor','dorian','mixolydian'],
            progressions:[[0,5,3,4],[0,3,5,4],[5,3,0,4]] },
  hiphop: { keys:['C','D','E','F','G','A','B'], scales:['minor','phrygian','dorian'],
            progressions:[[5,3,0,4],[0,5,4,3],[0,2,3,5]] },
  trap:   { keys:['D','E','F','G','A','B'], scales:['phrygian','aeolian','minor'],
            progressions:[[0,5,3,4],[0,2,3,5],[0,5,4,3]] },
  rnb:    { keys:['C','D','E','F','G','A'], scales:['major','lydian','mixolydian'],
            progressions:[[0,4,5,3],[0,2,3,5],[0,5,3,4]] },
  poprock:{ keys:['C','D','E','F','G','A','B'], scales:['major','mixolydian','minor'],
            progressions:[[0,4,5,3],[0,5,3,4],[0,4,3,5]] },
  funk:   { keys:['E','F','G','A','B','C','D'], scales:['mixolydian','dorian','major'],
            progressions:[[0,3,5,4],[0,4,5,3],[5,3,0,4]] },
  jazz:   { keys:['C','F','Bb','Eb','G','A'], scales:['mixolydian','dorian','lydian'],
            progressions:[[0,2,5,3],[0,3,4,5],[5,3,0,4]] },
  metal:  { keys:['D','E','F','G','A','B'], scales:['phrygian','aeolian','locrian'],
            progressions:[[0,5,3,4],[0,2,3,5],[0,5,4,3]] },
  edm:    { keys:['C','D','E','F','G','A','B'], scales:['major','mixolydian','minor'],
            progressions:[[0,4,3,5],[0,5,3,4],[0,3,4,5]] },
  ambient:{ keys:['C','D','E','F','G','A','B'], scales:['lydian','mixolydian','major'],
            progressions:[[0,3,4,5],[0,4,3,5],[0,5,4,3]] },
  dubstep:{ keys:['D','E','F','G','A','B'], scales:['phrygian','aeolian','minor'],
            progressions:[[0,5,3,4],[0,2,3,5],[0,5,4,3]] },
  reggae: { keys:['A','B','C','D','E','F','G'], scales:['mixolydian','major','dorian'],
            progressions:[[0,4,5,3],[0,5,3,4],[5,3,0,4]] },
  default:{ keys:['C','D','E','F','G','A','B'], scales:['major','minor'],
            progressions:[[0,5,3,4],[0,4,3,5],[5,3,0,4]] }
};
  
  // At the top with other state
let songBuilderState = {
  templateId: 'intro-verse-chorus',
  sections: SONG_TEMPLATES['intro-verse-chorus'].map(s => ({ ...s })),
  fillEvery: 4,
  durationMins: 2,
  isActive: false,  // ADD THIS FLAG
  genre: state.currentGenre,
  mood: (state && state.mood) || 'default'
};

// ============================================================================
// GLOBAL MOOD PROFILE (shared: drums / bass / chords / FX / transitions)
// ============================================================================

function getCurrentMood(section) {
  // section-level override if you ever add it
  if (section && section.mood) return section.mood;

  if (typeof songBuilderState !== 'undefined' && songBuilderState.mood) {
    return songBuilderState.mood;
  }
  return (state && state.mood) || 'default';
}

function getGlobalMoodProfile(mood, section) {
  const energy = section?.energy ?? 0.5;

  // Keep aliases in sync with your melody engine
  const moodAlias = {
    chill      : 'mellow',
    relaxed    : 'mellow',
    happy      : 'uplift',
    uplifting  : 'uplift',
    hype       : 'uplift',
    moody      : 'dark',
    angry      : 'tense',
    aggressive : 'tense'
  };

  const m = moodAlias[mood] || mood || 'default';

  const base = {
    energy,              // carry section energy

    // Drums
    drumDensityMul   : 1.0,
    drumGhostMul     : 1.0,
    drumFillMul      : 1.0,
    hatOpenMul       : 1.0,

    // Bass
    bassMovementMul  : 1.0,
    bassRegisterOff  : 0,

    // Harmony / chords
    chordTensionMul  : 1.0,
    chordSpreadMul   : 1.0,

    // FX / transitions
    fxRiserStrength   : 1.0,
    fxImpactStrength  : 1.0,
    fxReverseStrength : 1.0
  };

  const byMood = {
    default: {},

    dark: {
      drumDensityMul   : 0.9,
      drumGhostMul     : 0.9,
      drumFillMul      : 0.9,
      bassMovementMul  : 0.9,
      bassRegisterOff  : -1,
      chordTensionMul  : 1.2,
      chordSpreadMul   : 0.9,
      fxRiserStrength  : 0.9,
      fxImpactStrength : 1.1,
      fxReverseStrength: 1.0
    },

    sad: {
      drumDensityMul    : 0.6,
      drumGhostMul      : 0.7,
      drumFillMul       : 0.6,
      bassMovementMul   : 0.7,
      bassRegisterOff   : -1,
      chordTensionMul   : 1.0,
      chordSpreadMul    : 1.1,
      fxRiserStrength   : 0.7,
      fxImpactStrength  : 0.8,
      fxReverseStrength : 1.2
    },

    tense: {
      drumDensityMul   : 1.3,
      drumGhostMul     : 1.4,
      drumFillMul      : 1.4,
      hatOpenMul       : 1.2,
      bassMovementMul  : 1.3,
      chordTensionMul  : 1.4,
      chordSpreadMul   : 1.1,
      fxRiserStrength  : 1.5,
      fxImpactStrength : 1.4,
      fxReverseStrength: 1.1
    },

    mellow: {
      drumDensityMul   : 0.85,
      drumGhostMul     : 0.8,
      drumFillMul      : 0.8,
      hatOpenMul       : 0.8,
      bassMovementMul  : 0.9,
      chordTensionMul  : 0.9,
      chordSpreadMul   : 1.05,
      fxRiserStrength  : 0.9,
      fxImpactStrength : 0.9,
      fxReverseStrength: 1.0
    },

    dreamy: {
      drumDensityMul    : 0.8,
      drumGhostMul      : 0.9,
      drumFillMul       : 0.8,
      hatOpenMul        : 1.0,
      bassMovementMul   : 0.8,
      bassRegisterOff   : +1,
      chordTensionMul   : 1.1,
      chordSpreadMul    : 1.2,
      fxRiserStrength   : 1.3,
      fxImpactStrength  : 0.95,
      fxReverseStrength : 1.3
    },

    uplift: {
      drumDensityMul   : 1.15,
      drumGhostMul     : 1.1,
      drumFillMul      : 1.1,
      hatOpenMul       : 1.2,
      bassMovementMul  : 1.2,
      chordTensionMul  : 1.2,
      chordSpreadMul   : 1.2,
      fxRiserStrength  : 1.3,
      fxImpactStrength : 1.3,
      fxReverseStrength: 1.0
    }
  };

  return { ...base, ...(byMood[m] || {}) };
}

// ===== RISER AUTOMATION SCHEDULER HELPERS =====
songBuilderState._riserAutoIds = songBuilderState._riserAutoIds || [];

function clearRiserAutomation() {
  (songBuilderState._riserAutoIds || []).forEach(id => Tone.Transport.clear(id));
  songBuilderState._riserAutoIds = [];
}

function scheduleAndTrack(callback, time) {
  const id = Tone.Transport.schedule(callback, time);
  songBuilderState._riserAutoIds.push(id);
  return id;
}

// Genre-aware riser length
function getGenreAwareRiserBars(genre, prevSectionBars) {
  const base = {
    lofi: 1, hiphop: 1, rnb: 1, postpunk: 1, rock: 1, metal: 1,
    ambient: 2, pop: 2, edm: 4, dazecore: 2
  };
  const g = (genre || '').toLowerCase();
  let bars = base[g] ?? 2;
  if ((prevSectionBars|0) >= 4) bars = Math.max(bars, Math.min(4, Math.ceil(prevSectionBars / 2)));
  return Math.max(1, Math.min(4, bars));
}

// ===== MASTER AUTOMATION DURING RISERS =====
// Duck the overall volume a touch and (optionally) raise a master high-pass cutoff.
// Works without any special buses: uses Tone.Destination.volume for ducking.
// If you have a master HP filter node, expose it as window.masterHP (Tone.Filter type='highpass').

// ===== MASTER DUCK + OPTIONAL HP SWEEP, ALIGNED TO A RISER =====
function scheduleRiserMasterAutomation({
  targetDownbeat,
  bars = 2,
  duckDb = -3,
  hpMin = 30,
  hpMax = 160
}) {
  const targetSecs   = Tone.Time(targetDownbeat).toSeconds();
  const durSecs      = Tone.Time(`${bars}m`).toSeconds();
  const startSecs    = Math.max(0, targetSecs - durSecs);
  const startMusical = Tone.Time(startSecs).toBarsBeatsSixteenths();

  // DUCK: ramp overall volume down slightly across the riser, restore on drop
  scheduleAndTrack((t) => {
    const vol = Tone.Destination.volume;
    const startVol = vol.value;                // capture current
    vol.cancelScheduledValues(t);
    vol.setValueAtTime(startVol, t);
    vol.rampTo(duckDb, durSecs * 0.95);        // gentle dip during riser
    scheduleRiserMasterAutomation._lastStartVol = startVol;
  }, startMusical);

  scheduleAndTrack((t) => {
    const vol = Tone.Destination.volume;
    const startVol = scheduleRiserMasterAutomation._lastStartVol ?? 0;
    vol.cancelScheduledValues(t);
    vol.setValueAtTime(vol.value, t);
    vol.rampTo(startVol, 0.02);                // snap back on the drop
  }, targetDownbeat);

  // OPTIONAL HP SWEEP (only if window.masterHP is present)
  if (window.masterHP instanceof Tone.Filter && window.masterHP.type === 'highpass') {
    const minF = Math.max(20, hpMin|0);
    const maxF = Math.min(400, hpMax|0);

    scheduleAndTrack((t) => {
      const f = window.masterHP.frequency;
      f.cancelScheduledValues(t);
      f.setValueAtTime(minF, t);
      f.linearRampToValueAtTime(maxF, t + durSecs * 0.95);
    }, startMusical);

    scheduleAndTrack((t) => {
      const f = window.masterHP.frequency;
      f.cancelScheduledValues(t);
      f.setValueAtTime(minF, t); // full low-end back on drop
    }, targetDownbeat);
  }
}

// ===== ADD RISERS + MASTER AUTOMATION ACROSS STRUCTURE =====
function augmentTransitionsWithRisers(structure) {
  if (!structure || !Array.isArray(structure.sections)) return;

  const genre = (window.state && state.currentGenre) ? state.currentGenre : 'lofi';
  const worthyTargets = new Set(['chorus','drop','hook','biglift']);
  const likelyBuilds  = new Set(['build','pre','prechorus']);

  // Clear any previous riser automation so rebuilds don't stack
  clearRiserAutomation();

  for (let i = 0; i < structure.sections.length; i++) {
    const sec  = structure.sections[i];
    const prev = structure.sections[i - 1];
    if (!sec) continue;

    if (!worthyTargets.has(sec.type)) continue;

    // Decide riser bars (genre-aware + context-aware)
    const prevBars = prev ? (prev.lengthBars|0) : 2;
    let riserBars = getGenreAwareRiserBars(genre, prevBars);
    if (prev && (likelyBuilds.has(prev.type) || prev.lengthBars >= 4))
      riserBars = Math.min(4, Math.max(riserBars, 2));

    // Target downbeat (start of the target section)
    const targetDownbeat = `${sec.startBar}:0:0`;

    // 1) Place the riser (sample-backed or synth fallback)
    if (typeof scheduleSampleRiser === 'function') {
      // sample version backtimes automatically to end on the downbeat
      scheduleSampleRiser({ startTime: targetDownbeat, bars: riserBars });
    } else if (typeof scheduleSynthRiser === 'function') {
      // synth version needs explicit backtime: start at (target - bars)
      const startBars = Math.max(0, sec.startBar - riserBars);
      scheduleSynthRiser({ startTime: `${startBars}:0:0`, bars: riserBars });
    }

    // 2) Master automation aligned to the same riser window
    const lowEndGenres = ['lofi','hiphop','metal','postpunk','rnb'];
    const useHp = !lowEndGenres.includes((genre || '').toLowerCase());

    scheduleRiserMasterAutomation({
      targetDownbeat,
      bars: riserBars,
      duckDb: -3,
      hpMin: 30,
      hpMax: useHp ? (['edm','pop','ambient','dazecore'].includes((genre||'').toLowerCase()) ? 180 : 140) : 30
    });

    // 3) Optional: impact FX on the downbeat if you have an 'fx' lane
    if (window.sbSetStep && window.STEPS_PER_BAR && window.patterns && patterns.fx) {
      sbSetStep('fx', sec.startBar * STEPS_PER_BAR, {
        velocity: 0.9,
        probability: 100,
        duration: '2n'
      });
    }
  }
}

// Small helper for safe step activation
function sbSetStep(inst, stepIndex, opts = {}) {
  const arr = patterns[inst];
  if (!arr || stepIndex < 0 || stepIndex >= arr.length) return;
  const step = arr[stepIndex];
  const {
    velocity   = 0.8,
    probability = 100,
    note       = step.note || instruments[inst]?.note,
    duration   = '8n'
  } = opts;

  step.active = true;
  step.velocity = velocity;
  step.probability = probability;
  step.note = note;
  step.duration = duration;
}

function getSongBuilderTotalBars() {
  return songBuilderState.sections.reduce((sum, s) => sum + (s.bars || 0), 0);
}

function randomizeSongBuilderSections() {
  if (!songBuilderState.sections || !songBuilderState.sections.length) return;

  const template = SONG_TEMPLATES[songBuilderState.templateId] || songBuilderState.sections;

  const drumPatterns  = ['four-floor', 'breakbeat', 'trap', 'half-time'];
  const bassPatterns  = ['root-fifth', 'walking', 'syncopated', 'pedal'];
  const chordPatterns = ['sustained', 'arpeggiated', 'rhythmic', 'staccato'];
  const melodyStyles  = ['sparse', 'motif', 'scale-run', 'dense'];

  const randFrom = (arr, prefer) => {
    // 40% chance to keep the current/base value so it still â€œfeelsâ€ like the template,
    // otherwise pick something else
    if (prefer && arr.includes(prefer) && Math.random() < 0.4) return prefer;
    return arr[Math.floor(Math.random() * arr.length)];
  };

  const energyJitter  = 0.18;  // how far we can nudge energy
  const densityJitter = 0.20;  // how far we can nudge density

  songBuilderState.sections = songBuilderState.sections.map((section, idx) => {
    const base = template[idx] || section;

    const baseEnergy  = typeof base.energy  === 'number' ? base.energy  : (section.energy  ?? 0.7);
    const baseDensity = typeof base.density === 'number' ? base.density : (section.density ?? 0.7);

    let energy  = baseEnergy  + ((Math.random() * 2 - 1) * energyJitter);
    let density = baseDensity + ((Math.random() * 2 - 1) * densityJitter);

    energy  = clamp(energy,  0.1, 1.0);
    density = clamp(density, 0.15, 1.0);

    // --- Instrument on/off toggles ---
    let drums  = base.drums;
    let bass   = base.bass;
    let chords = base.chords;
    let lead   = base.lead;

    const id = (base.id || section.id || '').toLowerCase();
    const isIntro = id.includes('intro');
    const isOutro = id.includes('outro') || id.includes('end');
    const isBreak = id.includes('break') || id.includes('dub') || id.includes('drop');

    const flip = (value, prob) => (Math.random() < prob ? !value : value);

    if (isIntro) {
      drums  = flip(drums, 0.25);
      bass   = flip(bass, 0.35);
      chords = flip(chords, 0.15);
      lead   = flip(lead, 0.40);
    } else if (isOutro) {
      drums  = flip(drums, 0.20);
      bass   = flip(bass, 0.25);
      chords = flip(chords, 0.25);
      lead   = flip(lead, 0.50);
    } else if (isBreak) {
      drums  = flip(drums, 0.35);
      bass   = flip(bass, 0.45);
      chords = flip(chords, 0.40);
      lead   = flip(lead, 0.40);
    } else {
      // verses / choruses: subtle variation
      drums  = flip(drums, 0.15);
      bass   = flip(bass, 0.15);
      chords = flip(chords, 0.15);
      lead   = flip(lead, 0.30);
    }

    // Make sure we donâ€™t kill *all* harmonic content
    if (!bass && !chords && !lead) {
      chords = true;
    }

    const drumPattern  = randFrom(drumPatterns,  base.drumPattern  || section.drumPattern);
    const bassPattern  = randFrom(bassPatterns,  base.bassPattern  || section.bassPattern);
    const chordPattern = randFrom(chordPatterns, base.chordPattern || section.chordPattern);
    const melodyStyle  = randFrom(melodyStyles,  base.melodyStyle  || section.melodyStyle);

    return {
      ...section,
      energy,
      density,
      drums,
      bass,
      chords,
      lead,
      drumPattern,
      bassPattern,
      chordPattern,
      melodyStyle
      // bars stay as-is so your total length + 512-step cap stay predictable
    };
  });

  // Re-render the table so sliders / selects / toggles reflect the new values
  renderSongBuilderSections();
}

function applySongTemplate(id) {
  const tpl = SONG_TEMPLATES[id];
  if (!tpl) return;
  songBuilderState.templateId = id;
  songBuilderState.sections = tpl.map(s => ({ ...s }));
  renderSongBuilderSections();
}

function renderSongBuilderSections() {
  const tbody = document.getElementById('songSectionsTable');
  const totalLabel = document.getElementById('songTotalBarsLabel');
  if (!tbody) return;
  tbody.innerHTML = '';
  
  songBuilderState.sections.forEach((section, index) => {
    const tr = document.createElement('tr');
    tr.dataset.index = index;

    const sectionMood = section.mood || '';
    
    tr.innerHTML = `
      <td style="padding:6px 4px;">
        <span>${section.label}</span>
      </td>
      <td style="padding:6px 4px;">
        <input type="number"
               class="input"
               min="2" max="64"
               value="${section.bars}"
               data-field="bars"
               style="width:56px; padding:2px 4px; font-size:10px;">
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="range"
                 min="0" max="100"
                 value="${Math.round((section.energy || 0) * 100)}"
                 data-field="energy"
                 style="flex:1;">
          <span style="width:32px; text-align:right;">
            ${Math.round((section.energy || 0) * 100)}%
          </span>
        </div>
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="range"
                 min="0" max="100"
                 value="${Math.round((section.density || 0.7) * 100)}"
                 data-field="density"
                 style="flex:1;">
          <span style="width:32px; text-align:right;">
            ${Math.round((section.density || 0.7) * 100)}%
          </span>
        </div>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="drumPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="four-floor" ${(section.drumPattern || 'four-floor') === 'four-floor' ? 'selected' : ''}>4-Floor</option>
          <option value="breakbeat" ${section.drumPattern === 'breakbeat' ? 'selected' : ''}>Breakbeat</option>
          <option value="trap" ${section.drumPattern === 'trap' ? 'selected' : ''}>Trap</option>
          <option value="half-time" ${section.drumPattern === 'half-time' ? 'selected' : ''}>Half-time</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="bassPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="root-fifth" ${(section.bassPattern || 'root-fifth') === 'root-fifth' ? 'selected' : ''}>Root-Fifth</option>
          <option value="walking" ${section.bassPattern === 'walking' ? 'selected' : ''}>Walking</option>
          <option value="syncopated" ${section.bassPattern === 'syncopated' ? 'selected' : ''}>Syncopated</option>
          <option value="pedal" ${section.bassPattern === 'pedal' ? 'selected' : ''}>Pedal</option>
        </select>
      </td>
      <td style="padding:6px 4px%;">
        <select data-field="chordPattern" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="sustained" ${(section.chordPattern || 'sustained') === 'sustained' ? 'selected' : ''}>Sustained</option>
          <option value="staccato" ${section.chordPattern === 'staccato' ? 'selected' : ''}>Staccato</option>
          <option value="arpeggiated" ${section.chordPattern === 'arpeggiated' ? 'selected' : ''}>Arpeggiated</option>
          <option value="rhythmic" ${section.chordPattern === 'rhythmic' ? 'selected' : ''}>Rhythmic</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <select data-field="melodyStyle" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
          <option value="motif" ${(section.melodyStyle || 'motif') === 'motif' ? 'selected' : ''}>Motif</option>
          <option value="scale-run" ${section.melodyStyle === 'scale-run' ? 'selected' : ''}>Scale Run</option>
          <option value="sparse" ${section.melodyStyle === 'sparse' ? 'selected' : ''}>Sparse</option>
          <option value="dense" ${section.melodyStyle === 'dense' ? 'selected' : ''}>Dense</option>
        </select>
      </td>
      <td style="padding:6px 4px;">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <label><input type="checkbox" data-field="drums"  ${section.drums  ? 'checked' : ''}> Drums</label>
          <label><input type="checkbox" data-field="bass"   ${section.bass   ? 'checked' : ''}> Bass</label>
          <label><input type="checkbox" data-field="chords" ${section.chords ? 'checked' : ''}> Chords</label>
          <label><input type="checkbox" data-field="lead"   ${section.lead   ? 'checked' : ''}> Lead</label>
        </div>
        <div style="margin-top:4px;">
          <select data-field="mood" class="input" style="width:100%; padding:2px 4px; font-size:10px;">
            <option value="">Mood: inherit</option>
            <option value="mellow" ${sectionMood === 'mellow' ? 'selected' : ''}>Mellow</option>
            <option value="dreamy" ${sectionMood === 'dreamy' ? 'selected' : ''}>Dreamy</option>
            <option value="dark"   ${sectionMood === 'dark'   ? 'selected' : ''}>Dark</option>
            <option value="sad"    ${sectionMood === 'sad'    ? 'selected' : ''}>Sad</option>
            <option value="tense"  ${sectionMood === 'tense'  ? 'selected' : ''}>Tense</option>
            <option value="uplift" ${sectionMood === 'uplift' ? 'selected' : ''}>Uplift</option>
          </select>
        </div>
      </td>
    `;
    
    tbody.appendChild(tr);
  });
  
  // Wire changes
  tbody.querySelectorAll('input, select').forEach(input => {
    input.addEventListener('change', e => {
      const row = e.target.closest('tr');
      const idx = parseInt(row.dataset.index, 10);
      const field = e.target.dataset.field;
      const section = songBuilderState.sections[idx];
      if (!section) return;
      
      if (field === 'bars') {
        const v = Math.max(2, Math.min(64, parseInt(e.target.value || '0', 10)));
        section.bars = v;
        e.target.value = v;
      } else if (field === 'energy') {
        const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
        section.energy = pct / 100;
        const label = row.querySelector('td:nth-child(3) span:last-child');
        if (label) label.textContent = pct + '%';
      } else if (field === 'density') {
        const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
        section.density = pct / 100;
        const label = row.querySelector('td:nth-child(4) span:last-child');
        if (label) label.textContent = pct + '%';
      } else if (['drumPattern', 'bassPattern', 'chordPattern', 'melodyStyle'].includes(field)) {
        section[field] = e.target.value;
      } else if (['drums','bass','chords','lead'].includes(field)) {
        section[field] = e.target.checked;
      } else if (field === 'mood') {
        const v = e.target.value || null;   // null = inherit
        section.mood = v;
      }
      
      if (totalLabel) {
        totalLabel.textContent = getSongBuilderTotalBars();
      }
    });
    
    // For range inputs, also update on 'input' event for live feedback
    if (input.type === 'range') {
      input.addEventListener('input', e => {
        const row = e.target.closest('tr');
        const idx = parseInt(row.dataset.index, 10);
        const field = e.target.dataset.field;
        const section = songBuilderState.sections[idx];
        if (!section) return;
        
        if (field === 'energy') {
          const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
          section.energy = pct / 100;
          const label = row.querySelector('td:nth-child(3) span:last-child');
          if (label) label.textContent = pct + '%';
        } else if (field === 'density') {
          const pct = Math.max(0, Math.min(100, parseInt(e.target.value || '0', 10)));
          section.density = pct / 100;
          const label = row.querySelector('td:nth-child(4) span:last-child');
          if (label) label.textContent = pct + '%';
        }
      });
    }
  });
  
  if (totalLabel) {
    totalLabel.textContent = getSongBuilderTotalBars();
  }
}

// === Core generation ===

function wipeAllPatterns() {
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
}

// --- Song Builder randomness helpers ---

function sbClamp01(v) {
  return Math.max(0, Math.min(1, v));
}

function sbEnergyBand(e) {
  if (e <= 0.4) return 'low';
  if (e >= 0.75) return 'high';
  return 'mid';
}

function sbPick(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function getGenreAwareRiserBars(genre, prevSectionBars) {
  // sensible defaults
  const base = {
    lofi: 1,
    hiphop: 1,
    rnb: 1,
    ambient: 2,
    postpunk: 1,
    rock: 1,
    metal: 1,
    pop: 2,
    edm: 4,
    dazecore: 2
  };
  const g = (genre || '').toLowerCase();
  let bars = base[g] ?? 2;

  // if the previous section is already long or explicitly a "build", allow a bit more
  if (prevSectionBars >= 4) bars = Math.max(bars, Math.min(4, Math.ceil(prevSectionBars / 2)));

  // clamp 1..4
  return Math.max(1, Math.min(4, bars));
}
  
// ==================== DURATION + GENRE AWARE SECTION RANDOMIZER ====================
function randomizeSongBuilderSectionsForRun() {
  const templateId = songBuilderState.templateId || 'intro-verse-chorus';
  const baseSections = SONG_TEMPLATES[templateId] || [];
  const duration = songBuilderState.durationMins || 2;
  const genre = songBuilderState.genre || state.currentGenre || 'lofi';

  // --- Genre behaviour profiles ---
  const GENRE_BEHAVIOUR = {
    lofi:     { avgBars: 6,  extFactor: 0.9,  extraChorus: false, smoothFlow: true },
    hiphop:   { avgBars: 8,  extFactor: 1.0,  extraChorus: true,  smoothFlow: false },
    trap:     { avgBars: 8,  extFactor: 1.1,  extraChorus: true,  smoothFlow: false },
    metal:    { avgBars: 8,  extFactor: 1.2,  extraChorus: true,  smoothFlow: false },
    poprock:  { avgBars: 8,  extFactor: 1.0,  extraChorus: true,  smoothFlow: true  },
    funk:     { avgBars: 8,  extFactor: 1.0,  extraChorus: true,  smoothFlow: true  },
    jazz:     { avgBars: 16, extFactor: 1.3,  extraChorus: false, smoothFlow: true  },
    edm:      { avgBars: 8,  extFactor: 1.4,  extraChorus: true,  smoothFlow: false },
    dubstep:  { avgBars: 8,  extFactor: 1.3,  extraChorus: true,  smoothFlow: false },
    ambient:  { avgBars: 8,  extFactor: 1.6,  extraChorus: false, smoothFlow: true  },
    reggae:   { avgBars: 8,  extFactor: 1.0,  extraChorus: true,  smoothFlow: true  },
    default:  { avgBars: 8,  extFactor: 1.0,  extraChorus: true,  smoothFlow: true  }
  };

  const behaviour = GENRE_BEHAVIOUR[genre] || GENRE_BEHAVIOUR.default;

  // --- Base scaling by duration ---
  let sectionCountScale = 1.0;
  let barScale = behaviour.extFactor;

  if (duration <= 1) {
    sectionCountScale = 0.5; // fewer sections
    barScale *= 0.8;         // compress bars
  } else if (duration >= 3) {
    sectionCountScale = 1.2; // more sections
    barScale *= 1.2;         // extend bars
  }

  // --- Determine number of sections ---
  const targetSectionCount = Math.max(
    3,
    Math.round(baseSections.length * sectionCountScale)
  );

  // --- Select a flowing subset ---
  const selectedSections = baseSections
    .slice(0, targetSectionCount)
    .map((s, i) => ({
      ...s,
      bars: Math.max(2, Math.round((s.bars || behaviour.avgBars) * barScale)),
      variation: s.variation || (i % 2 ? 'a' : 'b')
    }));

  // --- Optional: duplicate a chorus/hook for long builds ---
  if (behaviour.extraChorus && duration >= 2.5) {
    const chorus = selectedSections.find(s => s.id.includes('chorus') || s.id.includes('hook'));
    if (chorus) selectedSections.push({ ...chorus, variation: 'b' });
  }

  // --- Optional: smooth transitions for flowy genres ---
  if (behaviour.smoothFlow) {
    selectedSections.forEach((s, i) => {
      const next = selectedSections[i + 1];
      if (next && next.energy < s.energy)
        next.energy = (next.energy + s.energy) / 2;
    });
  }

  // --- Small random dynamic tweaks for natural variation ---
  selectedSections.forEach(s => {
    s.energy = Math.min(1, Math.max(0, s.energy + (Math.random() - 0.5) * 0.1));
    s.density = Math.min(1, Math.max(0, s.density + (Math.random() - 0.5) * 0.1));
  });

  console.log(`ðŸŽ›ï¸ Duration: ${duration}min â€¢ Genre: ${genre} â†’ ${selectedSections.length} sections, ${selectedSections.reduce((a,b)=>a+b.bars,0)} bars`);
  return selectedSections;
}


function addHumanTiming() {
  return (Math.random() - 0.5) * 0.02;
}

function humanVel(base, variance = 0.1) {
  return Math.max(0.2, Math.min(1.0, base + (Math.random() - 0.5) * variance));
}

function surprise(chance = 0.15) {
  return Math.random() < chance;
}

function evolvingParam(base, bar, totalBars) {
  const progress = bar / Math.max(1, totalBars);
  const wave = Math.sin(progress * Math.PI * 2) * 0.15;
  return Math.max(0, Math.min(1, base + wave + (Math.random() - 0.5) * 0.1));
}

function getOrganicMelodyContour(barInSection, totalBars, mood) {
  const progress = barInSection / Math.max(1, totalBars);
  
  const contours = {
    default: (p) => Math.sin(p * Math.PI),
    dark: (p) => 1 - p * 0.7,
    sad: (p) => 1 - p * 0.8,
    tense: (p) => Math.abs(Math.sin(p * Math.PI * 4)),
    mellow: (p) => Math.sin(p * Math.PI * 0.5),
    dreamy: (p) => Math.sin(p * Math.PI * 2),
    uplift: (p) => p * 0.6
  };
  
  const contourFn = contours[mood] || contours.default;
  return contourFn(progress);
}


// ============ REPLACE generateSectionDrums ENTIRELY ============

function generateSectionDrums(section, startBar, endBar) {
  if (!section.drums) return;
  
  const drumPattern = section.drumPattern || 'four-floor';
  const density     = section.density || 0.7;
  const energy      = section.energy  || 0.7;
  const fillEvery   = songBuilderState.fillEvery || 0;

  const mood        = getCurrentMood(section);
  const moodProfile = getGlobalMoodProfile(mood, section);

  const mainDensity = density * (moodProfile.drumDensityMul || 1);
  const fillMul     = (moodProfile.drumFillMul || 1);
  const ghostMul    = (moodProfile.drumGhostMul || 1);
  const hatOpenMul  = (moodProfile.hatOpenMul || 1);

  const totalBars = endBar - startBar;

  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const barInSection = bar - startBar;
    
    // ðŸŽ² Evolving groove per bar
    const barEnergy = evolvingParam(energy, barInSection, totalBars);
    const barDensity = evolvingParam(mainDensity, barInSection, totalBars);
    
    // ðŸŽ² Occasional breaks
    const skipKick = surprise(0.08);
    const addGhost = surprise(barDensity * 0.3);
    const extraHat = surprise(barEnergy * 0.25);
    
    switch(drumPattern) {
      case 'four-floor':
        // Kicks with humanization
        [0, 4, 8, 12].forEach((s, i) => {
          if (i === 0 && skipKick) return;
          sbSetStep('kick', offset + s, { 
            velocity: humanVel(0.85 + barEnergy * 0.1, 0.08),
            probability: 92 + Math.floor(Math.random() * 8)
          });
        });
        
        // Snares with flams
        if (addGhost) {
          sbSetStep('snare', offset + 3, { velocity: humanVel(0.25, 0.05), probability: 65 });
        }
        sbSetStep('snare', offset + 4, { 
          velocity: humanVel(0.88, 0.1),
          probability: 98
        });
        sbSetStep('snare', offset + 12, { 
          velocity: humanVel(0.92, 0.08),
          probability: 100
        });
        
        // Hats with variation
        if (patterns.hihat) {
          for (let i = 0; i < 16; i += 2) {
            const isOffbeat = i % 4 === 2;
            const prob = barDensity * (isOffbeat ? ghostMul * 0.9 : 1.0);
            
            if (Math.random() < prob) {
              const isOpen = extraHat && (i === 6 || i === 14);
              sbSetStep('hihat', offset + i, {
                velocity: humanVel(isOpen ? 0.7 : (0.5 + barEnergy * 0.2), 0.15),
                duration: isOpen ? '8n' : '16n',
                probability: isOpen ? 85 : 90
              });
            }
          }
        }
        break;
        
      case 'breakbeat':
        const swingOffset = barDensity > 0.6 ? 1 : 0;
        
        sbSetStep('kick', offset + 0, { velocity: humanVel(0.95, 0.08) });
        sbSetStep('kick', offset + (6 + swingOffset), { velocity: humanVel(0.72, 0.1) });
        if (!skipKick) {
          sbSetStep('kick', offset + 10, { velocity: humanVel(0.75, 0.1) });
        }
        
        if (addGhost) {
          sbSetStep('snare', offset + 3, { velocity: humanVel(0.3, 0.05), probability: 70 });
        }
        sbSetStep('snare', offset + 4, { velocity: humanVel(0.9, 0.08) });
        sbSetStep('snare', offset + 12, { velocity: humanVel(0.95, 0.05) });

        if (patterns.hihat && barDensity > 0.35) {
          for (let i = 0; i < 16; i++) {
            const isSwing = i % 2 === 1;
            const baseProb = isSwing ? 0.65 : 0.35;
            const prob = baseProb * barDensity * ghostMul;
            
            if (Math.random() < prob) {
              sbSetStep('hihat', offset + i, {
                velocity: humanVel(0.4 + barEnergy * 0.25, 0.2),
                probability: 85 + Math.floor(Math.random() * 15)
              });
            }
          }
        }
        break;
        
      case 'trap':
        sbSetStep('kick', offset + 0, { velocity: humanVel(0.95, 0.05) });
        sbSetStep('kick', offset + 8, { velocity: humanVel(0.85, 0.08) });
        if (barEnergy > 0.7 || surprise(0.3)) {
          sbSetStep('kick', offset + 14, { velocity: humanVel(0.75, 0.1) });
        }

        sbSetStep('snare', offset + 4, { velocity: humanVel(0.9, 0.08) });
        sbSetStep('snare', offset + 12, { velocity: humanVel(0.95, 0.05) });

        if (patterns.hihat) {
          const rollStart = surprise(0.5) ? 6 : 14;
          for (let i = 0; i < 16; i++) {
            const isRoll = i >= rollStart && i < rollStart + 2;
            const isMain = i % 2 === 1;
            
            let baseProb = isRoll ? 0.95 : (isMain ? 0.7 : 0.25);
            baseProb *= barDensity;
            
            if (Math.random() < baseProb) {
              sbSetStep('hihat', offset + i, { 
                velocity: humanVel(isRoll ? 0.65 : 0.45, 0.15),
                probability: isRoll ? 95 : 80,
                duration: isRoll ? '32n' : '16n'
              });
            }
          }
        }
        break;
        
      case 'half-time':
        if (barInSection % 2 === 0) {
          sbSetStep('kick', offset + 0, { velocity: humanVel(0.95, 0.05) });
          sbSetStep('snare', offset + 8, { velocity: humanVel(0.9, 0.08) });
        }
        
        if (patterns.hihat) {
          for (let i = 0; i < 16; i += 2) {
            if (Math.random() < barDensity * 0.7) {
              sbSetStep('hihat', offset + i, { 
                velocity: humanVel(0.5, 0.12) 
              });
            }
          }
        }
        break;
    }
    
    // ðŸŽ² SMART FILLS
    if (fillEvery && ((barInSection + 1) % fillEvery === 0) && barEnergy > 0.5) {
      const fillStyle = Math.random();
      const fillLength = Math.floor(3 + barEnergy * 5);
      
      for (let i = STEPS_PER_BAR - fillLength; i < STEPS_PER_BAR; i++) {
        if (Math.random() < 0.75 * fillMul) {
          let inst;
          if (fillStyle < 0.4) inst = 'snare';
          else if (fillStyle < 0.7) inst = 'kick';
          else inst = Math.random() < 0.5 ? 'snare' : 'kick';
          
          sbSetStep(inst, offset + i, {
            velocity: humanVel(0.55 + (i / STEPS_PER_BAR) * 0.3, 0.15),
            probability: 70 + Math.floor(Math.random() * 25),
            duration: '16n'
          });
        }
      }
    }
  }
}
  
function generateSectionBass(section, startBar, endBar) {
  if (!section.bass) return;
  if (!patterns.bass) return;

  const mood = getCurrentMood(section);
  const moodProfile = getGlobalMoodProfile(mood, section);

  const baseOct = (state.octave || 3) - 2;
  const bassOct = baseOct + (moodProfile.bassRegisterOff || 0);
  const bassPattern = section.bassPattern || 'root-fifth';

  const rawEnergy = section.energy ?? 0.6;
  const rawDensity = section.density ?? 0.7;

  const moveMul = moodProfile.bassMovementMul || 1;
  const energy = rawEnergy;
  const effDensity = Math.max(0.2, Math.min(1.0, rawDensity * moveMul));

  const id = (section.id || '').toLowerCase();
  const isIntro = id.includes('intro');
  const isOutro = id.includes('outro') || id.includes('end');
  const isBreak = id.includes('break') || id.includes('dub');
  const isDrop = id.includes('drop');
  const isChorus = id.includes('chorus') || id.includes('hook') || isDrop;
  const isVerse = id.includes('verse');

  const motifSet = buildBassMotifSet(bassPattern, {
    isIntro, isOutro, isBreak, isChorus, isVerse,
    energy,
    density: effDensity
  });

  const totalBars = endBar - startBar;

  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const chord = sbGetChordForBar(bar) || buildTriadFromDegree(0, sbGlobalHarmony.key, sbGlobalHarmony.scale);
    const pcs = chord.map(n => n.replace(/\d/, ''));
    const [root, third, fifth] = pcs;

    const barInSection = bar - startBar;
    
    // ðŸŽ² Evolving bass energy
    const barEnergy = evolvingParam(energy, barInSection, totalBars);
    
    // ðŸŽ² Occasional motif variation
    const useAltMotif = surprise(0.2);
    
    let motif;
    if (barInSection % 4 === 3 && motifSet.fill) {
      motif = motifSet.fill;
    } else if (useAltMotif && motifSet.variant2) {
      motif = motifSet.variant2;
    } else if (barInSection % 2 === 1 && motifSet.variant1) {
      motif = motifSet.variant1;
    } else {
      motif = motifSet.main;
    }

    if (isBreak && barInSection % 8 === 7) {
      continue;
    }

    motif.forEach(ev => {
      let notePc;
      switch (ev.degree) {
        case 'third': notePc = third || root; break;
        case 'fifth': notePc = fifth || root; break;
        case 'seventh': notePc = pcs[3] || fifth || root; break;
        default: notePc = root; break;
      }

      // ðŸŽ² Add passing tones occasionally
      const addPassingTone = surprise(0.15) && ev.step % 4 !== 0;
      if (addPassingTone) {
        notePc = Math.random() < 0.5 ? third : fifth;
      }

      const baseVel = ev.velocity ?? (0.7 + barEnergy * 0.2);

      sbSetStep('bass', offset + ev.step, {
        note: withOct(notePc, bassOct + (ev.octShift || 0)),
        velocity: humanVel(baseVel, 0.12),
        duration: ev.duration || '8n',
        probability: (ev.probability ?? 100) - Math.floor(Math.random() * 5)
      });
    });
  }
}

// Builds a SET of motif variations instead of just one
function buildBassMotifSet(patternType, ctx) {
  const { isIntro, isOutro, isBreak, isChorus, isVerse, energy } = ctx;
  const isChill = isIntro || isOutro || isBreak;
  const isHigh = isChorus || energy > 0.7;

  const set = {
    main: [],
    variant1: [],
    variant2: [],
    fill: []
  };

  // --- PEDAL ---
  if (patternType === 'pedal') {
    set.main.push({
      step: 0, degree: 'root', duration: '1n', velocity: 0.75
    });
    
    set.variant1.push({
      step: 0, degree: 'root', duration: '2n', velocity: 0.75
    });
    set.variant1.push({
      step: 8, degree: 'fifth', duration: '2n', velocity: 0.7
    });
    
    set.fill.push({
      step: 0, degree: 'root', duration: '4n', velocity: 0.8
    });
    set.fill.push({
      step: 8, degree: 'third', duration: '4n', velocity: 0.75
    });
    set.fill.push({
      step: 12, degree: 'fifth', duration: '4n', velocity: 0.7
    });
    
    set.variant2 = set.variant1;
    return set;
  }

  // --- WALKING ---
  if (patternType === 'walking') {
    // Main: classic walk
    [0, 4, 8, 12].forEach((s, i) => {
      set.main.push({
        step: s,
        degree: ['root', 'third', 'fifth', 'third'][i],
        duration: '4n',
        velocity: 0.75 - i * 0.05
      });
    });

    // Variant 1: reversed walk
    [0, 4, 8, 12].forEach((s, i) => {
      set.variant1.push({
        step: s,
        degree: ['root', 'fifth', 'third', 'root'][i],
        duration: '4n',
        velocity: 0.75 - i * 0.05
      });
    });

    // Variant 2: denser walk
    [0, 2, 4, 6, 8, 10, 12, 14].forEach((s, i) => {
      set.variant2.push({
        step: s,
        degree: ['root', 'third', 'third', 'fifth', 'fifth', 'third', 'third', 'root'][i],
        duration: '8n',
        velocity: 0.7 - i * 0.02
      });
    });

    // Fill: chromatic approach
    set.fill.push({ step: 0, degree: 'root', duration: '4n', velocity: 0.85 });
    set.fill.push({ step: 4, degree: 'third', duration: '8n', velocity: 0.8 });
    set.fill.push({ step: 6, degree: 'fifth', duration: '8n', velocity: 0.8 });
    set.fill.push({ step: 8, degree: 'fifth', duration: '4n', velocity: 0.8 });
    set.fill.push({ step: 13, degree: 'third', duration: '16n', velocity: 0.75 });
    set.fill.push({ step: 14, degree: 'third', duration: '16n', velocity: 0.75 });
    
    return set;
  }

  // --- SYNCOPATED ---
  if (patternType === 'syncopated') {
    // Main: your original
    set.main.push({ step: 0,  degree: 'root',  duration: '8n', velocity: 0.85 });
    set.main.push({ step: 6,  degree: 'fifth', duration: '8n', velocity: 0.8 });
    if (!isChill) {
      set.main.push({ step: 10, degree: 'third', duration: '8n', velocity: 0.78 });
      if (isHigh) {
        set.main.push({ step: 14, degree: 'root', duration: '16n', velocity: 0.7 });
      }
    }

    // Variant 1: different syncopation
    set.variant1.push({ step: 0,  degree: 'root',  duration: '8n', velocity: 0.85 });
    set.variant1.push({ step: 5,  degree: 'third', duration: '16n', velocity: 0.75 });
    set.variant1.push({ step: 8,  degree: 'fifth', duration: '8n', velocity: 0.8 });
    set.variant1.push({ step: 13, degree: 'root',  duration: '16n', velocity: 0.75 });

    // Variant 2: heavier
    set.variant2.push({ step: 0,  degree: 'root',  duration: '8n', velocity: 0.9 });
    set.variant2.push({ step: 3,  degree: 'root',  duration: '16n', velocity: 0.7 });
    set.variant2.push({ step: 6,  degree: 'fifth', duration: '8n', velocity: 0.85 });
    set.variant2.push({ step: 10, degree: 'third', duration: '8n', velocity: 0.8 });
    set.variant2.push({ step: 12, degree: 'root',  duration: '16n', velocity: 0.75 });

    // Fill: rapid fire
    set.fill.push({ step: 0,  degree: 'root',  duration: '16n', velocity: 0.9 });
    set.fill.push({ step: 2,  degree: 'third', duration: '16n', velocity: 0.85 });
    set.fill.push({ step: 4,  degree: 'fifth', duration: '16n', velocity: 0.8 });
    set.fill.push({ step: 6,  degree: 'third', duration: '16n', velocity: 0.8 });
    set.fill.push({ step: 8,  degree: 'root',  duration: '8n', velocity: 0.9 });
    set.fill.push({ step: 12, degree: 'fifth', duration: '8n', velocity: 0.85 });
    set.fill.push({ step: 14, degree: 'root',  duration: '8n', velocity: 0.8 });

    return set;
  }

  // --- ROOT-FIFTH (default) ---
  // Main: your original
  set.main.push({
    step: 0,
    degree: 'root',
    duration: isChill ? '2n' : '4n',
    velocity: 0.85
  });
  set.main.push({
    step: 8,
    degree: isBreak ? 'root' : 'fifth',
    duration: '4n',
    velocity: 0.8
  });
  if (isHigh && !isBreak) {
    set.main.push({
      step: 12,
      degree: 'root',
      duration: '8n',
      velocity: 0.75
    });
  }

  // Variant 1: add octave jump
  set.variant1.push({
    step: 0,
    degree: 'root',
    duration: '4n',
    velocity: 0.85
  });
  set.variant1.push({
    step: 6,
    degree: 'fifth',
    duration: '8n',
    velocity: 0.75
  });
  set.variant1.push({
    step: 8,
    degree: 'root',
    octShift: 1,
    duration: '8n',
    velocity: 0.8
  });
  set.variant1.push({
    step: 12,
    degree: 'fifth',
    duration: '4n',
    velocity: 0.75
  });

  // Variant 2: busier rhythm
  set.variant2.push({
    step: 0,
    degree: 'root',
    duration: '8n',
    velocity: 0.85
  });
  set.variant2.push({
    step: 4,
    degree: 'third',
    duration: '8n',
    velocity: 0.75
  });
  set.variant2.push({
    step: 8,
    degree: 'fifth',
    duration: '8n',
    velocity: 0.8
  });
  set.variant2.push({
    step: 12,
    degree: 'root',
    duration: '8n',
    velocity: 0.8
  });

  // Fill: dramatic run
  set.fill.push({ step: 0,  degree: 'root',  duration: '8n', velocity: 0.9 });
  set.fill.push({ step: 4,  degree: 'third', duration: '8n', velocity: 0.85 });
  set.fill.push({ step: 8,  degree: 'fifth', duration: '8n', velocity: 0.85 });
  set.fill.push({ step: 10, degree: 'fifth', duration: '16n', velocity: 0.8 });
  set.fill.push({ step: 12, degree: 'root',  duration: '8n', velocity: 0.85 });
  set.fill.push({ step: 14, degree: 'root',  octShift: 1, duration: '8n', velocity: 0.9 });

  return set;
}
  
function generateSectionChords(section, startBar, endBar) {
  if (!section.chords) return;
  if (!patterns.keys) return;
  
  const mood = getCurrentMood(section);
  const moodProfile = getGlobalMoodProfile(mood, section);

  const baseKeysOct = state.octave || 3;
  let keysOct = baseKeysOct;
  if (moodProfile.chordSpreadMul > 1.15) keysOct += 1;
  if (moodProfile.chordSpreadMul < 0.9) keysOct -= 1;

  const chordPattern = section.chordPattern || 'sustained';
  const energy = section.energy || 0.5;
  const density = section.density || 0.7;

  const tensionMul = moodProfile.chordTensionMul || 1;
  const chordDensity = Math.max(0.2, Math.min(1.0, density * (moodProfile.chordSpreadMul || 1)));

  const totalBars = endBar - startBar;

  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const chord = sbGetChordForBar(bar) || buildTriadFromDegree(0, sbGlobalHarmony.key, sbGlobalHarmony.scale);
    const [root, third, fifth] = chord.map(n => n.replace(/\d/, ''));
    
    const barInSection = bar - startBar;
    const barEnergy = evolvingParam(energy, barInSection, totalBars);
    
    // ðŸŽ² Occasional chord extensions
    const addExtension = surprise(0.25);
    const seventh = chord[3] ? chord[3].replace(/\d/, '') : fifth;
    
    switch(chordPattern) {
      case 'sustained':
        const velBase = 0.5 + 0.2 * barEnergy;
        
        sbSetStep('keys', offset + 0, { 
          note: withOct(root, keysOct), 
          velocity: humanVel(velBase * tensionMul, 0.08), 
          duration: '1n' 
        });
        sbSetStep('keys', offset + 0, { 
          note: withOct(third, keysOct), 
          velocity: humanVel((velBase - 0.05) * tensionMul, 0.08), 
          duration: '1n' 
        });
        sbSetStep('keys', offset + 0, { 
          note: withOct(fifth, keysOct), 
          velocity: humanVel((velBase - 0.05) * tensionMul, 0.08), 
          duration: '1n' 
        });
        
        if (addExtension) {
          sbSetStep('keys', offset + 0, {
            note: withOct(seventh, keysOct + 1),
            velocity: humanVel(0.35 * tensionMul, 0.1),
            duration: '1n'
          });
        }
        break;
        
      case 'staccato':
        const stabSteps = [0, 4, 8, 12];
        stabSteps.forEach(step => {
          if (Math.random() < chordDensity * 0.95) {
            [root, third, fifth].forEach(note => {
              sbSetStep('keys', offset + step, {
                note: withOct(note, keysOct),
                velocity: humanVel(0.7 + 0.2 * barEnergy, 0.15) * tensionMul,
                duration: '16n',
                probability: 88 + Math.floor(Math.random() * 12)
              });
            });
          }
        });
        break;
        
      case 'arpeggiated':
        const arpNotes = addExtension 
          ? [root, third, fifth, seventh]
          : [root, third, fifth, third];
          
        const arpPattern = surprise(0.3) 
          ? [0, 3, 6, 9]
          : [0, 4, 8, 12];
          
        arpPattern.forEach((step, i) => {
          if (Math.random() < chordDensity || i === 0) {
            sbSetStep('keys', offset + step, {
              note: withOct(arpNotes[i % arpNotes.length], keysOct),
              velocity: humanVel(0.6 + 0.15 * barEnergy, 0.12) * tensionMul,
              duration: '8n',
              probability: 90 + Math.floor(Math.random() * 10)
            });
          }
        });
        break;
        
      case 'rhythmic':
        const rhythmSteps = surprise(0.4) 
          ? [0, 6, 8, 14]
          : [0, 4, 10, 14];
          
        rhythmSteps.forEach(step => {
          const prob = 0.85 * chordDensity;
          if (Math.random() < prob) {
            [root, third, fifth].forEach(note => {
              sbSetStep('keys', offset + step, {
                note: withOct(note, keysOct),
                velocity: humanVel(0.65 + 0.25 * barEnergy, 0.15) * tensionMul,
                duration: '8n',
                probability: 85 + Math.floor(Math.random() * 15)
              });
            });
          }
        });
        break;
    }
  }
}

function getMoodMelodyProfile(mood, section) {
  const energy  = section?.energy ?? 0.5;
  const baseVel = 0.7 + (energy - 0.5) * 0.4;

  // Small alias map so extra mood labels don't explode things
  const moodAlias = {
    chill      : 'mellow',
    relaxed    : 'mellow',
    happy      : 'uplift',
    uplifting  : 'uplift',
    hype       : 'uplift',
    moody      : 'dark',
    angry      : 'tense',
    aggressive : 'tense'
  };

  const normalizedMood = moodAlias[mood] || mood || 'default';

  const profiles = {
    // Balanced, genre-neutral
    default: {
      densityFactor     : 1.0,
      offbeatWeight     : 0.9,
      restChance        : 0.15,
      resetMotifChance  : 0.12,
      registerOffset    : 0,
      preferChordWeight : 1.0,
      brightToneWeight  : 1.0,
      darkToneWeight    : 1.0,
      biasUpwards       : 0.5,
      biasDownwards     : 0.5,
      smallStepBias     : 0.7,
      bigLeapBias       : 0.3,
      minVel            : Math.max(0.4, baseVel - 0.1),
      maxVel            : Math.min(1.0, baseVel + 0.2),
      minProb           : 80,
      maxProb           : 100,
      longNoteChance    : 0.25,
      mediumNoteValue   : '8n',
      longNoteValue     : '4n',
      shortNoteChance   : 0.25,
      shortNoteValue    : energy > 0.6 ? '16n' : '8n'
    },

    // Low, heavy, brooding, grinding forward inexorably
    dark: {
      densityFactor     : 0.7,
      offbeatWeight     : 0.5,
      restChance        : 0.2,
      resetMotifChance  : 0.08,
      registerOffset    : -1,
      preferChordWeight : 2.2,
      brightToneWeight  : 0.2,
      darkToneWeight    : 2.5,
      biasUpwards       : 0.3,
      biasDownwards     : 0.7,
      smallStepBias     : 0.95,
      bigLeapBias       : 0.05,
      minVel            : 0.55,
      maxVel            : 0.85,
      minProb           : 75,
      maxProb           : 100,
      longNoteChance    : 0.45,
      mediumNoteValue   : '8n',
      longNoteValue     : '4n',
      shortNoteChance   : 0.1,
      shortNoteValue    : '8n'
    },

    // Sparse, fragile, falling phrases with lots of silence
    sad: {
      densityFactor     : 0.45,
      offbeatWeight     : 0.4,
      restChance        : 0.55,
      resetMotifChance  : 0.18,
      registerOffset    : -1,
      preferChordWeight : 2.5,
      brightToneWeight  : 0.2,
      darkToneWeight    : 2.8,
      biasUpwards       : 0.2,
      biasDownwards     : 0.8,
      smallStepBias     : 0.98,
      bigLeapBias       : 0.02,
      minVel            : 0.35,
      maxVel            : 0.65,
      minProb           : 60,
      maxProb           : 85,
      longNoteChance    : 0.7,
      mediumNoteValue   : '4n',
      longNoteValue     : '2n',
      shortNoteChance   : 0.05,
      shortNoteValue    : '8n'
    },

    // Urgent, jagged, relentless, angular with constant motion
    tense: {
      densityFactor     : 1.8,
      offbeatWeight     : 1.6,
      restChance        : 0.03,
      resetMotifChance  : 0.3,
      registerOffset    : 0,
      preferChordWeight : 0.7,
      brightToneWeight  : 0.6,
      darkToneWeight    : 1.6,
      biasUpwards       : 0.6,
      biasDownwards     : 0.4,
      smallStepBias     : 0.3,
      bigLeapBias       : 0.7,
      minVel            : 0.85,
      maxVel            : 1.0,
      minProb           : 90,
      maxProb           : 100,
      longNoteChance    : 0.03,
      mediumNoteValue   : '16n',
      longNoteValue     : '8n',
      shortNoteChance   : 0.75,
      shortNoteValue    : '16n'
    },

    // Warm, smooth, relaxed, gently rolling like waves
    mellow: {
      densityFactor     : 0.75,
      offbeatWeight     : 0.65,
      restChance        : 0.28,
      resetMotifChance  : 0.1,
      registerOffset    : 0,
      preferChordWeight : 2.0,
      brightToneWeight  : 1.3,
      darkToneWeight    : 0.7,
      biasUpwards       : 0.5,
      biasDownwards     : 0.5,
      smallStepBias     : 0.92,
      bigLeapBias       : 0.08,
      minVel            : 0.5,
      maxVel            : 0.75,
      minProb           : 80,
      maxProb           : 98,
      longNoteChance    : 0.4,
      mediumNoteValue   : '8n',
      longNoteValue     : '4n',
      shortNoteChance   : 0.15,
      shortNoteValue    : '8n'
    },

    // Ethereal, floating, high register with dramatic swoops
    dreamy: {
      densityFactor     : 0.6,
      offbeatWeight     : 1.2,
      restChance        : 0.35,
      resetMotifChance  : 0.25,
      registerOffset    : +1,
      preferChordWeight : 1.4,
      brightToneWeight  : 2.5,
      darkToneWeight    : 0.5,
      biasUpwards       : 0.7,
      biasDownwards     : 0.3,
      smallStepBias     : 0.5,
      bigLeapBias       : 0.5,
      minVel            : 0.4,
      maxVel            : 0.8,
      minProb           : 65,
      maxProb           : 95,
      longNoteChance    : 0.75,
      mediumNoteValue   : '4n',
      longNoteValue     : '2n',
      shortNoteChance   : 0.1,
      shortNoteValue    : '8n'
    },

    // NEW: bright, hopeful, forward, â€œmajor-feelingâ€ uplift
    uplift: {
      densityFactor     : 1.1,
      offbeatWeight     : 1.1,
      restChance        : 0.18,
      resetMotifChance  : 0.18,
      registerOffset    : +1,
      preferChordWeight : 1.8,
      brightToneWeight  : 2.2,
      darkToneWeight    : 0.4,
      biasUpwards       : 0.75,
      biasDownwards     : 0.25,
      smallStepBias     : 0.85,
      bigLeapBias       : 0.15,
      minVel            : 0.55,
      maxVel            : 0.9,
      minProb           : 80,
      maxProb           : 100,
      longNoteChance    : 0.35,
      mediumNoteValue   : '8n',
      longNoteValue     : '4n',
      shortNoteChance   : 0.2,
      shortNoteValue    : '16n'
    }
  };

  const baseProfile = profiles[normalizedMood] || profiles.default;

  // âœ¨ Gentle energy-aware post-processing so
  // low-energy vs high-energy sections of the *same* mood feel different
  const energyDensityScale = 0.8 + energy * 0.4;   // 0.8 â€“ 1.2
  const velSpread          = 0.10 + energy * 0.15; // 0.10 â€“ 0.25

  const minVel = Math.max(0.3, baseVel - velSpread * 0.7);
  const maxVel = Math.min(1.0, baseVel + velSpread);

  const profile = { ...baseProfile };
  profile.densityFactor = baseProfile.densityFactor * energyDensityScale;
  profile.minVel        = minVel;
  profile.maxVel        = maxVel;

  return profile;
}

function pickMoodPitchClassIndex(scalePcs, chordPcs, profile) {
  // We weight chord tones vs non-chord tones, and bright vs dark tones
  const weights = [];

  for (let i = 0; i < scalePcs.length; i++) {
    const pc = scalePcs[i];

    const isChordTone = chordPcs.includes(pc);
    const isBright    = /^(3|6|7)/.test(pcDegreeHint(pc)) || /#/.test(pc);
    const isDark      = /b/.test(pc);

    let w = 1.0;

    if (isChordTone) w *= profile.preferChordWeight;
    if (isBright)    w *= profile.brightToneWeight;
    if (isDark)      w *= profile.darkToneWeight;

    weights.push(w);
  }

  return weightedRandomIndex(weights);
}

function pickContourDirection(profile) {
  const r = Math.random();
  if (r < profile.biasUpwards) return +1;
  if (r < profile.biasUpwards + profile.biasDownwards) return -1;
  return (Math.random() < 0.5) ? +1 : -1;
}

function pickIntervalStep(profile) {
  return (Math.random() < profile.smallStepBias) ? 1 : 2 + Math.floor(Math.random() * 2);
}

function clampPcIndex(idx, len) {
  if (len <= 0) return 0;
  if (idx < 0) return 0;
  if (idx >= len) return len - 1;
  return idx;
}

function randRange(min, max) {
  return min + (max - min) * Math.random();
}

function weightedRandomIndex(weights) {
  let total = 0;
  for (let w of weights) total += w;
  if (total <= 0) return Math.floor(Math.random() * weights.length);

  let r = Math.random() * total;
  for (let i = 0; i < weights.length; i++) {
    r -= weights[i];
    if (r <= 0) return i;
  }
  return weights.length - 1;
}

/**
 * Very rough "degree hint" helper â€” if you already have a smarter
 * degree function, you can swap this out. For now we just classify
 * by accidental and letter as a proxy.
 */
function pcDegreeHint(pc) {
  // this doesn't map exact scale degree, it just gives
  // us something to "pretend" for weighting; we mostly
  // care about flats vs sharps vs naturals
  if (!pc) return '';
  return pc;
}
  
// ==================== MOOD-AWARE MELODY ENGINE ====================

function generateSectionMelody(section, startBar, endBar) {
  if (!section.lead) return;
  if (!patterns.lead) return;

  const mood = (typeof songBuilderState !== 'undefined' && songBuilderState.mood)
    ? songBuilderState.mood
    : (state.mood || 'default');

  const energy      = section?.energy ?? 0.5;
  const baseProfile = getMoodMelodyProfile(mood, section);
  const leadOctBase = (state.octave || 3) + 1;

  // Detect solo sections: explicit flag, or id/label includes "solo", or super high-energy lead
  const isSoloSection =
    section.solo === true ||
    /solo/i.test(section.id || '') ||
    /solo/i.test(section.label || '') ||
    (section.lead && energy >= 0.9);

  // Clone profile so we can tweak it for solos without mutating the shared object
  const profile = { ...baseProfile };
  const totalBars = endBar - startBar;

  if (isSoloSection) {
    // Rhythm-tightened, more expressive for solos
    profile.densityFactor  *= 1.2;
    profile.offbeatWeight  *= 1.1;
    profile.restChance     *= 0.6;        // fewer rests
    profile.registerOffset += 1;          // push solos up an octave
    profile.smallStepBias   = Math.max(0.2, profile.smallStepBias * 0.7);
    profile.bigLeapBias     = Math.min(0.9, profile.bigLeapBias + 0.2);
    profile.minVel          = Math.min(0.85, (profile.minVel || 0.6) + 0.1);
    profile.maxVel          = Math.min(1.0, (profile.maxVel || 0.9) + 0.1);
    profile.longNoteChance  = Math.max(0.1, profile.longNoteChance - 0.1);
    profile.shortNoteChance = Math.min(0.7, profile.shortNoteChance + 0.1);
  }

  let lastPcIndex = null;
  let lastWasRest = true;

  for (let bar = startBar; bar < endBar; bar++) {
    const offset   = bar * STEPS_PER_BAR;
    const chord    = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale);
    const chordPcs = chord.map(n => n.replace(/\d/, ''));

    const scaleNotes = getScaleNotes(state.key, state.scale) || [];
    const scalePcs   = [...new Set(scaleNotes.map(n => n.replace(/\d/, '')))];
    if (!scalePcs.length) continue;

    if (isSoloSection) {
      // ---------- SOLO MODE: RHYTHM-GRID BASED ----------
      const soloPattern = getSoloRhythmPattern(mood, section, profile);
      const fillPattern = getSoloFillPattern(mood, section, profile);

      for (let step = 0; step < STEPS_PER_BAR; step++) {
        const idx  = offset + step;
        const cell = patterns.lead[idx];
        if (!cell) continue;

        // Reset
        cell.active      = false;
        cell.velocity    = 0.8;
        cell.probability = 100;
        cell.duration    = '8n';
        cell.note        = instruments.lead?.note || `C${leadOctBase}`;

        const isMainHit = soloPattern.includes(step);
        const isFillHit = !isMainHit && fillPattern.includes(step);

        if (!isMainHit && !isFillHit) {
          lastWasRest = true;
          continue;
        }

        // Main hits are more reliable; fills obey density
        if (isFillHit) {
          const fillDensity = (section.density ?? 0.6) * profile.densityFactor;
          if (Math.random() > fillDensity) {
            lastWasRest = true;
            continue;
          }
        }

        // Extra rest chance for some moods (sad, dreamy, etc.)
        if (Math.random() < profile.restChance) {
          lastWasRest = true;
          continue;
        }

        // Choose pitch class index with contour + mood bias
        let pcIndex;
        if (lastPcIndex == null || lastWasRest || Math.random() < profile.resetMotifChance) {
          pcIndex = pickMoodPitchClassIndex(scalePcs, chordPcs, profile);
        } else {
          const dir      = pickContourDirection(profile);
          const interval = pickIntervalStep(profile);
          pcIndex        = clampPcIndex(lastPcIndex + dir * interval, scalePcs.length);
        }

        lastPcIndex = pcIndex;
        lastWasRest = false;

        const pc      = scalePcs[pcIndex];
        const noteOct = leadOctBase + profile.registerOffset;
        const note    = `${pc}${noteOct}`;

        cell.active      = true;
        cell.note        = note;
        cell.velocity    = randRange(profile.minVel, profile.maxVel);
        cell.probability = randRange(profile.minProb, profile.maxProb);

        // Note length choices: main hits vs fills
        if (isMainHit) {
          if (Math.random() < profile.longNoteChance) {
            cell.duration = profile.longNoteValue;
          } else {
            cell.duration = profile.mediumNoteValue;
          }
        } else {
          // fills tend to be shorter
          if (Math.random() < profile.shortNoteChance) {
            cell.duration = profile.shortNoteValue;
          } else {
            cell.duration = '16n';
          }
        }
      }

    } else {
      // ---------- NON-SOLO: YOUR EXISTING GRID-BASED MOOD ENGINE ----------
      for (let step = 0; step < STEPS_PER_BAR; step++) {
        const idx  = offset + step;
        const cell = patterns.lead[idx];
        if (!cell) continue;

        // Reset
        cell.active      = false;
        cell.velocity    = 0.8;
        cell.probability = 100;
        cell.duration    = '8n';
        cell.note        = instruments.lead?.note || `C${leadOctBase}`;

        const isStrongBeat = (step % 4 === 0);
        const isOffBeat    = (step % 2 === 1);

        const energyFactor = 0.7 + energy * 0.6; // 0.7â€“1.3
        const baseDensity  = (section.density ?? 0.6) * profile.densityFactor * energyFactor;

        let hitChance = isStrongBeat
          ? baseDensity
          : baseDensity * (isOffBeat ? profile.offbeatWeight : 0.8);

        hitChance = Math.max(0, Math.min(1.2, hitChance));

        if (Math.random() > hitChance) {
          lastWasRest = true;
          continue;
        }

        if (Math.random() < profile.restChance) {
          lastWasRest = true;
          continue;
        }

        let pcIndex;
        if (lastPcIndex == null || lastWasRest || Math.random() < profile.resetMotifChance) {
          pcIndex = pickMoodPitchClassIndex(scalePcs, chordPcs, profile);
        } else {
          const dir      = pickContourDirection(profile);
          const interval = pickIntervalStep(profile);
          pcIndex        = clampPcIndex(lastPcIndex + dir * interval, scalePcs.length);
        }

        lastPcIndex = pcIndex;
        lastWasRest = false;

        const pc      = scalePcs[pcIndex];
        const noteOct = leadOctBase + profile.registerOffset;
        const note    = `${pc}${noteOct}`;

        cell.active      = true;
        cell.note        = note;
        cell.velocity    = randRange(profile.minVel, profile.maxVel);
        cell.probability = randRange(profile.minProb, profile.maxProb);

        if (Math.random() < profile.longNoteChance) {
          cell.duration = profile.longNoteValue;
        } else if (Math.random() < profile.shortNoteChance) {
          cell.duration = profile.shortNoteValue;
        } else {
          cell.duration = profile.mediumNoteValue;
        }
      }
    } // end solo vs non-solo
  } // end bars
}

// Solo rhythm: main grid per mood, tied to 16-step bar
function getSoloRhythmPattern(mood, section, profile) {
  const base = [
    [0, 4, 8, 12],          // straight 4-on-the-floor phrasing
    [0, 4, 10, 14],         // end-weighted
    [0, 3, 7, 11],          // slightly pushed
    [0, 4, 7, 11, 14]       // more active
  ];

  const darkSad = [
    [0, 8],                 // two long phrases
    [0, 6, 12],             // 3-point arc
    [4, 12]                 // off-center phrases
  ];

  const tensePatterns = [
    [0, 2, 4, 6, 8, 10, 12, 14],      // 8th-note drive
    [0, 3, 4, 7, 8, 11, 12, 15],      // syncopated
    [0, 2, 5, 7, 10, 12, 14]          // jagged
  ];

  const dreamyPatterns = [
    [0, 8, 12],                        // long, floaty phrases
    [0, 6, 10, 14],                    // airy but rhythmic
    [2, 8, 14]                         // drifty off-center
  ];

  const mellowPatterns = [
    [0, 4, 8],                         // simple, smooth
    [0, 4, 8, 12],                     // straight but gentle
    [2, 6, 10, 14]                     // soft syncopation
  ];

  let pool = base;

  switch (mood) {
    case 'dark':
      pool = darkSad;
      break;
    case 'sad':
      pool = darkSad;
      break;
    case 'tense':
      pool = tensePatterns;
      break;
    case 'dreamy':
      pool = dreamyPatterns;
      break;
    case 'mellow':
      pool = mellowPatterns;
      break;
    default:
      pool = base;
      break;
  }

  // Slightly bias simpler patterns for low-energy sections
  const energy = section?.energy ?? 0.5;
  let candidates = pool;
  if (energy < 0.6 && pool.length > 1) {
    candidates = pool.slice(0, Math.max(1, Math.floor(pool.length * 0.6)));
  }

  return candidates[Math.floor(Math.random() * candidates.length)];
}

// Solo fills: extra in-between hits per mood
function getSoloFillPattern(mood, section, profile) {
  const baseFills = [
    [1, 3, 5, 7, 9, 11, 13, 15],      // all 16th off-steps
    [3, 7, 11, 15],                   // end-of-beat pushes
    [1, 5, 9, 13]                     // light pushes
  ];

  const darkSadFills = [
    [7, 11, 15],                      // end-of-bar flicks
    [5, 9],                           // mid-bar pushes
    []                                // sometimes no fills at all
  ];

  const tenseFills = [
    [1, 3, 5, 7, 9, 11, 13, 15],      // continuous 16ths potential
    [1, 2, 5, 6, 9, 10, 13, 14],      // clustered bursts
    [3, 4, 7, 8, 11, 12, 15]          // syncopated flurries
  ];

  const dreamyFills = [
    [3, 7, 11, 15],                   // light sparkles
    [2, 6, 10, 14],                   // airy offsets
    [5, 9]                            // gentle mid-bar nudges
  ];

  const mellowFills = [
    [3, 7, 11],                       // subtle & sparse
    [5, 9],                           // mid-bar
    []                                // sometimes none
  ];

  let pool = baseFills;

  switch (mood) {
    case 'dark':
      pool = darkSadFills;
      break;
    case 'sad':
      pool = darkSadFills;
      break;
    case 'tense':
      pool = tenseFills;
      break;
    case 'dreamy':
      pool = dreamyFills;
      break;
    case 'mellow':
      pool = mellowFills;
      break;
    default:
      pool = baseFills;
      break;
  }

  const energy = section?.energy ?? 0.5;
  let candidates = pool;

  // For low energy, bias toward sparser fill sets
  if (energy < 0.6 && pool.length > 1) {
    candidates = pool.slice(1); // skip the heaviest option
  }
  // For very high energy, bias toward heavier fills if available
  else if (energy > 0.85 && pool.length > 1) {
    candidates = pool;
  }

  return candidates[Math.floor(Math.random() * candidates.length)];
}

function getScaleNotes(key, scaleName) {
  // Use the global scales object you defined earlier
  const intervals = scales[scaleName];

  if (!Array.isArray(intervals)) {
    console.warn(`âš ï¸ Unknown scale "${scaleName}", using first scale in list.`);
    const first = Object.keys(scales)[0];
    state.scale = first;
    return getScaleNotes(key, first);
  }

  const rootIdx = keysArr.indexOf(key);
  if (rootIdx === -1) {
    console.warn(`âš ï¸ Unknown key "${key}", defaulting to C.`);
    return getScaleNotes('C', scaleName);
  }

  return intervals.map(i => keysArr[(rootIdx + i) % 12]);
}
  
// Coherent transition design for risers + impacts
function applyTransitionEffects(section, nextSection, endBar) {
  if (!nextSection) return;

  const lastBar       = endBar - 1;
  const lastBarOffset = lastBar * STEPS_PER_BAR;

  const energyJump = (nextSection.energy || 0.5) - (section.energy || 0.5);

  const mood        = getCurrentMood(section);
  const moodProfile = getGlobalMoodProfile(mood, section);

  const placeAtmos = (inst, startBar, barsLen, velocity = 0.7) => {
    const startOffset = startBar * STEPS_PER_BAR;
    sbSetStep(inst, startOffset, {
      velocity,
      probability: 100,
      duration: `${Math.max(1, barsLen)}m`
    });
  };

  const frothDrums = () => {
    // Open hats crescendo (last 4 steps of the last bar)
    for (let step = STEPS_PER_BAR - 4; step < STEPS_PER_BAR; step++) {
      if (patterns.hihat) {
        const idx = lastBarOffset + step;
        sbSetStep('hihat', idx, {
          velocity: 0.4 + ((step - (STEPS_PER_BAR - 4)) * 0.15) * (moodProfile.drumFillMul || 1),
          probability: 100
        });
      }
    }
    // Snare 16ths roll on the back half of the last bar
    for (let step = Math.floor(STEPS_PER_BAR / 2); step < STEPS_PER_BAR; step++) {
      if (step % 2 === 0 && patterns.snare) {
        const idx = lastBarOffset + step;
        sbSetStep('snare', idx, {
          velocity: (0.55 + ((step - Math.floor(STEPS_PER_BAR / 2)) * 0.04)) * (moodProfile.drumFillMul || 1),
          probability: 95,
          duration: '16n'
        });
      }
    }
  };

  // BIG LIFT
  if (energyJump > 0.3) {
    const isSoftMood = (mood === 'sad' || mood === 'mellow');
    const riserBars  = (section.bars >= 2) ? 2 : 1;
    const riserStartBar = lastBar - (riserBars - 1);

    if (isSoftMood) {
      // gentler riser, no crazy froth
      placeAtmos('riser', riserStartBar, riserBars, 0.5 * (moodProfile.fxRiserStrength || 1));
    } else {
      placeAtmos('riser', riserStartBar, riserBars, 0.7 * (moodProfile.fxRiserStrength || 1));
      frothDrums();
    }

    const nextStartBar = endBar;
    if (patterns.fx) {
      sbSetStep('fx', nextStartBar * STEPS_PER_BAR, {
        velocity: 0.9 * (moodProfile.fxImpactStrength || 1),
        probability: 100,
        duration: '2n'
      });
    }
  }

  // STEP-DOWN / breakdown
  else if (energyJump < -0.3) {
    const softer = (mood === 'sad' || mood === 'dreamy');

    for (let step = Math.floor(STEPS_PER_BAR / 2); step < STEPS_PER_BAR; step++) {
      if (patterns.kick && step % 4 === 0) {
        const k = patterns.kick[lastBarOffset + step];
        if (k) {
          const atten = softer ? 0.35 : 0.5;
          k.velocity = Math.max(0.2, (k.velocity || 0.8) * atten);
        }
      }
    }

    const sweepVel = 0.45 * (moodProfile.fxReverseStrength || 1);
    placeAtmos('riser', lastBar, 1, sweepVel);
  }
}

function setSongBuilderBusy(isBusy, label = '') {
  state.isSongBuilding = isBusy;

  const buildBtn  = document.getElementById('songBuildBtn');
  const statusEl  = document.getElementById('songBuilderStatus');

  if (buildBtn) {
    buildBtn.disabled = isBusy;
  }

  // OPTIONAL: if you know your play button id, you can also gate that:
  const playBtn = document.getElementById('playBtn');
  if (playBtn) playBtn.disabled = isBusy;

  if (!statusEl) return;

  if (isBusy) {
    songBuilderBusyStartedAt = performance.now();
    statusEl.classList.add('active');
    statusEl.innerHTML = `<span class="dot"></span>${label || 'Building songâ€¦'}`;
  } else {
    statusEl.classList.remove('active');
    statusEl.textContent = '';
  }
}

let songBuilderBusyStartedAt = 0;

function endSongBuilderBusy() {
  const MIN_BUSY_MS = 300; // change to 250â€“300ms if you want more visible time
  const elapsed = performance.now() - songBuilderBusyStartedAt;

  if (elapsed >= MIN_BUSY_MS) {
    setSongBuilderBusy(false);
  } else {
    setTimeout(() => setSongBuilderBusy(false), MIN_BUSY_MS - elapsed);
  }
}

// ==================== COHERENT SONG BUILDER UPGRADE ====================

// ðŸŽ¹ GLOBAL HARMONY CONTEXT (persistent for one build)
let sbGlobalHarmony = null;

let sbChordDegrees = [];

// Utility: random key/scale, consistent through song
// ==================== EXTENDED GENRE-AWARE HARMONY ====================

function sbChooseGlobalHarmony_GenreAware() {
  const genre = songBuilderState.genre || state.currentGenre || 'lofi';
  const mood  = songBuilderState.mood || state.mood || 'default';

  const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;

  // Start from the genreâ€™s default scale list
  let scalePool = profile.scales.slice();

  const minorish   = ['minor', 'aeolian', 'dorian', 'phrygian', 'locrian'];
  const brightish  = ['major', 'mixolydian', 'lydian'];

  // Mood â†’ scale biasing
  if (mood === 'dark' || mood === 'sad') {
    const filtered = scalePool.filter(s => minorish.includes(s));
    if (filtered.length) scalePool = filtered;
  } else if (mood === 'tense') {
    const filtered = scalePool.filter(s =>
      ['phrygian', 'locrian', 'minor', 'aeolian'].includes(s)
    );
    if (filtered.length) scalePool = filtered;
  } else if (mood === 'mellow') {
    const filtered = scalePool.filter(s =>
      ['major', 'mixolydian', 'dorian'].includes(s)
    );
    if (filtered.length) scalePool = filtered;
  } else if (mood === 'dreamy') {
    const filtered = scalePool.filter(s =>
      ['lydian', 'mixolydian', 'dorian', 'major'].includes(s)
    );
    if (filtered.length) scalePool = filtered;
  }
  // 'default' falls back to whatever the genre profile had

  const key = profile.keys[Math.floor(Math.random() * profile.keys.length)];
  const scale = scalePool[Math.floor(Math.random() * scalePool.length)];
  const progression = profile.progressions[Math.floor(Math.random() * profile.progressions.length)];

  sbGlobalHarmony = { key, scale, progression, genre, mood };
  console.log(`ðŸŽ¸ Genre-aware harmony â†’ ${genre} [${mood}]`, sbGlobalHarmony);
  return sbGlobalHarmony;
}

// note: MIDI number
// key: "C", "D#", etc
// scaleArray: array of pitch classes 0â€“11 (relative to key)
// chordMidi: OPTIONAL array of MIDI notes for current chord (for solo smarts)
function quantizeNoteToScale(note, key, scaleArray, chordMidi = []) {
  try {
    const root = Tone.Frequency(`${key || 'C'}4`).toMidi();

    // Build candidate notes near the original
    const baseOct = Math.floor((note - root) / 12);
    const candidates = [];

    scaleArray.forEach(step => {
      // same octave
      candidates.push(root + step + 12 * baseOct);
      // nearby octaves for nicer phrasing
      candidates.push(root + step + 12 * (baseOct - 1));
      candidates.push(root + step + 12 * (baseOct + 1));
    });

    let best = note;
    let bestScore = Infinity;

    // Precompute chord pitch classes if provided
    const chordPcs = (chordMidi || []).map(cm => ((cm - root) % 12 + 12) % 12);

    candidates.forEach(c => {
      let score = Math.abs(c - note); // base: distance

      const cPc = ((c - root) % 12 + 12) % 12;

      // ---- SOLO BRAIN STARTS HERE ----

      // A) Strongly favor chord tones (1/3/5/7 etc)
      if (chordPcs.length) {
        chordPcs.forEach(cp => {
          const diffPc = Math.abs(cPc - cp);
          if (diffPc === 0) score *= 0.4;      // dead-on chord tone = big win
          else if (diffPc === 1) score *= 0.7; // approach tone = still tasty
        });
      }

      // B) Prefer small, singable steps
      if (Math.abs(c - note) <= 2) score *= 0.8;  // stepwise motion feels melodic

      // C) Penalize huge jumps unless theyâ€™re doing something nice
      if (Math.abs(c - note) >= 7) score *= 1.3;

      // D) Let "blue" pitches exist but not dominate (b3, b5, b7)
      const blues = [3, 6, 10]; // relative to root
      if (blues.includes(cPc)) {
        score *= 1.1; // allowed spice, slight penalty so they donâ€™t take over
      }

      // E) Leading tone (maj7) resolving to root feels good
      // if original note is 11 semitones above root, bias candidate root
      const notePc = ((note - root) % 12 + 12) % 12;
      if (notePc === 11 && cPc === 0) {
        score *= 0.3;
      }

      // ---- SOLO BRAIN ENDS ----

      if (score < bestScore) {
        bestScore = score;
        best = c;
      }
    });

    return best;
  } catch (err) {
    console.warn('quantizeNoteToScale (solo) failed, returning original', err);
    return note;
  }
}

// Snap a note name (e.g. "C#4") to the nearest note
// in the current key/scale using getScaleNotes(...)
function snapLeadNote(noteName) {
  try {
    // If anything critical is missing, bail out safely
    if (typeof Tone === 'undefined' || !Tone.Frequency) return noteName;
    if (typeof getScaleNotes !== 'function') return noteName;
    if (!state || !state.key || !state.scale) return noteName;

    const targetMidi = Tone.Frequency(noteName).toMidi();

    // Get scale notes for the current key/scale
    const scaleNames = getScaleNotes(state.key, state.scale);
    if (!Array.isArray(scaleNames) || !scaleNames.length) return noteName;

    let bestName = noteName;
    let bestDiff = Infinity;

    scaleNames.forEach(baseName => {
      // Ensure there is an octave; if not, reuse the octave from noteName
      let candidate = baseName;
      if (!/\d/.test(candidate)) {
        const oct = (noteName.match(/\d+/) || ['4'])[0];
        candidate = candidate + oct;
      }

      // Convert to MIDI and consider nearby octaves
      const m = Tone.Frequency(candidate).toMidi();
      [m - 12, m, m + 12].forEach(mm => {
        const diff = Math.abs(mm - targetMidi);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestName = Tone.Frequency(mm, 'midi').toNote();
        }
      });
    });

    return bestName;
  } catch (err) {
    console.warn('snapLeadNote failed, using original note', err);
    return noteName;
  }
}

function buildScaleStepsForKey(key, scaleName) {
  if (typeof getScaleNotes !== 'function' || typeof Tone === 'undefined') {
    return [0, 2, 4, 5, 7, 9, 11]; // fallback major
  }

  const names = getScaleNotes(key, scaleName); // e.g. ["C4","D4","E4"...]
  const rootMidi = Tone.Frequency(`${key}4`).toMidi();

  const steps = names.map(n => {
    const m = Tone.Frequency(n).toMidi();
    let pc = (m - rootMidi) % 12;
    if (pc < 0) pc += 12;
    return pc;
  });

  // unique + sorted
  return [...new Set(steps)].sort((a, b) => a - b);
}

// Pick a progression for a specific section type
function sbPickProgressionForSection(section, profile) {
  const id = (section.id || '').toLowerCase();

  // you can tweak these however you like
  if (id.includes('intro') || id.includes('outro') || id.includes('break') || id.includes('dub')) {
    return profile.progressions[0]; // simpler / vibe
  }
  if (id.includes('verse')) {
    return profile.progressions[1] || profile.progressions[0];
  }
  if (id.includes('chorus') || id.includes('drop') || id.includes('hook')) {
    return profile.progressions[2] || profile.progressions[1] || profile.progressions[0];
  }

  // fallback: any
  return sbPick(profile.progressions);
}

// Build the harmony map for the *whole* song, bar by bar
function sbPlanHarmonyForSong(runSections) {
  const genre = songBuilderState.genre || state.currentGenre || 'lofi';
  const profile = GENRE_PROFILES[genre] || GENRE_PROFILES.default;

  const key   = sbPick(profile.keys);
  const scale = sbPick(profile.scales);

  sbGlobalHarmony = { key, scale, genre };
  sbChordDegrees = [];

  let currentBar = 0;

  runSections.forEach(section => {
    const bars = section.bars || 0;
    if (!bars) return;

    const prog = sbPickProgressionForSection(section, profile);

    for (let i = 0; i < bars; i++) {
      const degree = prog[i % prog.length];
      sbChordDegrees[currentBar + i] = degree;
    }

    currentBar += bars;
  });

  console.log('ðŸŽ¹ Harmony plan per bar:', {
    ...sbGlobalHarmony,
    totalBars: currentBar,
    sbChordDegrees
  });
}


function sbGetChordForBar(bar) {
  if (!sbGlobalHarmony) {
    return buildTriadFromDegree(0, state.key, state.scale);
  }

  const degree =
    sbChordDegrees[bar] != null
      ? sbChordDegrees[bar]
      : 0; // fallback to I if out-of-range

  return buildTriadFromDegree(degree, sbGlobalHarmony.key, sbGlobalHarmony.scale);
}


// --- Thematic memory pools ---
let sbMotifCache = [];
let sbRhythmCache = { kick: [], snare: [], hihat: [] };

// ðŸ‘‡ Wrapped coherent generator (called instead of generateFullSongFromStructure)
function generateFullSongFromStructure_COHERENT() {
  if (songBuilderState.isActive) return;
  songBuilderState.isActive = true;
  setSongBuilderBusy(true, 'Building coherent songâ€¦');

  const wasPlaying = Tone.Transport.state === 'started';
  if (wasPlaying) Tone.Transport.pause();
  Tone.Transport.cancel(0);
  if (window.mainLoop) {
    try { window.mainLoop.stop(); window.mainLoop.dispose(); } catch {}
    window.mainLoop = null;
  }

  window.sbBassMotifs = {};   // reset bass motifs per song
  sbMotifCache = [];
  sbRhythmCache = { kick: [], snare: [], hihat: [] };

  // --- Prepare sections (with your existing randomness) ---
  const runSections = randomizeSongBuilderSectionsForRun();

  // --- Build per-section harmony plan ---
  sbPlanHarmonyForSong(runSections);
  state.key   = sbGlobalHarmony.key;
  state.scale = sbGlobalHarmony.scale;

  // --- Sequence length as before ---
  const totalBars = Math.max(
    2,
    runSections.reduce((a, b) => a + (b.bars || 0), 0)
  );

  state.sequenceLength = Math.min(
    CONFIG.MAX_SEQUENCE_LENGTH,
    totalBars * STEPS_PER_BAR
  );
  ensurePatternLength(state.sequenceLength);
  wipeAllPatterns();

  // --- Generate each section coherently ---
  let currentBar = 0;

  for (let i = 0; i < runSections.length; i++) {
    const section = runSections[i];
    const startBar = currentBar;
    const endBar   = currentBar + (section.bars || 0);

    // --- Maintain rhythmic coherence across verses/choruses
    if (section.id.includes('verse') && sbRhythmCache.kick.length) {
      sbRhythmCache.kick.forEach(step => sbSetStep('kick', startBar*STEPS_PER_BAR + step, {velocity:0.9}));
      sbRhythmCache.snare.forEach(step => sbSetStep('snare', startBar*STEPS_PER_BAR + step, {velocity:0.9}));
      sbRhythmCache.hihat.forEach(step => sbSetStep('hihat', startBar*STEPS_PER_BAR + step, {velocity:0.6}));
    } else {
      generateSectionDrums(section, startBar, endBar);
      if (section.id.includes('verse') && sbRhythmCache.kick.length===0) {
        for (let s=0; s<STEPS_PER_BAR; s++){
          if (patterns.kick[s+startBar*STEPS_PER_BAR]?.active) sbRhythmCache.kick.push(s);
          if (patterns.snare[s+startBar*STEPS_PER_BAR]?.active) sbRhythmCache.snare.push(s);
          if (patterns.hihat[s+startBar*STEPS_PER_BAR]?.active) sbRhythmCache.hihat.push(s);
        }
      }
    }

    // --- Harmony instruments
    generateSectionBass(section, startBar, endBar);
    generateSectionChords(section, startBar, endBar);

    // --- Melodic coherence: motif reuse
    if (section.id.includes('verse') && sbMotifCache.length) {
      const offset = startBar * STEPS_PER_BAR;
      sbMotifCache.forEach(m =>
        sbSetStep('lead', offset + m.step, {
          note: withOct(m.note, (state.octave || 3) + 1),
          velocity: m.velocity,
          duration: '8n'
        })
      );
    } else {
      generateSectionMelody(section, startBar, endBar);
      if (section.id.includes('verse') && sbMotifCache.length===0) {
        const offset = startBar * STEPS_PER_BAR;
        for (let s=0; s<STEPS_PER_BAR; s++){
          const step = patterns.lead[offset+s];
          if (step?.active) sbMotifCache.push({step:s, note:step.note, velocity:step.velocity});
        }
      }
    }

    applyTransitionEffects(section, runSections[i+1], endBar);
    currentBar = endBar;
  }

  // --- Wrap up ---
  setTimeout(() => {
    try {
      sequencerInitialized = false;
      initAudioLight();
      renderSequencer();
      if (wasPlaying) Tone.Transport.start('+0.05');
      showToast('ðŸŽ¶ Coherent song built', 'success');
    } finally {
      songBuilderState.isActive = false;
      endSongBuilderBusy();
    }
  }, 0);
}

// ==================== SONG TEMPLATE â†’ GENRE MAP ====================

function generateFullSongFromStructure() {
  // delegate to the coherent generator so the existing button still works
  return generateFullSongFromStructure_COHERENT();
}

// ==================== SONG BUILDER UI WIRING ====================
function setupSongBuilderControls() {
  const templateSelect = document.getElementById('songTemplateSelect');
  const fillSelect     = document.getElementById('songFillEverySelect');
  const buildBtn       = document.getElementById('songBuildBtn');
  const randomBtn      = document.getElementById('songRandomizeSectionsBtn');

  // Safety guard in case the tab isn't rendered yet
  if (!templateSelect || !fillSelect || !buildBtn) return;

  // === INITIAL RENDER ===
  applySongTemplate(songBuilderState.templateId);

  // --- Template dropdown ---
  templateSelect.value = songBuilderState.templateId;
  templateSelect.addEventListener('change', e => {
    const selected = e.target.value;
    applySongTemplate(selected);
    // ðŸ”— Auto-link genre when template changes
    const mappedGenre = TEMPLATE_TO_GENRE[selected] || 'lofi';
    state.currentGenre = mappedGenre;
    songBuilderState.genre = mappedGenre;
    console.log(`ðŸŽ¨ Template '${selected}' â†’ Genre '${mappedGenre}'`);
  });

  const durationSelect = document.getElementById('songDurationSelect');
  if (durationSelect) {
    durationSelect.value = String(songBuilderState.durationMins);
    durationSelect.addEventListener('change', e => {
      songBuilderState.durationMins = parseInt(e.target.value, 10);
    });
  }

  // --- Fill every X bars ---
  fillSelect.value = String(songBuilderState.fillEvery);
  fillSelect.addEventListener('change', e => {
    songBuilderState.fillEvery = parseInt(e.target.value, 10) || 0;
  });

  // --- ðŸŽ² Randomize Sections ---
  if (randomBtn) {
    randomBtn.addEventListener('click', () => {
      randomizeSongBuilderSections();
      // optionally update UI if you have a bar label or counter
      // updateSongTotalBarsLabel();
    });
  }

  // --- ðŸŽ¼ Build Song ---
  buildBtn.addEventListener('click', () => {
    generateFullSongFromStructure_COHERENT();

    augmentTransitionsWithRisers(songBuilderState.structure);

    // Optional: auto-switch to the Sequencer tab when done
    const sequencerTabBtn = document.querySelector(
      '.sidebar-tab[data-tab="sequencer"]'
    );
    if (sequencerTabBtn) sequencerTabBtn.click();
  });

  const moodSelect = document.getElementById('moodSelect');
  if (moodSelect && !moodSelect.dataset._wired) {
    moodSelect.dataset._wired = 'true';

    const initialMood = songBuilderState.mood || state.mood || 'default';
    moodSelect.value = initialMood;
    songBuilderState.mood = initialMood;
    state.mood = initialMood;

    moodSelect.addEventListener('change', (e) => {
      const m = e.target.value || 'default';
      songBuilderState.mood = m;
      state.mood = m;
      console.log('ðŸŽ­ Song mood set to', m);
    });
  }

  // --- â¬‡ï¸ Export to Multitrack (disabled for now) ---
  // const exportBtn = document.getElementById('songBuilderToMultitrackBtn');
  // if (exportBtn) {
  //   exportBtn.addEventListener('click', exportSongBuilderToMultitrack);
  // }

  // --- Initialize genre based on default template ---
  const defaultTemplate = templateSelect.value || 'intro-verse-chorus';
  const defaultGenre = TEMPLATE_TO_GENRE[defaultTemplate] || 'lofi';
  state.currentGenre = defaultGenre;
  songBuilderState.genre = defaultGenre;
  console.log(`ðŸŽ¨ Default template '${defaultTemplate}' â†’ Genre '${defaultGenre}'`);
}


async function exportSongBuilderToMultitrack() {
  try {
    await Tone.start();
    ensureHarmonyGuardrails();

    // 1) Build the song once in the live context so patterns + sequenceLength are correct
    generateFullSongFromStructure();

    // 2) Compute actual song duration from sequenceLength + resolution
    const secondsPerStep = Tone.Time(state.resolution).toSeconds();
    const durationSec = Math.max(
      4,
      state.sequenceLength * secondsPerStep + 2 // little tail for reverb, etc
    );

    // 3) Offline render the master mix of the Song Builder arrangement
    const offlineBuffer = await Tone.Offline(() => {
      // Rebuild the full arrangement inside the Offline context
      generateFullSongFromStructure();

      // Start playback for the offline render
      Tone.Transport.start();
    }, durationSec);

    if (!offlineBuffer) {
      showToast("âŒ Export failed (empty render)", "error");
      return;
    }

    // 4) Convert to WAV bytes and Blob (so you can download/export later if you want)
    const wavData = bufferToWavImproved(offlineBuffer); // already defined elsewhere
    const blob = new Blob([wavData], { type: "audio/wav" });

    // 5) Find or create a dedicated "Song Builder" stem track
    let targetTrack = multitrack.tracks.find(t => t.name === "Song Builder");
    if (!targetTrack) {
      const id = multitrack.nextTrackId++;
      targetTrack = new AudioTrack(id, "Song Builder", "stem", true);

      // Minimal routing like addExternalAudioTrackFromBuffer
      const gain = new Tone.Gain(1);
      targetTrack.channel = gain;
      gain.connect(master.fxIn);

      multitrack.tracks.push(targetTrack);
    }

    // 6) Create a proper take object (same shape as imported stems)
    const take = {
      id: `take-${Date.now()}-${targetTrack.id}`,
      buffer: offlineBuffer,
      startTime: 0,
      duration: offlineBuffer.duration,
      muted: false,
      source: "song-builder",
      fileName: "Song Builder",
      blob // optional but nice to have
    };

    targetTrack.takes.push(take);
    targetTrack.selectedTakeIndex = targetTrack.takes.length - 1;

    // 7) Update history + UI and jump to Multitrack tab
    if (typeof multitrackHistory?.captureState === "function") {
      multitrackHistory.captureState();
    }

    renderMultitrack();
    showToast("âœ… Song Builder sent to Multitrack", "success");

    document
      .querySelector('.sidebar-tab[data-tab="multitrack"]')
      ?.click();
  } catch (err) {
    console.error("Song Builder export failed:", err);
    showToast(`âŒ Export failed: ${err.message || err}`, "error");
  }
}

// -------------------- Pattern Management --------------------
function ensurePatternLength(length) {
  Object.keys(patterns).forEach(inst => {
    const arr = patterns[inst];
    
    while (arr.length < length) {
      arr.push({
        active: false,
        velocity: 0.8,
        probability: 100,
        note: instruments[inst].note,
        duration: '8n'
      });
    }
    
    if (arr.length > length) arr.length = length;
  });
}

// -------------------- Event Handlers Setup --------------------
function setupEventListeners() {
  setupTabs();
  setupTransportControls();
  setupParameterControls();
  setupGeneratorButtons();
  setupSequencerControls();
  setupMixerListeners();
  //setupFXListeners();
  setupHarmonyControls();
  setupProjectManagement();
  setupKeyboardShortcuts();
  setupVibeSelector();
  setupMultitrackListeners();
  setupSongBuilderControls();

  // Add this to your main JS file
  document.getElementById('switchToSimpleBtn')?.addEventListener('click', () => {
    localStorage.setItem('8beat.uiMode', 'simple');
    location.reload();
  });

  // Sidebar controls
  document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
  document.getElementById('sidebarBackdrop').addEventListener('click', closeSidebar);
  
  // Keyboard shortcut: ESC to close sidebar
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      closeSidebar();
    }
  });

  // Event delegation for track control buttons (REC, ARM, MUTE, SOLO, etc.)
  const trackList = document.getElementById('dawTrackList');
  if (trackList) {
    trackList.addEventListener('click', (e) => {
      const btn = e.target.closest('.track-mini-btn');
      if (!btn) return;
      
      const trackId = parseInt(btn.dataset.trackId);
      const action = btn.dataset.action;
      const track = multitrack.tracks.find(t => t.id === trackId);
      
      if (track && action) {
        handleTrackAction(track, action);
      }
    });
  }
}
  
// -------------------- Sample Browser (no custom uploads) --------------------
function setupSampleUpload() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) {
    console.warn('âš ï¸ setupSampleUpload: #sampleUploadGrid not found');
    return;
  }
  renderSampleUploadGrid();
}

function renderSampleUploadGrid() {
  const grid = document.getElementById('sampleUploadGrid');
  if (!grid) return;

  grid.innerHTML = '';

  // Show all drum / atmospheric instruments as previewable samples
  const uploadableInstruments = Object.keys(instruments).filter(inst =>
    instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric'
  );

  if (uploadableInstruments.length === 0) {
    const msg = document.createElement('div');
    msg.className = 'panel';
    msg.style.padding = 'var(--space-4)';
    msg.textContent = 'No sample-based instruments found. Drums and atmospheric instruments will show here.';
    grid.appendChild(msg);
    return;
  }

  uploadableInstruments.forEach(inst => {
    const data = instruments[inst];

    const card = document.createElement('div');
    card.className = 'panel';
    card.style.padding = 'var(--space-4)';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = 'var(--space-3)';

    card.innerHTML = `
      <div style="text-align: center;">
        <div style="font-size: var(--text-3xl); margin-bottom: var(--space-2);">
          ${data.icon || 'ðŸŽ›ï¸'}
        </div>
        <div style="font-weight: 700; margin-bottom: var(--space-1); color: var(--text-primary);">
          ${data.name || inst}
        </div>
        <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
          Built-in sample
        </div>
      </div>

      <div style="display: flex; flex-direction: column; gap: var(--space-2);">
        <button class="btn btn-primary btn-sm preview-sample-btn" data-inst="${inst}">
          â–¶ï¸ Preview
        </button>
      </div>
    `;

    grid.appendChild(card);
  });

  // Preview listeners
  grid.querySelectorAll('.preview-sample-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const inst = btn.dataset.inst;
      previewInstrument(inst);
    });
  });
}
  
function previewInstrument(inst) {
  const synth = synths[inst];
  if (!synth) {
    showToast('âŒ Instrument not loaded', 'error');
    return;
  }
  
  // Check if it's loaded
  if (!synth.loaded) {
    showToast('â³ Sample still loading...', 'warning');
    return;
  }
  
  const time = Tone.now();
  
  // For drum samples, trigger at standard note
  if (instruments[inst].type === 'drum' || instruments[inst].type === 'atmospheric') {
    synth.triggerAttackRelease('C2', '8n', time, 0.8);
  } else {
    // For melodic instruments
    const note = instruments[inst].note || 'C4';
    synth.triggerAttackRelease(note, '8n', time, 0.8);
  }
  
  showToast(`â–¶ï¸ ${instruments[inst].name}`, 'info');
}

// Helper functions for base64 conversion
async function arrayBufferToBase64(buffer) {
  const blob = new Blob([buffer]);
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
  
function setupTabs() {
  const sidebarTabs = document.getElementById('sidebarTabs');
  
  sidebarTabs.addEventListener('click', e => {
    const tab = e.target.closest('.sidebar-tab');
    if (!tab) return;
    
    document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
    
    state.currentTab = tab.dataset.tab;

    if (tab.dataset.tab === 'samples') {
      setupSampleUpload();
    }
    
    // Close sidebar after selection
    closeSidebar();
  });
}

// ==================== AI MIXING & MASTERING ====================

// ============================================================================
// GENRE MIX PROFILES â€” Gentle EQ tilt per genre (in dB)
// Used by applyProfessionalEQ() to shape low/mid/high balance
// ============================================================================

const GENRE_MIX_PROFILES = {
  // Fallback / safety
  default: {
    name: "Balanced",
    tilt: { low: 0, mid: 0, high: 0 }
  },

  // --- POP / ROCK ---
  poprock: {
    name: "Pop / Rock",
    // Tight low end, forward mids, clear highs
    tilt: { low: -1, mid: +1.5, high: +1 }
  },

  // --- EDM / HOUSE / TRANCE ---
  edm: {
    name: "EDM / House",
    // Strong lows, scooped mids, bright highs
    tilt: { low: +2, mid: -1, high: +1.5 }
  },

  // --- HIP-HOP / LOFI / JAM ---
  lofi: {
    name: "Lo-Fi / Hip-Hop",
    // Warm low end, muted highs, vintage mid bloom
    tilt: { low: +1.5, mid: +0.5, high: -2 }
  },

  // --- METAL / HARDCORE ---
  metal: {
    name: "Metal / Hardcore",
    // Lean lows, very strong mids for guitars, slightly bright top
    tilt: { low: -2, mid: +3, high: +1 }
  },

  // --- AMBIENT / DOWNTEMPO ---
  ambient: {
    name: "Ambient / Downtempo",
    // Reduced lows, open airy highs
    tilt: { low: -2, mid: -1, high: +3 }
  },

  // --- TRAP ---
  trap: {
    name: "Trap",
    // Big sub, cleaner mids, bright hats
    tilt: { low: +2.5, mid: -1, high: +1.5 }
  },

  // --- FUNK / DISCO ---
  funk: {
    name: "Funk / Disco",
    // Tight lows, punchy mids, crisp top
    tilt: { low: -1, mid: +2, high: +1 }
  },

  // --- JAZZ / FUSION ---
  jazz: {
    name: "Jazz / Fusion",
    // Natural lows, mid-rich body, gentle highs
    tilt: { low: 0, mid: +2, high: -0.5 }
  },

  // --- DUBSTEP / BASS MUSIC ---
  dubstep: {
    name: "Dubstep / Bass",
    // Heavy bass emphasis, scooped mids, slightly bright
    tilt: { low: +3, mid: -2, high: +1 }
  },

  // --- REGGAE / DUB ---
  reggae: {
    name: "Reggae / Dub",
    // Round lows, soft mids, smooth highs
    tilt: { low: +1.5, mid: -0.5, high: -1 }
  }
};

function analyzeTrackFrequencies(inst) {
  const synth = synths[inst];
  if (!synth) return null;
  
  const instData = instruments[inst];
  const type = instData.type;
  
  // Frequency profiles for intelligent EQ
  const profiles = {
    kick: { fundamental: 60, lowEnd: 40, midRange: 200, presence: 3000, clarity: 8000 },
    snare: { fundamental: 200, body: 400, snap: 3500, brightness: 8000 },
    hihat: { fundamental: 8000, shimmer: 12000, air: 16000 },
    bass: { fundamental: 80, subBass: 40, warmth: 200, definition: 800 },
    guitar: { body: 300, presence: 2500, clarity: 5000 },
    keys: { warmth: 250, body: 800, presence: 3000, air: 8000 },
    lead: { fundamental: 1000, presence: 3000, brightness: 6000 }
  };
  
  return profiles[inst] || profiles.keys;
}

function calculateOptimalGain(inst) {
  const instData = instruments[inst];
  const type = instData.type;
  
  // Target levels in dB
  const targets = {
    kick: -6,
    snare: -9,
    hihat: -14,
    clap: -12,
    rimshot: -15,
    tom: -10,
    crash: -16,
    ride: -16,
    bass: -8,
    guitar: -12,
    keys: -14,
    lead: -10,
    fx: -18,
    riser: -20,
    ambience: -22
  };
  
  return targets[inst] || -12;
}

function calculateOptimalPan(inst, totalInstruments) {
  const instData = instruments[inst];
  
  // Stereo field strategy
  const panMap = {
    // Center (mono sources)
    kick: 0,
    snare: 0,
    bass: 0,
    lead: 0,
    
    // Slight spread
    hihat: 15,
    rimshot: -10,
    clap: 5,
    
    // Wide stereo
    guitar: 35,
    keys: -25,
    crash: 40,
    ride: -35,
    
    // Atmospheric spread
    fx: 20,
    ambience: -30,
    riser: 0
  };
  
  return panMap[inst] || 0;
}

function analyzePatternDensity(inst) {
  const pattern = patterns[inst];
  const activeSteps = pattern.filter(s => s.active).length;
  const density = activeSteps / state.sequenceLength;
  
  const avgVelocity = activeSteps > 0
    ? pattern.filter(s => s.active).reduce((sum, s) => sum + s.velocity, 0) / activeSteps
    : 0;
  
  return {
    density,
    avgVelocity,
    activeSteps,
    totalSteps: state.sequenceLength,
    importance: density * avgVelocity // Combined metric
  };
}

function calculateIntelligentEQ(inst, freqProfile, density) {
  const eq = { low: 0, mid: 0, high: 0 };
  
  const instData = instruments[inst];
  const type = instData.type;
  
  if (type === 'drum') {
    // Drums: enhance fundamental, reduce mud
    if (inst === 'kick') {
      eq.low = 2; // Boost sub
      eq.mid = -3; // Cut mud
      eq.high = -1; // Slight air reduction
    } else if (inst === 'snare') {
      eq.low = -2; // Reduce rumble
      eq.mid = 1; // Enhance body
      eq.high = 2; // Add crack
    } else if (inst === 'hihat' || inst === 'crash' || inst === 'ride') {
      eq.low = -4; // Cut lows completely
      eq.mid = -2; // Reduce mids
      eq.high = 3; // Boost highs for shimmer
    }
  } else if (type === 'melodic') {
    if (inst === 'bass') {
      eq.low = 3; // Strong bass boost
      eq.mid = -2; // Cut muddiness
      eq.high = -3; // Remove highs
    } else if (inst === 'guitar') {
      eq.low = -1;
      eq.mid = 2; // Presence boost
      eq.high = 1;
    } else if (inst === 'keys') {
      eq.low = 0;
      eq.mid = 1;
      eq.high = 2; // Clarity
    } else if (inst === 'lead') {
      eq.low = -2;
      eq.mid = 3; // Strong presence
      eq.high = 2; // Brightness
    }
  } else if (type === 'atmospheric') {
    eq.low = -3; // Clean lows
    eq.mid = -1;
    eq.high = 4; // Emphasize air
  }
  
  // Adjust based on density - busier instruments get subtle treatment
  if (density.density > 0.5) {
    eq.low *= 0.7;
    eq.mid *= 0.7;
    eq.high *= 0.7;
  }
  
  return eq;
}

// ============================================================================
// ENHANCED applyAIMixing() - Professional Grade
// ============================================================================

async function applyAIMixing() {
  if (!state.aiMixing.enabled) return;
  
  showToast('ðŸ¤– AI analyzing mix...', 'info');
  
  const analysis = {
    instruments: {},
    totalDensity: 0,
    activeInstruments: 0,
    freqMasking: {},
    stereoBalance: 0
  };
  
  // PHASE 1: Deep Analysis
  Object.keys(instruments).forEach(inst => {
    const density = analyzePatternDensity(inst);
    const freqProfile = analyzeTrackFrequenciesAdvanced(inst);
    
    analysis.instruments[inst] = {
      density,
      freqProfile,
      currentGain: instruments[inst].volume,
      currentPan: instruments[inst].pan,
      dynamicRange: calculateDynamicRange(inst),
      peakFrequency: freqProfile.peakFreq,
      spectralCentroid: calculateSpectralCentroid(freqProfile)
    };
    
    if (density.activeSteps > 0) {
      analysis.totalDensity += density.importance;
      analysis.activeInstruments++;
    }
  });
  
  // Calculate frequency masking matrix
  Object.keys(instruments).forEach(inst => {
    analysis.freqMasking[inst] = calculateFrequencyMasking(inst, analysis);
  });
  
  state.aiMixing.lastAnalysis = analysis;
  
  // PHASE 2: Professional Mixing
  let adjustments = 0;
  
  Object.keys(instruments).forEach(inst => {
    const instAnalysis = analysis.instruments[inst];
    const instData = instruments[inst];
    
    if (instAnalysis.density.activeSteps === 0) return;

    // 1. PROFESSIONAL GAIN STAGING
    if (state.aiMixing.autoGain) {
      // Calculate optimal linear gain 0.1â€“1.0
      const targetGain = calculateProfessionalGain(inst, instAnalysis, analysis);
    
      // Convert to dB for your mixer UI
      const targetDb = 20 * Math.log10(targetGain); // e.g. 0.5 â†’ -6 dB
    
      // Store in your instrument model (dB)
      instData.volume = targetDb;
    
      // Apply to Tone channel in dB
      if (instData.channel && instData.channel.volume) {
        instData.channel.volume.rampTo(targetDb, 0.5);
      }
    
      adjustments++;
    }

    
    // 2. INTELLIGENT STEREO PLACEMENT
    if (state.aiMixing.autoPan) {
      const targetPan = calculateIntelligentPan(inst, instAnalysis, analysis);
      instData.pan = targetPan;
      
      if (instData.channel) {
        instData.channel.pan.rampTo(targetPan / 100, 0.5);
      }
      adjustments++;
    }
    
    // 3. SURGICAL EQ
    if (state.aiMixing.autoEQ) {
      const eq = applyProfessionalEQ(inst, instAnalysis, analysis);
      
      // Create or update EQ nodes
      if (!instData.eq) {
        instData.eq = {
          low: new Tone.EQ3(),
          mid: new Tone.Filter(),
          high: new Tone.EQ3()
        };
        instData.channel.chain(instData.eq.low, instData.eq.mid, instData.eq.high);
      }
      
      // Apply EQ settings
      if (instData.eq.low) {
        instData.eq.low.low.value = eq.low;
        instData.eq.low.mid.value = eq.mid;
        instData.eq.low.high.value = eq.high;
      }
      
      console.log(`ðŸŽ›ï¸ ${inst} EQ: L${eq.low > 0 ? '+' : ''}${eq.low.toFixed(1)}dB M${eq.mid > 0 ? '+' : ''}${eq.mid.toFixed(1)}dB H${eq.high > 0 ? '+' : ''}${eq.high.toFixed(1)}dB`);
      adjustments++;
    }
    
    // 4. DYNAMIC COMPRESSION
    if (state.aiMixing.autoCompression) {
      const compSettings = calculateIntelligentCompression(inst, instAnalysis, analysis);
      
      if (compSettings.enabled) {
        if (!instData.compressor) {
          instData.compressor = new Tone.Compressor();
          instData.channel.chain(instData.compressor);
        }
        
        instData.compressor.threshold.rampTo(compSettings.threshold, 0.5);
        instData.compressor.ratio.value = compSettings.ratio;
        instData.compressor.attack.rampTo(compSettings.attack, 0.5);
        instData.compressor.release.rampTo(compSettings.release, 0.5);
        instData.compressor.knee.value = compSettings.knee;
        
        console.log(`ðŸ“Š ${inst} compression: ${compSettings.ratio}:1 @ ${compSettings.threshold}dB`);
        adjustments++;
      }
    }
  });
  
  // PHASE 3: Master Bus Intelligence
  const mixCharacteristics = analyzeMixCharacteristics(analysis);
  
  // Adaptive master compression
  if (mixCharacteristics.density > 0.7) {
    // Dense mix - multiband approach
    master.comp.threshold.rampTo(-18, 0.5);
    master.comp.ratio.value = 4;
    master.comp.attack.rampTo(0.005, 0.5);
    master.comp.release.rampTo(0.12, 0.5);
  } else if (mixCharacteristics.density > 0.4) {
    // Medium density - gentle glue
    master.comp.threshold.rampTo(-22, 0.5);
    master.comp.ratio.value = 3;
    master.comp.attack.rampTo(0.01, 0.5);
    master.comp.release.rampTo(0.15, 0.5);
  } else {
    // Sparse mix - transparent
    master.comp.threshold.rampTo(-26, 0.5);
    master.comp.ratio.value = 2.5;
    master.comp.attack.rampTo(0.02, 0.5);
    master.comp.release.rampTo(0.2, 0.5);
  }
  
  // Adaptive master EQ
  if (mixCharacteristics.lowEndEnergy > 0.4) {
    // Tighten bass
    if (master.lowCutFilter) {
      master.lowCutFilter.frequency.rampTo(35, 0.5);
    }
  }
  
  if (mixCharacteristics.highEndEnergy < 0.15) {
    // Add air
    if (master.highShelf) {
      master.highShelf.gain.rampTo(1.5, 0.5);
    }
  }
  
  renderMixer();
  
  // Detailed reporting
  console.log('ðŸ¤– Professional AI Mixing Complete:');
  console.log(`   âœ“ ${adjustments} intelligent adjustments`);
  console.log(`   âœ“ ${analysis.activeInstruments} instruments balanced`);
  console.log(`   âœ“ Mix density: ${mixCharacteristics.density.toFixed(2)}`);
  console.log(`   âœ“ Frequency balance: ${mixCharacteristics.balance}`);
  console.log(`   âœ“ Stereo width: ${mixCharacteristics.stereoWidth.toFixed(1)}%`);
  console.log(`   âœ“ Dynamic range: ${mixCharacteristics.dynamicRange.toFixed(1)}dB`);
  
  showToast(`âœ… Professional mix: ${analysis.activeInstruments} tracks`, 'success');
}

// Helper: Advanced frequency analysis
function analyzeTrackFrequenciesAdvanced(inst) {
  const profile = {
    subBass: 0,    // 20-60 Hz
    bass: 0,       // 60-250 Hz
    lowMid: 0,     // 250-500 Hz
    mid: 0,        // 500-2k Hz
    highMid: 0,    // 2k-6k Hz
    presence: 0,   // 6k-12k Hz
    brilliance: 0, // 12k-20k Hz
    peakFreq: 0,
    peakEnergy: 0
  };
  
  // Instrument-based frequency profiles (synthesized from typical values)
  const profiles = {
    kick: { subBass: 0.45, bass: 0.35, lowMid: 0.10, mid: 0.05, highMid: 0.03, presence: 0.02, brilliance: 0.00 },
    bass: { subBass: 0.35, bass: 0.40, lowMid: 0.15, mid: 0.07, highMid: 0.02, presence: 0.01, brilliance: 0.00 },
    snare: { subBass: 0.05, bass: 0.15, lowMid: 0.20, mid: 0.25, highMid: 0.20, presence: 0.10, brilliance: 0.05 },
    hihat: { subBass: 0.00, bass: 0.00, lowMid: 0.02, mid: 0.08, highMid: 0.25, presence: 0.35, brilliance: 0.30 },
    clap: { subBass: 0.00, bass: 0.05, lowMid: 0.15, mid: 0.25, highMid: 0.30, presence: 0.20, brilliance: 0.05 },
    perc: { subBass: 0.00, bass: 0.05, lowMid: 0.10, mid: 0.30, highMid: 0.30, presence: 0.20, brilliance: 0.05 },
    synth: { subBass: 0.10, bass: 0.20, lowMid: 0.25, mid: 0.25, highMid: 0.12, presence: 0.06, brilliance: 0.02 },
    lead: { subBass: 0.00, bass: 0.05, lowMid: 0.15, mid: 0.35, highMid: 0.25, presence: 0.15, brilliance: 0.05 }
  };
  
  const instProfile = profiles[inst] || profiles.synth;
  Object.assign(profile, instProfile);
  
  // Find peak frequency
  let maxEnergy = 0;
  const freqRanges = {
    subBass: 40, bass: 150, lowMid: 375, mid: 1250,
    highMid: 4000, presence: 9000, brilliance: 16000
  };
  
  Object.entries(profile).forEach(([band, energy]) => {
    if (freqRanges[band] && energy > maxEnergy) {
      maxEnergy = energy;
      profile.peakFreq = freqRanges[band];
      profile.peakEnergy = energy;
    }
  });
  
  return profile;
}

// Helper: Calculate spectral centroid
function calculateSpectralCentroid(freqProfile) {
  const freqs = [40, 150, 375, 1250, 4000, 9000, 16000];
  const weights = [
    freqProfile.subBass,
    freqProfile.bass,
    freqProfile.lowMid,
    freqProfile.mid,
    freqProfile.highMid,
    freqProfile.presence,
    freqProfile.brilliance
  ];
  
  let weightedSum = 0;
  let totalWeight = 0;
  
  freqs.forEach((freq, i) => {
    weightedSum += freq * weights[i];
    totalWeight += weights[i];
  });
  
  return totalWeight > 0 ? weightedSum / totalWeight : 1000;
}

// Helper: Calculate dynamic range
function calculateDynamicRange(inst) {
  const density = analyzePatternDensity(inst);
  // Estimate based on pattern complexity
  const baseRange = {
    kick: 12, bass: 8, snare: 14, hihat: 10,
    clap: 12, perc: 11, synth: 10, lead: 13
  };
  
  const range = baseRange[inst] || 10;
  const densityReduction = density.density * 4; // Dense patterns = less dynamic range
  
  return Math.max(6, range - densityReduction);
}

// Helper: Frequency masking calculation
function calculateFrequencyMasking(inst, analysis) {
  const instFreq = analysis.instruments[inst].freqProfile;
  let maskingScore = 0;
  let conflicts = 0;
  
  Object.keys(analysis.instruments).forEach(otherInst => {
    if (otherInst === inst) return;
    
    const otherFreq = analysis.instruments[otherInst].freqProfile;
    
    // Weight overlaps by importance (low freq conflicts matter more)
    const overlap = 
      Math.min(instFreq.subBass, otherFreq.subBass) * 3.0 +
      Math.min(instFreq.bass, otherFreq.bass) * 2.5 +
      Math.min(instFreq.lowMid, otherFreq.lowMid) * 2.0 +
      Math.min(instFreq.mid, otherFreq.mid) * 1.5 +
      Math.min(instFreq.highMid, otherFreq.highMid) * 1.2 +
      Math.min(instFreq.presence, otherFreq.presence) * 1.0 +
      Math.min(instFreq.brilliance, otherFreq.brilliance) * 0.8;
    
    if (overlap > 0.15) conflicts++;
    maskingScore += overlap;
  });
  
  return {
    score: Math.min(maskingScore / Math.max(analysis.activeInstruments - 1, 1), 1),
    conflicts
  };
}

// Helper: Professional gain calculation
function calculateProfessionalGain(inst, instAnalysis, mixAnalysis) {
  const targetLevels = {
    kick: 0.71,
    bass: 0.63,
    snare: 0.56,
    clap: 0.50,
    hihat: 0.40,
    perc: 0.35,
    lead: 0.63,
    synth: 0.56,
    pad: 0.45,
    default: 0.50
  };
  
  let targetGain = targetLevels[inst] || 0.65;
  
  // 1. Density compensation (softer)
  const densityFactor = Math.pow(instAnalysis.density.density, 0.5);
  targetGain *= (1 - densityFactor * 0.15);  // was 0.25
  
  // 2. Frequency masking compensation (softer)
  const masking = mixAnalysis.freqMasking[inst];
  targetGain *= (1 - masking.score * 0.15);  // was 0.3
  
  // 3. Mix crowding compensation (softer)
  const crowdingFactor = Math.min(mixAnalysis.activeInstruments / 8, 1);
  targetGain *= (1 - crowdingFactor * 0.10); // was 0.2
  
  // 4. Importance boost (keep)
  const importanceRatio = instAnalysis.density.importance / mixAnalysis.totalDensity;
  targetGain *= (1 + importanceRatio * 0.4);
  
  // 5. Dynamic range consideration (keep)
  const drFactor = instAnalysis.dynamicRange / 14;
  targetGain *= (0.85 + drFactor * 0.15);

  // Small overall loudness bump & higher floor
  targetGain *= 1.15;
  
  return Math.max(0.2, Math.min(1.0, targetGain)); // floor at 0.2 instead of 0.1
}


// Helper: Intelligent panning
function calculateIntelligentPan(inst, instAnalysis, mixAnalysis) {
  // Keep low frequencies centered for mono compatibility
  const lowEndEnergy = instAnalysis.freqProfile.subBass + instAnalysis.freqProfile.bass;
  
  if (lowEndEnergy > 0.5 || inst === 'kick' || inst === 'bass') {
    return 0; // Center
  }
  
  // Strategic panning zones
  const panStrategy = {
    snare: 0,     // Center for impact
    clap: 5,      // Slight offset
    hihat: 30,    // Right
    perc: -25,    // Left
    synth: 20,    // Right
    lead: 0       // Center focus
  };
  
  let targetPan = panStrategy[inst] || 0;
  
  // Add spectral-based variation
  const spectralBias = (instAnalysis.spectralCentroid - 1000) / 100;
  targetPan += spectralBias * 0.5;
  
  // Avoid crowding
  const existingPans = Object.values(mixAnalysis.instruments)
    .map(i => i.currentPan)
    .filter(p => p !== undefined);
  
  // Find least crowded zone
  const zones = [-40, -25, -10, 0, 10, 25, 40];
  let bestZone = targetPan;
  let minCrowding = Infinity;
  
  zones.forEach(zone => {
    const crowding = existingPans.reduce((sum, pan) => {
      return sum + Math.max(0, 30 - Math.abs(zone - pan));
    }, 0);
    
    if (crowding < minCrowding) {
      minCrowding = crowding;
      bestZone = zone;
    }
  });
  
  return Math.max(-50, Math.min(50, bestZone));
}

// Helper: Professional EQ
function applyProfessionalEQ(inst, instAnalysis, mixAnalysis) {
  // Instrument-specific EQ templates
  const eqTemplates = {
    kick: { low: 3, mid: -4, high: 0 },
    bass: { low: 2, mid: -2, high: -6 },
    snare: { low: -8, mid: -1, high: 3 },
    hihat: { low: -18, mid: -3, high: 2 },
    clap: { low: -12, mid: 1, high: 2 },
    perc: { low: -10, mid: 2, high: 1 },
    synth: { low: 0, mid: 1, high: 0 },
    lead: { low: -4, mid: 2, high: 1 }
  };
  
  const eq = { ...(eqTemplates[inst] || { low: 0, mid: 0, high: 0 }) };

  // Genre tilt (lofi vs hiphop vs ambient, etc.)
  const genreKey = (state.currentGenre || 'default').toLowerCase();
  const genreProfile = GENRE_MIX_PROFILES[genreKey] || GENRE_MIX_PROFILES.default;
  const tilt = genreProfile.tilt || { low: 0, mid: 0, high: 0 };

  eq.low  += tilt.low;
  eq.mid  += tilt.mid;
  eq.high += tilt.high;
  // Dynamic adjustments based on masking
  const masking = mixAnalysis.freqMasking[inst];
  if (masking.score > 0.5) {
    // Heavy masking - carve space
    if (instAnalysis.freqProfile.bass > 0.3) {
      eq.low += 1; // Boost strength
    }
    eq.mid -= 2; // Cut mids to reduce conflicts
  }
  
  // Density adjustments
  if (instAnalysis.density.density > 0.6) {
    eq.low -= 1; // Reduce mud in busy sections
  }
  
  // Spectral balance
  const mixBalance = analyzeMixCharacteristics(mixAnalysis);
  if (mixBalance.lowEndEnergy > 0.5) {
    eq.low -= 1; // Reduce if mix is bass-heavy
  }
  if (mixBalance.highEndEnergy < 0.2) {
    eq.high += 1.5; // Add air if mix is dull
  }
  
  return eq;
}

// Helper: Intelligent compression
function calculateIntelligentCompression(inst, instAnalysis, mixAnalysis) {
  const settings = {
    enabled: false,
    threshold: -20,
    ratio: 3,
    attack: 0.01,
    release: 0.1,
    knee: 4
  };
  
  // Only compress if needed
  if (instAnalysis.dynamicRange > 10 || instAnalysis.density.density > 0.5) {
    settings.enabled = true;
    
    // Instrument-specific settings
    const compProfiles = {
      kick: { threshold: -12, ratio: 4, attack: 0.003, release: 0.08, knee: 2 },
      bass: { threshold: -15, ratio: 5, attack: 0.01, release: 0.15, knee: 4 },
      snare: { threshold: -10, ratio: 4, attack: 0.001, release: 0.05, knee: 2 },
      hihat: { threshold: -18, ratio: 3, attack: 0.001, release: 0.04, knee: 3 },
      clap: { threshold: -14, ratio: 4, attack: 0.002, release: 0.06, knee: 3 },
      synth: { threshold: -16, ratio: 3.5, attack: 0.01, release: 0.12, knee: 5 },
      lead: { threshold: -14, ratio: 4, attack: 0.005, release: 0.1, knee: 4 }
    };
    
    Object.assign(settings, compProfiles[inst] || {});
    
    // Dynamic adjustments
    if (instAnalysis.density.density > 0.7) {
      settings.ratio += 1; // More compression for dense patterns
      settings.threshold -= 2;
    }
  }
  
  return settings;
}

// Helper: Analyze overall mix characteristics
function analyzeMixCharacteristics(analysis) {
  let lowEndEnergy = 0;
  let midEnergy = 0;
  let highEndEnergy = 0;
  let totalEnergy = 0;
  let stereoSpread = 0;
  let avgDynamicRange = 0;
  
  Object.values(analysis.instruments).forEach(inst => {
    const weight = inst.density.importance;
    
    lowEndEnergy += (inst.freqProfile.subBass + inst.freqProfile.bass) * weight;
    midEnergy += (inst.freqProfile.lowMid + inst.freqProfile.mid) * weight;
    highEndEnergy += (inst.freqProfile.highMid + inst.freqProfile.presence + inst.freqProfile.brilliance) * weight;
    totalEnergy += weight;
    
    stereoSpread += Math.abs(inst.currentPan || 0);
    avgDynamicRange += inst.dynamicRange;
  });
  
  const count = analysis.activeInstruments || 1;
  
  return {
    density: analysis.totalDensity / Math.max(count, 1),
    lowEndEnergy: lowEndEnergy / totalEnergy,
    midEnergy: midEnergy / totalEnergy,
    highEndEnergy: highEndEnergy / totalEnergy,
    balance: lowEndEnergy > 0.4 ? 'bass-heavy' : highEndEnergy > 0.4 ? 'bright' : 'balanced',
    stereoWidth: (stereoSpread / count) * 2,
    dynamicRange: avgDynamicRange / count
  };
}

// ============================================================================
// ENHANCED applyMasteringPreset() - Professional Grade
// ============================================================================

function applyMasteringPreset(preset) {
  const presets = {
    gentle: {
      name: "Gentle Dynamics",
      comp: { threshold: -20, ratio: 2.5, attack: 0.02, release: 0.3, knee: 8 },
      limiter: -2.0,
      tape: 12,
      highCut: 18000,
      lowCut: 22,
      stereoWidth: 1.0,
      targetLUFS: -18
    },
    modern: {
      name: "Modern Streaming",
      comp: { threshold: -16, ratio: 4, attack: 0.005, release: 0.15, knee: 6 },
      limiter: -0.8,
      tape: 25,
      highCut: 17000,
      lowCut: 28,
      stereoWidth: 1.08,
      targetLUFS: -14
    },
    aggressive: {
      name: "Aggressive/Club",
      comp: { threshold: -12, ratio: 6, attack: 0.002, release: 0.1, knee: 4 },
      limiter: -0.3,
      tape: 38,
      highCut: 16000,
      lowCut: 32,
      stereoWidth: 1.15,
      targetLUFS: -11
    },
    lofi: {
      name: "Lo-Fi/Vintage",
      comp: { threshold: -22, ratio: 3, attack: 0.03, release: 0.35, knee: 10 },
      limiter: -3.0,
      tape: 55,
      highCut: 10000,
      lowCut: 45,
      stereoWidth: 0.9,
      targetLUFS: -16
    },
    broadcast: {
      name: "Broadcast Ready",
      comp: { threshold: -14, ratio: 5, attack: 0.003, release: 0.12, knee: 5 },
      limiter: -0.5,
      tape: 20,
      highCut: 15000,
      lowCut: 40,
      stereoWidth: 1.0,
      targetLUFS: -16
    },
    vinyl: {
      name: "Vinyl Master",
      comp: { threshold: -18, ratio: 3, attack: 0.01, release: 0.25, knee: 8 },
      limiter: -2.5,
      tape: 48,
      highCut: 12000,
      lowCut: 30,
      stereoWidth: 0.95,
      targetLUFS: -16
    }
  };
  
  const config = presets[preset];
  if (!config) {
    console.warn(`Unknown preset: ${preset}`);
    return;
  }
  
  showToast(`ðŸŽšï¸ Applying ${config.name}...`, 'info');
  
  // 1. Master Compression with advanced settings
  master.comp.threshold.rampTo(config.comp.threshold, 0.5);
  master.comp.ratio.value = config.comp.ratio;
  master.comp.attack.rampTo(config.comp.attack, 0.5);
  master.comp.release.rampTo(config.comp.release, 0.5);
  
  if (master.comp.knee) {
    master.comp.knee.value = config.comp.knee;
  }
  
  // 2. Filtering with precise control
  state.lowCut = config.lowCut;
  state.highCut = config.highCut;
  
  if (master.lowCutFilter) {
    master.lowCutFilter.frequency.rampTo(config.lowCut, 0.5);
    master.lowCutFilter.Q.value = 0.707; // Butterworth response
  }
  
  if (master.highCutFilter) {
    master.highCutFilter.frequency.rampTo(config.highCut, 0.5);
    master.highCutFilter.Q.value = 0.707;
  }
  
  // 3. Tape Saturation with harmonic enhancement
  state.tapeSaturation = config.tape;
  if (master.tapeDistortion) {
    const saturation = config.tape / 100;
    master.tapeDistortion.distortion = saturation * 0.25;
    master.tapeDistortion.wet.rampTo(saturation * 0.65, 0.5);
    
    // Add subtle odd harmonics for warmth
    if (master.tapeDistortion.oversample) {
      master.tapeDistortion.oversample = saturation > 0.4 ? '4x' : '2x';
    }
  }
  
  // 4. Stereo Width Enhancement
  if (master.stereoWidth) {
    master.stereoWidth.wet.rampTo(config.stereoWidth - 1, 0.5);
  }
  
  // 5. Peak Limiter (brickwall)
  if (master.limiter) {
    master.limiter.threshold.rampTo(config.limiter, 0.5);
    // Fast attack, medium release for transparency
    if (master.limiter.attack) master.limiter.attack.value = 0.001;
    if (master.limiter.release) master.limiter.release.rampTo(0.05, 0.5);
  }
  
  // 6. Update UI elements
  const uiUpdates = {
    'compSlider': config.comp.threshold,
    'compValue': config.comp.threshold + 'dB',
    'ratioValue': config.comp.ratio + ':1',
    'lowCutSlider': config.lowCut,
    'lowCutValue': config.lowCut + 'Hz',
    'highCutSlider': config.highCut,
    'highCutValue': (config.highCut / 1000).toFixed(1) + 'kHz',
    'tapeSlider': config.tape,
    'tapeValue': config.tape + '%',
    'widthValue': Math.round(config.stereoWidth * 100) + '%'
  };
  
  Object.entries(uiUpdates).forEach(([id, value]) => {
    const element = document.getElementById(id);
    if (element) {
      if (id.includes('Slider')) {
        element.value = value;
      } else {
        element.textContent = value;
      }
    }
  });
  
  // 7. Detailed console logging
  console.log(`ðŸŽšï¸ Professional Mastering Applied: ${config.name}`);
  console.log(`   Target Loudness: ${config.targetLUFS} LUFS`);
  console.log(`   Compression: ${config.comp.ratio}:1 @ ${config.comp.threshold}dB`);
  console.log(`   Attack/Release: ${(config.comp.attack * 1000).toFixed(1)}ms / ${(config.comp.release * 1000).toFixed(0)}ms`);
  console.log(`   Tape Saturation: ${config.tape}% (${config.tape > 40 ? 'Heavy' : config.tape > 25 ? 'Medium' : 'Light'})`);
  console.log(`   Frequency Range: ${config.lowCut}Hz - ${(config.highCut / 1000).toFixed(1)}kHz`);
  console.log(`   Stereo Width: ${Math.round(config.stereoWidth * 100)}%`);
  console.log(`   Peak Limiter: ${config.limiter}dB ceiling`);
  
  // 8. Show professional feedback
  const characteristics = [];
  
  if (config.comp.ratio >= 5) characteristics.push('punchy');
  if (config.tape > 40) characteristics.push('warm');
  if (config.stereoWidth > 1.1) characteristics.push('wide');
  if (config.targetLUFS <= -16) characteristics.push('dynamic');
  if (config.targetLUFS >= -12) characteristics.push('loud');
  if (config.highCut < 14000) characteristics.push('vintage');
  
  const charText = characteristics.length > 0 ? ` (${characteristics.join(', ')})` : '';
  
  showToast(`âœ… ${config.name} mastering applied${charText}`, 'success');
}

// ============================================================================
// ADDITIONAL PROFESSIONAL UTILITIES
// ============================================================================

// Calculate LUFS (simplified integrated loudness)
function calculateLUFS() {
  if (!master || !master.meter) return -18;
  
  // This would need actual audio analysis in production
  // Simplified estimation based on current meter reading
  const currentLevel = master.meter.getValue();
  const estimatedLUFS = currentLevel + 6; // Rough conversion
  
  return Math.max(-40, Math.min(0, estimatedLUFS));
}

// Real-time mix analysis for display
function getMixAnalysisReport() {
  if (!state.aiMixing || !state.aiMixing.lastAnalysis) {
    return null;
  }
  
  const analysis = state.aiMixing.lastAnalysis;
  const mixChar = analyzeMixCharacteristics(analysis);
  
  return {
    activeInstruments: analysis.activeInstruments,
    totalDensity: analysis.totalDensity.toFixed(2),
    frequencyBalance: mixChar.balance,
    stereoWidth: mixChar.stereoWidth.toFixed(1) + '%',
    dynamicRange: mixChar.dynamicRange.toFixed(1) + 'dB',
    estimatedLUFS: calculateLUFS().toFixed(1),
    recommendations: generateMixRecommendations(analysis, mixChar)
  };
}

// Generate intelligent recommendations
function generateMixRecommendations(analysis, mixChar) {
  const recommendations = [];
  
  // Check frequency balance
  if (mixChar.lowEndEnergy > 0.5) {
    recommendations.push('âš ï¸ Mix is bass-heavy - consider high-pass filtering or reducing low-end');
  }
  
  if (mixChar.highEndEnergy < 0.15) {
    recommendations.push('ðŸ’¡ Add brightness - boost high shelf or add more high-frequency content');
  }
  
  // Check density
  if (mixChar.density > 0.8) {
    recommendations.push('ðŸ“Š Very dense mix - ensure clarity with EQ carving');
  } else if (mixChar.density < 0.3) {
    recommendations.push('ðŸŽµ Sparse mix - good dynamics, consider adding texture');
  }
  
  // Check stereo field
  if (mixChar.stereoWidth < 15) {
    recommendations.push('â†”ï¸ Narrow stereo image - pan elements for wider mix');
  } else if (mixChar.stereoWidth > 45) {
    recommendations.push('âš ï¸ Very wide - check mono compatibility');
  }
  
  // Check dynamic range
  if (mixChar.dynamicRange < 6) {
    recommendations.push('ðŸ“ˆ Low dynamic range - reduce compression or limiting');
  } else if (mixChar.dynamicRange > 14) {
    recommendations.push('ðŸ“‰ High dynamic range - consider compression for consistency');
  }
  
  // Check for frequency masking conflicts
  let highMaskingCount = 0;
  Object.values(analysis.freqMasking || {}).forEach(masking => {
    if (masking.score > 0.6) highMaskingCount++;
  });
  
  if (highMaskingCount > 2) {
    recommendations.push('ðŸŽšï¸ Heavy frequency masking detected - use EQ to separate instruments');
  }
  
  if (recommendations.length === 0) {
    recommendations.push('âœ… Mix balance looks good!');
  }
  
  return recommendations;
}

// Automatic loudness normalization
function normalizeMixLoudness(targetLUFS = -14) {
  const currentLUFS = calculateLUFS();
  const difference = targetLUFS - currentLUFS;
  
  if (Math.abs(difference) > 0.5) {
    const gainAdjust = Math.pow(10, difference / 20);
    
    if (master.gain) {
      const currentGain = master.gain.gain.value;
      master.gain.gain.rampTo(currentGain * gainAdjust, 1.0);
    }
    
    console.log(`ðŸ“Š Loudness normalized: ${currentLUFS.toFixed(1)} â†’ ${targetLUFS} LUFS`);
    showToast(`Normalized to ${targetLUFS} LUFS`, 'success');
  }
}

// Export professional mix analysis
function exportMixAnalysis() {
  const report = getMixAnalysisReport();
  if (!report) return null;
  
  const analysis = state.aiMixing.lastAnalysis;
  
  const detailedReport = {
    timestamp: new Date().toISOString(),
    summary: report,
    instruments: {}
  };
  
  // Add per-instrument details
  Object.entries(analysis.instruments).forEach(([inst, data]) => {
    detailedReport.instruments[inst] = {
      active: data.density.activeSteps > 0,
      density: data.density.density.toFixed(2),
      importance: data.density.importance.toFixed(2),
      gain: data.currentGain,
      pan: data.currentPan,
      peakFrequency: data.peakFrequency ? data.peakFrequency.toFixed(0) + 'Hz' : 'N/A',
      spectralCentroid: data.spectralCentroid ? data.spectralCentroid.toFixed(0) + 'Hz' : 'N/A',
      dynamicRange: data.dynamicRange ? data.dynamicRange.toFixed(1) + 'dB' : 'N/A',
      frequencyProfile: {
        low: ((data.freqProfile.subBass + data.freqProfile.bass) * 100).toFixed(0) + '%',
        mid: ((data.freqProfile.lowMid + data.freqProfile.mid) * 100).toFixed(0) + '%',
        high: ((data.freqProfile.highMid + data.freqProfile.presence + data.freqProfile.brilliance) * 100).toFixed(0) + '%'
      }
    };
  });
  
  return detailedReport;
}

// Preset comparison tool
function comparePresets() {
  const presetNames = Object.keys({
    gentle: true,
    modern: true,
    aggressive: true,
    lofi: true,
    broadcast: true,
    vinyl: true
  });
  
  console.log('ðŸŽšï¸ MASTERING PRESET COMPARISON');
  console.log('â•'.repeat(60));
  
  presetNames.forEach(preset => {
    const presets = {
      gentle: { targetLUFS: -18, ratio: 2.5, tape: 12, character: 'Natural & Dynamic' },
      modern: { targetLUFS: -14, ratio: 4, tape: 25, character: 'Streaming Ready' },
      aggressive: { targetLUFS: -11, ratio: 6, tape: 38, character: 'Loud & Punchy' },
      lofi: { targetLUFS: -16, ratio: 3, tape: 55, character: 'Vintage Warmth' },
      broadcast: { targetLUFS: -16, ratio: 5, tape: 20, character: 'Broadcast Safe' },
      vinyl: { targetLUFS: -16, ratio: 3, tape: 48, character: 'Analog Style' }
    };
    
    const config = presets[preset];
    console.log(`${preset.toUpperCase()}: ${config.character}`);
    console.log(`  Loudness: ${config.targetLUFS} LUFS | Ratio: ${config.ratio}:1 | Tape: ${config.tape}%`);
    console.log('â”€'.repeat(60));
  });
}

// ============================================================================
// INTEGRATION HELPERS
// ============================================================================

// ðŸ”¥ Randomized mix hype messages (no more mix scores!)
const MIX_HYPE = [
  "You Rock! ðŸ¤˜",
  "Mix Locked In! ðŸ”’ðŸ”¥",
  "Sounding Killer ðŸŽ§",
  "Vibes Secured âœ¨",
  "Your ears? Legendary ðŸ‘‘",
  "Certified Fresh ðŸ¥¬ðŸ”¥",
  "High-Key Slaps ðŸ˜¤ðŸŽ¶",
  "Studio Mode: ENGAGED âš¡",
  "Clean Mix, Dirty Attitude ðŸ˜ˆðŸŽ›ï¸",
  "Producer Level: Unlocked ðŸ—ï¸",
  "Zero Mid, All Hit ðŸ’¥",
  "Faders Blessed ðŸ™ðŸŽšï¸",
  "Big Brain Mix Moves ðŸ§ âœ¨",
  "This Would Fool a Pro ðŸ‘€",
  "Headphone Check: PASSED âœ…",
];

function showMixHypeToast() {
  if (typeof showToast !== 'function') {
    console.warn('âš ï¸ showToast not available for mix hype');
    return;
  }
  const msg = MIX_HYPE[Math.floor(Math.random() * MIX_HYPE.length)];
  showToast(msg, 'success');
}
  
// Call this to apply AI mixing with current settings
function autoMixNow() {
  if (state.aiMixing && state.aiMixing.enabled) {
    applyAIMixing();
  } else {
    showToast('Enable AI Mixing first', 'warning');
  }
}

// Quick preset switcher
function quickMaster(style) {
  const styleMap = {
    soft: 'gentle',
    balanced: 'modern',
    loud: 'aggressive',
    vintage: 'lofi',
    radio: 'broadcast',
    analog: 'vinyl'
  };
  
  const preset = styleMap[style] || style;
  applyMasteringPreset(preset);
}

// Get current mix health score (0-100)
function getMixHealthScore() {
  const report = getMixAnalysisReport();
  if (!report) return 75; // neutral if no data yet
  
  // Start from a realistic â€œgood but improvableâ€ baseline
  let score = 85;
  
  const mixChar = analyzeMixCharacteristics(state.aiMixing.lastAnalysis);
  
  // Much softer penalties
  if (mixChar.lowEndEnergy > 0.55) score -= 5;   // slightly bass-heavy
  if (mixChar.highEndEnergy < 0.15) score -= 5;  // slightly dull
  if (mixChar.density > 0.85) score -= 5;        // very dense
  
  if (mixChar.dynamicRange < 6)  score -= 8;     // too crushed
  if (mixChar.dynamicRange > 14) score -= 5;     // super wide dynamics (maybe too loose)
  
  // Masking: add up small penalties but cap it
  let maskingPenalty = 0;
  Object.values(state.aiMixing.lastAnalysis.freqMasking || {}).forEach(masking => {
    if (masking.score > 0.6) maskingPenalty += 3;
  });
  score -= Math.min(maskingPenalty, 12);
  
  // Clamp to a sane window: 20â€“100
  return Math.max(20, Math.min(100, score));
}

console.log('ðŸŽ›ï¸ Professional AI Mixing & Mastering System Loaded');
console.log('ðŸ“Š Features: Advanced gain staging, surgical EQ, intelligent compression');
console.log('ðŸŽšï¸ Mastering presets: gentle, modern, aggressive, lofi, broadcast, vinyl');
console.log('ðŸ’¡ Type comparePresets() to see all preset details');
  
function setupTransportControls() {
  document.getElementById('playBtn').addEventListener('click', togglePlay);
  document.getElementById('stopBtn').addEventListener('click', stop);
  document.getElementById('exportBtn').addEventListener('click', exportAudio);
  
  // Metronome controls
  document.getElementById('metronomeBtn')?.addEventListener('click', () => {
    state.metronomeEnabled = !state.metronomeEnabled;
    const btn = document.getElementById('metronomeBtn');
    btn.textContent = state.metronomeEnabled ? 'ðŸ¥ Click: On' : 'ðŸ¥ Click: Off';
  });
  
  document.getElementById('countInBtn')?.addEventListener('click', () => {
    state.countInBars = state.countInBars === 1 ? 2 : state.countInBars === 2 ? 0 : 1;
    const btn = document.getElementById('countInBtn');
    const labels = ['â±ï¸ Count: Off', 'â±ï¸ Count: 1 bar', 'â±ï¸ Count: 2 bars'];
    btn.textContent = labels[state.countInBars];
  });
}

function setupParameterControls() {
  // BPM with debounce
  const bpmHandler = debounce(value => {
    state.bpm = clamp(value, 60, CONFIG.MAX_BPM);
    Tone.Transport.bpm.value = state.bpm;
  }, CONFIG.DEBOUNCE_MS);
  
  document.getElementById('bpmSlider').addEventListener('input', e => {
    const value = parseInt(e.target.value, 10);
    document.getElementById('bpmValue').textContent = value;
    bpmHandler(value);
  });
  
  // Swing
  document.getElementById('swingSlider').addEventListener('input', e => {
    state.swing = parseInt(e.target.value, 10);
    document.getElementById('swingValue').textContent = state.swing + '%';
    Tone.Transport.swing = state.swing / 100;
    Tone.Transport.swingSubdivision = '8n';
  });
  
  // Duration
  document.getElementById('durSlider').addEventListener('input', e => {
    state.duration = parseInt(e.target.value, 10);
    document.getElementById('durValue').textContent = state.duration + ' min';
    document.getElementById('durationDisplay').textContent = 
      '/ ' + String(state.duration).padStart(2, '0') + ':00';
  });
  
  // Complexity
  document.getElementById('complexSlider').addEventListener('input', e => {
    state.complexity = parseInt(e.target.value, 10);
    const labels = ['Simple', 'Medium', 'Complex'];
    document.getElementById('complexValue').textContent = labels[state.complexity - 1];
  });
  
  // Humanize
  document.getElementById('humanSlider').addEventListener('input', e => {
    state.humanize = parseInt(e.target.value, 10);
    document.getElementById('humanValue').textContent = state.humanize + 'ms';
  });
  
  // Master controls
  setupMasterControls();
}

function setupMasterControls() {
  const masterVolSlider  = document.getElementById('masterVolSlider');
  const masterVolValue   = document.getElementById('masterVolValue');
  const masterFader      = document.getElementById('masterFader');
  const masterFaderLabel = document.getElementById('masterFaderLabel');

  // ---- MASTER VOLUME SYNC (Mixer slider <-> Master strip fader) ----
  function applyMasterVolume(db, source) {
    // Persist in state
    state.masterVolume = db;

    // Mixer tab label
    if (masterVolValue) {
      masterVolValue.textContent = db.toFixed(0) + 'dB';
    }

    // Master strip label
    if (masterFaderLabel) {
      masterFaderLabel.textContent = db.toFixed(1) + ' dB';
    }

    // Keep controls in sync, but avoid loops
    if (masterVolSlider && source !== 'slider') {
      masterVolSlider.value = db;
    }
    if (masterFader && source !== 'fader') {
      masterFader.value = db;
    }

    // Actually apply to audio
    // (this is what you already had for the mixer slider)
    Tone.Destination.volume.rampTo(db, 0.1);
  }

  // Initial volume (default -6 dB for headroom)
  const initialDb =
    typeof state.masterVolume === 'number' ? state.masterVolume : -3;
  applyMasterVolume(initialDb);

  // Mixer Master Volume slider (horizontal, existing control)
  if (masterVolSlider) {
    masterVolSlider.addEventListener(
      'input',
      debounce((e) => {
        const db = parseInt(e.target.value, 10);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'slider');
      }, 100)
    );
  }

  // NEW: Master Strip fader (vertical, in multitrack column)
  if (masterFader) {
    masterFader.addEventListener(
      'input',
      debounce((e) => {
        const db = parseFloat(e.target.value);
        applyMasterVolume(Number.isFinite(db) ? db : 0, 'fader');
      }, 50)
    );
  }

  // ---- EXISTING MASTER FX CONTROLS (unchanged, just moved under here) ----

  const tapeSlider = document.getElementById('tapeSlider');
  if (tapeSlider) {
    tapeSlider.addEventListener(
      'input',
      debounce((e) => {
        state.tapeSaturation = parseInt(e.target.value, 10);
        document.getElementById('tapeValue').textContent =
          state.tapeSaturation + '%';
        if (master.tapeDistortion) {
          master.tapeDistortion.distortion =
            (state.tapeSaturation / 100) * 0.2; // Reduced
          master.tapeDistortion.wet.rampTo(
            (state.tapeSaturation / 100) * 0.6,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const vinylSlider = document.getElementById('vinylSlider');
  if (vinylSlider) {
    vinylSlider.addEventListener(
      'input',
      debounce((e) => {
        state.vinylNoise = parseInt(e.target.value, 10);
        document.getElementById('vinylValue').textContent =
          state.vinylNoise + '%';
        if (master.vinylNoise) {
          master.vinylNoise.volume.rampTo(
            -50 + (state.vinylNoise / 100) * 15,
            0.1
          ); // Ramp
        }
      }, 100)
    );
  }

  const lowCutSlider = document.getElementById('lowCutSlider');
  if (lowCutSlider) {
    lowCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.lowCut = parseInt(e.target.value, 10);
        document.getElementById('lowCutValue').textContent =
          state.lowCut + 'Hz';
        if (master.lowCutFilter) {
          master.lowCutFilter.frequency.rampTo(state.lowCut, 0.15); // Slower ramp
        }
      }, 100)
    );
  }

  const highCutSlider = document.getElementById('highCutSlider');
  if (highCutSlider) {
    highCutSlider.addEventListener(
      'input',
      debounce((e) => {
        state.highCut = parseInt(e.target.value, 10);
        document.getElementById('highCutValue').textContent =
          state.highCut + 'Hz';
        if (master.highCutFilter) {
          master.highCutFilter.frequency.rampTo(state.highCut, 0.15);
        }
      }, 100)
    );
  }

  const compSlider = document.getElementById('compressorSlider');
  if (compSlider) {
    compSlider.addEventListener(
      'input',
      debounce((e) => {
        state.compressor = parseInt(e.target.value, 10);
        document.getElementById('compressorValue').textContent =
          state.compressor + 'dB';
        if (master.comp) {
          master.comp.threshold.rampTo(state.compressor, 0.15);
        }
      }, 100)
    );
  }

  // Finally: wire up the master meters
  setupMasterMeters();
}

function setupMasterMeters() {
  if (!master || !master.meter) return;

  const meterL = document.getElementById('masterMeterL');
  const meterR = document.getElementById('masterMeterR');
  if (!meterL || !meterR) return;

  // Ensure inner fill elements exist
  function ensureFill(el) {
    let fill = el.querySelector('.daw-meter-fill');
    if (!fill) {
      fill = document.createElement('div');
      fill.className = 'daw-meter-fill';
      el.appendChild(fill);
    }
    return fill;
  }

  const fillL = ensureFill(meterL);
  const fillR = ensureFill(meterR);

  function dbToNorm(db) {
    if (db === -Infinity) return 0;
    const minDb = -60;
    if (db < minDb) db = minDb;
    const norm = (db - minDb) / -minDb; // map [-60,0] â†’ [0,1]
    return Math.max(0, Math.min(norm, 1));
  }

  function update() {
    // Tone.Meter returns either a single value or an array for stereo
    const value = master.meter.getValue();
    let left, right;

    if (Array.isArray(value)) {
      left = value[0];
      right = value[1] != null ? value[1] : value[0];
    } else {
      left = right = value;
    }

    const lNorm = dbToNorm(left);
    const rNorm = dbToNorm(right);

    fillL.style.height = (lNorm * 100).toFixed(1) + '%';
    fillR.style.height = (rNorm * 100).toFixed(1) + '%';

    requestAnimationFrame(update);
  }

  requestAnimationFrame(update);
}

// ============================================================================
// ðŸŽ›ï¸ PROFESSIONAL AI MIXING & MASTERING - COMPLETE UPGRADED SYSTEM
// ============================================================================

// This goes RIGHT AFTER your existing applyMasteringPreset() function

// ============================================================================
// MASTER INITIALIZATION
// ============================================================================

function initializeAIMixingSystem() {
  console.log('ðŸŽ›ï¸ Initializing Professional AI Mixing & Mastering...');
  
  // State already exists from your chunk, just verify it
  if (!state.aiMixing) {
    state.aiMixing = {
      enabled: false,
      autoGain: true,
      autoPan: true,
      autoEQ: true,
      autoCompression: true,
      lastAnalysis: null
    };
  }
  
  // Wire up all controls
  setupAIMixingToggle();
  setupAIMixingFeatures();
  setupAIMixingApplyButton();
  setupMasteringPresets();
  
  console.log('âœ… Professional AI Mixing System Ready');
  console.log('ðŸŽšï¸ Features: Gain staging, Panning, Surgical EQ, Compression');
  console.log('ðŸŽ›ï¸ Presets: gentle, modern, aggressive, lofi');
}

// ============================================================================
// TOGGLE AI MIXING ON/OFF
// ============================================================================

function setupAIMixingToggle() {
  const toggleBtn = document.getElementById('toggleAIMixingBtn');
  const statusText = document.getElementById('aiMixingStatus');
  const applyBtn = document.getElementById('applyAIMixBtn');
  
  if (!toggleBtn) {
    console.warn('âš ï¸ toggleAIMixingBtn not found in DOM');
    return;
  }
  
  toggleBtn.addEventListener('click', () => {
    // Toggle state
    state.aiMixing.enabled = !state.aiMixing.enabled;
    
    // Update status text
    if (statusText) {
      statusText.textContent = state.aiMixing.enabled ? 'ðŸ¤– AI Active' : 'Enable AI';
    }
    
    // Update button styling
    toggleBtn.classList.remove('btn-secondary', 'btn-success');
    toggleBtn.classList.add(state.aiMixing.enabled ? 'btn-success' : 'btn-secondary');
    
    // Enable/disable apply button
    if (applyBtn) {
      applyBtn.disabled = !state.aiMixing.enabled;
      applyBtn.classList.remove('btn-primary', 'btn-secondary');
      applyBtn.classList.add(state.aiMixing.enabled ? 'btn-primary' : 'btn-secondary');
    }
    
    // User feedback
    const message = state.aiMixing.enabled 
      ? 'âœ… AI Mixing enabled - Generate or click "Apply AI Mix"' 
      : 'âŒ AI Mixing disabled';
    const type = state.aiMixing.enabled ? 'success' : 'info';
    
    showToast(message, type);
    console.log(`ðŸ¤– AI Mixing: ${state.aiMixing.enabled ? 'ENABLED' : 'DISABLED'}`);
  });
}

// ============================================================================
// FEATURE CHECKBOXES (Gain, Pan, EQ, Compression)
// ============================================================================

function setupAIMixingFeatures() {
  const featureMap = {
    'autoGainCheckbox': 'autoGain',
    'autoPanCheckbox': 'autoPan',
    'autoEQCheckbox': 'autoEQ',
    'autoCompCheckbox': 'autoCompression'
  };
  
  const featureNames = {
    autoGain: 'Gain Staging',
    autoPan: 'Stereo Panning',
    autoEQ: 'Surgical EQ',
    autoCompression: 'Dynamics Compression'
  };
  
  Object.entries(featureMap).forEach(([checkboxId, stateKey]) => {
    const checkbox = document.getElementById(checkboxId);
    
    if (!checkbox) {
      console.warn(`âš ï¸ ${checkboxId} not found in DOM`);
      return;
    }
    
    // Set initial state from state.aiMixing
    checkbox.checked = state.aiMixing[stateKey];
    
    // Listen for changes
    checkbox.addEventListener('change', (e) => {
      state.aiMixing[stateKey] = e.target.checked;
      
      const status = e.target.checked ? 'ENABLED' : 'DISABLED';
      const emoji = e.target.checked ? 'âœ…' : 'âŒ';
      
      console.log(`${emoji} ${featureNames[stateKey]}: ${status}`);
      
      // Show toast if AI mixing is active
      if (state.aiMixing.enabled) {
        showToast(`${featureNames[stateKey]} ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
      }
    });
  });
  
  console.log('ðŸŽ›ï¸ AI Feature Controls initialized');
}

// ============================================================================
// APPLY AI MIXING BUTTON (Main processing)
// ============================================================================

// ============================================================================
// APPLY AI MIXING BUTTON (Main processing)
// ============================================================================

function setupAIMixingApplyButton() {
  const applyBtn = document.getElementById('applyAIMixBtn');
  
  if (!applyBtn) {
    console.warn('âš ï¸ applyAIMixBtn not found in DOM');
    return;
  }
  
  applyBtn.addEventListener('click', async () => {
    // Safety check
    if (!state.aiMixing.enabled) {
      showToast('âš ï¸ Enable AI Mixing first', 'warning');
      return;
    }
    
    // Disable button during processing
    const originalText = applyBtn.textContent;
    applyBtn.disabled = true;
    applyBtn.textContent = 'â³ Analyzing...';
    
    try {
      console.log('ðŸ¤– Starting Professional AI Mixing...');
      
      // Run the professional AI mixing engine
      await applyAIMixing();
      
      // Update mixer display
      renderMixer();
      
      // Get detailed analysis report (console-only for power users)
      const report = getMixAnalysisReport?.();
      
      if (report) {
        // Beautiful console output
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ðŸ“Š PROFESSIONAL MIX ANALYSIS REPORT');
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log(`   ðŸŽšï¸ Active Instruments: ${report.activeInstruments}`);
        console.log(`   ðŸŽµ Frequency Balance: ${report.frequencyBalance}`);
        console.log(`   â†”ï¸  Stereo Width: ${report.stereoWidth}`);
        console.log(`   ðŸ“Š Dynamic Range: ${report.dynamicRange}`);
        console.log(`   ðŸ”Š Estimated LUFS: ${report.estimatedLUFS}`);
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        if (report.recommendations && report.recommendations.length > 0) {
          console.log('ðŸ’¡ PROFESSIONAL RECOMMENDATIONS:');
          report.recommendations.forEach(rec => console.log(`   ${rec}`));
          console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        }

        // ðŸ”¬ Power users can still inspect everything in the console.
        console.log('ðŸ§ª Detailed mix report available above (console-only, no UI score).');
      }
      
      // ðŸŽ‰ User-facing feedback: ONLY hype, no scores
      showMixHypeToast();
      
    } catch (error) {
      console.error('âŒ AI Mixing Error:', error);
      console.error('Stack trace:', error.stack);
      showToast('âŒ Mixing failed: ' + error.message, 'error');
    } finally {
      // Re-enable button
      applyBtn.disabled = false;
      applyBtn.textContent = originalText;
    }
  });
  
  console.log('ðŸŽšï¸ AI Apply Button initialized');
}

// ============================================================================
// MASTERING PRESETS (One-click professional mastering)
// ============================================================================

function setupMasteringPresets() {
  const presetButtons = document.querySelectorAll('[data-master-preset]');
  
  if (presetButtons.length === 0) {
    console.warn('âš ï¸ No mastering preset buttons found');
    return;
  }
  
  presetButtons.forEach(btn => {
    const preset = btn.dataset.masterPreset;
    
    btn.addEventListener('click', () => {
      // Visual feedback
      btn.style.transform = 'scale(0.95)';
      setTimeout(() => {
        btn.style.transform = '';
      }, 150);
      
      // Apply the professional mastering preset
      console.log(`ðŸŽšï¸ Applying ${preset} mastering preset...`);
      applyMasteringPreset(preset);
    });
  });
  
  console.log(`ðŸŽ›ï¸ Registered ${presetButtons.length} mastering presets`);
}

// ============================================================================
// AUTO-APPLY AI MIXING (Optional - triggers after beat generation)
// ============================================================================

function autoApplyAIMixingIfEnabled() {
  if (!state.aiMixing || !state.aiMixing.enabled) {
    return;
  }

  console.log('ðŸ¤– Auto-applying AI mixing after generation...');

  // Small delay to let patterns settle
  setTimeout(async () => {
    try {
      await applyAIMixing();

      // âœ… Only try to render the mixer if it's in the DOM
      const grid = document.getElementById('mixerGrid');
      if (grid) {
        renderMixer();
      } else {
        console.log('ðŸŽšï¸ Auto-mix: mixerGrid not found, skipping renderMixer()');
      }

      const score = getMixHealthScore();
      console.log(`âœ… Auto-mix complete. Health: ${score}/100`);
      showToast(`ðŸ¤– Auto-mixed! Health: ${score}/100`, 'success');
    } catch (error) {
      console.error('âŒ Auto-mix failed:', error);
      console.error('Stack trace:', error.stack);
      showToast('âŒ Auto-mix failed: ' + error.message, 'error');
    }
  }, 500);
}

// ============================================================================
// KEYBOARD SHORTCUTS (Optional power-user feature)
// ============================================================================

function setupAIMixingKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Ignore if typing in input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }
    
    // Cmd/Ctrl + M = Toggle AI Mixing
    if ((e.metaKey || e.ctrlKey) && e.key === 'm' && !e.shiftKey) {
      e.preventDefault();
      const toggleBtn = document.getElementById('toggleAIMixingBtn');
      if (toggleBtn) {
        toggleBtn.click();
        console.log('âŒ¨ï¸ Keyboard shortcut: Toggle AI Mixing');
      }
    }
    
    // Cmd/Ctrl + Shift + M = Apply AI Mix
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'M') {
      e.preventDefault();
      const applyBtn = document.getElementById('applyAIMixBtn');
      if (applyBtn && !applyBtn.disabled) {
        applyBtn.click();
        console.log('âŒ¨ï¸ Keyboard shortcut: Apply AI Mix');
      }
    }
  });
  
  console.log('âŒ¨ï¸ AI Mixing keyboard shortcuts enabled:');
  console.log('   Cmd/Ctrl + M = Toggle AI Mixing');
  console.log('   Cmd/Ctrl + Shift + M = Apply AI Mix');
}

// ============================================================================
// UTILITY: Export Mix Analysis as JSON
// ============================================================================

function exportMixAnalysisToJSON() {
  const analysis = exportMixAnalysis();
  
  if (!analysis) {
    showToast('âš ï¸ No mix analysis available. Apply AI mixing first.', 'warning');
    return;
  }
  
  const blob = new Blob([JSON.stringify(analysis, null, 2)], { 
    type: 'application/json' 
  });
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `mix-analysis-${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  showToast('ðŸ“Š Mix analysis exported', 'success');
  console.log('ðŸ“Š Mix Analysis Exported:', analysis);
}

// ============================================================================
// UTILITY: Compare All Presets
// ============================================================================

function displayPresetComparison() {
  comparePresets(); // Uses your existing function
  
  const presets = ['gentle', 'modern', 'aggressive', 'lofi', 'broadcast', 'vinyl'];
  showToast(`ðŸ“Š Check console for ${presets.length} preset comparisons`, 'info');
}

// ============================================================================
// PATCH: Auto-apply after generation (if enabled)
// ============================================================================

// Store original functions
const _originalGenerateBeat = typeof generateBeat !== 'undefined' ? generateBeat : null;
const _originalGenerateMelodicPatterns = typeof generateMelodicPatterns !== 'undefined' ? generateMelodicPatterns : null;

// Override generateBeat to include auto-mixing
if (_originalGenerateBeat) {
  generateBeat = function() {
    const result = _originalGenerateBeat.apply(this, arguments);
    autoApplyAIMixingIfEnabled();
    return result;
  };
}

// Override generateMelodicPatterns to include auto-mixing
if (_originalGenerateMelodicPatterns) {
  generateMelodicPatterns = function() {
    const result = _originalGenerateMelodicPatterns.apply(this, arguments);
    autoApplyAIMixingIfEnabled();
    return result;
  };
}

// ============================================================================
// CONSOLE COMMANDS (for power users)
// ============================================================================

// Make these globally accessible for console use
window.aiMixingCommands = {
  toggle: () => document.getElementById('toggleAIMixingBtn')?.click(),
  apply: () => document.getElementById('applyAIMixBtn')?.click(),
  preset: (name) => applyMasteringPreset(name),
  health: () => {
    const score = getMixHealthScore();
    console.log(`ðŸ¥ Mix Health: ${score}/100`);
    return score;
  },
  export: () => exportMixAnalysisToJSON(),
  compare: () => displayPresetComparison(),
  report: () => {
    const report = getMixAnalysisReport();
    if (report) {
      console.table(report);
    } else {
      console.log('No analysis available. Apply AI mixing first.');
    }
    return report;
  }
};

console.log('ðŸŽ›ï¸ Professional AI Mixing & Mastering System Loaded');
console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
console.log('ðŸ“Š Features:');
console.log('   âœ“ Professional gain staging');
console.log('   âœ“ Intelligent stereo panning');
console.log('   âœ“ Surgical EQ (7-band analysis)');
console.log('   âœ“ Dynamic compression');
console.log('   âœ“ Frequency masking detection');
console.log('   âœ“ Mix health scoring');
console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
console.log('ðŸŽšï¸ Mastering Presets:');
console.log('   â€¢ gentle - Natural & Dynamic (-18 LUFS)');
console.log('   â€¢ modern - Streaming Ready (-14 LUFS)');
console.log('   â€¢ aggressive - Club/Loud (-11 LUFS)');
console.log('   â€¢ lofi - Vintage Warmth (-16 LUFS)');
console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
console.log('ðŸ’¡ Console Commands (window.aiMixingCommands):');
console.log('   .toggle() - Toggle AI mixing');
console.log('   .apply() - Apply AI mix');
console.log('   .preset("modern") - Apply preset');
console.log('   .health() - Get mix health score');
console.log('   .export() - Export analysis JSON');
console.log('   .compare() - Compare all presets');
console.log('   .report() - Show detailed report');
console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
console.log('ðŸ“ Call initializeAIMixingSystem() to activate UI');
console.log('âŒ¨ï¸ Call setupAIMixingKeyboardShortcuts() for shortcuts');

// Clear only melodic instruments (bass/keys/lead/guitar) and leave drums alone
function clearMelodicLanes() {
  const melodicInstruments = ['bass', 'keys', 'lead', 'guitar'];
  const len =
    state.sequenceLength ||
    (patterns.kick?.length ||
     patterns.snare?.length ||
     patterns.hihat?.length ||
     0);
  melodicInstruments.forEach(inst => {
    const lane = patterns[inst];
    if (!lane) return;
    for (let i = 0; i < len; i++) {
      const cell = lane[i];
      if (!cell) continue;
      cell.active      = false;
      cell.velocity    = 0.8;
      cell.probability = 100;
      cell.duration    = '8n';
      cell.note        = instruments[inst]?.note || cell.note;
    }
  });
  if (typeof renderSequencer === 'function') {
    renderSequencer();
  }
}
  
function setupGeneratorButtons() {
  const beatBtn    = document.getElementById('generateBtn');
  const bothBtn    = document.getElementById('generateSongBtn');
  const rhythmBtn  = document.getElementById('generateRhythmBtn');
  
  // ðŸ¥ Generate Beat = drums only
  if (beatBtn) {
    beatBtn.addEventListener('click', () => {
      ensureHarmonyGuardrails?.();
      
      // Calculate total bars
      const totalBars = Math.ceil((state.sequenceLength || 64) / STEPS_PER_BAR);
      
      // Create a drum section
      const section = {
        id: 'beat-regen',
        drums: true,
        drumPattern: 'four-floor', // could vary based on genre/complexity
        energy: state.complexity ? state.complexity / 3 : 0.7,
        density: 0.7
      };
      
      // Clear melodic lanes first
      clearMelodicLanes();
      
      // Generate drums using the section generator
      generateSectionDrums(section, 0, totalBars);
      
      // Optional drum polish
      if (state.complexity >= 2 && typeof addRhythmicVariety === 'function') {
        addRhythmicVariety();
      }
      if (typeof addDrumFills === 'function') addDrumFills();
      if (typeof addSwingVariations === 'function') addSwingVariations();
      
      renderSequencer();
      showToast?.('ðŸ¥ Beat generated', 'success');
    });
  }
  
  // ðŸŽµ Generate Both = full beat + melodic patterns
  if (bothBtn) {
    bothBtn.addEventListener('click', () => {
      showToast?.('ðŸŽ¶ Generating full song...', 'info');
      ensureHarmonyGuardrails?.();
      
      const totalBars = Math.ceil((state.sequenceLength || 64) / STEPS_PER_BAR);
      
      const section = {
        id: 'full-song',
        drums: true,
        bass: true,
        chords: true,
        lead: true,
        drumPattern: 'four-floor',
        bassPattern: 'root-fifth',
        chordPattern: 'sustained',
        energy: state.complexity ? state.complexity / 3 : 0.7,
        density: 0.7
      };
      
      // Generate everything
      generateSectionDrums(section, 0, totalBars);
      generateSectionBass(section, 0, totalBars);
      generateSectionChords(section, 0, totalBars);
      generateSectionMelody(section, 0, totalBars);
      
      // Optional polish
      if (state.complexity >= 2 && typeof addRhythmicVariety === 'function') {
        addRhythmicVariety();
      }
      if (typeof addDrumFills === 'function') addDrumFills();
      if (typeof addSwingVariations === 'function') addSwingVariations();
      
      renderSequencer();
      showToast?.('âœ… Song ready!', 'success');
    });
  }
  
  // ðŸŽ¼ Generate Rhythm = melodic only (regenerate melodies on existing beat)
  if (rhythmBtn) {
    rhythmBtn.addEventListener('click', () => {
      ensureHarmonyGuardrails?.();
      
      const totalBars = Math.ceil((state.sequenceLength || 64) / STEPS_PER_BAR);
      
      const section = {
        id: 'rhythm-regen',
        bass: true,
        chords: true,
        lead: true,
        bassPattern: 'root-fifth',
        chordPattern: 'sustained',
        energy: state.complexity ? state.complexity / 3 : 0.6,
        density: 0.7
      };
      
      // Generate melodic content only (drums stay intact)
      generateSectionBass(section, 0, totalBars);
      generateSectionChords(section, 0, totalBars);
      generateSectionMelody(section, 0, totalBars);
      
      renderSequencer();
      showToast?.('ðŸŽ¼ Regenerated melodies on current beat', 'success');
    });
  }
  
  // AI variations and groove templates stay the same
  document.getElementById('aiVariationBtn')?.addEventListener('click', generateAIVariation);
  document.getElementById('aiMelodicBtn')?.addEventListener('click', generateMelodicAIVariation);
  
  document.querySelectorAll('.groove-template-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const template = e.currentTarget.dataset.template;
      applyGrooveTemplate(template);
    });
  });
  
  document.getElementById('randomVelBtn')?.addEventListener('click', randomizeVelocity);
  document.getElementById('randomProbBtn')?.addEventListener('click', randomizeProbability);
  document.getElementById('clearBtn')?.addEventListener('click', clearPattern);
}

function setupSequencerControls() {
  document.getElementById('lenDecBtn').addEventListener('click', () => {
    state.sequenceLength = Math.max(CONFIG.MIN_SEQUENCE_LENGTH, state.sequenceLength - 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('lenIncBtn').addEventListener('click', () => {
    state.sequenceLength = Math.min(CONFIG.MAX_SEQUENCE_LENGTH, state.sequenceLength + 4);
    ensurePatternLength(state.sequenceLength);
    renderSequencer();
  });
  
  document.getElementById('resSelect').addEventListener('change', e => {
    state.resolution = e.target.value;
  });
  
  document.getElementById('euclidBtn').addEventListener('click', applyEuclidean);
  document.getElementById('ghostBtn').addEventListener('click', addGhostNotes);
  
  // Delegated sequencer events
  const seqGrid = document.getElementById('seqGrid');
  seqGrid.addEventListener('click', handleSequencerClick);
}

function handleSequencerClick(e) {
  songBuilderState.isActive = false;
  const stepEl = e.target.closest('.step');
  if (stepEl) {
    const inst = stepEl.dataset.inst;
    const step = parseInt(stepEl.dataset.step, 10);
    toggleStep(inst, step, e);
    return;
  }
  
  const icon = e.target.closest('.seq-icon');
  if (icon) {
    const inst = icon.dataset.inst;
    const action = icon.dataset.action;
    
    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    } else if (action === 'note') {
      if (!isPro()) {
        showToast('ðŸ”’ Changing note pitch is available in 8-Beat Pro.', 'info');
        return;
      }
      openNoteEditor(inst);
    }
    
    renderSequencer();
  }
}

function setupMixerListeners() {
  const mixerGrid = document.getElementById('mixerGrid');
  if (!mixerGrid) return;

  // --- MUTE / SOLO BUTTONS ---
  mixerGrid.addEventListener('click', e => {
    const btn = e.target.closest('.channel-btn');
    if (!btn) return;

    const inst = btn.dataset.inst;
    const action = btn.dataset.action;

    if (!inst || !action || !instruments[inst]) return;

    if (action === 'mute') {
      instruments[inst].mute = !instruments[inst].mute;
    } else if (action === 'solo') {
      instruments[inst].solo = !instruments[inst].solo;
    }

    renderMixer();
    renderSequencer();
  });

  // --- FADERS (VOLUME / PAN) ---
  mixerGrid.addEventListener('input', e => {
    if (e.target.type !== 'range') return;

    const inst  = e.target.dataset.inst;
    const param = e.target.dataset.param;
    const value = parseFloat(e.target.value);

    if (!inst || !param || !instruments[inst]) return;

    instruments[inst][param] = value;

    // Apply to Tone.js channel
    if (param === 'volume' && instruments[inst].channel) {
      // volume is in dB
      instruments[inst].channel.volume.value = value;
    } else if (param === 'pan' && instruments[inst].channel) {
      // pan is -100..100 â†’ -1..1
      instruments[inst].channel.pan.value = value / 100;
    }

    // Update numeric label in mixer UI
    const parent = e.target.closest('.param-control');
    const valEl  = parent ? parent.querySelector('.param-value') : null;

    if (!valEl) return;

    if (param === 'volume') {
      valEl.textContent = value + 'dB';
    } else if (param === 'pan') {
      const label = value > 0 ? 'R' : value < 0 ? 'L' : 'C';
      valEl.textContent = label + Math.abs(value);
    }
  });
}

function invalidateHarmonyCache() {
  state.progressionNotes = null;
}

function setupHarmonyControls() {
  document.getElementById('keySelect').addEventListener('change', e => {
    state.key = e.target.value;
    invalidateHarmonyCache();      // ðŸ§¹
    updateChords();
  });
  
  document.getElementById('scaleSelect').addEventListener('change', e => {
    state.scale = e.target.value;
    invalidateHarmonyCache();      // ðŸ§¹
    updateChords();
  });
  
  document.getElementById('octaveSelect').addEventListener('change', e => {
    state.octave = parseInt(e.target.value, 10);
    // (no need to invalidate here unless you use octave in chords)
  });
  
  document.getElementById('genProgBtn').addEventListener('click', () => {
    generateProgression();
    invalidateHarmonyCache();      // ðŸ§¹
  });

  document.getElementById('clearProgBtn').addEventListener('click', () => {
    state.progression = [];
    invalidateHarmonyCache();      // ðŸ§¹
    renderProgression();
  });

  document.querySelectorAll('[data-prog]').forEach(btn => {
    btn.addEventListener('click', e => {
      loadProgressionTemplate(e.currentTarget.dataset.prog);
      invalidateHarmonyCache();    // ðŸ§¹
    });
  });
}

function setupProjectManagement() {
  document.getElementById('saveBtn').addEventListener('click', saveProject);
  document.getElementById('loadBtn').addEventListener('click', loadProject);
}

function setupKeyboardShortcuts() {
  // Detect if device is mobile/tablet
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);
  
  // Don't enable keyboard shortcuts on mobile devices
  if (isMobile) {
    console.log('ðŸ“± Mobile device detected - keyboard shortcuts disabled');
    return;
  }

  document.addEventListener('keydown', e => {
    // Also check if user is typing in an input field
    const isTyping = e.target.tagName === 'INPUT' || 
                     e.target.tagName === 'TEXTAREA' || 
                     e.target.isContentEditable;
    
    if (isTyping) return; // Don't trigger shortcuts while typing

    // Basic transport shortcuts
    if (e.code === 'Space') {
      e.preventDefault();
      togglePlay();
    } else if (e.code === 'KeyS') {
      e.preventDefault();
      stop();
    } else if (e.code === 'KeyE') {
      e.preventDefault();
      exportAudio();
    }

    // === NEW MULTITRACK SHORTCUTS ===
    if (e.code === 'KeyX' && !e.ctrlKey && !e.metaKey) {
      // Split at playhead
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'split'
        );
      }
    }

    if (e.code === 'KeyD' && (e.ctrlKey || e.metaKey)) {
      // Duplicate region
      e.preventDefault();
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        handleContextAction(
          multitrack.tracks.find(t => t.id === trackId),
          takeIndex,
          'duplicate'
        );
      }
    }

    if ((e.code === 'Delete' || e.code === 'Backspace') && !isTyping) {
      // Delete selected region
      const selected = document.querySelector('.audio-region.selected');
      if (selected) {
        e.preventDefault();
        const trackId = parseInt(selected.dataset.trackId);
        const takeIndex = parseInt(selected.dataset.takeIndex);
        const track = multitrack.tracks.find(t => t.id === trackId);
        if (track && confirm('Delete selected region?')) {
          track.deleteTake(takeIndex);
          renderMultitrack();
        }
      }
    }

    // Zoom shortcuts
    if (e.code === 'Equal' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomInBtn')?.click();
    }
    
    if (e.code === 'Minus' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      document.getElementById('zoomOutBtn')?.click();
    }
    
    // === UNDO/REDO ===
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && !e.shiftKey) {
      e.preventDefault();
      multitrackHistory.undo();
    }
      
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'KeyZ') {
      e.preventDefault();
      multitrackHistory.redo();
    }
      
    // Alternative: Ctrl+Y for redo
    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {
      e.preventDefault();
      multitrackHistory.redo();
    }
  });
}


function setupVibeSelector() {
  const vibeBtn = document.getElementById('vibeBtn');
  if (vibeBtn) {
    vibeBtn.addEventListener('click', () => {
      applyVibe(nextVibe());
    });
  }
}

// -------------------- FX Parameter Mapping --------------------
function mapFxParam(param, raw) {
  switch (param) {
    case 'decay':
      return raw / 20;
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return raw / 100;
    case 'time':
      return ['16n', '8n', '4n', '2n'][Math.min(3, Math.floor(raw / 25))];
    case 'frequency':
      return 100 + raw * 79;
    case 'octaves':
      return Math.floor(raw / 20) + 1;
    default:
      return raw / 50;
  }
}

function applyFxParam(fx, param, value) {
  const node = effects[fx];
  if (!node) return;
  
  if (param === 'decay' && node.decay !== undefined) {
    node.decay = value;
  } else if (param === 'wet' && node.wet) {
    node.wet.value = value;
  } else if (param === 'time' && node.delayTime) {
    node.delayTime.value = Tone.Time(value);
  } else if (param === 'feedback' && node.feedback) {
    node.feedback.value = value;
  } else if (param === 'frequency') {
    // Safe frequency updates with ramp to avoid clicks
    if (node.frequency) {
      node.frequency.rampTo(value, 0.1);
    }
  } else if (param === 'depth') {
    if (node.depth !== undefined) {
      node.depth = value;
    }
  } else if (param === 'amount' && node.distortion !== undefined) {
    node.distortion = value;
  } else if (param === 'octaves' && node.octaves !== undefined) {
    node.octaves = value;
  }
}

function formatFxDisplay(param, value) {
  switch (param) {
    case 'wet':
    case 'feedback':
    case 'depth':
    case 'amount':
      return Math.round(value * 100) + '%';
    case 'decay':
      return value.toFixed(2) + 's';
    case 'time':
      return String(value);
    case 'frequency':
      return Math.round(value) + 'Hz';
    case 'octaves':
      return value + ' oct';
    default:
      return String(value);
  }
}

// -------------------- Sequencer Rendering --------------------
let renderSequencerVersion = 0;

function renderSequencer() {
  const grid = document.getElementById('seqGrid');
  if (!grid) return;

  const instrumentKeys = Object.keys(instruments);
  if (!instrumentKeys.length) {
    grid.innerHTML = '';
    return;
  }

  // Bump version so any in-flight render knows it's stale
  const myVersion = ++renderSequencerVersion;

  // Clear old grid immediately so we don't layout around stale content
  grid.innerHTML = '';

  const fragment = document.createDocumentFragment();
  const totalInstruments = instrumentKeys.length;
  const ROWS_PER_FRAME = 2; // tweak: 1 = safest, 3â€“4 = faster but heavier

  function buildRow(inst) {
    const instData = instruments[inst];
    const row = document.createElement('div');
    row.className = 'seq-row';

    // --- Label ---
    const label = document.createElement('div');
    label.className = 'seq-label';

    const span = document.createElement('span');
    span.textContent = `${instData.icon} ${instData.name}`;
    label.appendChild(span);

    const iconsWrap = document.createElement('div');
    iconsWrap.className = 'seq-icons';

    const muteBtn = document.createElement('button');
    muteBtn.className = `seq-icon ${instData.mute ? 'active' : ''}`;
    muteBtn.dataset.inst = inst;
    muteBtn.dataset.action = 'mute';
    muteBtn.textContent = 'M';
    iconsWrap.appendChild(muteBtn);

    const soloBtn = document.createElement('button');
    soloBtn.className = `seq-icon ${instData.solo ? 'active' : ''}`;
    soloBtn.dataset.inst = inst;
    soloBtn.dataset.action = 'solo';
    soloBtn.textContent = 'S';
    iconsWrap.appendChild(soloBtn);

    if (instData.type === 'melodic') {
      const noteBtn = document.createElement('button');
      noteBtn.className = 'seq-icon';
      noteBtn.dataset.inst = inst;
      noteBtn.dataset.action = 'note';
      noteBtn.textContent = 'ðŸŽµ';
      iconsWrap.appendChild(noteBtn);
    }

    label.appendChild(iconsWrap);
    row.appendChild(label);

    // --- Steps ---
    const seqLen = state.sequenceLength;
    const instPatterns = patterns[inst];

    for (let i = 0; i < seqLen; i++) {
      const step = instPatterns[i];
      const cell = document.createElement('div');
      cell.className = 'step';
      cell.dataset.inst = inst;
      cell.dataset.step = i;

      if (step.active) {
        cell.classList.add('active');

        // Prob / note label
        const probLabel = document.createElement('div');
        probLabel.className = 'step-prob';

        if (instData.type === 'melodic' && step.note) {
          probLabel.textContent = step.note;
          probLabel.style.fontSize = '0.6rem';
        } else {
          probLabel.textContent = (step.probability ?? 100) + '%';
        }
        cell.appendChild(probLabel);

        // Velocity bar
        const velBar = document.createElement('div');
        velBar.className = 'step-vel';

        const fill = document.createElement('div');
        fill.className = 'step-vel-fill';
        fill.style.width = `${Math.round((step.velocity || 0) * 100)}%`;

        velBar.appendChild(fill);
        cell.appendChild(velBar);
      }

      row.appendChild(cell);
    }

    return row;
  }

  let nextIndex = 0;

  function renderChunk() {
    // If a newer render started, abort this one
    if (myVersion !== renderSequencerVersion) return;

    const end = Math.min(nextIndex + ROWS_PER_FRAME, totalInstruments);

    for (let idx = nextIndex; idx < end; idx++) {
      const inst = instrumentKeys[idx];
      const row = buildRow(inst);
      fragment.appendChild(row);
    }

    nextIndex = end;

    if (nextIndex < totalInstruments) {
      // More rows to do; yield to browser, then continue
      requestAnimationFrame(renderChunk);
    } else {
      // Finished building all rows; attach once
      if (myVersion !== renderSequencerVersion) return; // safety

      grid.appendChild(fragment);

      // Ensure playhead exists once grid is ready
      let playhead = document.getElementById('playhead');
      if (!playhead) {
        const seqWrapper = document.querySelector('.sequencer');
        if (seqWrapper) {
          playhead = document.createElement('div');
          playhead.id = 'playhead';
          playhead.className = 'playhead';
          seqWrapper.appendChild(playhead);
        }
      }
    }
  }

  // Kick off chunked render
  requestAnimationFrame(renderChunk);
}


function toggleStep(inst, stepIndex, e) {
  songBuilderState.isActive = false;
  const pattern = patterns[inst][stepIndex];
  const instData = instruments[inst];
  
  if (e.altKey) {
    if (pattern.active) {
      pattern.velocity = Math.min(1, (pattern.velocity || 0.8) + 0.2);
      if (pattern.velocity > 1) pattern.velocity = 0.4;
    }
  } else if (e.shiftKey) {
    if (pattern.active) {
      if (instData.type === 'melodic') {
        cycleNote(inst, stepIndex);
      } else {
        pattern.probability = Math.min(100, pattern.probability + 25);
        if (pattern.probability > 100) pattern.probability = 50;
      }
    }
  } else if (e.ctrlKey || e.metaKey) {
    if (instData.type === 'melodic' && pattern.active) {
      const newNote = prompt(
        `Enter note (e.g., C4, D#3):`,
        pattern.note || instData.note
      );
      if (newNote && /^[A-G]#?[1-6]$/.test(newNote)) {
        pattern.note = newNote;
      }
    }
  } else {
    pattern.active = !pattern.active;
    if (pattern.active) {
      pattern.velocity = 0.8;
      pattern.probability = 100;
      if (instData.type === 'melodic') {
        pattern.note = instData.note;
        pattern.duration = '8n';
      }
    }
  }
  
  renderSequencer();
}

function cycleNote(inst, stepIndex) {
  const pattern = patterns[inst][stepIndex];
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const currentNote = pattern.note || instruments[inst].note;
  const match = currentNote.match(/^([A-G]#?)(\d+)$/);
  if (!match) return;
  
  const [, noteName, octave] = match;
  const scaleNotes = scaleIntervals.map(iv => keysArr[(keyIndex + iv) % 12]);
  const index = scaleNotes.indexOf(noteName);
  const nextNote = scaleNotes[(index + 1 + scaleNotes.length) % scaleNotes.length] + octave;
  
  pattern.note = nextNote;
}

function updateStepVisuals(step) {
  const widthPerStep = 100 / state.sequenceLength;
  const playhead = document.getElementById('playhead');
  if (playhead) {
    playhead.style.transform = `translateX(${(step + 0.5) * widthPerStep}%)`;
  }
}

function openNoteEditor(inst) {
  // Create modal backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  // Get current note
  const currentNote = instruments[inst].note || 'C4';
  
  // Generate all possible notes (C1 to C6)
  const allNotes = [];
  for (let octave = 1; octave <= 6; octave++) {
    keysArr.forEach(note => {
      allNotes.push(note + octave);
    });
  }
  
  modal.innerHTML = `
    <div class="pro-locked">
      <div class="modal-header">
        <div class="modal-title">ðŸŽµ ${instruments[inst].icon} ${instruments[inst].name} - Select Note</div>
        <button class="modal-close" id="closeNoteModal">âœ•</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: var(--space-4); color: var(--text-secondary);">
          Choose the default note for <strong>${instruments[inst].name}</strong>. 
          This will apply to all active steps that don't have a custom note set.
        </p>
        
        <div style="display: grid; gap: var(--space-3);">
          <label style="display: flex; flex-direction: column; gap: var(--space-2);">
            <span style="font-weight: 700; color: var(--text-primary);">Note</span>
            <select id="noteSelect" style="font-size: var(--text-base); padding: var(--space-4);">
              ${allNotes.map(note => 
                `<option value="${note}" ${note === currentNote ? 'selected' : ''}>${note}</option>`
              ).join('')}
            </select>
          </label>
          
          <div style="padding: var(--space-4); background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border);">
            <div style="font-weight: 700; margin-bottom: var(--space-2); color: var(--text-primary);">Current: ${currentNote}</div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              Lower octaves (1-2) = Bass range<br>
              Mid octaves (3-4) = Chord/melody range<br>
              High octaves (5-6) = Lead range
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelNoteBtn">Cancel</button>
        <button class="btn btn-primary" id="applyNoteBtn">Apply Note</button>
      </div>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  // Focus the select
  setTimeout(() => document.getElementById('noteSelect').focus(), 100);
  
  // Event handlers
  const close = () => backdrop.remove();
  
  document.getElementById('closeNoteModal').onclick = close;
  document.getElementById('cancelNoteBtn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  document.getElementById('applyNoteBtn').onclick = () => {
    const newNote = document.getElementById('noteSelect').value;
    instruments[inst].note = newNote;
    
    // Update all active steps without custom notes
    patterns[inst].forEach(step => {
      if (step.active && !step.note) {
        step.note = newNote;
      }
    });
    
    renderSequencer();
    close();
    
    // Show confirmation toast
    showToast(`ðŸŽµ ${instruments[inst].name} note set to ${newNote}`, 'success');
  };
  
  // Keyboard support
  modal.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
    if (e.key === 'Enter' && e.target.tagName !== 'SELECT') {
      document.getElementById('applyNoteBtn').click();
    }
  });
}

function showToast(message, type = 'info') {
  let container = document.querySelector('.toast-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'toast-container';
    document.body.appendChild(container);
  }
  
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  
  const icons = {
    success: 'âœ“',
    error: 'âœ•',
    warning: 'âš ',
    info: 'â„¹'
  };
  
  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || icons.info}</span>
    <span>${message}</span>
    <button class="toast-close">âœ•</button>
  `;
  
  container.appendChild(toast);
  
  toast.querySelector('.toast-close').onclick = () => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => toast.remove(), 200);
  };
  
  // Auto-dismiss faster based on message length
  const baseTime = 1500; // 1.5s base
  const charTime = message.length * 30; // 30ms per character
  const dismissTime = Math.min(baseTime + charTime, 2000); // Max 2s
  
  setTimeout(() => {
    if (toast.parentElement) {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      setTimeout(() => toast.remove(), 200);
    }
  }, dismissTime);
  
  // Limit to 3 toasts at once
  const toasts = container.querySelectorAll('.toast');
  if (toasts.length > 3) {
    toasts[0].remove();
  }
}
  
// ==================== COHERENT BEAT GENERATOR (SONG BUILDER LITE) ====================
function generateBeat() {
  const genre = state.currentGenre || 'lofi';

  if (!genre) {
    showToast?.('Set a genre first!', 'error');
    return;
  }

  const wasPlaying = Tone.Transport.state === 'started';
  if (wasPlaying) Tone.Transport.pause();
  Tone.Transport.cancel(0);
  if (window.mainLoop) {
    try { window.mainLoop.stop(); window.mainLoop.dispose(); } catch {}
    window.mainLoop = null;
  }

  let templateId = null;
  for (const [id, g] of Object.entries(TEMPLATE_TO_GENRE)) {
    if (g === genre) {
      templateId = id;
      break;
    }
  }
  if (!templateId) {
    templateId = 'intro-verse-chorus';
  }

  const tpl = SONG_TEMPLATES[templateId];
  if (!tpl || !tpl.length) {
    console.warn('[Beat] Missing template for', templateId);
    showToast?.('âš ï¸ No template for this genre', 'error');
    return;
  }

  let baseSection = tpl.find(s => /verse|hook|drop|chorus/i.test((s.id || '') + (s.label || ''))) || tpl[0];

  const clampLocal = typeof clamp === 'function'
    ? clamp
    : (v, min, max) => Math.max(min, Math.min(max, v));

  const bars = 4 + Math.floor(Math.random() * 5);

  const beatSection = {
    ...baseSection,
    id: 'beat-loop',
    label: 'Beat',
    bars,
    energy: clampLocal((baseSection.energy || 0.7) + (Math.random() * 0.5 - 0.25), 0.3, 0.95),
    density: clampLocal((baseSection.density || 0.7) + (Math.random() * 0.5 - 0.25), 0.3, 0.9),
    drumPattern: ['four-floor', 'breakbeat', 'trap', 'half-time'][Math.floor(Math.random() * 4)],
    bassPattern: ['root-fifth', 'walking', 'syncopated', 'pedal'][Math.floor(Math.random() * 4)],
    chordPattern: ['sustained', 'arpeggiated', 'rhythmic', 'staccato'][Math.floor(Math.random() * 4)],
    melodyStyle: ['sparse', 'motif', 'scale-run', 'dense', 'solo'][Math.floor(Math.random() * 5)]
  };

  sbPlanHarmonyForSong([beatSection]);
  state.key = sbGlobalHarmony.key;
  state.scale = sbGlobalHarmony.scale;

  const totalBars = beatSection.bars;
  const totalSteps = totalBars * STEPS_PER_BAR;

  const maxLen = (CONFIG && CONFIG.MAX_SEQUENCE_LENGTH) || 2048;
  state.sequenceLength = Math.min(maxLen, totalSteps);

  ensurePatternLength(state.sequenceLength);
  wipeAllPatterns();

  generateSectionDrums(beatSection, 0, beatSection.bars);
  generateSectionBass(beatSection, 0, beatSection.bars);
  generateSectionChords(beatSection, 0, beatSection.bars);
  generateSectionMelody(beatSection, 0, beatSection.bars);

  addSubtleStructuralVariation(beatSection.bars);

  sequencerInitialized = false;
  if (typeof initAudioLight === 'function') initAudioLight();
  if (typeof renderSequencer === 'function') renderSequencer();
  if (wasPlaying) Tone.Transport.start('+0.05');

  showToast?.(`ðŸ¥ ${genre} beat: ${sbGlobalHarmony.key} ${sbGlobalHarmony.scale}`, 'success');
  console.log('[Beat]', genre, beatSection);
}

// Add subtle variations every 4 bars to keep things interesting
function addSubtleStructuralVariation(totalBars) {
  if (totalBars < 4) return;

  const barIndices = [];
  for (let i = 4; i < totalBars; i += 4) {
    barIndices.push(i);
  }

  barIndices.forEach(barIdx => {
    const offset = barIdx * STEPS_PER_BAR;

    // Add subtle drum variation (10% chance per hit)
    if (Math.random() < 0.3) {
      // Add ghost snare
      const ghostStep = offset + 2 + Math.floor(Math.random() * 4) * 4;
      if (patterns.snare && patterns.snare[ghostStep]) {
        patterns.snare[ghostStep].active = true;
        patterns.snare[ghostStep].velocity = 0.25 + Math.random() * 0.15;
        patterns.snare[ghostStep].probability = 70;
      }
    }

    // Add hi-hat variation (20% chance)
    if (Math.random() < 0.2 && patterns.hihat) {
      for (let s = 0; s < 4; s++) {
        const step = offset + 12 + s;
        if (step < state.sequenceLength && Math.random() < 0.6) {
          patterns.hihat[step].active = true;
          patterns.hihat[step].velocity = 0.4 + Math.random() * 0.2;
        }
      }
    }

    // Add percussion accent (15% chance)
    if (Math.random() < 0.15 && patterns.rimshot) {
      const accentStep = offset + 6;
      if (patterns.rimshot[accentStep]) {
        patterns.rimshot[accentStep].active = true;
        patterns.rimshot[accentStep].velocity = 0.5 + Math.random() * 0.2;
      }
    }
  });
}

// ==================== IMPROVED DRUM GENERATION ====================
function generateSectionDrums(section, startBar, endBar) {
  if (!section.drums) return;
  
  const drumPattern = section.drumPattern || 'four-floor';
  const density = section.density || 0.7;
  const energy = section.energy || 0.7;
  const fillEvery = songBuilderState.fillEvery || 4;
  
  // Get genre-specific drum characteristics
  const genreStyle = getGenreDrumStyle(state.currentGenre || 'lofi');
  
  for (let bar = startBar; bar < endBar; bar++) {
    const offset = bar * STEPS_PER_BAR;
    const barInSection = bar - startBar;
    
    // Determine if this is a fill bar
    const isFillBar = fillEvery > 0 && ((barInSection + 1) % fillEvery === 0);
    
    switch(drumPattern) {
      case 'four-floor':
        generateFourFloorDrums(offset, density, energy, genreStyle, isFillBar);
        break;
        
      case 'breakbeat':
        generateBreakbeatDrums(offset, density, energy, genreStyle, isFillBar);
        break;
        
      case 'trap':
        generateTrapDrums(offset, density, energy, genreStyle, isFillBar);
        break;
        
      case 'half-time':
        generateHalfTimeDrums(offset, density, energy, genreStyle, isFillBar, bar);
        break;
        
      default:
        generateFourFloorDrums(offset, density, energy, genreStyle, isFillBar);
    }
  }
}

// Genre-specific drum characteristics
function getGenreDrumStyle(genre) {
  const styles = {
    lofi: { kickVel: 0.8, snareVel: 0.75, hatVel: 0.5, swing: 0.3, ghostProb: 0.25 },
    hiphop: { kickVel: 0.9, snareVel: 0.85, hatVel: 0.6, swing: 0.2, ghostProb: 0.2 },
    trap: { kickVel: 0.95, snareVel: 0.9, hatVel: 0.7, swing: 0, ghostProb: 0.15 },
    rnb: { kickVel: 0.85, snareVel: 0.8, hatVel: 0.55, swing: 0.25, ghostProb: 0.3 },
    postpunk: { kickVel: 0.85, snareVel: 0.85, hatVel: 0.65, swing: 0, ghostProb: 0.1 },
    ambient: { kickVel: 0.7, snareVel: 0.65, hatVel: 0.4, swing: 0.1, ghostProb: 0.2 },
    dazecore: { kickVel: 0.8, snareVel: 0.75, hatVel: 0.55, swing: 0.2, ghostProb: 0.25 }
  };
  return styles[genre] || styles.lofi;
}

function generateFourFloorDrums(offset, density, energy, style, isFillBar) {
  // Kick on every beat
  [0, 4, 8, 12].forEach(s => {
    sbSetStep('kick', offset + s, { 
      velocity: style.kickVel * (0.95 + Math.random() * 0.1),
      probability: 100
    });
  });
  
  // Snare on 2 & 4
  sbSetStep('snare', offset + 4, { velocity: style.snareVel * (0.95 + Math.random() * 0.1) });
  sbSetStep('snare', offset + 12, { velocity: style.snareVel * (0.98 + Math.random() * 0.05) });
  
  // Hi-hats (8ths)
  if (patterns.hihat) {
    for (let i = 0; i < 16; i += 2) {
      const isUpbeat = i % 4 === 2;
      const vel = isUpbeat ? style.hatVel * 0.7 : style.hatVel;
      
      if (Math.random() < density * 0.9) {
        sbSetStep('hihat', offset + i, { 
          velocity: vel * (0.9 + Math.random() * 0.2),
          probability: isUpbeat ? 90 : 100
        });
      }
    }
    
    // Add 16th hats for higher density
    if (density > 0.7) {
      for (let i = 1; i < 16; i += 4) {
        if (Math.random() < (density - 0.7) * 1.5) {
          sbSetStep('hihat', offset + i, { 
            velocity: style.hatVel * 0.5,
            probability: 75
          });
        }
      }
    }
  }
  
  // Ghost notes on snare
  if (Math.random() < style.ghostProb && density > 0.5) {
    const ghostSteps = [2, 6, 10, 14];
    ghostSteps.forEach(s => {
      if (Math.random() < 0.4) {
        sbSetStep('snare', offset + s, { 
          velocity: 0.25 + Math.random() * 0.15,
          probability: 70
        });
      }
    });
  }
  
  // Fill on last bar
  if (isFillBar) {
    addDrumFill(offset, energy, style);
  }
}

function generateBreakbeatDrums(offset, density, energy, style, isFillBar) {
  // Syncopated kick pattern
  sbSetStep('kick', offset + 0, { velocity: style.kickVel });
  sbSetStep('kick', offset + 6, { velocity: style.kickVel * 0.85 });
  sbSetStep('kick', offset + 10, { velocity: style.kickVel * 0.8 });
  
  if (energy > 0.7) {
    sbSetStep('kick', offset + 13, { velocity: style.kickVel * 0.75, probability: 90 });
  }
  
  // Snare backbeat
  sbSetStep('snare', offset + 4, { velocity: style.snareVel });
  sbSetStep('snare', offset + 12, { velocity: style.snareVel * 1.05 });
  
  // Busy hi-hats
  if (patterns.hihat) {
    for (let i = 0; i < 16; i++) {
      const onBeat = i % 4 === 0;
      const vel = onBeat ? style.hatVel : style.hatVel * 0.6;
      
      if (Math.random() < density * 0.8) {
        sbSetStep('hihat', offset + i, { 
          velocity: vel * (0.85 + Math.random() * 0.3),
          probability: onBeat ? 100 : 80
        });
      }
    }
  }
  
  if (isFillBar) {
    addDrumFill(offset, energy, style);
  }
}

function generateTrapDrums(offset, density, energy, style, isFillBar) {
  // Heavy kick
  sbSetStep('kick', offset + 0, { velocity: style.kickVel });
  sbSetStep('kick', offset + 8, { velocity: style.kickVel * 0.9 });
  
  if (energy > 0.7) {
    sbSetStep('kick', offset + 14, { velocity: style.kickVel * 0.8, probability: 90 });
  }
  
  // Snare
  sbSetStep('snare', offset + 4, { velocity: style.snareVel });
  sbSetStep('snare', offset + 12, { velocity: style.snareVel * 1.05 });
  
  // Trap hi-hat rolls
  if (patterns.hihat) {
    // Base pattern
    for (let i = 0; i < 16; i += 2) {
      sbSetStep('hihat', offset + i, { velocity: style.hatVel * 0.7 });
    }
    
    // Roll sections
    const rollStart = Math.random() < 0.5 ? 6 : 14;
    for (let i = rollStart; i < Math.min(rollStart + 2, 16); i++) {
      sbSetStep('hihat', offset + i, { 
        velocity: style.hatVel * (0.8 + Math.random() * 0.3),
        probability: 95
      });
    }
    
    // Extra 16ths for density
    if (density > 0.6) {
      for (let i = 3; i < 16; i += 4) {
        if (Math.random() < density * 0.7) {
          sbSetStep('hihat', offset + i, { 
            velocity: style.hatVel * 0.5,
            probability: 80
          });
        }
      }
    }
  }
  
  if (isFillBar) {
    addDrumFill(offset, energy, style);
  }
}

function generateHalfTimeDrums(offset, density, energy, style, isFillBar, bar) {
  // Half-time feel (slower)
  if (bar % 2 === 0) {
    sbSetStep('kick', offset + 0, { velocity: style.kickVel });
    sbSetStep('snare', offset + 8, { velocity: style.snareVel });
  }
  
  // Steady hats
  if (patterns.hihat) {
    for (let i = 0; i < 16; i += 2) {
      if (Math.random() < density * 0.85) {
        sbSetStep('hihat', offset + i, { 
          velocity: style.hatVel * (0.9 + Math.random() * 0.2)
        });
      }
    }
  }
  
  if (isFillBar && bar % 2 === 1) {
    addDrumFill(offset, energy, style);
  }
}

function addDrumFill(offset, energy, style) {
  const fillLength = Math.floor(3 + energy * 3); // 3-6 steps
  const startStep = 16 - fillLength;
  
  const fillType = Math.random();
  
  if (fillType < 0.4) {
    // Tom roll
    for (let i = startStep; i < 16; i++) {
      if (Math.random() < 0.85 && patterns.tom) {
        sbSetStep('tom', offset + i, {
          velocity: 0.6 + ((i - startStep) / fillLength) * 0.3,
          probability: 95
        });
      }
    }
  } else if (fillType < 0.7) {
    // Snare roll
    for (let i = startStep; i < 16; i++) {
      if ((i % 2 === 0 || energy > 0.7) && patterns.snare) {
        sbSetStep('snare', offset + i, {
          velocity: 0.5 + ((i - startStep) / fillLength) * 0.35,
          probability: 90
        });
      }
    }
  } else {
    // Mixed fill
    const fillPattern = [
      { inst: 'tom', vel: 0.6 },
      { inst: 'tom', vel: 0.7 },
      { inst: 'snare', vel: 0.75 },
      { inst: 'snare', vel: 0.85 }
    ];
    
    fillPattern.forEach((hit, idx) => {
      const step = startStep + idx;
      if (step < 16 && patterns[hit.inst]) {
        sbSetStep(hit.inst, offset + step, {
          velocity: hit.vel * (0.95 + Math.random() * 0.1),
          probability: 95
        });
      }
    });
    
    // Crash on the last step
    if (patterns.crash) {
      sbSetStep('crash', offset + 15, { velocity: 0.85, probability: 100 });
    }
  }
}

console.log('âœ… Coherent beat generator loaded');
 
  
// AI-powered beat generation
function generateAIVariation() {
  songBuilderState.isActive = false;
  const activeInsts = Object.keys(patterns).filter(inst =>
    patterns[inst].some(s => s.active)
  );
  
  if (activeInsts.length === 0) {
    showToast('âŒ Generate a beat first', 'error');
    return;
  }
  
  showToast('ðŸ¤– AI generating variation...', 'info');
  
  // Analyze current pattern
  const analysis = analyzePattern();
  
  // EXPANDED: Now includes harmonic variations (40% of the time)
  const variationType = Math.random();
  
  if (variationType < 0.12) {
    generateRhythmicDisplacement(analysis);
    showToast('ðŸŽ² Applied: Rhythmic Displacement', 'success');
  } else if (variationType < 0.24) {
    generateDensityVariation(analysis);
    showToast('ðŸŽ² Applied: Density Variation', 'success');
  } else if (variationType < 0.36) {
    generatePolyrhythmicLayer(analysis);
    showToast('ðŸŽ² Applied: Polyrhythmic Layer', 'success');
  } else if (variationType < 0.48) {
    generateSyncopation(analysis);
    showToast('ðŸŽ² Applied: Syncopation', 'success');
  } else if (variationType < 0.60) {
    applyModalInterchange();
    showToast('ðŸŽµ Applied: Modal Interchange', 'success');
  } else if (variationType < 0.72) {
    applySecondaryDominants();
    showToast('ðŸŽµ Applied: Secondary Dominants', 'success');
  } else if (variationType < 0.84) {
    applyChordSubstitutions();
    showToast('ðŸŽµ Applied: Chord Substitutions', 'success');
  } else {
    applyChordExtensions();
    showToast('ðŸŽµ Applied: Chord Extensions', 'success');
  }
  
  renderSequencer();
}
  
function analyzePattern() {
  const analysis = {
    kickCount: 0,
    snareCount: 0,
    hihatCount: 0,
    totalNotes: 0,
    trackActivity: {}
  };
  
  const instNames = Object.keys(instruments);
  
  instNames.forEach((instName, index) => {
    let activeSteps = 0;
    const pattern = patterns[instName];
    
    if (pattern) {
      for (let step = 0; step < state.sequenceLength; step++) {
        if (pattern[step]?.active) {
          activeSteps++;
          analysis.totalNotes++;
          
          const name = instName.toLowerCase();
          if (name.includes('kick')) analysis.kickCount++;
          else if (name.includes('snare') || name.includes('clap')) analysis.snareCount++;
          else if (name.includes('hat')) analysis.hihatCount++;
        }
      }
    }
    analysis.trackActivity[index] = activeSteps;
  });
  
  return analysis;
}

function generateRhythmicDisplacement(analysis) {
  songBuilderState.isActive = false;
  // Shift patterns by random amounts to create variation
  const shiftAmount = Math.floor(Math.random() * 4) + 1;
  
  Object.keys(instruments).forEach(inst => {
    if (Math.random() > 0.6) return; // Only shift 40% of instruments
    
    const oldPattern = [...patterns[inst]];
    
    for (let i = 0; i < state.sequenceLength; i++) {
      const newIndex = (i + shiftAmount) % state.sequenceLength;
      patterns[inst][newIndex] = { ...oldPattern[i] };
    }
  });
}

function generateDensityVariation(analysis) {
  songBuilderState.isActive = false;
  // Add or remove notes to change groove density
  const shouldAdd = Math.random() > 0.5;
  
  Object.keys(instruments).forEach(inst => {
    const currentDensity = analysis.instruments[inst].density;
    
    if (shouldAdd && currentDensity < 0.6) {
      // Add ghost notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (!patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = true;
          patterns[inst][i].velocity = 0.3 + Math.random() * 0.2;
          patterns[inst][i].probability = 60 + Math.random() * 30;
        }
      }
    } else if (!shouldAdd && currentDensity > 0.3) {
      // Remove some notes
      for (let i = 0; i < state.sequenceLength; i++) {
        if (patterns[inst][i].active && Math.random() > 0.7) {
          patterns[inst][i].active = false;
        }
      }
    }
  });
}

function generatePolyrhythmicLayer(analysis) {
  songBuilderState.isActive = false;
  // Add polyrhythmic patterns (e.g., 3-over-4, 5-over-4)
  const polyrhythms = [3, 5, 7];
  const poly = polyrhythms[Math.floor(Math.random() * polyrhythms.length)];
  
  // Choose a percussive instrument
  const percInsts = Object.keys(instruments).filter(k => 
    instruments[k].type === 'drum' || instruments[k].type === 'atmospheric'
  );
  
  if (percInsts.length === 0) return;
  
  const inst = percInsts[Math.floor(Math.random() * percInsts.length)];
  
  // Clear existing pattern
  patterns[inst].forEach(s => s.active = false);
  
  // Apply polyrhythm
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % Math.floor(state.sequenceLength / poly) === 0) {
      patterns[inst][i].active = true;
      patterns[inst][i].velocity = 0.6 + Math.random() * 0.2;
      patterns[inst][i].probability = 90 + Math.random() * 10;
    }
  }
}

function generateSyncopation(analysis) {
  songBuilderState.isActive = false;
  // Add off-beat accents
  Object.keys(instruments).forEach(inst => {
    const instData = instruments[inst];
    if (instData.type !== 'drum') return;
    
    for (let i = 0; i < state.sequenceLength; i++) {
      // Target off-beats (odd steps)
      if (i % 2 === 1 && !patterns[inst][i].active && Math.random() > 0.6) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.5 + Math.random() * 0.3;
        patterns[inst][i].probability = 70 + Math.random() * 25;
      }
      
      // Occasionally accent existing off-beats
      if (i % 2 === 1 && patterns[inst][i].active && Math.random() > 0.7) {
        patterns[inst][i].velocity = Math.min(1, patterns[inst][i].velocity * 1.3);
      }
    }
  });
}

// Melodic AI variations
function generateMelodicAIVariation() {
  songBuilderState.isActive = false;
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  if (!melodicInsts.some(inst => patterns[inst].some(s => s.active))) {
    showToast('âŒ Generate melodies first', 'error');
    return;
  }
  
  showToast('ðŸŽ¹ AI generating melodic variation...', 'info');
  
  const variationType = Math.random();
  
  if (variationType < 0.33) {
    generateMelodicInversion();
    showToast('ðŸŽ² Applied: Melodic Inversion', 'success');
  } else if (variationType < 0.66) {
    generateArpeggiation();
    showToast('ðŸŽ² Applied: Arpeggiation', 'success');
  } else {
    generateHarmonicVariation();
    showToast('ðŸŽ² Applied: Harmonic Variation', 'success');
  }
  
  renderSequencer();
}

function generateMelodicInversion() {
  songBuilderState.isActive = false;
  // Invert melodic contours
  const melodicInsts = ['bass', 'guitar', 'keys', 'lead'];
  
  melodicInsts.forEach(inst => {
    const notes = patterns[inst]
      .filter(s => s.active && s.note)
      .map(s => s.note);
    
    if (notes.length === 0) return;
    
    // Find pivot point (median note)
    const midiNotes = notes.map(n => Tone.Frequency(n).toMidi());
    const pivot = midiNotes.reduce((a, b) => a + b, 0) / midiNotes.length;
    
    // Invert around pivot
    patterns[inst].forEach(step => {
      if (step.active && step.note) {
        const midi = Tone.Frequency(step.note).toMidi();
        const distance = midi - pivot;
        const newMidi = Math.round(pivot - distance);
        step.note = Tone.Frequency(newMidi, 'midi').toNote();
      }
    });
  });
}

function generateArpeggiation() {
  songBuilderState.isActive = false;
  // Convert chords to arpeggios
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = state.octave;
  
  // Target keys instrument
  patterns.keys.forEach(step => step.active = false);
  
  // Create ascending arpeggio
  const arpPattern = [0, 2, 4, 2]; // I - III - V - III
  const arpSpeed = 2; // Every 2 steps
  
  for (let i = 0; i < state.sequenceLength; i += arpSpeed) {
    const degree = arpPattern[(i / arpSpeed) % arpPattern.length];
    const note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + octave;
    
    if (i < state.sequenceLength) {
      patterns.keys[i].active = true;
      patterns.keys[i].note = note;
      patterns.keys[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.keys[i].duration = '8n';
    }
  }
}

function generateHarmonicVariation() {
  songBuilderState.isActive = false;
  // Change chord voicings/extensions on melodic instruments
  const scaleIntervals = scales[state.scale];

  // Instruments we want to treat harmonically
  const chordInsts = ['keys', 'guitar', 'lead'];

  chordInsts.forEach(inst => {
    const pattern = patterns[inst];
    if (!pattern) return;

    pattern.forEach(step => {
      if (!step.active || !step.note) return;

      const baseNote = Array.isArray(step.note) ? step.note[0] : step.note;
      const match = baseNote.match(/^([A-G]#?)(\d+)$/);
      if (!match) return;

      const [, noteName, oct] = match;
      const noteIndex = keysArr.indexOf(noteName);
      if (noteIndex < 0) return;

      const extensions = [];

      // 9th
      if (Math.random() > 0.3) {
        const ninthName = keysArr[(noteIndex + scaleIntervals[1]) % 12];
        const ninth = ninthName + (parseInt(oct, 10) + 1);
        extensions.push(ninth);
      }

      // 11th
      if (Math.random() > 0.5) {
        const eleventhName = keysArr[(noteIndex + scaleIntervals[3]) % 12];
        const eleventh = eleventhName + (parseInt(oct, 10) + 1);
        extensions.push(eleventh);
      }

      if (!extensions.length) return;

      const originalChord = Array.isArray(step.note) ? step.note : [step.note];
      step.note = [...originalChord, ...extensions];
    });
  });
}

// Groove template system
function applyGrooveTemplate(template) {
  const templates = {
    shuffle: {
      name: 'Shuffle',
      // swing: 66,  // REMOVED - user controls this
      hihatPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      velocityMap: [0.8, 0.4, 0.7, 0.35, 0.8, 0.4, 0.7, 0.35]
    },
    halfTime: {
      name: 'Half-Time',
      // bpmMultiplier: 0.5,  // REMOVED
      kickPattern: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
    },
    doubleTime: {
      name: 'Double-Time',
      // bpmMultiplier: 2,  // REMOVED
      kickPattern: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
      hihatPattern: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    },
    breakbeat: {
      name: 'Breakbeat',
      kickPattern: [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
      snarePattern: [0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1],
      complexity: 3
    }
  };
  
  const groove = templates[template];
  if (!groove) return;
  
  showToast(`ðŸŽµ Applying ${groove.name} groove...`, 'info');
  
  // NO BPM OR SWING CHANGES - user controls these for recording!
  
  // Apply patterns (extend to 32 steps if needed)
  if (groove.kickPattern) {
    patterns.kick.forEach((step, i) => {
      const patternIndex = i % groove.kickPattern.length;
      step.active = groove.kickPattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.8;
        step.probability = 100;
      }
    });
  }
  
  if (groove.snarePattern) {
    patterns.snare.forEach((step, i) => {
      const patternIndex = i % groove.snarePattern.length;
      step.active = groove.snarePattern[patternIndex] === 1;
      if (step.active) {
        step.velocity = 0.75;
        step.probability = 100;
      }
    });
  }
  
  if (groove.hihatPattern) {
    patterns.hihat.forEach((step, i) => {
      const patternIndex = i % groove.hihatPattern.length;
      step.active = groove.hihatPattern[patternIndex] === 1;
      if (step.active) {
        const velIdx = i % (groove.velocityMap?.length || 8);
        step.velocity = groove.velocityMap ? groove.velocityMap[velIdx] : 0.6;
        step.probability = 100;
      }
    });
  }
  
  renderSequencer();
  showToast(`âœ… ${groove.name} groove applied! (BPM/swing unchanged)`, 'success');
}

function applyModalInterchange() {
  // Borrow chords from parallel major/minor
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  // Parallel scale (major â†” minor)
  const parallelScale = state.scale === 'major' ? 'minor' : 'major';
  const parallelIntervals = scales[parallelScale];
  
  // Only apply to chord instruments
  const chordInsts = ['keys', 'guitar'].filter(inst =>
    patterns[inst].some(s => s.active)
  );
  
  if (chordInsts.length === 0) return;
  
  const targetInst = chordInsts[Math.floor(Math.random() * chordInsts.length)];
  
  patterns[targetInst].forEach((step, idx) => {
    if (!step.active || !step.note) return;
    
    // 40% chance to borrow from parallel scale
    if (Math.random() < 0.4) {
      const baseNote = Array.isArray(step.note) ? step.note[0] : step.note;
      const match = baseNote.match(/^([A-G]#?)(\d+)$/);
      if (!match) return;
      
      const [, noteName, octave] = match;
      
      // Find current scale degree
      const currentInterval = (keysArr.indexOf(noteName) - keyIndex + 12) % 12;
      const degree = scaleIntervals.indexOf(currentInterval);
      
      if (degree === -1 || degree >= parallelIntervals.length) return;
      
      // Borrow the same degree from parallel scale
      const borrowedInterval = parallelIntervals[degree];
      const borrowedRoot = keysArr[(keyIndex + borrowedInterval) % 12];
      
      // Rebuild chord with borrowed root
      if (Array.isArray(step.note)) {
        const intervalShift = (borrowedInterval - currentInterval + 12) % 12;
        step.note = step.note.map(n => {
          const noteMatch = n.match(/^([A-G]#?)(\d+)$/);
          if (!noteMatch) return n;
          const [, name, oct] = noteMatch;
          const noteIdx = keysArr.indexOf(name);
          const newIdx = (noteIdx + intervalShift) % 12;
          return keysArr[newIdx] + oct;
        });
      } else {
        step.note = borrowedRoot + octave;
      }
    }
  });
  
  console.log(`ðŸŽµ Modal interchange â†’ ${instruments[targetInst].name}`);
}

function applySecondaryDominants() {
  // Add dominant chords that resolve to the next chord
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const chordInsts = ['keys', 'guitar'].filter(inst =>
    patterns[inst].some(s => s.active && s.note && Array.isArray(s.note))
  );
  
  if (chordInsts.length === 0) return;
  
  const targetInst = chordInsts[Math.floor(Math.random() * chordInsts.length)];
  
  patterns[targetInst].forEach((step, idx) => {
    if (!step.active || !step.note || !Array.isArray(step.note)) return;
    
    // Look ahead to next chord (find next active step)
    let nextChordIdx = idx + 1;
    while (nextChordIdx < state.sequenceLength && !patterns[targetInst][nextChordIdx].active) {
      nextChordIdx++;
    }
    
    if (nextChordIdx >= state.sequenceLength) return;
    
    const nextChord = patterns[targetInst][nextChordIdx].note;
    if (!Array.isArray(nextChord)) return;
    
    // 30% chance to insert V/x before target chord
    if (Math.random() < 0.3) {
      const targetRoot = nextChord[0];
      const targetMatch = targetRoot.match(/^([A-G]#?)(\d+)$/);
      if (!targetMatch) return;
      
      const [, targetNote, targetOct] = targetMatch;
      const targetIdx = keysArr.indexOf(targetNote);
      
      // V chord is a 5th above target (7 semitones)
      const dominantIdx = (targetIdx + 7) % 12;
      const dominantRoot = keysArr[dominantIdx];
      
      // Build dominant 7th chord (major 3rd + minor 7th for tension)
      const third = keysArr[(dominantIdx + 4) % 12]; // Major 3rd
      const fifth = keysArr[(dominantIdx + 7) % 12]; // Perfect 5th
      const seventh = keysArr[(dominantIdx + 10) % 12]; // Minor 7th
      
      step.note = [
        dominantRoot + targetOct,
        third + targetOct,
        fifth + targetOct,
        seventh + targetOct
      ];
      step.duration = '8n'; // Shorter = more tension
    }
  });
  
  console.log(`ðŸŽµ Secondary dominants â†’ ${instruments[targetInst].name}`);
}

function applyChordSubstitutions() {
  // Replace chords with functional equivalents
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const chordInsts = ['keys', 'guitar'].filter(inst =>
    patterns[inst].some(s => s.active && s.note && Array.isArray(s.note))
  );
  
  if (chordInsts.length === 0) return;
  
  const targetInst = chordInsts[Math.floor(Math.random() * chordInsts.length)];
  
  patterns[targetInst].forEach((step, idx) => {
    if (!step.active || !step.note || !Array.isArray(step.note)) return;
    
    // 35% chance to substitute
    if (Math.random() < 0.35) {
      const rootNote = step.note[0];
      const match = rootNote.match(/^([A-G]#?)(\d+)$/);
      if (!match) return;
      
      const [, noteName, octave] = match;
      const rootIdx = keysArr.indexOf(noteName);
      
      // Choose substitution type
      const subType = Math.random();
      let newRootIdx;
      
      if (subType < 0.5) {
        // Tritone substitution (6 semitones away)
        newRootIdx = (rootIdx + 6) % 12;
      } else {
        // Relative chord (3 semitones away - minor â†” major)
        newRootIdx = (rootIdx + 3) % 12;
      }
      
      const newRoot = keysArr[newRootIdx];
      
      // Rebuild chord with new root, keeping same structure
      step.note = step.note.map((n, i) => {
        if (i === 0) return newRoot + octave;
        
        const noteMatch = n.match(/^([A-G]#?)(\d+)$/);
        if (!noteMatch) return n;
        const [, name, oct] = noteMatch;
        
        // Calculate interval from old root
        const oldInterval = (keysArr.indexOf(name) - rootIdx + 12) % 12;
        // Apply to new root
        const newNoteIdx = (newRootIdx + oldInterval) % 12;
        return keysArr[newNoteIdx] + oct;
      });
    }
  });
  
  console.log(`ðŸŽµ Chord substitutions â†’ ${instruments[targetInst].name}`);
}

function applyChordExtensions() {
  // Add 9ths, 11ths, 13ths for color
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  
  const chordInsts = ['keys', 'guitar', 'lead'].filter(inst =>
    patterns[inst].some(s => s.active)
  );
  
  if (chordInsts.length === 0) return;
  
  const targetInst = chordInsts[Math.floor(Math.random() * chordInsts.length)];
  
  patterns[targetInst].forEach((step, idx) => {
    if (!step.active || !step.note) return;
    
    const baseNote = Array.isArray(step.note) ? step.note[0] : step.note;
    const match = baseNote.match(/^([A-G]#?)(\d+)$/);
    if (!match) return;
    
    const [, noteName, octave] = match;
    const rootIdx = keysArr.indexOf(noteName);
    
    const extensions = [];
    const upperOct = parseInt(octave) + 1;
    
    // 9th (2nd scale degree, octave up)
    if (Math.random() > 0.4) {
      const ninthIdx = (rootIdx + scaleIntervals[1]) % 12;
      extensions.push(keysArr[ninthIdx] + upperOct);
    }
    
    // 11th (4th scale degree, octave up)
    if (Math.random() > 0.6) {
      const eleventhIdx = (rootIdx + scaleIntervals[3]) % 12;
      extensions.push(keysArr[eleventhIdx] + upperOct);
    }
    
    // 13th (6th scale degree, octave up)
    if (Math.random() > 0.75) {
      const thirteenthIdx = (rootIdx + scaleIntervals[5]) % 12;
      extensions.push(keysArr[thirteenthIdx] + upperOct);
    }
    
    if (extensions.length > 0) {
      const originalChord = Array.isArray(step.note) ? step.note : [step.note];
      step.note = [...originalChord, ...extensions];
    }
  });
  
  console.log(`ðŸŽµ Chord extensions â†’ ${instruments[targetInst].name}`);
}
  
// Lo-Fi: Laid back, off-grid, jazzy
function generateLoFiBeat() {
  songBuilderState.isActive = false;
  // DON'T set BPM - user controls it
  const len = state.sequenceLength;
  
  // Kick: Sparse, on 1 and 3 throughout entire sequence
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    setStep('kick', offset + 8, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.3) setStep('kick', offset + 6, 0.7, 80);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 10, 0.75, 70);
  }
  
  // Snare: Backbeat on 2 and 4
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) setStep('snare', offset + 14, 0.4, 60);
  }
  
  // Hi-hat: Shuffled 8ths
  for (let i = 0; i < len; i += 2) {
    const vel = i % 4 === 0 ? 0.7 : 0.45;
    setStep('hihat', i, vel, 95);
    if (state.complexity >= 2 && i % 4 === 2) setStep('hihat', i + 1, 0.3, 70);
  }
  
  // Rimshot: Sparse accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.5, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.5, 80);
    }
  }
  
  // Crash: Bar markers
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
    }
  }
}
  
// Hip-Hop: Boom-bap, hard-hitting
function generateHipHopBeat() {
  songBuilderState.isActive = false;
  
  const len = state.sequenceLength;
  
  // Kick: Boom-bap throughout
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.9, 100);
    setStep('kick', offset + 6, 0.85, 100);
    if (state.complexity >= 2) {
      if (Math.random() > 0.5) setStep('kick', offset + 9, 0.8, 90);
      if (Math.random() > 0.6) setStep('kick', offset + 13, 0.75, 85);
    }
  }
  
  // Snare: Hard backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.9, 100);
    setStep('snare', offset + 12, 0.9, 100);
  }
  
  // Clap: Layer with snare
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('clap', offset + 4, 0.7, 100);
    setStep('clap', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Steady 8ths and 16ths
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    for (let i = 3; i < len; i += 4) {
      setStep('hihat', i, 0.4, 85);
    }
  }
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.5) setStep('crash', offset + 6, 0.5, 75);
      if (Math.random() > 0.5) setStep('crash', offset + 14, 0.5, 75);
    }
  }
  
  // Tom fills at end of each bar
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.65, 95);
        setStep('tom', offset + 14, 0.75, 95);
        setStep('tom', offset + 15, 0.85, 95);
      }
    }
  }
}
  
// Post-Punk: Driving, motorik, relentless
function generatePostPunkBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  const fourOnFloor = Math.random() > 0.3;
  
  // Kick: Four-on-floor or driving 8ths
  if (fourOnFloor) {
    for (let i = 0; i < len; i += 4) {
      setStep('kick', i, 0.85, 100);
    }
  } else {
    for (let i = 0; i < len; i += 2) {
      setStep('kick', i, i % 4 === 0 ? 0.85 : 0.75, 100);
    }
  }
  
  // Snare: Backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.8, 100);
    setStep('snare', offset + 12, 0.8, 100);
    if (state.complexity >= 2) setStep('snare', offset + 10, 0.7, 80);
  }
  
  // Rimshot: Driving 16ths
  if (state.complexity >= 2) {
    for (let i = 1; i < len; i += 2) {
      if (Math.random() > 0.4) setStep('rimshot', i, 0.5, 85);
    }
  }
  
  // Hi-hat: Mechanical 16ths
  for (let i = 0; i < len; i++) {
    const vel = i % 4 === 0 ? 0.7 : 0.5;
    setStep('hihat', i, vel, 100);
  }
  
  // Ride: Alternative
  if (state.complexity >= 3 && Math.random() > 0.5) {
    for (let i = 0; i < len; i += 2) {
      if (Math.random() > 0.3) setStep('ride', i, 0.55, 90);
    }
  }
  
  // Tom fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
        setStep('tom', offset + 15, 0.8, 90);
      }
    }
  }
  
  // Crash on downbeat
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.4) setStep('crash', bar * 16, 0.75, 100);
  }
}
  
// R&B: Syncopated, groovy, pocket
function generateRnBBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Syncopated
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.85, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 95);
    setStep('kick', offset + 10, 0.8, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) setStep('kick', offset + 13, 0.7, 85);
  }
  
  // Snare: Laid back backbeat
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.75, 100);
    setStep('snare', offset + 12, 0.75, 100);
    if (state.complexity >= 3) {
      setStep('snare', offset + 11, 0.4, 70);
      setStep('snare', offset + 15, 0.45, 75);
    }
  }
  
  // Rimshot: Syncopated accents
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.4) setStep('rimshot', offset + 6, 0.55, 80);
      if (Math.random() > 0.4) setStep('rimshot', offset + 14, 0.55, 80);
    }
  }
  
  // Hi-hat: Intricate 16th patterns
  for (let i = 0; i < len; i += 2) {
    setStep('hihat', i, 0.6, 100);
  }
  if (state.complexity >= 2) {
    const offbeats = [1, 3, 5, 9, 11, 13];
    for (let bar = 0; bar < len / 16; bar++) {
      offbeats.forEach(pos => {
        if (Math.random() > 0.3) setStep('hihat', bar * 16 + pos, 0.35, 75);
      });
    }
  }
  
  // Clap: Occasional layers
  if (state.complexity >= 3 && Math.random() > 0.6) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      setStep('clap', offset + 4, 0.5, 85);
      setStep('clap', offset + 12, 0.5, 85);
    }
  }
}
  
// Ambient: Sparse, textural, atmospheric
function generateAmbientBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Minimal bar markers
  for (let bar = 0; bar < len / 16; bar++) {
    setStep('kick', bar * 16, 0.7, 100);
    if (state.complexity >= 2 && Math.random() > 0.5) {
      setStep('kick', bar * 16 + 8, 0.65, 90);
    }
  }
  
  // Snare: Very sparse
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.5) setStep('snare', bar * 16 + 8, 0.5, 85);
    }
  }
  
  // Hi-hat: Sparse texture
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    if (Math.random() > 0.3) setStep('hihat', offset + 0, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 6, 0.4, 80);
    if (Math.random() > 0.3) setStep('hihat', offset + 10, 0.4, 80);
  }
  
  // Crash: Textural swells
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) setStep('crash', bar * 16, 0.6, 90);
      if (Math.random() > 0.4) setStep('crash', bar * 16 + 12, 0.55, 80);
    }
  }
  
  // Ride: Subtle pulse
  if (state.complexity >= 3) {
    for (let i = 0; i < len; i += 4) {
      if (Math.random() > 0.3) setStep('ride', i, 0.35, 70);
    }
  }
  
  // Tom: Occasional atmospheric hits
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.7) {
        const tomStep = [4, 8, 12][Math.floor(Math.random() * 3)];
        setStep('tom', bar * 16 + tomStep, 0.45, 75);
      }
    }
  }
}
  
function generateDazecoreBeat() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Kick: Warm and bouncy
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('kick', offset + 0, 0.8, 100);
    if (Math.random() > 0.3) setStep('kick', offset + 6, 0.75, 90);
    setStep('kick', offset + 12, 0.8, 100);
    if (state.complexity >= 3 && Math.random() > 0.5) setStep('kick', offset + 3, 0.5, 70);
  }
  
  // Snare: Off-grid, nostalgic
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    setStep('snare', offset + 4, 0.7, 100);
    if (state.complexity >= 2) setStep('snare', offset + 7, 0.5, 80);
    setStep('snare', offset + 12, 0.7, 100);
  }
  
  // Hi-hat: Shimmering, irregular
  const glitchyHats = [0, 2, 3, 5, 6, 8, 10, 11, 13, 14];
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    glitchyHats.forEach((step, idx) => {
      const vel = idx % 3 === 0 ? 0.65 : 0.4;
      const prob = Math.random() > 0.2 ? 90 : 60;
      setStep('hihat', offset + step, vel, prob);
    });
  }
  
  // Rimshot: Dial-up clicks
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [1, 5, 9].forEach(step => {
        if (Math.random() > 0.4) setStep('rimshot', offset + step, 0.45, 75);
      });
    }
  }
  
  // Clap: Sunny handclaps
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      if (Math.random() > 0.3) setStep('clap', offset + 7, 0.55, 85);
      if (Math.random() > 0.3) setStep('clap', offset + 15, 0.55, 85);
    }
  }
  
  // Tom: Nostalgic fills
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      if (Math.random() > 0.6) {
        const offset = bar * 16;
        setStep('tom', offset + 13, 0.6, 90);
        setStep('tom', offset + 14, 0.7, 90);
      }
    }
  }
  
  // Crash: Sunshine swells
  for (let bar = 0; bar < len / 16; bar++) {
    if (Math.random() > 0.5) setStep('crash', bar * 16, 0.65, 95);
  }
}

// Helper to set a step
function setStep(inst, step, velocity, probability) {
  if (step < state.sequenceLength) {
    patterns[inst][step].active = true;
    patterns[inst][step].velocity = velocity;
    patterns[inst][step].probability = probability;
  }
}

// ==================== BEAT VARIETY GENERATORS ====================

// Add rhythmic variations - keep the groove but make it interesting
function addRhythmicVariety() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Add syncopated kicks (occasional off-beat hits)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 30% chance to add syncopated kick
      if (Math.random() > 0.7) {
        const positions = [3, 7, 11, 15]; // Syncopated positions
        const pos = positions[Math.floor(Math.random() * positions.length)];
        setStep('kick', offset + pos, 0.65 + Math.random() * 0.15, 85);
      }
    }
  }
  
  // Add hi-hat variations (open hats, rolls)
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // Random hi-hat roll at end of bar
      if (Math.random() > 0.6) {
        for (let i = 13; i < 16; i++) {
          if (Math.random() > 0.3) {
            setStep('hihat', offset + i, 0.4 + Math.random() * 0.2, 90);
          }
        }
      }
    }
  }
  
  // Add snare flams (double hits)
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      // 20% chance to add flam before main snare
      [4, 12].forEach(mainHit => {
        if (Math.random() > 0.8 && !patterns.snare[offset + mainHit - 1].active) {
          setStep('snare', offset + mainHit - 1, 0.4, 80);
        }
      });
    }
  }
  
  // Add crash accents on sections
  if (state.complexity >= 2) {
    const sectionsCount = Math.floor(len / 16);
    for (let i = 0; i < sectionsCount; i += 4) {
      // Every 4 bars, add emphasis
      if (i > 0) {
        setStep('crash', i * 16, 0.7, 100);
      }
    }
  }
  
  renderSequencer();
}

// Create a fill pattern at the end of 4/8 bar sections
function addDrumFills() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  const barsPerFill = state.complexity === 1 ? 8 : state.complexity === 2 ? 4 : 2;
  
  for (let bar = barsPerFill - 1; bar < len / 16; bar += barsPerFill) {
    const fillStart = bar * 16 + 12; // Last 4 steps of bar
    
    if (fillStart + 4 > len) continue;
    
    // Random fill type
    const fillType = Math.floor(Math.random() * 3);
    
    if (fillType === 0) {
      // Tom roll descending
      for (let i = 0; i < 4; i++) {
        setStep('tom', fillStart + i, 0.6 + (i * 0.1), 95);
      }
    } else if (fillType === 1) {
      // Snare roll
      for (let i = 0; i < 4; i++) {
        if (i % 2 === 0 || state.complexity >= 3) {
          setStep('snare', fillStart + i, 0.5 + (i * 0.1), 90);
        }
      }
    } else {
      // Mixed fill (toms + crash)
      setStep('tom', fillStart + 0, 0.6, 95);
      setStep('tom', fillStart + 1, 0.7, 95);
      setStep('snare', fillStart + 2, 0.75, 95);
      setStep('crash', fillStart + 3, 0.8, 100);
    }
  }
  
  renderSequencer();
}

// Add swing feel variations
function addSwingVariations() {
  songBuilderState.isActive = false;
  const len = state.sequenceLength;
  
  // Offset every other hi-hat slightly for swing feel
  for (let i = 1; i < len; i += 4) {
    if (patterns.hihat[i].active) {
      patterns.hihat[i].velocity *= 0.7; // Quieter on off-beats
    }
  }
  
  // Add ghost notes on snare
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      const ghostPositions = [2, 6, 10, 14];
      
      ghostPositions.forEach(pos => {
        if (Math.random() > 0.6 && !patterns.snare[offset + pos].active) {
          setStep('snare', offset + pos, 0.25 + Math.random() * 0.15, 70);
        }
      });
    }
  }
  
  renderSequencer();
}
  
// More subtle variations - don't destroy the groove
function addSubtleVariations() {
  songBuilderState.isActive = false;
  // Only add to hi-hats and rimshots - keep kick/snare solid
  ['hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      // Only 15% chance to add variation on empty steps
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 30;
      }
    }
  });
}

// Add after generateBeat function
function applyGenreFX() {
  songBuilderState.isActive = false;
  if (state.currentGenre === 'postpunk') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 2.0;
    fxConfig.chorus.active = true;
    fxConfig.filter.active = false;
  } else if (state.currentGenre === 'rnb') {
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.5;
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.3;
    fxConfig.distortion.active = false;
  } else if (state.currentGenre === 'dazecore') {
    // Warm glitchy sunshine sound
    fxConfig.reverb.active = true;
    fxConfig.reverb.decay = 1.8; // Nostalgic space
    fxConfig.chorus.active = true;
    fxConfig.chorus.depth = 0.5; // Shimmer
    fxConfig.bitcrusher.active = true; // Dial-up glitch texture
    fxConfig.bitcrusher.bits = 6; // Lo-fi crunch
    fxConfig.delay.active = true; // Echo memories
    fxConfig.delay.time = '8n';
    fxConfig.delay.feedback = 0.3;
    fxConfig.filter.active = true; // Warm cut
    fxConfig.filter.frequency = 4000; // Bright but not harsh
  }
  
  // Apply settings
  Object.keys(fxConfig).forEach(fx => {
    const cfg = fxConfig[fx];
    if (effects[fx] && effects[fx].wet) {
      effects[fx].wet.value = cfg.active ? 0.25 : 0;
    }
  });
  
  renderFX();
}
  
function addVariations() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.2 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.4 + Math.random() * 0.3;
        patterns[inst][i].probability = 50 + Math.random() * 50;
      }
    }
  });
}

function addGhostNotes() {
  songBuilderState.isActive = false;
  ['snare', 'hihat', 'rimshot'].forEach(inst => {
    for (let i = 0; i < state.sequenceLength; i++) {
      if (Math.random() < 0.15 && !patterns[inst][i].active) {
        patterns[inst][i].active = true;
        patterns[inst][i].velocity = 0.2 + Math.random() * 0.2;
        patterns[inst][i].probability = 60 + Math.random() * 40;
      }
    }
  });
  renderSequencer();
}

function randomizeVelocity() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.velocity = 0.5 + Math.random() * 0.5;
      }
    });
  });
  renderSequencer();
}

function randomizeProbability() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      if (step.active) {
        step.probability = 50 + Math.floor(Math.random() * 51);
      }
    });
  });
  renderSequencer();
}

function clearPattern() {
  songBuilderState.isActive = false;
  Object.keys(instruments).forEach(inst => {
    patterns[inst].forEach(step => {
      step.active = false;
      step.velocity = 0.8;
      step.probability = 100;
      step.note = instruments[inst].note;
      step.duration = '8n';
    });
  });
  renderSequencer();
}

function clearLeadPattern() {
  if (!patterns.lead) return;

  patterns.lead.forEach(step => {
    step.active      = false;
    step.velocity    = 0.8;
    step.probability = 100;
    step.note        = instruments.lead?.note || step.note;
    step.duration    = '8n';
  });
}

function generateMelodicPatterns() {
  songBuilderState.isActive = false;

  ensureHarmonyGuardrails();

  // Only reset the lead lane
  clearLeadPattern();

  const genre = state.currentGenre;

  if (genre === 'lofi') {
    generateLoFiMelodies();
  } else if (genre === 'hiphop') {
    generateHipHopMelodies();
  } else if (genre === 'postpunk') {
    generatePostPunkMelodies();
  } else if (genre === 'rnb') {
    generateRnBMelodies();
  } else if (genre === 'ambient') {
    generateAmbientMelodies();
  } else if (genre === 'dazecore') {
    generateDazecoreMelodies();
  }

  renderSequencer();
}


// Lo-Fi: chords/bass/lead driven by the active chord progression (phrase-aware)
function generateLoFiMelodies() {
  songBuilderState.isActive = false;
  ensureHarmonyGuardrails();

  const len = state.sequenceLength;
  const bars = Math.max(1, Math.floor(len / 16));
  const keysOct  = state.octave || 3;   // keys/blocks
  const bassOct  = (state.octave || 3) - 2;
  const leadOct  = (state.octave || 3) + 1;

  // Clear any existing melodic notes
  ['bass','keys','lead','guitar'].forEach(inst => {
    if (!patterns[inst]) return;
    for (let i=0;i<len;i++) {
      patterns[inst][i].active = false;
      patterns[inst][i].note = instruments[inst]?.note || patterns[inst][i].note;
      patterns[inst][i].velocity = 0.8;
      patterns[inst][i].duration = '8n';
    }
  });

  // Simple A / A' phrase plan: first half repeats with light variation
  const phraseLenBars = Math.max(2, Math.min(4, bars)); // 2â€“4 bar phrase
  let lastLeadPC = null; // previous pitch-class for smoothing

  for (let bar = 0; bar < bars; bar++) {
    const offset = bar * 16;
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale); // safety
    const [root, third, fifth] = chord;

    // === KEYS (block chords on the grid) ===
    // Downbeats: 0, 4, 8, 12 â€” alternate chord tones
    const keysPlan = [
      withOct(root,  keysOct),
      withOct(third, keysOct),
      withOct(fifth, keysOct),
      withOct(root,  keysOct)
    ];
    [0,4,8,12].forEach((step, i) => {
      const idx = offset + step;
      patterns.keys[idx].active   = true;
      patterns.keys[idx].note     = keysPlan[i % keysPlan.length];
      patterns.keys[idx].velocity = 0.6;
      patterns.keys[idx].duration = '2n';
    });

    // === BASS (root/5th on strong beats, passing on weak) ===
    for (let s = 0; s < 16; s++) {
      const idx = offset + s;
      const n = chooseBassNote(chord, s, bassOct);
      if (s % 2 === 0) { // half the density; feel free to tweak
        patterns.bass[idx].active   = true;
        patterns.bass[idx].note     = n;
        patterns.bass[idx].velocity = (s % 4 === 0) ? 0.9 : 0.7;
        patterns.bass[idx].duration = (s % 4 === 0) ? '8n' : '16n';
      }
    }

    // === LEAD (motif that lightly varies every phrase) ===
    // Place on weak beats inside the bar for a laid-back feel
    const motifSteps = [2, 6, 10, 14];
    motifSteps.forEach((s, i) => {
      const idx = offset + s;
      const n = chooseMelodyNote(chord, s, leadOct, lastLeadPC);
      lastLeadPC = n; // keep string (has octave, okay)
      patterns.lead[idx].active   = true;
      patterns.lead[idx].note     = n;
      patterns.lead[idx].velocity = 0.7;
      patterns.lead[idx].duration = '8n';
    });

    // === Light variation on A' phrases ===
    if (bar >= phraseLenBars && (bar % phraseLenBars === 0)) {
      // Nudge one keys hit and one lead note
      const idxK = offset + 8;
      if (patterns.keys[idxK]?.active) {
        patterns.keys[idxK].note = withOct(third, keysOct); // swap tone
      }
      const idxL = offset + 10;
      if (patterns.lead[idxL]?.active) {
        patterns.lead[idxL].note = withOct(fifth, leadOct); // small lift
      }
    }
  }

  renderSequencer?.();
}

// Hip-Hop: Heavy bass, sparse chords, melodic hooks
function generateHipHopMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Root notes, heavy and sparse
  const bassOctave = 1;
  const bassPattern = [0, 0, 4, 0, 0, 3, 0, 5];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassPattern.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree % 7]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.8;
        patterns.bass[offset + step].duration = '4n';
      }
    });
  }
  
  // Keys: Simple triads on downbeats
  const chordOctave = 3;
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach(step => {
      const root = keysArr[keyIndex] + chordOctave;
      const third = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
      const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
      
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = [root, third, fifth];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '1n';
    });
  }
  
  // Lead: Melodic hook
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const hook = [0, 3, 2, 0, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [8, 9, 10, 11, 12].forEach((step, idx) => {
        if (hook[idx] !== undefined) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[hook[idx]]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.6;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 100;
        }
      });
    }
  }
}

// Post-Punk: Dark bass, angular guitars, minimal keys
function generatePostPunkMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.minor;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Driving 8th notes, root-fifth motion
  const bassOctave = 1;
  
  for (let i = 0; i < len; i += 2) {
    patterns.bass[i].active = true;
    const useFifth = i % 4 === 2;
    const degree = useFifth ? 4 : 0;
    patterns.bass[i].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[i].velocity = 0.75;
    patterns.bass[i].duration = '8n';
  }
  
  // Guitar: Power chords, angular rhythm
  if (state.complexity >= 2) {
    const chordOctave = 2;
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [0, 4, 8, 12].forEach(step => {
        const root = keysArr[keyIndex] + chordOctave;
        const fifth = keysArr[(keyIndex + scaleIntervals[4]) % 12] + chordOctave;
        const octave = keysArr[keyIndex] + (chordOctave + 1);
        
        patterns.guitar[offset + step].active = true;
        patterns.guitar[offset + step].note = [root, fifth, octave];
        patterns.guitar[offset + step].velocity = 0.6;
        patterns.guitar[offset + step].duration = '4n';
      });
    }
  }
  
  // Keys: Sparse stabs
  if (state.complexity >= 3) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [6, 14].forEach(step => {
        if (Math.random() > 0.3) {
          const chordOctave = 4;
          patterns.keys[offset + step].active = true;
          patterns.keys[offset + step].note = keysArr[(keyIndex + scaleIntervals[2]) % 12] + chordOctave;
          patterns.keys[offset + step].velocity = 0.5;
          patterns.keys[offset + step].duration = '16n';
        }
      });
    }
  }
}

// R&B: Smooth chords, groovy bass, soulful leads
function generateRnBMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Syncopated groove
  const bassOctave = 2;
  const bassGroove = [0, null, 4, null, 3, null, 5, null];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    bassGroove.forEach((degree, idx) => {
      const step = idx * 2;
      if (degree !== null && step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7;
        patterns.bass[offset + step].duration = '8n';
      }
    });
  }
  
  // Keys: 7th chords with extensions
  const chordOctave = 3;
  const rnbChords = [0, 3, 4, 5].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, seventh + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = rnbChords[idx % rnbChords.length];
      patterns.keys[offset + step].velocity = 0.45;
      patterns.keys[offset + step].duration = '2n';
    });
  }
  
  // Guitar: Rhythm chops
  if (state.complexity >= 2) {
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [2, 6, 10, 14].forEach(step => {
        if (Math.random() > 0.4) {
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = rnbChords[Math.floor(step / 4) % rnbChords.length];
          patterns.guitar[offset + step].velocity = 0.35;
          patterns.guitar[offset + step].duration = '16n';
        }
      });
    }
  }
  
  // Lead: Soulful melody
  if (state.complexity >= 3) {
    const leadOctave = 5;
    const soul = [0, 2, 3, 4, 3, 2, 0, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      soul.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.55 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
        }
      });
    }
  }
}

// Ambient: Atmospheric pads, sparse melodic elements
function generateAmbientMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Long sustained root notes
  const bassOctave = 2;
  const bassProgression = [0, 4]; // Alternate between root and fifth
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    const degree = bassProgression[bar % bassProgression.length];
    
    patterns.bass[offset].active = true;
    patterns.bass[offset].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
    patterns.bass[offset].velocity = 0.6;
    patterns.bass[offset].duration = '1n';
    
    if (state.complexity >= 2 && bar % 2 === 1) {
      patterns.bass[offset + 8].active = true;
      patterns.bass[offset + 8].note = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12] + bassOctave;
      patterns.bass[offset + 8].velocity = 0.55;
      patterns.bass[offset + 8].duration = '1n';
    }
  }
  
  // Keys: Wide ambient chords
  const chordOctave = 3;
  const ambientChords = [0, 4, 5, 3].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % 7]) % 12];
    return [root + (chordOctave - 1), third + chordOctave, fifth + chordOctave, seventh + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 8].forEach((step, idx) => {
      if (Math.random() > 0.2) {
        patterns.keys[offset + step].active = true;
        patterns.keys[offset + step].note = ambientChords[(bar + idx) % ambientChords.length];
        patterns.keys[offset + step].velocity = 0.4;
        patterns.keys[offset + step].duration = '1n';
      }
    });
  }
  
  // Lead: Sparse ethereal notes
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const etherealNotes = [0, 2, 4];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      [4, 8, 12].forEach((step, idx) => {
        if (Math.random() > 0.4) {
          const degree = etherealNotes[idx % etherealNotes.length];
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.35;
          patterns.lead[offset + step].duration = '2n';
          patterns.lead[offset + step].probability = 70;
        }
      });
    }
  }
}

// Dazecore: Warm, nostalgic melodies with glitchy textures
function generateDazecoreMelodies() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales.major;
  const keyIndex = keysArr.indexOf(state.key);
  const len = state.sequenceLength;
  
  // Bass: Warm, syncopated bounce
  const bassOctave = 2;
  const sunnyBass = [0, 0, 2, 0, 4, 0, 2, 0];
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    sunnyBass.forEach((degree, idx) => {
      const step = idx * 2;
      if (step < 16) {
        patterns.bass[offset + step].active = true;
        patterns.bass[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + bassOctave;
        patterns.bass[offset + step].velocity = 0.7 + Math.random() * 0.1;
        patterns.bass[offset + step].duration = '8n';
        patterns.bass[offset + step].probability = 95;
      }
    });
  }
  
  // Keys: Shimmering nostalgic chords with add9s
  const chordOctave = 3;
  const nostalgiaChords = [0, 4, 5, 2].map(degree => {
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % 7]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % 7]) % 12];
    const ninth = keysArr[(keyIndex + scaleIntervals[(degree + 1) % 7]) % 12];
    return [root + chordOctave, third + chordOctave, fifth + chordOctave, ninth + (chordOctave + 1)];
  });
  
  for (let bar = 0; bar < len / 16; bar++) {
    const offset = bar * 16;
    [0, 4, 8, 12].forEach((step, idx) => {
      patterns.keys[offset + step].active = true;
      patterns.keys[offset + step].note = nostalgiaChords[idx % nostalgiaChords.length];
      patterns.keys[offset + step].velocity = 0.5;
      patterns.keys[offset + step].duration = '2n';
      patterns.keys[offset + step].probability = 95;
    });
  }
  
  // Guitar: Glitchy arpeggios (dial-up texture)
  if (state.complexity >= 2) {
    const arpSteps = [1, 2, 5, 6, 9, 10, 13, 14];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      arpSteps.forEach((step, idx) => {
        if (Math.random() > 0.3) {
          const chordIdx = Math.floor(step / 4) % nostalgiaChords.length;
          const noteIdx = idx % 4;
          patterns.guitar[offset + step].active = true;
          patterns.guitar[offset + step].note = nostalgiaChords[chordIdx][noteIdx];
          patterns.guitar[offset + step].velocity = 0.35 + Math.random() * 0.15;
          patterns.guitar[offset + step].duration = '16n';
          patterns.guitar[offset + step].probability = 70 + Math.floor(Math.random() * 25);
        }
      });
    }
  }
  
  // Lead: Nostalgic melody fragments (summer memory)
  if (state.complexity >= 2) {
    const leadOctave = 5;
    const memory = [4, 5, 4, 2, 0, 2, 4, null];
    
    for (let bar = 0; bar < len / 16; bar++) {
      const offset = bar * 16;
      memory.forEach((degree, idx) => {
        const step = idx + 8;
        if (degree !== null && step < 16 && Math.random() > 0.2) {
          patterns.lead[offset + step].active = true;
          patterns.lead[offset + step].note = keysArr[(keyIndex + scaleIntervals[degree]) % 12] + leadOctave;
          patterns.lead[offset + step].velocity = 0.5 + Math.random() * 0.15;
          patterns.lead[offset + step].duration = '8n';
          patterns.lead[offset + step].probability = 85;
        }
      });
    }
  }
}
// Add after generateMelodicPatterns function
function addDrumFills() {
  songBuilderState.isActive = false;
  // Add crash on bar 1
  patterns.crash[0].active = true;
  patterns.crash[0].velocity = 0.8;
  patterns.crash[0].probability = 100;
  
  // Random tom fills every 2 bars
  if (state.complexity >= 2) {
    for (let bar = 1; bar < state.sequenceLength / 16; bar++) {
      const fillStart = (bar * 16) - 4; // Last 4 steps of bar
      
      if (Math.random() < 0.3) { // 30% chance
        for (let i = 0; i < 4; i++) {
          if (Math.random() < 0.7) {
            patterns.tom[fillStart + i].active = true;
            patterns.tom[fillStart + i].velocity = 0.6 + (i * 0.1);
          }
        }
      }
    }
  }
}

function generateBassLine() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const root = state.key;
  const octave = 2; // Keep bass in low register
  
  // Use darker intervals - root, minor 3rd, 4th, 5th
  const bassNotes = [
    root + octave,
    keysArr[(keyIndex + scaleIntervals[2]) % 12] + octave,  // minor 3rd
    keysArr[(keyIndex + scaleIntervals[3]) % 12] + octave,  // 4th
    keysArr[(keyIndex + scaleIntervals[4]) % 12] + octave   // 5th
  ];
  
  const density = state.complexity === 1 ? 4 : state.complexity === 2 ? 6 : 8;
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % (16 / density) === 0 || (state.complexity >= 3 && Math.random() < 0.2)) {
      patterns.bass[i].active = true;
      patterns.bass[i].note = bassNotes[Math.floor(i / 4) % bassNotes.length];
      patterns.bass[i].velocity = 0.6 + Math.random() * 0.2;
      patterns.bass[i].duration = '4n'; // Longer, sustained notes
      patterns.bass[i].probability = 100;
    }
  }
}

function generateKeyPattern() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 3; // Lower octave - darker
  
  // Build darker, more dissonant chords
  const chords = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 4][i]; // Use 2nd (adds tension), minor 3rd, 4th
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const third = keysArr[(keyIndex + scaleIntervals[(degree + 2) % scaleIntervals.length]) % 12];
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Add 7th for more color/tension
    const seventh = keysArr[(keyIndex + scaleIntervals[(degree + 6) % scaleIntervals.length]) % 12];
    
    chords.push([
      root + octave, 
      third + octave, 
      fifth + octave,
      seventh + (octave + 1)
    ]);
  }
  
  // Sparse, sustained pads
  for (let i = 0; i < state.sequenceLength; i++) {
    if (i % 8 === 0) { // Only every 8 steps = very sparse
      const index = Math.floor(i / 8) % chords.length;
      patterns.keys[i].active = true;
      patterns.keys[i].note = chords[index];
      patterns.keys[i].velocity = 0.5 + Math.random() * 0.15; // Quiet
      patterns.keys[i].duration = '1n'; // Whole note - long sustain
      patterns.keys[i].probability = 100;
    }
  }
}

function generateLeadMelody() {
  songBuilderState.isActive = false;

  // If you have this helper, it's nice to ensure harmony is sane:
  if (typeof ensureHarmonyGuardrails === 'function') {
    ensureHarmonyGuardrails();
  }

  const len     = state.sequenceLength;
  const bars    = Math.max(1, Math.floor(len / STEPS_PER_BAR));
  const leadOct = (state.octave || 3) + 1;
  const density = state.complexity === 1 ? 0.3 :
                  state.complexity === 2 ? 0.5 : 0.8;

  // Wipe only the lead lane
  if (patterns.lead) {
    patterns.lead.forEach(step => {
      step.active      = false;
      step.velocity    = 0.8;
      step.probability = 100;
      step.note        = instruments.lead?.note || step.note;
      step.duration    = '8n';
    });
  }

  let lastMidi = null;

  for (let bar = 0; bar < bars; bar++) {
    const offset = bar * STEPS_PER_BAR;

    // === THIS IS YOUR SNIPPET ===
    const chord = getChordNotesForBar(bar) || buildTriadFromDegree(0, state.key, state.scale);
    const pcs   = chord.map(n => n.replace(/\d/, ''));
    const [root, third, fifth] = pcs;
    // =============================

    // Safe chord-tone pool (fallbacks if third/fifth are missing)
    const chordPool = [root, third || root, fifth || root].filter(Boolean);

    // Strong beats where we really want chord tones
    const strongSteps = [0, 4, 8, 12];

    strongSteps.forEach(step => {
      if (Math.random() > density) return;

      const pc = chordPool[Math.floor(Math.random() * chordPool.length)];
      const noteName = withOct(pc, leadOct);
      const idx = offset + step;

      if (!patterns.lead[idx]) return;

      patterns.lead[idx].active   = true;
      patterns.lead[idx].note     = noteName;
      patterns.lead[idx].velocity = 0.65 + 0.2 * Math.random();
      patterns.lead[idx].duration = '8n';
      patterns.lead[idx].probability = 95;

      lastMidi = Tone.Frequency(noteName).toMidi();
    });

    // Optional passing tones between chord hits, still quantized to scale
    if (lastMidi != null && typeof buildScaleStepsForKey === 'function' && typeof quantizeNoteToScale === 'function') {
      const scaleSteps = buildScaleStepsForKey(state.key, state.scale);

      for (let step = 1; step < STEPS_PER_BAR; step += 2) {
        if (Math.random() > density * 0.5) continue;
        const idx = offset + step;
        if (!patterns.lead[idx]) continue;

        const jump     = [-2, -1, 1, 2][Math.floor(Math.random() * 4)];
        const target   = quantizeNoteToScale(
          lastMidi + jump,
          state.key,
          scaleSteps,
          chord.map(n => Tone.Frequency(n).toMidi())
        );
        const noteName = Tone.Frequency(target, 'midi').toNote();

        patterns.lead[idx].active   = true;
        patterns.lead[idx].note     = noteName;
        patterns.lead[idx].velocity = 0.5 + 0.2 * Math.random();
        patterns.lead[idx].duration = '16n';
        patterns.lead[idx].probability = 85;

        lastMidi = target;
      }
    }
  }
}

// Add after line ~1260 (after generateLeadMelody function)
function generateGuitarStrums() {
  songBuilderState.isActive = false;
  const scaleIntervals = scales[state.scale];
  const keyIndex = keysArr.indexOf(state.key);
  const octave = 2; // Lower, darker
  
  // Build power chords and sus chords (no 3rd = ambiguous/dreamy)
  const chordShapes = [];
  for (let i = 0; i < 4; i++) {
    const degree = [0, 2, 3, 5][i];
    const root = keysArr[(keyIndex + scaleIntervals[degree]) % 12];
    const fourth = keysArr[(keyIndex + scaleIntervals[(degree + 3) % scaleIntervals.length]) % 12]; // sus4
    const fifth = keysArr[(keyIndex + scaleIntervals[(degree + 4) % scaleIntervals.length]) % 12];
    
    // Sus chords = dreamy, no major/minor
    chordShapes.push([
      root + octave, 
      fourth + octave, 
      fifth + octave,
      root + (octave + 1)
    ]);
  }
  
  // Very sparse strumming
  const strumPattern = [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]; // Only twice per bar
  
  for (let i = 0; i < state.sequenceLength; i++) {
    if (strumPattern[i % strumPattern.length]) {
      const chordIndex = Math.floor(i / 8) % chordShapes.length;
      patterns.guitar[i].active = true;
      patterns.guitar[i].note = chordShapes[chordIndex];
      patterns.guitar[i].velocity = 0.4 + Math.random() * 0.15; // Quiet
      patterns.guitar[i].duration = '2n'; // Half note sustain
      patterns.guitar[i].probability = 100;
    }
  }
}

function applyEuclidean() {
  songBuilderState.isActive = false;
  const instrumentKeys = Object.keys(instruments);
  const inst = instrumentKeys[Math.floor(Math.random() * instrumentKeys.length)];
  const hits = Math.floor(Math.random() * 8) + 3;
  const steps = state.sequenceLength;
  
  const pattern = generateEuclidean(hits, steps);
  pattern.forEach((value, i) => {
    patterns[inst][i].active = value === 1;
    if (value === 1) {
      patterns[inst][i].velocity = 0.7 + Math.random() * 0.3;
      patterns[inst][i].probability = 100;
    }
  });
  
  renderSequencer();
}

function generateEuclidean(hits, steps) {
  songBuilderState.isActive = false;
  const result = Array(steps).fill(0);
  const bucket = [];
  
  for (let i = 0; i < steps; i++) {
    bucket.push(Math.floor((i * hits) / steps));
  }
  
  for (let i = 0; i < steps; i++) {
    if (i === 0 || bucket[i] !== bucket[i - 1]) {
      result[i] = 1;
    }
  }
  
  return result;
}

// -------------------- Mixer Rendering --------------------
function renderMixer() {
  const grid = document.getElementById('mixerGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(instruments).forEach(inst => {
    const data = instruments[inst];
    const channel = document.createElement('div');
    channel.className = 'mixer-channel';
    
    channel.innerHTML = `
      <div class="channel-header">
        <div class="channel-name">${data.icon} ${data.name}</div>
        <div class="channel-btns">
          <button class="channel-btn mute ${data.mute ? 'active' : ''}" 
                  data-inst="${inst}" data-action="mute">M</button>
          <button class="channel-btn solo ${data.solo ? 'active' : ''}" 
                  data-inst="${inst}" data-action="solo">S</button>
        </div>
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Volume</span>
          <span class="param-value">${data.volume}dB</span>
        </div>
        <input type="range" min="-40" max="10" value="${data.volume}" 
               data-inst="${inst}" data-param="volume">
      </div>
      <div class="param-control">
        <div class="param-label">
          <span>Pan</span>
          <span class="param-value">${data.pan > 0 ? 'R' : data.pan < 0 ? 'L' : 'C'}${Math.abs(data.pan)}</span>
        </div>
        <input type="range" min="-100" max="100" value="${data.pan}" 
               data-inst="${inst}" data-param="pan">
      </div>
    `;
    
    fragment.appendChild(channel);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

// -------------------- FX Rendering --------------------
function renderFX() {
  const grid = document.getElementById('fxGrid');
  const fragment = document.createDocumentFragment();
  
  Object.keys(fxConfig).forEach(fx => {
    const config = fxConfig[fx];
    const unit = document.createElement('div');
    unit.className = 'fx-unit';
    
    const params = Object.keys(config).filter(k => k !== 'name' && k !== 'active');
    let paramsHTML = '';
    
    params.forEach(param => {
      const value = config[param];
      const display = formatFxDisplay(param, value);
      
      let sliderVal = 50;
      if (param === 'decay') {
        sliderVal = clamp(Math.round(value * 20), 0, 100);
      } else if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
        sliderVal = Math.round(value * 100);
      } else if (param === 'time') {
        const timeMap = { '16n': 0, '8n': 33, '4n': 66, '2n': 100 };
        sliderVal = timeMap[value] ?? 50;
      } else if (param === 'frequency') {
        sliderVal = Math.round((value - 100) / 79);
      } else if (param === 'octaves') {
        sliderVal = (value - 1) * 20;
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value">${display}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx="${fx}" data-param="${param}">
        </div>
      `;
    });
    
    unit.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${config.name}</div>
        <div class="fx-toggle ${config.active ? 'active' : ''}" data-fx="${fx}"></div>
      </div>
      ${paramsHTML}
    `;
    
    fragment.appendChild(unit);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);

  wireGlobalFXControls();
}

function wireGlobalFXControls() {
  const grid = document.getElementById('fxGrid');
  if (!grid) return;

  // Avoid double binding if renderFX runs multiple times
  if (grid.dataset._wired === 'true') return;
  grid.dataset._wired = 'true';

  // --- Slider changes ---
  grid.addEventListener('input', (e) => {
    const target = e.target;
    if (!(target instanceof HTMLInputElement)) return;
    if (target.type !== 'range') return;

    const fxName = target.dataset.fx;
    const param  = target.dataset.param;
    if (!fxName || !param) return;

    const raw = parseFloat(target.value);
    const mapped = sliderToFxValue(fxName, param, raw);

    // Update config
    const cfg = fxConfig[fxName];
    if (cfg) cfg[param] = mapped;

    // Push into Tone node
    applyFxParamToNode(fxName, param, mapped);

    // Update displayed text
    const label = target.closest('.param-control')?.querySelector('.param-value');
    if (label) {
      label.textContent = formatFxDisplay(param, mapped);
    }
  });

  // --- Toggle active on/off ---
  grid.addEventListener('click', (e) => {
    const toggle = e.target.closest('.fx-toggle');
    if (!toggle) return;

    const fxName = toggle.dataset.fx;
    const cfg = fxConfig[fxName];
    if (!cfg) return;

    cfg.active = !cfg.active;
    toggle.classList.toggle('active', cfg.active);

    applyFxActiveState(fxName, cfg.active);
  });
}

// Map 0â€“100 slider â†’ actual useful value
function sliderToFxValue(fxName, param, raw) {
  // Normalized 0â€“1
  if (['wet', 'feedback', 'depth', 'amount'].includes(param)) {
    return raw / 100;
  }

  if (param === 'decay') {
    // 0â€“5 seconds
    return raw / 20;
  }

  if (param === 'time') {
    const steps = ['16n', '8n', '4n', '2n'];
    return steps[Math.round(raw / 33)] || '4n';
  }

  if (param === 'frequency') {
    // 100 Hz â†’ 8000 Hz
    return 100 + (raw / 100) * (8000 - 100);
  }

  if (param === 'octaves') {
    // 1 â†’ 6 octaves
    return 1 + (raw / 20);
  }

  if (param === 'bits') {
    // 4 â†’ 16 bits
    return Math.round(4 + (raw / 100) * 12);
  }

  return raw;
}

// Actually update the Tone.js nodes you created in initAudio
function applyFxParamToNode(fxName, param, value) {
  const fx = effects[fxName];
  if (!fx) return;

  const ramp = 0.05;

  try {
    if (fxName === 'reverb') {
      if (param === 'decay' && fx.decay !== undefined) fx.decay = value;
      if (param === 'wet' && fx.wet) fx.wet.rampTo(value, ramp);
    }
    else if (fxName === 'delay') {
      if (param === 'time' && fx.delayTime) fx.delayTime.value = Tone.Time(value);
      if (param === 'feedback' && fx.feedback) fx.feedback.rampTo(value, ramp);
    }
    else if (fxName === 'chorus' || fxName === 'flanger') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'depth' && fx.depth !== undefined) fx.depth = value;
    }
    else if (fxName === 'phaser') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'octaves' && fx.octaves !== undefined) fx.octaves = value;
    }
    else if (fxName === 'distortion') {
      if (param === 'amount' && fx.distortion !== undefined) fx.distortion = value;
    }
    else if (fxName === 'bitcrusher') {
      if (param === 'bits' && fx.bits !== undefined) fx.bits = value;
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
    }
    else if (fxName === 'filter') {
      if (param === 'frequency' && fx.frequency) fx.frequency.rampTo(value, ramp);
      if (param === 'type' && typeof fx.type === 'string') fx.type = value;
    }
  } catch (err) {
    console.warn(`FX param update failed for ${fxName}.${param}`, err);
  }
}

// Turn FX "on/off" based on fxConfig.active
function applyFxActiveState(fxName, active) {
  const fx = effects[fxName];
  if (!fx) return;

  // Most of your effects in initAudio are Tone.Effect subclasses, so they have .wet
  if (fx.wet) {
    const cfg = fxConfig[fxName];
    const wet = cfg && typeof cfg.wet === 'number' ? cfg.wet : (active ? 0.3 : 0);
    fx.wet.value = active ? wet : 0;
    return;
  }

  // Special case: filter has no .wet - "off" = wide open
  if (fxName === 'filter' && fx.frequency) {
    const targetFreq = active ? (fxConfig.filter.frequency || 5000) : 20000;
    fx.frequency.rampTo(targetFreq, 0.05);
  }
}

function randomizeHarmony() {
  const possibleKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

  // Base scale pool (what you already had)
  const BASE_SCALES = ['major', 'minor', 'dorian', 'mixolydian'];

  // Read mood from Song Builder / global state
  const mood = (typeof songBuilderState !== 'undefined' && songBuilderState.mood)
    ? songBuilderState.mood
    : (state.mood || 'default');

  let possibleScales;

  switch (mood) {
    case 'dark':
    case 'sad':
      // Heavier bias toward minor / dorian
      possibleScales = ['minor', 'minor', 'dorian', 'minor', 'mixolydian'];
      break;

    case 'tense':
      // More edgy, modal vibes
      possibleScales = ['dorian', 'minor', 'dorian', 'mixolydian'];
      break;

    case 'mellow':
      // Softer, happier mix
      possibleScales = ['major', 'major', 'mixolydian', 'mixolydian', 'dorian'];
      break;

    case 'dreamy':
      // Bright, floaty â€“ use lydian as well
      possibleScales = ['lydian', 'lydian', 'major', 'mixolydian'];
      break;

    case 'default':
    default:
      // EXACTLY what you had before
      possibleScales = BASE_SCALES.slice();
      break;
  }

  // Chord preset IDs â€“ unchanged
  let chordPresetIds = [];
  if (typeof CHORD_PRESETS === 'object' && CHORD_PRESETS !== null) {
    chordPresetIds = Object.keys(CHORD_PRESETS);
  }

  const rand = arr => arr[Math.floor(Math.random() * arr.length)];

  const newKey    = rand(possibleKeys);
  const newScale  = rand(possibleScales);
  const newPreset = chordPresetIds.length ? rand(chordPresetIds) : null;

  // Make sure state.harmony exists
  state.harmony = state.harmony || {};
  state.harmony.key      = newKey;
  state.harmony.scale    = newScale;
  if (newPreset) state.harmony.presetId = newPreset;

  // Update the UI controls if they exist
  const keySelect    = document.getElementById('harmonyKeySelect');
  const scaleSelect  = document.getElementById('harmonyScaleSelect');
  const presetSelect = document.getElementById('chordPresetSelect');

  if (keySelect)    keySelect.value    = newKey;
  if (scaleSelect)  scaleSelect.value  = newScale;
  if (presetSelect && newPreset) presetSelect.value = newPreset;

  // Apply the new harmony to your engine / chord progression
  if (typeof applyHarmonySettings === 'function') {
    applyHarmonySettings();
  } else if (typeof generateChordProgression === 'function') {
    generateChordProgression();
  }

  console.log(
    `ðŸŽ¹ Randomized harmony â†’ Key: ${newKey}, Scale: ${newScale}, Mood: ${mood}` +
    (newPreset ? `, Chords: ${newPreset}` : '')
  );
}

/* ============================
   HARMONY GUARDRAILS (v1.7)
   - Progression templates (degrees)
   - Triad builder from scale
   - Normalization of state.progression -> state.progressionNotes
   - Chord/phrase helpers
============================ */

const PROGRESSION_TEMPLATES = {
  lofi: [
    // Degrees in current scale (0..6)
    [0, 5, 3, 4],  // I â€“ vi â€“ IV â€“ V
    [1, 4, 0, 5],  // ii â€“ V â€“ I â€“ vi
    [0, 3, 4, 0],  // I â€“ IV â€“ V â€“ I
    [5, 3, 0, 4],  // vi â€“ IV â€“ I â€“ V
  ],
  hiphop: [
    [5, 3, 0, 4],  // vi â€“ IV â€“ I â€“ V
    [0, 0, 3, 4],  // I â€“ I â€“ IV â€“ V
  ],
  default: [[0, 3, 4, 0]]
};

// Build a triad (root, 3rd, 5th) from a scale degree using your keysArr/scales tables
function buildTriadFromDegree(degree, keyRoot = state.key, scaleName = state.scale) {
  const keyIndex = keysArr.indexOf(keyRoot);
  const scaleIntervals = scales[scaleName] || scales.major; // fallback

  if (keyIndex === -1 || !Array.isArray(scaleIntervals) || !scaleIntervals.length) {
    console.warn('buildTriadFromDegree: bad key/scale', keyRoot, scaleName);
    return ['C', 'E', 'G']; // ultra-safe fallback
  }

  const len = scaleIntervals.length;
  const deg = ((degree % len) + len) % len;

  const rootSemis    = scaleIntervals[deg];
  const thirdSemis   = scaleIntervals[(deg + 2) % len];
  const fifthSemis   = scaleIntervals[(deg + 4) % len];
  const seventhSemis = scaleIntervals[(deg + 6) % len]; // diatonic 7th in that scale

  const root    = keysArr[(keyIndex + rootSemis)    % 12];
  const third   = keysArr[(keyIndex + thirdSemis)   % 12];
  const fifth   = keysArr[(keyIndex + fifthSemis)   % 12];
  const seventh = keysArr[(keyIndex + seventhSemis) % 12];

  // return 7th as 4th element â€“ old code using [root, third, fifth] still works
  return [root, third, fifth, seventh];
}


// Normalize any existing state.progression into state.progressionNotes = [ ['C','E','G'], ... ]
function ensureHarmonyGuardrails() {
  // Already normalized?
  if (Array.isArray(state.progressionNotes) && state.progressionNotes.length) return;

  // Case A: User/Harmony tab already created a progression we can normalize
  if (Array.isArray(state.progression) && state.progression.length) {
    const normalized = [];
    for (const chord of state.progression) {
      if (Array.isArray(chord)) {
        // ['C','E','G'] or with stray octaves like ['C3','E3','G3']
        normalized.push(chord.map(n => String(n).replace(/\d/g,'')));
      } else if (chord && chord.root) {
        // { root:'C', type:'minor'|'major'|'dim' , ... }
        // Try Tonal first (if available), else derive from the scale degree fallback
        try {
          const typeSuffix = chord.type === 'minor' ? 'm' : (chord.type === 'dim' ? 'dim' : '');
          const tonalNotes = (window.Tonal?.Chord?.get?.(`${chord.root}${typeSuffix}`)?.notes) || [];
          if (tonalNotes.length) {
            normalized.push(tonalNotes.map(n => n.replace(/\d/g,'')));
            continue;
          }
        } catch (e) {}
        // Fallback: build a triad on the root as if it's a scale member (best-effort)
        normalized.push([chord.root, chord.root, chord.root]);
      }
    }
    if (normalized.length) {
      state.progressionNotes = normalized;
      return;
    }
  }

  // Case B: Nothing to normalize â†’ generate from template for the current genre
  const bank = PROGRESSION_TEMPLATES[state.currentGenre] || PROGRESSION_TEMPLATES.lofi || PROGRESSION_TEMPLATES.default;
  const tpl = bank[Math.floor(Math.random() * bank.length)];
  state.progressionNotes = tpl.map(deg => buildTriadFromDegree(deg, state.key, state.scale));
}

// Map a *bar index* to its chord (notes WITHOUT octaves)
function getChordNotesForBar(barIndex) {
  ensureHarmonyGuardrails();
  if (!Array.isArray(state.progressionNotes) || !state.progressionNotes.length) return null;
  return state.progressionNotes[barIndex % state.progressionNotes.length];
}

// Append an octave to a pitch class like "C" -> "C3"
function withOct(note, octave) {
  return `${note.replace(/\d/g,'')}${octave}`;
}

// Pick a bass note for a step in the bar: strong beats = root/5th, weak = passing
function chooseBassNote(chordNotes, stepInBar, baseOct = 2) {
  const strong = (stepInBar % 4 === 0); // steps 0,4,8,12 within a 16-step bar
  if (strong) {
    // Alternate root and fifth to create simple movement
    const pick = (stepInBar === 8) ? 2 : 0; // 0=root, 2=fifth (root,3rd,5th indexing)
    return withOct(chordNotes[Math.min(pick, chordNotes.length-1)], baseOct);
  }
  // Weak beats: neighbor/passing = third or step back to root
  const pick = (stepInBar % 8 < 4) ? 1 : 0;
  return withOct(chordNotes[Math.min(pick, chordNotes.length-1)], baseOct);
}

// Choose a chord-tone melody note; strong beats prefer chord tones, weak beats can use neighbors
function chooseMelodyNote(chordNotes, stepInBar, baseOct = 4, last = null) {
  const strong = (stepInBar % 4 === 0);
  const pool = strong ? chordNotes : [...chordNotes]; // could add scale neighbors if you like
  let pick = pool[Math.floor(Math.random() * pool.length)];
  // Gentle smoothing: avoid repeating the exact same note too often on weak beats
  if (!strong && last && pick === last.replace(/\d/g,'')) {
    pick = pool[(pool.indexOf(pick)+1) % pool.length];
  }
  // Keep melodic contour inside a comfy range
  const oct = strong ? baseOct : (Math.random() < 0.6 ? baseOct : baseOct + 1);
  return withOct(pick, oct);
}

// -------------------- Harmony System --------------------
function renderHarmony() {
  const keySelect = document.getElementById('keySelect');
  keySelect.innerHTML = keysArr.map(k => 
    `<option value="${k}" ${k === state.key ? 'selected' : ''}>${k}</option>`
  ).join('');
  
  const scaleSelect = document.getElementById('scaleSelect');
  scaleSelect.innerHTML = Object.keys(scales).map(s => 
    `<option value="${s}" ${s === state.scale ? 'selected' : ''}>${s}</option>`
  ).join('');
  
  const octaveSelect = document.getElementById('octaveSelect');
  octaveSelect.innerHTML = [2, 3, 4, 5, 6].map(o => 
    `<option value="${o}" ${o === state.octave ? 'selected' : ''}>${o}</option>`
  ).join('');
  
  updateChords();
}

function updateChords() {
  const chordChips = document.getElementById('chordChips');
  const fragment = document.createDocumentFragment();
  
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  
  const chords = [];
  scaleIntervals.forEach((interval, i) => {
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(i + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type =
      thirdInterval === 3 ? 'minor' :
      thirdInterval === 4 ? 'major' :
      'dim';

    chords.push({
      root,
      type,
      roman: ['I','II','III','IV','V','VI','VII'][i]
    });
  });
  
  chords.forEach(chord => {
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent =
      `${chord.roman} - ${chord.root}${
        chord.type === 'minor' ? 'm' :
        chord.type === 'dim'   ? 'Â°' : ''
      }`;
    
    chip.addEventListener('click', () => {
      state.progression.push(chord);
      invalidateHarmonyCache();   // ðŸ§¹ harmony cache reset
      renderProgression();
    });
    
    fragment.appendChild(chip);   // âœ… this was missing
  });

  chordChips.innerHTML = '';
  chordChips.appendChild(fragment);
}

function renderProgression() {
  const wrap = document.getElementById('progressionChips');
  const fragment = document.createDocumentFragment();
  
  if (!state.progression.length) {
    wrap.innerHTML =
      '<div style="color: var(--text-muted); font-size: 0.9rem;">Click chords above to build progression</div>';
    return;
  }
  
  state.progression.forEach((chord, index) => {
    const chip = document.createElement('div');
    chip.className = 'chip active';
    chip.textContent =
      `${chord.roman} - ${chord.root}${
        chord.type === 'minor' ? 'm' :
        chord.type === 'dim'   ? 'Â°' : ''
      }`;
    
    chip.addEventListener('click', () => {
      state.progression.splice(index, 1);
      invalidateHarmonyCache();   // ðŸ§¹ reset *then* re-render
      renderProgression();
    });

    fragment.appendChild(chip);
  });
  
  wrap.innerHTML = '';
  wrap.appendChild(fragment);
}

function generateProgression() {
  const keyIndex = keysArr.indexOf(state.key);
  const scaleIntervals = scales[state.scale];
  const templates = [
    [0, 3, 4, 0],
    [0, 5, 3, 4],
    [1, 4, 0],
    [0, 4, 5, 3]
  ];
  
  const template = templates[Math.floor(Math.random() * templates.length)];
  state.progression = [];
  
  template.forEach(degree => {
    const interval = scaleIntervals[degree];
    const root = keysArr[(keyIndex + interval) % 12];
    const third = scaleIntervals[(degree + 2) % scaleIntervals.length];
    const thirdInterval = (third - interval + 12) % 12;
    const type = thirdInterval === 3 ? 'minor' : thirdInterval === 4 ? 'major' : 'dim';
    state.progression.push({ root, type, roman: ['I','II','III','IV','V','VI','VII'][degree] });
  });
  
  renderProgression();
}

function loadProgressionTemplate(name) {
  const templates = {
    'ii-v-i': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'G', type: 'major', roman: 'V' },
      { root: 'C', type: 'major', roman: 'I' }
    ],
    'lofi': [
      { root: 'C', type: 'major', roman: 'I' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'F', type: 'major', roman: 'IV' },
      { root: 'G', type: 'major', roman: 'V' }
    ],
    'neosoul': [
      { root: 'D', type: 'minor', roman: 'II' },
      { root: 'E', type: 'minor', roman: 'III' },
      { root: 'A', type: 'minor', roman: 'VI' },
      { root: 'D', type: 'minor', roman: 'II' }
    ],
    'modal': [
      { root: 'D', type: 'minor', roman: 'I' },
      { root: 'E', type: 'minor', roman: 'II' },
      { root: 'F', type: 'major', roman: 'III' },
      { root: 'G', type: 'major', roman: 'IV' }
    ]
  };
  
  state.progression = templates[name] || [];
  renderProgression();
}

// ==================== MULTITRACK RECORDING SYSTEM ====================

const multitrack = {
  tracks: [],
  nextTrackId: 1,
  recordingTracks: new Set(),
  currentFxTrackId: null,
  globalRecordStartTime: null,
  zoom: 100, // pixels per second
  snapEnabled: true,
  snapInterval: 0.25,
  loopEnabled: false,
  loopStart: null,
  loopEnd: null,
  currentTool: 'select'   // âœï¸ timeline tool state
};

// === UNDO/REDO HISTORY SYSTEM ===
const multitrackHistory = {
  stack: [],
  currentIndex: -1,
  maxSize: 50,
  isRestoring: false, // Prevent recording during undo/redo
  
  captureState() {
    if (this.isRestoring) return; // Don't record during undo/redo
    
    // Serialize current multitrack state (without audio buffers to save memory)
    const state = {
      tracks: multitrack.tracks.map(t => ({
        id: t.id,
        name: t.name,
        instrument: t.instrument,
        isExternalAudio: t.isExternalAudio,
        volume: t.volume,
        pan: t.pan,
        muted: t.muted,
        soloed: t.soloed,
        armed: t.armed,
        selectedTakeIndex: t.selectedTakeIndex,
        takes: t.takes.map(take => ({
          id: take.id,
          duration: take.duration,
          startTime: take.startTime,
          muted: take.muted,
          timestamp: take.timestamp,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd
          // Note: We keep audio buffers in the actual track objects
        }))
      })),
      nextTrackId: multitrack.nextTrackId,
      zoom: multitrack.zoom,
      timestamp: Date.now()
    };
    
    // Remove any states after current index (branching timeline)
    this.stack = this.stack.slice(0, this.currentIndex + 1);
    
    // Add new state
    this.stack.push(state);
    
    // Limit stack size
    if (this.stack.length > this.maxSize) {
      this.stack.shift();
    } else {
      this.currentIndex++;
    }
    
    updateUndoRedoButtons();
  },
  
  undo() {
    if (!this.canUndo()) return;
    
    this.currentIndex--;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('â†¶ Undo', 'info');
  },
  
  redo() {
    if (!this.canRedo()) return;
    
    this.currentIndex++;
    this.restoreState(this.stack[this.currentIndex]);
    updateUndoRedoButtons();
    showToast('â†· Redo', 'info');
  },
  
  canUndo() {
    return this.currentIndex > 0;
  },
  
  canRedo() {
    return this.currentIndex < this.stack.length - 1;
  },
  
  restoreState(state) {
    this.isRestoring = true;
    
    try {
      // Restore track metadata (preserve existing audio buffers)
      state.tracks.forEach(savedTrack => {
        const liveTrack = multitrack.tracks.find(t => t.id === savedTrack.id);
        
        if (liveTrack) {
          // Update existing track
          liveTrack.name = savedTrack.name;
          liveTrack.volume = savedTrack.volume;
          liveTrack.pan = savedTrack.pan;
          liveTrack.muted = savedTrack.muted;
          liveTrack.soloed = savedTrack.soloed;
          liveTrack.armed = savedTrack.armed;
          liveTrack.selectedTakeIndex = savedTrack.selectedTakeIndex;
          
          // Update audio routing
          if (liveTrack.channel) {
            liveTrack.channel.volume.value = liveTrack.volume;
            liveTrack.channel.pan.value = liveTrack.pan / 100;
          }
          
          // Restore take metadata (keep audio buffers)
          savedTrack.takes.forEach((savedTake, idx) => {
            if (liveTrack.takes[idx]) {
              liveTrack.takes[idx].startTime = savedTake.startTime;
              liveTrack.takes[idx].muted = savedTake.muted;
              liveTrack.takes[idx].trimStart = savedTake.trimStart;
              liveTrack.takes[idx].trimEnd = savedTake.trimEnd;
            }
          });
        }
      });
      
      // Remove tracks that don't exist in saved state
      multitrack.tracks = multitrack.tracks.filter(t => 
        state.tracks.some(st => st.id === t.id)
      );
      
      // Restore other properties
      multitrack.zoom = state.zoom;
      multitrack.nextTrackId = state.nextTrackId;
      
      renderMultitrack();
      
    } finally {
      this.isRestoring = false;
    }
  },
  
  clear() {
    this.stack = [];
    this.currentIndex = -1;
    updateUndoRedoButtons();
  }
};

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn) {
    undoBtn.disabled = !multitrackHistory.canUndo();
  }
  
  if (redoBtn) {
    redoBtn.disabled = !multitrackHistory.canRedo();
  }
}
  
// ==================== ENHANCED MULTITRACK WITH EXTERNAL AUDIO ====================

class AudioTrack {
  constructor(id, name = `Track ${id}`, instrument = null, isExternalAudio = false) {
    this.id = id;
    this.name = name;
    this.instrument = instrument || 'internal';
    this.isExternalAudio = isExternalAudio;
    this.takes = [];
    this.selectedTakeIndex = -1;
    this.armed = false;
    this.recording = false;
    this.muted = false;
    this.soloed = false;
    this.volume = 0;
    this.pan = 0;
    this.inputMonitoring = false;
    this.recordStartTime = null;

    // Audio routing
    this.channel = new Tone.Channel({ volume: 0, pan: 0 }).connect(master.fxIn);
    this.recorder = null;
    this.recordedChunks = [];
    this.fxChain = [];
    
    // Meter for visual feedback
    this.meter = new Tone.Meter();
    this.channel.connect(this.meter);
    
    // External audio setup
    this.mediaStream = null;
    this.mediaStreamSource = null;
    this.externalInput = null;
    
    if (!isExternalAudio && instrument !== 'external') {
      this.routeInstrument();
    }
  }
  
  rename(newName) {
    this.name = newName.trim() || `Track ${this.id}`;
    showToast(`âœï¸ Renamed to "${this.name}"`, 'info');
    renderMultitrack();
  }
  
  async setupExternalAudio() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000
        }
      });
      
      console.log(`ðŸŽ¤ Microphone access granted for track ${this.id}`);
      
      const audioContext = Tone.context.rawContext;
      this.mediaStreamSource = audioContext.createMediaStreamSource(this.mediaStream);
      
      this.externalInput = new Tone.Gain(1);
      this.mediaStreamSource.connect(this.externalInput.input);
      
      this.externalInput.connect(this.channel);
      this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      
      console.log(`âœ… External audio routed for track ${this.id}`);
      
    } catch (err) {
      console.error(`âŒ Failed to access microphone for track ${this.id}:`, err);
      showToast(`âŒ Microphone access denied: ${err.message}`, 'error');
    }
  }

  toggleInputMonitoring() {
    if (!this.mediaStreamSource) return showToast('âš ï¸ No input available', 'warning');

    if (!this.isExternalAudio || !this.externalInput) return;
    
    this.inputMonitoring = !this.inputMonitoring;
    this.externalInput.gain.rampTo(this.inputMonitoring ? 1 : 0, 0.05);
    
    console.log(`ðŸ”Š Input monitoring ${this.inputMonitoring ? 'ON' : 'OFF'} for ${this.name}`);
    renderMultitrack();
  }
  
  routeInstrument() {
    // Internal audio tracks no longer route from a fixed instrument.
    // They simply exist as live audio buses (Tone.Channel â†’ master).
    console.log(`ðŸŽšï¸ ${this.name} ready as internal track`);
  }

  
  addFx(type, params = {}) {
    let fx;
    params = { ...params };
  
    switch (type) {
      case 'reverb': {
        const decay = params.decay ?? 1.5;
        const wet = params.wet ?? 0.3;
        fx = new Tone.Reverb({ decay, wet });
        params.decay = decay;
        params.wet = wet;
        break;
      }
      case 'delay': {
        const time = params.time ?? '8n';
        const feedback = params.feedback ?? 0.3;
        const wet = params.wet ?? 0.3;
        fx = new Tone.FeedbackDelay({ delayTime: time, feedback, wet });
        params.time = time;
        params.feedback = feedback;
        params.wet = wet;
        break;
      }
      case 'chorus': {
        const frequency = params.frequency ?? 1.5;
        const delayTime = params.delayTime ?? 3.5;
        const depth = params.depth ?? 0.7;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Chorus({ frequency, delayTime, depth, wet }).start();
        params.frequency = frequency;
        params.delayTime = delayTime;
        params.depth = depth;
        params.wet = wet;
        break;
      }
      case 'distortion': {
        const amount = params.amount ?? 0.4;
        const wet = params.wet ?? 0.5;
        fx = new Tone.Distortion({ distortion: amount, wet });
        params.amount = amount;
        params.wet = wet;
        break;
      }
      case 'filter': {
        const typeOpt = params.type ?? 'lowpass';
        const frequency = params.frequency ?? 5000;
        const q = params.q ?? 1;
        fx = new Tone.Filter({ type: typeOpt, frequency, Q: q });
        params.type = typeOpt;
        params.frequency = frequency;
        params.q = q;
        break;
      }
      case 'compressor': {
        const threshold = params.threshold ?? -24;
        const ratio = params.ratio ?? 4;
        const attack = params.attack ?? 0.003;
        const release = params.release ?? 0.25;
        fx = new Tone.Compressor({ threshold, ratio, attack, release });
        params.threshold = threshold;
        params.ratio = ratio;
        params.attack = attack;
        params.release = release;
        break;
      }
      case 'eq': {
        const low = params.low ?? 0;
        const mid = params.mid ?? 0;
        const high = params.high ?? 0;
        fx = new Tone.EQ3({ low, mid, high });
        params.low = low;
        params.mid = mid;
        params.high = high;
        break;
      }
      case 'bitcrusher': {
        const bits = params.bits ?? 4;
        fx = new Tone.BitCrusher({ bits });
        params.bits = bits;
        break;
      }
      default:
        return null;
    }
  
    const fxObj = {
      id: Date.now() + Math.random(),
      type,
      node: fx,
      params,
      enabled: true
    };
  
    this.fxChain.push(fxObj);
    this.reconnectFxChain();
  
    return fxObj;
  }
  
  removeFx(fxId) {
    const index = this.fxChain.findIndex(fx => fx.id === fxId);
    if (index === -1) return;
    
    const fx = this.fxChain[index];
    fx.node.disconnect();
    fx.node.dispose();
    
    this.fxChain.splice(index, 1);
    this.reconnectFxChain();
  }
  
  reconnectFxChain() {
    const masterBus = window.master?.fxIn || Tone.Destination;
  
    // 1) Disconnect channel from previous routing
    try {
      this.channel.disconnect();
    } catch (err) {
      console.warn('Channel disconnect failed:', err);
    }
  
    // 2) Keep the meter tapped off the channel (pre-FX)
    if (this.meter) {
      try {
        this.channel.connect(this.meter);
      } catch (err) {
        console.warn('Meter reconnect failed:', err);
      }
    }
  
    // 3) Clear old FX connections
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.disconnect === 'function') {
        try { fx.node.disconnect(); } catch (err) {
          console.warn('FX disconnect failed:', err);
        }
      }
    });
  
    // 4) Only use enabled FX with actual nodes
    const activeFx = this.fxChain.filter(fx => fx.enabled && fx.node);
  
    // No FX? Channel goes straight to master
    if (activeFx.length === 0) {
      this.channel.connect(masterBus);
      return;
    }
  
    // 5) Rebuild: channel -> fx1 -> fx2 -> ... -> master
    let lastNode = this.channel;
    activeFx.forEach(fx => {
      if (!fx.node) return;
      lastNode.connect(fx.node);
      lastNode = fx.node;
    });
  
    lastNode.connect(masterBus);
  }

  updateFxParam(fxId, param, value) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    const node = fx.node;
    fx.params[param] = value;

    const fastRamp = 0.01; 

    try {
      // Generic Tone.Param
      if (node[param] && node[param].rampTo) {
        node[param].rampTo(value, fastRamp);
      }
      // Common FX types
      else if (param === 'wet' && node.wet) node.wet.rampTo(value, fastRamp);
      else if (param === 'decay' && node.decay !== undefined) node.decay = value;
      else if (param === 'time' && node.delayTime) node.delayTime.value = Tone.Time(value);
      else if (param === 'feedback' && node.feedback) node.feedback.rampTo(value, fastRamp);
      else if (param === 'frequency' && node.frequency) node.frequency.rampTo(value, fastRamp);
      else if (param === 'depth' && node.depth !== undefined) node.depth = value;
      else if (param === 'amount' && node.distortion !== undefined) node.distortion = value;
      else if (param === 'bits' && node.bits !== undefined) node.bits = Math.round(value);
      else if (param === 'threshold' && node.threshold) node.threshold.rampTo(value, fastRamp);
      else if (param === 'ratio' && node.ratio) node.ratio.rampTo(value, fastRamp);
      else if (param === 'attack' && node.attack) node.attack.rampTo(value, fastRamp);
      else if (param === 'release' && node.release) node.release.rampTo(value, fastRamp);
      else if (param === 'low' && node.low) node.low.rampTo(value, fastRamp);
      else if (param === 'mid' && node.mid) node.mid.rampTo(value, fastRamp);
      else if (param === 'high' && node.high) node.high.rampTo(value, fastRamp);
      else if (param === 'q' && node.Q) node.Q.rampTo(value, fastRamp);
      else if (param === 'type' && node.type !== undefined) node.type = value;
      else if (node.set) node.set({ [param]: value }); // Fallback for Tone.js node.set()

      console.log(`ðŸŽ›ï¸ Live FX: ${fx.type}.${param} â†’ ${value}`);
    } catch (err) {
      console.warn(`âš ï¸ FX param update failed: ${param}`, err);
    }
  }
  
  toggleFx(fxId) {
    const fx = this.fxChain.find(f => f.id === fxId);
    if (!fx) return;
    
    fx.enabled = !fx.enabled;
    this.reconnectFxChain();
  }
  
  async startRecording(options = {}) {
    if (this.recording) return;
  
    await Tone.start();
    if (Tone.context.state !== 'running') await Tone.context.resume();
  
    // keep timing logic
    const forcedStart = typeof options.forcedStartTime === 'number' ? options.forcedStartTime : null;
    if (this.recordStartTime == null)
      this.recordStartTime = forcedStart ?? Tone.now();
  
    // external input monitor stays unchanged
    if (this.isExternalAudio) {
      if (!this.mediaStreamSource) await this.setupExternalAudio();
      this.inputMonitoring = true;
      if (this.externalInput) this.externalInput.gain.value = 1;
    }
  
    // ðŸŽ¯ record the *master bus* instead of a per-track stem
    const ctx = Tone.getContext().rawContext;
    let stream;
  
    if (window.master?.mediaDest) {
      stream = master.mediaDest.stream;        // post-limiter master
      this.recordDest = null;
    } else {
      const dest = ctx.createMediaStreamDestination();
      this.recordDest = dest;
      (master?.limiter || master?.fxIn || Tone.getDestination()).connect(dest);
      stream = dest.stream;
    }
  
    this.recordedChunks = [];
    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus'
      : 'audio/webm';
  
    this.recorder = new MediaRecorder(stream, { mimeType });
    this.recorder.ondataavailable = e => e.data?.size && this.recordedChunks.push(e.data);
    this.recorder.onstop = () => this.finishRecording();
    this.recorder.start(100);
    this.recording = true;
  
    showToast(`ðŸŽ§ Recording live master output into ${this.name}`, 'success');
  }

  stopRecording() {
    if (this.recording && this.recorder) {
      this.recorder.stop();
      this.recording = false;
      if (this.isExternalAudio && this.externalInput) {
        // Keep live monitoring on stop for feedback continuity
        this.externalInput.gain.value = this.inputMonitoring ? 1 : 0;
      }
    }
  }
  
  async finishRecording() {
    if (this.recordedChunks.length === 0) {
      console.warn('âš ï¸ No audio data recorded');
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      showToast('âš ï¸ Recording was empty', 'warning'); 
      return;
    }
  
    const blob = new Blob(this.recordedChunks, {
      type: (this.recorder && this.recorder.mimeType) || 'audio/webm'
    });
  
    console.log(`ðŸ’¾ Processing ${blob.size} bytes`);
  
    if (blob.size < 1000) {
      console.error('âŒ Recording too small, likely corrupted');
      showToast('âŒ Recording failed - file too small', 'error');
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
      renderMultitrack();
      return;
    }
  
    try {
      const arrayBuffer = await blob.arrayBuffer();
      if (arrayBuffer.byteLength === 0) {
        throw new Error('ArrayBuffer is empty');
      }
  
      const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
      if (!audioBuffer || audioBuffer.length === 0 || audioBuffer.numberOfChannels === 0) {
        throw new Error('Decoded buffer is invalid');
      }
      
      // ðŸ”Š Auto-normalize recorded takes so bounced samples aren't super quiet
      (function normalizeBuffer(buf) {
        let peak = 0;
        const channels = buf.numberOfChannels;
      
        // Find peak
        for (let ch = 0; ch < channels; ch++) {
          const data = buf.getChannelData(ch);
          for (let i = 0; i < data.length; i++) {
            const v = Math.abs(data[i]);
            if (v > peak) peak = v;
          }
        }
      
        if (peak > 0) {
          // Target â‰ˆ -1 dBFS
          const targetLinear = Math.pow(10, -1 / 20); // ~0.891
          const gain = targetLinear / peak;
      
          for (let ch = 0; ch < channels; ch++) {
            const data = buf.getChannelData(ch);
            for (let i = 0; i < data.length; i++) {
              data[i] *= gain;
            }
          }
        }
      })(audioBuffer);
      
      const duration = audioBuffer.duration;

      // ðŸ”¥ Compute timeline start based on global record start
      let startTime = 0;
      if (multitrack.globalRecordStartTime != null && this.recordStartTime != null) {
        startTime = Math.max(
          0,
          this.recordStartTime - multitrack.globalRecordStartTime
        );
      }
  
      const take = {
        id: Date.now(),
        buffer: audioBuffer,
        blob,
        duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime,   // <-- used by preview & bounce for alignment
        recordedAt: Date.now()
      };
  
      this.takes.push(take);
      this.selectedTakeIndex = this.takes.length - 1;
  
      console.log(
        `âœ… Take ${this.takes.length} created: ${take.duration.toFixed(
          3
        )}s (start=${startTime.toFixed(3)}s)`
      );

      multitrackHistory.captureState();
      
      renderMultitrack();
      showToast(`âœ… Recorded ${take.duration.toFixed(1)}s take`, 'success');
    } catch (err) {
      console.error('âŒ Failed to decode audio:', err);
      showToast(`âŒ Recording failed: ${err.message}`, 'error');
    } finally {
      this.recordedChunks = [];
      this.recorder = null;
      this.recordStartTime = null;
    }
  }
  
  selectTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.selectedTakeIndex = index;
    renderMultitrack();
  }

  toggleTakeMute(index) {
    if (index < 0 || index >= this.takes.length) return;
    this.takes[index].muted = !this.takes[index].muted;
    renderMultitrack();
  }
  
  deleteTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    this.takes.splice(index, 1);
    
    if (this.selectedTakeIndex >= this.takes.length) {
      this.selectedTakeIndex = this.takes.length - 1;
    }
    
    renderMultitrack();
  }

  async playTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    if (take.muted) {
      showToast('âŒ Take is muted', 'warning');
      return;
    }
    
    if (this.currentPlayer) {
      try {
        if (this.currentPlayer.state === 'started') {
          this.currentPlayer.stop();
        }
        this.currentPlayer.dispose();
      } catch (err) {
        console.warn('Error stopping previous player:', err);
      }
    }
    
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`âŒ ${this.name}: Invalid or empty buffer`);
      showToast(`âŒ ${this.name}: Take corrupted, cannot play`, 'error');
      return;
    }
    
    try {
      this.currentPlayer = new Tone.Player({
        buffer: take.buffer,
        fadeOut: 0.01
      }).connect(this.channel);
      
      await new Promise((resolve, reject) => {
        let attempts = 0;
        const checkReady = setInterval(() => {
          attempts++;
          
          if (this.currentPlayer.loaded) {
            clearInterval(checkReady);
            resolve();
          } else if (attempts > 50) {
            clearInterval(checkReady);
            reject(new Error('Buffer load timeout'));
          }
        }, 100);
        
        this.currentPlayer.onsuccess = () => {
          clearInterval(checkReady);
          resolve();
        };
      });
      
      await Tone.start();
      
      this.currentPlayer.start();
      
      const takeRegions = document.querySelectorAll('.take-region');
      takeRegions.forEach((region, idx) => {
        if (idx === index) {
          region.style.borderColor = 'var(--warning)';
          region.style.boxShadow = '0 0 20px var(--warning)';
        }
      });
      
      showToast(`â–¶ï¸ Playing ${this.name} - Take ${index + 1}`, 'info');
      
      setTimeout(() => {
        if (this.currentPlayer) {
          try {
            if (this.currentPlayer.state === 'started') {
              this.currentPlayer.stop();
            }
            this.currentPlayer.dispose();
          } catch (err) {
            console.warn('Cleanup error:', err);
          }
          this.currentPlayer = null;
        }
        
        takeRegions.forEach(region => {
          region.style.borderColor = '';
          region.style.boxShadow = '';
        });
      }, take.duration * 1000 + 500);
      
    } catch (err) {
      console.error(`âŒ Failed to play ${this.name}:`, err);
      showToast(`âŒ Playback failed: ${err.message}`, 'error');
      
      if (this.currentPlayer) {
        this.currentPlayer.dispose();
        this.currentPlayer = null;
      }
    }
  }
  
  stopTake() {
    if (this.currentPlayer) {
      this.currentPlayer.stop();
      this.currentPlayer.dispose();
      this.currentPlayer = null;
    }
  }
  
  async exportTake(index) {
    if (index < 0 || index >= this.takes.length) return;
    
    const take = this.takes[index];
    const url = URL.createObjectURL(take.blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.name.replace(/\s+/g, '_')}_take${index + 1}_${Date.now()}.webm`;
    a.click();
    
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }
  
  dispose() {
    console.log('ðŸ—‘ï¸ Disposing track:', this.id);
    
    this.stopTake();
    
    if (this.recorder && this.recording) {
      this.stopRecording();
    }
    
    if (this.isExternalAudio) {
      if (this.mediaStreamSource) {
        this.mediaStreamSource.disconnect();
        this.mediaStreamSource = null;
      }
      
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }
      
      if (this.externalInput) {
        this.externalInput.disconnect();
        this.externalInput.dispose();
        this.externalInput = null;
      }
    } else {
      const instSynth = synths[this.instrument];
      if (instSynth && this.originalChannel) {
        if (typeof instSynth.disconnect === 'function') {
          instSynth.disconnect();
          instSynth.connect(this.originalChannel);
        } else if (instSynth.gain && typeof instSynth.gain.disconnect === 'function') {
          instSynth.gain.disconnect();
          instSynth.gain.connect(this.originalChannel);
        }
      }
    }
    
    this.fxChain.forEach(fx => {
      if (fx.node && typeof fx.node.dispose === 'function') {
        fx.node.disconnect();
        fx.node.dispose();
      }
    });
    
    if (this.meter && typeof this.meter.dispose === 'function') {
      this.meter.dispose();
    }
    
    if (this.channel && typeof this.channel.dispose === 'function') {
      this.channel.disconnect();
      this.channel.dispose();
    }
    
    console.log('âœ… Track disposed:', this.id);
  }
}

// ==================== EXTERNAL STEM IMPORT ====================

// 1) Decode an uploaded file into an AudioBuffer
async function decodeFileToBuffer(file) {
  const arrayBuffer = await file.arrayBuffer();

  const audioCtx =
    (Tone && Tone.context && Tone.context.rawContext) ||
    (Tone && Tone.getContext && Tone.getContext().rawContext) ||
    (Tone && Tone.context) ||
    null;

  if (!audioCtx || !audioCtx.decodeAudioData) {
    throw new Error('AudioContext not available for decoding');
  }

  return new Promise((resolve, reject) => {
    audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
  });
}

// 2) Create a new multitrack track from an AudioBuffer
function addExternalAudioTrackFromBuffer(audioBuffer, fileName = 'Imported Stem') {
  const id = multitrack.nextTrackId++;
  const niceName = fileName.replace(/\.[^/.]+$/, ''); // strip extension

  // Create track marked as external audio
  const track = new AudioTrack(id, niceName, 'stem', true);

  // Single take covering whole buffer
  const take = {
    id: `take-${Date.now()}-${id}`,
    buffer: audioBuffer,
    startTime: 0,                 // starts at 0 in the session
    duration: audioBuffer.duration,
    muted: false,
    source: 'external',
    fileName
  };

  track.takes.push(take);
  track.selectedTakeIndex = 0;

  // Minimal routing: gain â†’ master.fxIn
  // (Adjust if you already have a per-track channel system)
  const gain = new Tone.Gain(1);
  track.channel = gain;
  gain.connect(master.fxIn);

  multitrack.tracks.push(track);

  return track;
}

// 3) Wire up the "Import Stem" button
function setupStemImport() {
  const importBtn = document.getElementById('importStemBtn');
  if (!importBtn) {
    console.warn('âš ï¸ setupStemImport: #importStemBtn not found');
    return;
  }

  if (importBtn.dataset._wired) return; // avoid double binding
  importBtn.dataset._wired = 'true';

  importBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/webm';

    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      // Optional size guard
      if (file.size > 50 * 1024 * 1024) {
        showToast('âŒ File too large (max 50MB)', 'error');
        return;
      }

      try {
        showToast(`â³ Importing ${file.name}...`, 'info');
        const buffer = await decodeFileToBuffer(file);
        const track = addExternalAudioTrackFromBuffer(buffer, file.name);
        renderMultitrack(); // your existing UI refresh
        showToast(`âœ… Imported stem: ${track.name}`, 'success');
      } catch (err) {
        console.error('Stem import failed:', err);
        showToast(`âŒ Import failed: ${err.message}`, 'error');
      }
    };

    input.click();
  });
}
  
async function createTrack(instrument = null, isExternalAudio = false) {
  const isInternal = !isExternalAudio;
  const baseName = isExternalAudio
    ? `Mic/Ext ${multitrack.tracks.filter(t => t.isExternalAudio).length + 1}`
    : `Track ${multitrack.tracks.filter(t => !t.isExternalAudio).length + 1}`;

  const track = new AudioTrack(multitrack.nextTrackId++, baseName, instrument, isExternalAudio);

  if (isExternalAudio) {
    try {
      await track.setupExternalAudio();
    } catch (err) {
      console.error('âŒ External audio setup failed:', err);
      showToast(`âŒ Microphone access failed: ${err.message}`, 'error');
      return null;
    }
  }

  multitrack.tracks.push(track);
  multitrackHistory.captureState();
  renderMultitrack();
  showToast(`âœ… ${isExternalAudio ? 'External' : 'Internal'} track added`, 'success');
  return track;
}

function removeTrack(trackId) {
  const index = multitrack.tracks.findIndex(t => t.id === trackId);
  if (index === -1) return;
  
  const track = multitrack.tracks[index];
  track.dispose();
  multitrack.tracks.splice(index, 1);
  multitrackHistory.captureState();
  renderMultitrack();
}

function drawTakeWaveform(canvasEl, audioBuffer) {
  const ctx = canvasEl.getContext('2d');
  const width = canvasEl.width;
  const height = canvasEl.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = audioBuffer.getChannelData(0);
  const step = Math.ceil(data.length / width);
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  ctx.beginPath();
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const datum = data[(i * step) + j];
      if (datum < min) min = datum;
      if (datum > max) max = datum;
    }
    
    const x = i;
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(x, yMin, 1, yMax - yMin);
  }
}

function renderTakes(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  let html = '<div style="display: flex; flex-direction: column; gap: var(--space-2); padding: var(--space-2);">';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    html += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}" 
           data-track-id="${track.id}" data-take-index="${idx}"
           style="cursor: pointer; position: relative;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: var(--space-2);">
          <div style="flex: 1;">
            <div style="font-size: var(--text-xs); font-weight: 700;">
              Take ${idx + 1} ${isSelected ? 'â˜…' : ''}
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-tertiary);">
              ${take.duration.toFixed(1)}s
            </div>
          </div>
          <div style="display: flex; gap: var(--space-1);">
            <button class="region-action-btn" data-action="play-take" title="Play">â–¶ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-take" title="Mute/Unmute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" 
                    data-track-id="${track.id}" data-take-index="${idx}" title="Edit Waveform">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="delete-take" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  
  return html;
}
  
// Enhanced track strip rendering
function createTrackStrip(track, timelineWidth) {
  const strip = document.createElement('div');
  strip.className = 'track-strip';
  strip.dataset.trackId = track.id;
  if (track.recording) strip.classList.add('recording');
  if (track.armed) strip.classList.add('armed');
  if (track.isExternalAudio) strip.classList.add('external-audio');
  
  const instData = track.isExternalAudio ? 
    { icon: 'ðŸŽ¤', name: 'External' } : 
    instruments[track.instrument];
  
  const takesCount = track.takes.length;
  const duration = track.selectedTakeIndex >= 0 ? 
    track.takes[track.selectedTakeIndex].duration.toFixed(1) + 's' : 
    '0.0s';
  
  // Format pan display
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };
  
  strip.innerHTML = `
    <div class="track-header">
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || 'ðŸŽšï¸'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-action="rec">
          ${track.recording ? 'âºï¸' : 'âšª'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-action="arm">
          ${track.armed ? 'ðŸ”´' : 'âšª'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-action="monitor">
            ${track.inputMonitoring ? 'ðŸ”Š' : 'ðŸ”‡'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-action="fx">
          ðŸŽ›ï¸ FX
        </button>
        <button class="track-mini-btn" data-action="delete">
          ðŸ—‘ï¸
        </button>
      </div>

      <div class="track-fx-panel" style="display:none;">
        <div class="fx-chain-mini">
          <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
          <div class="fx-slots-inline"></div>
        </div>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" 
               class="track-volume-slider" data-param="volume" data-track-id="${track.id}">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" 
               class="track-pan-slider" data-param="pan" data-track-id="${track.id}">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    </div>
    
    <div class="track-canvas-area">
      <div class="track-canvas" style="width: ${timelineWidth}px; min-width: ${timelineWidth}px;">
        ${track.takes.length === 0 && !track.recording ? `
          <div class="track-empty-state">
            <div class="track-empty-state-icon">ðŸŽ™ï¸</div>
            <div>Arm and record to create takes</div>
          </div>
        ` : ''}
        ${track.recording ? `
          <div class="recording-indicator">
            <div class="recording-indicator-dot"></div>
            <span>Recording...</span>
          </div>
        ` : ''}
        ${renderTimelineRegions(track)}
      </div>
    </div>
  `;
  
  // Attach control listeners
  strip.querySelectorAll('.track-mini-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      handleTrackAction(track, action);
    });
  });
  
  // Volume slider
  const volumeSlider = strip.querySelector('.track-volume-slider');
  if (volumeSlider) {
    volumeSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      track.volume = value;
      
      if (track.channel && track.channel.volume) {
        track.channel.volume.rampTo(value, 0.05);
      }
      
      const label = strip.querySelector('.track-volume-value');
      if (label) label.textContent = value.toFixed(1) + 'dB';
    });
  }
  
  // Pan slider - FIXED
  const panSlider = strip.querySelector('.track-pan-slider');
  if (panSlider) {
    panSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      track.pan = value;
      
      if (track.channel && track.channel.pan) {
        track.channel.pan.rampTo(value / 100, 0.05);
      }
      
      const label = strip.querySelector('.track-pan-value');
      if (label) {
        label.textContent = formatPan(value);
      }
    });
  }
  
  setupRegionInteractions(strip, track);
  
  // Start meter animation
  if (track.meter) {
    const updateMeters = () => {
      const fills = strip.querySelectorAll(`[data-meter-track="${track.id}"]`);
      if (fills.length === 0 || !track.meter) return;
      
      const value = track.meter.getValue();
      const channels = Array.isArray(value) ? value : [value, value];
      
      fills.forEach((fill, idx) => {
        const db = channels[idx] || channels[0] || -60;
        const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
        fill.style.height = normalized + '%';
      });
      
      if (strip.isConnected) {
        requestAnimationFrame(updateMeters);
      }
    };
    
    requestAnimationFrame(updateMeters);
  }
  
  // Draw waveforms after DOM is ready
  requestAnimationFrame(() => {
    setTimeout(() => {
      track.takes.forEach((take, idx) => {
        const canvas = strip.querySelector(`canvas[data-take-id="${take.id}"]`);
        if (canvas && take.buffer) {
          if (canvas.width === 0 || canvas.height === 0) {
            canvas.width = Math.max(100, take.duration * (multitrack.zoom || 100));
            canvas.height = 20;
          }
          drawRegionWaveform(canvas, take.buffer);
        }
      });
    }, 100);
  });
  
  return strip;
}
  
function renderTimelineRegions(track) {
  if (!track.takes || track.takes.length === 0) return '';
  
  const zoom = multitrack.zoom || 100;
  let html = '';
  
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    const isMuted = take.muted;
    
    const startPos = (take.startTime || 0) * zoom;
    const width = take.duration * zoom;
    
    html += `
      <div class="audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}"
           data-track-id="${track.id}"
           data-take-index="${idx}"
           data-region-id="${take.id}"
           style="position: absolute; left: ${startPos}px; width: ${width}px; height: 80px; top: 0;">
        
        <div class="region-header">
          <div class="region-name">Take ${idx + 1}</div>
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">âœï¸</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">ðŸ—‘ï¸</button>
          </div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      </div>
    `;
  });
  
  return html;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 100);
  return `${mins}:${String(secs).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;
}

function setupRegionInteractions(stripEl, track) {
  // ðŸ’¡ Work with either the old .track-canvas or the lane itself
  const canvas = stripEl.querySelector('.track-canvas') || stripEl;
  if (!canvas) return;
  
  let dragState = null;
  let isTouchDevice = 'ontouchstart' in window;
  
  // === CRITICAL: Use event delegation for action buttons ===
  canvas.addEventListener('click', (e) => {
    const btn = e.target.closest('.region-action-btn');
    if (!btn) return;
    
    e.stopPropagation(); // CRITICAL: Prevent drag logic
    e.preventDefault();
    
    const region = btn.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const action = btn.dataset.action;
    
    handleRegionAction(trackId, takeIndex, action, e);
  }, { capture: true }); // Use capture phase

  const startDrag = (e) => {
    if (e.target.closest('.region-action-btn')) return; // Skip buttons
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    
    const region = document.elementFromPoint(clientX, clientY)?.closest('.audio-region');
    if (!region) return;
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    const handle = e.target.closest('.region-resize-handle')?.dataset.handle || null;
    
    const track = multitrack.tracks.find(t => t.id === trackId);
    if (!track) return;
    
    const take = track.takes[takeIndex];
    if (!take) return;
    
    const zoom = multitrack.zoom || 100;
    
    dragState = {
      mode: handle ? `resize-${handle}` : 'move',
      trackId,
      takeIndex,
      startX: clientX,
      originalStart: take.startTime || 0,
      originalDuration: take.duration,
      minStart: 0,
      maxEnd: multitrack.projectDuration || (state.duration * 60)
    };
    
    region.classList.add('dragging');
  };
  
  const moveDrag = (e) => {
    if (!dragState) return;
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const zoom = multitrack.zoom || 100;
    const deltaX = clientX - dragState.startX;
    const deltaSeconds = deltaX / zoom;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (!track) return;
    
    const take = track.takes[dragState.takeIndex];
    if (!take) return;
    
    if (dragState.mode === 'move') {
      let newStart = dragState.originalStart + deltaSeconds;
      newStart = Math.max(dragState.minStart, Math.min(newStart, dragState.maxEnd - take.duration));
  
      // ðŸ§² Apply snapping
      newStart = applySnap(newStart);
  
      take.startTime = newStart;
  
    } else if (dragState.mode === 'resize-left') {
      let newStart = dragState.originalStart + deltaSeconds;
      const maxStart = dragState.originalStart + dragState.originalDuration - 0.05;
      newStart = Math.max(dragState.minStart, Math.min(newStart, maxStart));
  
      // ðŸ§² Snap left edge if desired
      newStart = applySnap(newStart);
  
      const newDuration = (dragState.originalStart + dragState.originalDuration) - newStart;
      if (newDuration >= 0.05) {
        take.startTime = newStart;
        take.duration = newDuration;
      }
  
    } else if (dragState.mode === 'resize-right') {
      let newDuration = dragState.originalDuration + deltaSeconds;
      const maxDuration = dragState.maxEnd - dragState.originalStart;
      newDuration = Math.max(0.05, Math.min(newDuration, maxDuration));
  
      // ðŸ§² Snap right edge
      const endTime = dragState.originalStart + newDuration;
      const snappedEnd = applySnap(endTime);
      take.duration = Math.max(0.05, snappedEnd - dragState.originalStart);
    }
  
    renderMultitrack();
  };
  
  const endDrag = (e) => {
    if (!dragState) return;
    
    const track = multitrack.tracks.find(t => t.id === dragState.trackId);
    if (track) {
      const lane = document.querySelector(`.track-lane[data-track-id="${track.id}"]`);
      if (lane) {
        const regionEls = lane.querySelectorAll('.audio-region');
        regionEls.forEach(r => r.classList.remove('dragging'));
      }
    }
    
    multitrackHistory.captureState();
    dragState = null;
  };
  
  // Mouse + touch bindings
  if (isTouchDevice) {
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        startDrag(e);
      }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
      if (dragState) {
        e.preventDefault();
        moveDrag(e);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', endDrag, { passive: true });
    canvas.addEventListener('touchcancel', endDrag, { passive: true });
  } else {
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      startDrag(e);
    });
    
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
  }
}

  
function handleRegionAction(trackId, takeIndex, action, event) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take) {
    console.error('Take not found:', takeIndex);
    return;
  }
  
  console.log(`âœ… Handling action: ${action}`);
  
  if (action === 'split-region') {
    openSplitDialog(track, takeIndex, event);
  } else if (action === 'toggle-mute-region') {
    take.muted = !take.muted;
    renderMultitrack();
    showToast(take.muted ? 'ðŸ”‡ Region muted' : 'ðŸ”Š Region unmuted', 'info');
  } else if (action === 'edit-waveform') {
    openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete-region') {
    if (confirm('Delete this region?')) {
      track.takes.splice(takeIndex, 1);
      if (track.selectedTakeIndex >= track.takes.length) {
        track.selectedTakeIndex = track.takes.length - 1;
      }
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('ðŸ—‘ï¸ Region deleted', 'success');
    }
  } else {
    console.warn('Unknown action:', action);
  }
}

function openSplitDialog(track, takeIndex, event) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '600px';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Split Region</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="splitPreviewCanvas" width="500" height="150"
                style="width: 100%; height: 150px; background: var(--glass-bg); border-radius: var(--radius-md); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="param-control">
        <div class="param-label">
          <span>Split Point</span>
          <span class="param-value" id="splitPointValue">0.00s</span>
        </div>
        <input type="range" id="splitPointSlider" min="0" max="100" value="50" step="0.1">
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); margin-top: var(--space-3);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          ðŸ’¡ <strong>Tip:</strong> Click on the waveform to set split point
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-split-btn">Cancel</button>
      <button class="btn btn-primary confirm-split-btn">âœ‚ï¸ Split</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('splitPreviewCanvas');
  const slider = document.getElementById('splitPointSlider');
  const valueLabel = document.getElementById('splitPointValue');
  
  let splitPoint = 0.5; // 0-1 normalized
  
  function drawSplitPreview() {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!take.buffer) return;
    
    // Draw waveform
    const data = take.buffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    for (let i = 0; i < width; i++) {
      let min = 1.0, max = -1.0;
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < data.length) {
          const datum = data[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw split line
    const splitX = splitPoint * width;
    ctx.strokeStyle = 'var(--error)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(splitX, 0);
    ctx.lineTo(splitX, height);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Labels
    ctx.fillStyle = 'var(--text-primary)';
    ctx.font = '12px var(--font-mono)';
    ctx.fillText('A', 10, 20);
    ctx.fillText('B', width - 20, 20);
  }
  
  function updateSplitPoint(newPoint) {
    splitPoint = Math.max(0.01, Math.min(0.99, newPoint));
    slider.value = splitPoint * 100;
    const timeInSeconds = splitPoint * take.duration;
    valueLabel.textContent = timeInSeconds.toFixed(2) + 's';
    drawSplitPreview();
  }
  
  slider.addEventListener('input', (e) => {
    updateSplitPoint(parseFloat(e.target.value) / 100);
  });
  
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const normalizedX = x / rect.width;
    updateSplitPoint(normalizedX);
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-split-btn').onclick = close;
  
  modal.querySelector('.confirm-split-btn').onclick = async () => {
    try {
      showToast('â³ Splitting region...', 'info');
      
      const splitTime = splitPoint * take.duration;
      const buffer = take.buffer;
      
      // Create two new buffers
      const sampleRate = buffer.sampleRate;
      const splitSample = Math.floor(splitTime * sampleRate);
      
      const bufferA = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        splitSample,
        sampleRate
      );
      
      const bufferB = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length - splitSample,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const dataA = bufferA.getChannelData(c);
        const dataB = bufferB.getChannelData(c);
        
        for (let i = 0; i < splitSample; i++) {
          dataA[i] = original[i];
        }
        
        for (let i = splitSample; i < buffer.length; i++) {
          dataB[i - splitSample] = original[i];
        }
      }
      
      // Create blobs
      const wavA = bufferToWavImproved(bufferA);
      const wavB = bufferToWavImproved(bufferB);
      const blobA = new Blob([wavA], { type: 'audio/wav' });
      const blobB = new Blob([wavB], { type: 'audio/wav' });
      
      // Create new takes
      const takeA = {
        id: Date.now(),
        buffer: bufferA,
        blob: blobA,
        duration: bufferA.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: take.startTime || 0
      };
      
      const takeB = {
        id: Date.now() + 1,
        buffer: bufferB,
        blob: blobB,
        duration: bufferB.duration,
        timestamp: new Date().toISOString(),
        muted: false,
        startTime: (take.startTime || 0) + splitTime
      };
      
      // Replace original take with split takes
      track.takes.splice(takeIndex, 1, takeA, takeB);
      
      if (track.selectedTakeIndex === takeIndex) {
        track.selectedTakeIndex = takeIndex; // Select first part
      } else if (track.selectedTakeIndex > takeIndex) {
        track.selectedTakeIndex++; // Adjust index
      }

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast('âœ… Region split successfully!', 'success');
      
    } catch (err) {
      console.error('Split failed:', err);
      showToast(`âŒ Split failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  updateSplitPoint(0.5);
  drawSplitPreview();
}

function drawRegionWaveform(canvas, buffer) {
  if (!canvas || !buffer) return;
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = buffer.getChannelData(0);
  const step = Math.max(1, Math.ceil(data.length / width));
  const amp = height / 2;
  
  ctx.fillStyle = 'rgba(124, 131, 255, 0.5)';
  ctx.strokeStyle = 'rgb(124, 131, 255)';
  ctx.lineWidth = 1;
  
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const index = (i * step) + j;
      if (index < data.length) {
        const sample = data[index];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
      }
    }
    
    const yMin = (1 + min) * amp;
    const yMax = (1 + max) * amp;
    
    ctx.fillRect(i, yMin, 1, Math.max(1, yMax - yMin));
  }
}

function setupRegionContextMenu() {
  let contextMenu = null;
  let contextTarget = null;
  
  document.addEventListener('contextmenu', (e) => {
    const region = e.target.closest('.audio-region');
    if (!region) return;
    
    e.preventDefault();
    
    if (contextMenu) contextMenu.remove();
    
    const trackId = parseInt(region.dataset.trackId);
    const takeIndex = parseInt(region.dataset.takeIndex);
    
    contextTarget = { trackId, takeIndex };
    
    contextMenu = document.createElement('div');
    contextMenu.className = 'region-context-menu';
    
    contextMenu.innerHTML = `
      <div class="region-context-item" data-action="split">âœ‚ï¸ Split at Playhead</div>
      <div class="region-context-item" data-action="duplicate">ðŸ“‹ Duplicate</div>
      <div class="region-context-item" data-action="reverse">â†©ï¸ Reverse</div>
      <div class="region-context-item" data-action="normalize">ðŸ“Š Normalize</div>
      <div class="region-context-item" data-action="fade-in">ðŸ“ˆ Fade In</div>
      <div class="region-context-item" data-action="fade-out">ðŸ“‰ Fade Out</div>
      <div class="region-context-item" data-action="export">ðŸ’¾ Export Region</div>
      <div style="height: 1px; background: var(--glass-border); margin: var(--space-2) 0;"></div>
      <div class="region-context-item danger" data-action="delete">ðŸ—‘ï¸ Delete</div>
    `;
    
    document.body.appendChild(contextMenu);
    
    // FIXED: Better positioning that accounts for scroll
    requestAnimationFrame(() => {
      const menuRect = contextMenu.getBoundingClientRect();
      const menuWidth = menuRect.width;
      const menuHeight = menuRect.height;
      
      // Start with click position
      let x = e.clientX;
      let y = e.clientY;
      
      // Right edge
      if (x + menuWidth > window.innerWidth) {
        x = window.innerWidth - menuWidth - 10;
      }
      // Bottom edge
      if (y + menuHeight > window.innerHeight) {
        y = window.innerHeight - menuHeight - 10;
      }
      // Left edge
      if (x < 10) x = 10;
      // Top edge
      if (y < 10) y = 10;
      
      contextMenu.style.position = 'fixed';
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.style.zIndex = '10000';
    });
    
    // Handle menu clicks
    contextMenu.addEventListener('click', async (e2) => {
      const item = e2.target.closest('.region-context-item');
      if (!item || !contextTarget) return;
      
      const action = item.dataset.action;
      const track = multitrack.tracks.find(t => t.id === contextTarget.trackId);
      if (!track) return;
      
      const take = track.takes[contextTarget.takeIndex];
      if (!take) return;
      
      contextMenu.remove();
      contextMenu = null;
      
      await handleContextAction(track, contextTarget.takeIndex, action);
    });

    // Close on click outside
    const closeHandler = (e3) => {
      if (contextMenu && !contextMenu.contains(e3.target)) {
        contextMenu.remove();
        contextMenu = null;
        document.removeEventListener('click', closeHandler);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeHandler);
    }, 0);
  }); // ðŸ”š close contextmenu listener


  // === LONG-PRESS SUPPORT (mobile / touch) ===
  let longPressTimer = null;
  let touchStartX = 0;
  let touchStartY = 0;
  const LONG_PRESS_MS = 550;
  const MOVE_TOLERANCE = 10; // px

  // Start tracking on touchstart
  document.addEventListener(
    'touchstart',
    (e) => {
      const region = e.target.closest('.audio-region');
      if (!region) return;

      if (e.touches.length !== 1) return; // ignore multi-touch

      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(() => {
        const fakeEvent = new MouseEvent('contextmenu', {
          bubbles: true,
          cancelable: true,
          clientX: touchStartX,
          clientY: touchStartY,
        });
        region.dispatchEvent(fakeEvent);
      }, LONG_PRESS_MS);
    },
    { passive: true }
  );

  // Cancel if the finger moves too far
  document.addEventListener(
    'touchmove',
    (e) => {
      if (!longPressTimer) return;

      const touch = e.touches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > MOVE_TOLERANCE) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    },
    { passive: true }
  );

  // Cancel on touchend / cancel
  const cancelLongPress = () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  };

  document.addEventListener('touchend', cancelLongPress, { passive: true });
  document.addEventListener('touchcancel', cancelLongPress, { passive: true });
}

async function handleContextAction(track, takeIndex, action) {
  const take = track.takes[takeIndex];
  
  switch(action) {
    case 'split':
      // Split at current playhead position
      const currentTime = Tone.Transport.seconds;
      const relativeTime = currentTime - (take.startTime || 0);
      
      if (relativeTime > 0 && relativeTime < take.duration) {
        const splitPoint = relativeTime / take.duration;
        openSplitDialog(track, takeIndex, { splitPoint });
      } else {
        showToast('âš ï¸ Playhead not within region', 'warning');
      }
      break;
      
    case 'duplicate':
      const duplicate = {
        ...take,
        id: Date.now(),
        startTime: (take.startTime || 0) + take.duration + 0.1
      };
      track.takes.splice(takeIndex + 1, 0, duplicate);
      multitrackHistory.captureState();
      renderMultitrack();
      showToast('âœ… Region duplicated', 'success');
      break;
      
    case 'reverse':
      await reverseRegion(track, takeIndex);
      break;
      
    case 'normalize':
      await normalizeRegion(track, takeIndex);
      break;
      
    case 'fade-in':
      openFadeDialog(track, takeIndex, 'in');
      break;
      
    case 'fade-out':
      openFadeDialog(track, takeIndex, 'out');
      break;
      
    case 'export':
      track.exportTake(takeIndex);
      break;
      
    case 'delete':
      if (confirm('Delete this region?')) {
        track.deleteTake(takeIndex);
        renderMultitrack();
        showToast('ðŸ—‘ï¸ Region deleted', 'success');
      }
      break;
  }
}

async function reverseRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('â³ Reversing region...', 'info');
  
  try {
    const buffer = take.buffer;
    const reversed = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const reversedData = reversed.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        reversedData[i] = original[buffer.length - 1 - i];
      }
    }
    
    const wavData = bufferToWavImproved(reversed);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = reversed;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast('âœ… Region reversed', 'success');
    
  } catch (err) {
    console.error('Reverse failed:', err);
    showToast(`âŒ Reverse failed: ${err.message}`, 'error');
  }
}

async function normalizeRegion(track, takeIndex) {
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) return;
  
  showToast('â³ Normalizing region...', 'info');
  
  try {
    const buffer = take.buffer;
    
    // Find peak
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('âš ï¸ Region is silent', 'warning');
      return;
    }
    
    const normalized = Tone.context.rawContext.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );
    
    const targetPeak = 0.891; // -1dB
    const gain = targetPeak / peak;
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const original = buffer.getChannelData(c);
      const normalizedData = normalized.getChannelData(c);
      
      for (let i = 0; i < buffer.length; i++) {
        normalizedData[i] = original[i] * gain;
      }
    }
    
    const wavData = bufferToWavImproved(normalized);
    const blob = new Blob([wavData], { type: 'audio/wav' });
    
    take.buffer = normalized;
    take.blob = blob;

    multitrackHistory.captureState();
    renderMultitrack();
    showToast(`âœ… Normalized (+${(20 * Math.log10(gain)).toFixed(1)}dB)`, 'success');
    
  } catch (err) {
    console.error('Normalize failed:', err);
    showToast(`âŒ Normalize failed: ${err.message}`, 'error');
  }
}

function openFadeDialog(track, takeIndex, type) {
  const take = track.takes[takeIndex];
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10001';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  const fadeType = type === 'in' ? 'Fade In' : 'Fade Out';
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">ðŸ“ˆ ${fadeType}</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body">
      <div class="param-control">
        <div class="param-label">
          <span>Duration</span>
          <span class="param-value" id="fadeDurationValue">100ms</span>
        </div>
        <input type="range" id="fadeDurationSlider" min="10" max="5000" value="100" step="10">
      </div>
      
      <div class="param-control" style="margin-top: var(--space-4);">
        <div class="param-label">
          <span>Curve Type</span>
        </div>
        <select id="fadeCurveSelect" style="width: 100%;">
          <option value="linear">Linear</option>
          <option value="exponential">Exponential</option>
          <option value="logarithmic">Logarithmic</option>
          <option value="sCurve">S-Curve</option>
        </select>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-fade-btn">Cancel</button>
      <button class="btn btn-primary apply-fade-btn">Apply ${fadeType}</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const slider = document.getElementById('fadeDurationSlider');
  const valueLabel = document.getElementById('fadeDurationValue');
  const curveSelect = document.getElementById('fadeCurveSelect');
  
  slider.addEventListener('input', (e) => {
    const ms = parseInt(e.target.value);
    valueLabel.textContent = ms + 'ms';
  });
  
  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-fade-btn').onclick = close;
  
  modal.querySelector('.apply-fade-btn').onclick = async () => {
    try {
      const duration = parseInt(slider.value) / 1000; // Convert to seconds
      const curve = curveSelect.value;
      
      showToast(`â³ Applying ${fadeType.toLowerCase()}...`, 'info');
      
      const buffer = take.buffer;
      const sampleRate = buffer.sampleRate;
      const fadeSamples = Math.floor(duration * sampleRate);
      
      const processed = Tone.context.rawContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length,
        sampleRate
      );
      
      for (let c = 0; c < buffer.numberOfChannels; c++) {
        const original = buffer.getChannelData(c);
        const processedData = processed.getChannelData(c);
        
        for (let i = 0; i < buffer.length; i++) {
          let gain = 1.0;
          
          if (type === 'in' && i < fadeSamples) {
            const progress = i / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          } else if (type === 'out' && i >= buffer.length - fadeSamples) {
            const progress = (buffer.length - i) / fadeSamples;
            gain = applyFadeCurve(progress, curve);
          }
          
          processedData[i] = original[i] * gain;
        }
      }
      
      const wavData = bufferToWavImproved(processed);
      const blob = new Blob([wavData], { type: 'audio/wav' });
      
      take.buffer = processed;
      take.blob = blob;

      multitrackHistory.captureState();
      close();
      renderMultitrack();
      showToast(`âœ… ${fadeType} applied`, 'success');
      
    } catch (err) {
      console.error('Fade failed:', err);
      showToast(`âŒ Fade failed: ${err.message}`, 'error');
    }
  };
  
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

function applyFadeCurve(progress, curve) {
  switch(curve) {
    case 'exponential':
      return Math.pow(progress, 2);
    case 'logarithmic':
      return Math.sqrt(progress);
    case 'sCurve':
      return 0.5 - 0.5 * Math.cos(progress * Math.PI);
    default: // linear
      return progress;
  }
}

function setupTimelineCursor() {
  const wrapper = document.getElementById('dawArrangementScroll');
  const ruler   = document.getElementById('dawRuler');
  if (!wrapper || !ruler) return;

  ruler.addEventListener('click', (e) => {
    const zoom = multitrack.zoom || 100;

    const rect   = ruler.getBoundingClientRect();
    const clickX = e.clientX - rect.left;

    // account for horizontal scroll
    const timelineX = clickX + wrapper.scrollLeft;

    const projectDurationSeconds =
      multitrack.projectDuration || (state.duration * 60);

    let seconds = timelineX / zoom;
    if (!Number.isFinite(seconds)) seconds = 0;

    // clamp inside project range
    seconds = Math.max(0, Math.min(seconds, projectDurationSeconds));

    state.cursorSeconds = seconds;
    multitrack.playheadSeconds = seconds;

    // this already moves the playhead & updates timestamp
    updatePlayheadAndScroll(seconds);

    console.log('ðŸ•’ Cursor set to', seconds.toFixed(3), 's');
  });
}

  
function updateTimelineRuler() {
  const ruler   = document.getElementById('dawRuler');
  const markers = document.getElementById('dawRulerMarkers');
  if (!markers || !ruler) return;

  markers.innerHTML = '';

  const zoom = multitrack.zoom || 100;
  const durationMinutes = typeof state.duration === 'number' && state.duration > 0
    ? state.duration
    : 1;

  const projectDurationSeconds = durationMinutes * 60;
  const totalWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth   = totalWidth;
  document.documentElement.style.setProperty('--timeline-width', totalWidth + 'px');

  ruler.style.width    = totalWidth + 'px';
  ruler.style.minWidth = totalWidth + 'px';

  markers.style.width    = totalWidth + 'px';
  markers.style.minWidth = totalWidth + 'px';

  let interval = 1;
  if (zoom < 25) interval = 10;
  else if (zoom < 50) interval = 5;
  else if (zoom > 200) interval = 0.5;

  for (let t = 0; t <= projectDurationSeconds; t += interval) {
    const x = t * zoom;
    const isMajor = t % (interval * 4) === 0;

    const marker = document.createElement('div');
    marker.className = 'daw-ruler-marker' + (isMajor ? ' bar' : '');
    marker.style.left = x + 'px';

    if (isMajor) {
      const label = document.createElement('div');
      label.className = 'daw-ruler-label';
      const full = formatTime(t);
      label.textContent = full.split('.')[0]; // drop fractional seconds
      marker.appendChild(label);
    }

    markers.appendChild(marker);
  }
}
  
// Enhanced track action handler
async function handleTrackAction(track, action) {
  if (action === 'arm') {
    track.armed = !track.armed;
    renderMultitrack();
  } else if (action === 'monitor') {
    if (track.isExternalAudio) {
      track.toggleInputMonitoring();
    }
  } else if (action === 'rec') {
    await toggleRecordTrack(track.id);
  } else if (action === 'mute') {
    track.muted = !track.muted;
    track.channel.mute = track.muted;
    renderMultitrack();
  } else if (action === 'solo') {
    track.soloed = !track.soloed;
    
    const anySolo = multitrack.tracks.some(t => t.soloed);
    multitrack.tracks.forEach(t => {
      t.channel.mute = anySolo && !t.soloed;
    });
    
    renderMultitrack();
  } else if (action === 'fx') {
    openFxChainEditor(track.id);
  } else if (action === 'rename') {
    const newName = prompt('Rename track:', track.name);
    if (newName !== null) track.rename(newName);
  } else if (action === 'edit') {
    openTakeEditor(track.id);
  } else if (action === 'edit-waveform') {
  e.stopPropagation();
  openWaveformEditor(trackId, takeIndex);
  } else if (action === 'delete') {
    if (confirm(`Delete track "${track.name}"?`)) {
      removeTrack(track.id);
    }
  }
}

// === Mobile keyboard fix for inspector inputs ===
(function setupInspectorKeyboardFix() {
  const inspector = document.querySelector('.daw-inspector');
  if (!inspector) return;

  const focusSelector = 'input[type="text"], input[type="number"], input[type="email"], textarea, select';

  // When any editable control inside the inspector gets focus,
  // put the inspector into "keyboard-safe" mode.
  inspector.addEventListener('focusin', (e) => {
    if (!e.target.matches(focusSelector)) return;

    inspector.classList.add('inspector-keyboard-open');

    // Make sure the field is visible once the keyboard comes up
    setTimeout(() => {
      try {
        e.target.scrollIntoView({ block: 'center', behavior: 'smooth' });
      } catch (_) {
        // scrollIntoView may not exist in some environments; ignore
      }
    }, 50);
  });

  // When focus leaves all fields in the inspector, restore bottom-sheet behavior.
  inspector.addEventListener('focusout', () => {
    setTimeout(() => {
      const active = document.activeElement;
      if (!inspector.contains(active)) {
        inspector.classList.remove('inspector-keyboard-open');
      }
    }, 100);
  });
})();


// ============================================================================
// MULTITRACK INSPECTOR â€” TRACK-FOCUSED DETAIL PANEL
// ============================================================================

// Keep track of what the inspector is currently showing
let inspectorSelection = {
  type: 'none',     // 'none' | 'track'
  trackId: null,
  takeIndex: null
};

const inspectorPlaceholderHTML = `
  <div class="inspector-placeholder">
    <div style="text-align:center; padding: var(--space-8); color: var(--text-tertiary);">
      <div style="font-size: var(--text-3xl); margin-bottom: var(--space-3);">ðŸŽšï¸</div>
      <div>Select a track or region</div>
      <div style="font-size: var(--text-sm); margin-top: var(--space-2);">
        Tap a track name on the left to open its details here.
      </div>
    </div>
  </div>
`;

function getInspectorEls() {
  return {
    root: document.querySelector('.daw-inspector'),
    titleEl: document.getElementById('inspectorTitle'),
    contentEl: document.getElementById('inspectorContent')
  };
}

function resetInspector() {
  const { root, titleEl, contentEl } = getInspectorEls();
  if (!root || !titleEl || !contentEl) return;
  inspectorSelection = { type: 'none', trackId: null, takeIndex: null };
  titleEl.textContent = 'ðŸŽ›ï¸ Inspector';
  contentEl.innerHTML = inspectorPlaceholderHTML;

  // Remove header highlight
  document.querySelectorAll('#dawTrackList .track-header').forEach(el => {
    el.classList.remove('selected');
  });
}

// Open the inspector focused on a given track
function openTrackInspector(trackId) {
  const { root, titleEl, contentEl } = getInspectorEls();
  if (!root || !titleEl || !contentEl) return;

  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;

  inspectorSelection = { type: 'track', trackId, takeIndex: null };
  multitrack.selectedTrackId = trackId;

  // Highlight the selected header
  document.querySelectorAll('#dawTrackList .track-header').forEach(el => {
    const id = parseInt(el.dataset.trackId || '0', 10);
    el.classList.toggle('selected', id === trackId);
  });

  titleEl.textContent = `Track ${track.id} â€¢ ${track.name}`;

  const formatPanLabel = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };

  const numRegions = (track.takes || []).length;

  contentEl.innerHTML = `
    <div class="inspector-section">
      <div class="inspector-section-title">Overview</div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Name</span>
        </div>
        <input type="text"
               data-inspector-field="name"
               value="${track.name}"
               style="width:100%;">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Source</span>
        </div>
        <div class="inspector-param-value">
          ${track.isExternalAudio ? 'External / Mic' : (track.instrument || 'Internal')}
        </div>
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Regions on track</span>
        </div>
        <div class="inspector-param-value">
          ${numRegions}
        </div>
      </div>
    </div>

    <div class="inspector-section">
      <div class="inspector-section-title">Mix</div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Volume</span>
          <span class="inspector-param-value" data-inspector-value="volume">
            ${track.volume.toFixed(1)} dB
          </span>
        </div>
        <input type="range"
               min="-40" max="10" step="0.1"
               value="${track.volume}"
               data-inspector-control="volume">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>Pan</span>
          <span class="inspector-param-value" data-inspector-value="pan">
            ${formatPanLabel(track.pan)}
          </span>
        </div>
        <input type="range"
               min="-100" max="100" step="1"
               value="${track.pan}"
               data-inspector-control="pan">
      </div>

      <div class="inspector-param">
        <div class="inspector-param-label">
          <span>States</span>
        </div>
        <div class="inspector-toggle-row">
          <button class="btn btn-xs" data-inspector-toggle="mute"></button>
          <button class="btn btn-xs" data-inspector-toggle="solo"></button>
          <button class="btn btn-xs" data-inspector-toggle="monitor"></button>
        </div>
      </div>
    </div>
  `;

  // --- Wire controls ---

  // Rename
  const nameInput = contentEl.querySelector('[data-inspector-field="name"]');
  if (nameInput) {
    nameInput.addEventListener('change', () => {
      const newName = nameInput.value.trim();
      if (!newName || newName === track.name) return;
      if (typeof track.rename === 'function') {
        track.rename(newName);
      } else {
        track.name = newName;
      }
      // Also update header text
      const headerName = document.querySelector(
        `#dawTrackList .track-header[data-track-id="${track.id}"] .track-name`
      );
      if (headerName) headerName.textContent = newName;
      titleEl.textContent = `Track ${track.id} â€¢ ${newName}`;
    });
  }

  // Volume
  const volSlider = contentEl.querySelector('[data-inspector-control="volume"]');
  const volLabel  = contentEl.querySelector('[data-inspector-value="volume"]');
  if (volSlider) {
    volSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      track.volume = value;
      if (track.channel && track.channel.volume) {
        track.channel.volume.rampTo(value, 0.05);
      }
      if (volLabel) volLabel.textContent = value.toFixed(1) + ' dB';

      // Keep header slider & label in sync
      const headerSlider = document.querySelector(
        `.track-header .track-volume-slider[data-track-id="${track.id}"]`
      );
      if (headerSlider) {
        headerSlider.value = value;
        const label = headerSlider.closest('.track-volume-control')?.querySelector('.track-volume-value');
        if (label) label.textContent = value.toFixed(1) + 'dB';
      }
    });
  }

  // Pan
  const panSlider = contentEl.querySelector('[data-inspector-control="pan"]');
  const panLabel  = contentEl.querySelector('[data-inspector-value="pan"]');
  if (panSlider) {
    panSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value, 10);
      track.pan = value;
      if (track.channel && track.channel.pan) {
        track.channel.pan.rampTo(value / 100, 0.05);
      }
      if (panLabel) panLabel.textContent = formatPanLabel(value);

      const headerSlider = document.querySelector(
        `.track-header .track-pan-slider[data-track-id="${track.id}"]`
      );
      if (headerSlider) {
        headerSlider.value = value;
        const label = headerSlider.closest('.track-volume-control')?.querySelector('.track-pan-value');
        if (label) label.textContent = formatPanLabel(value);
      }
    });
  }

  // State toggles
  const muteBtn = contentEl.querySelector('[data-inspector-toggle="mute"]');
  const soloBtn = contentEl.querySelector('[data-inspector-toggle="solo"]');
  const monBtn  = contentEl.querySelector('[data-inspector-toggle="monitor"]');

  if (muteBtn) {
    const syncMuteBtn = () => {
      muteBtn.textContent = track.muted ? 'Muted' : 'Mute';
      muteBtn.classList.toggle('btn-primary', track.muted);
      muteBtn.classList.toggle('btn-secondary', !track.muted);
    };
    syncMuteBtn();
    muteBtn.addEventListener('click', async () => {
      await handleTrackAction(track, 'mute');
      openTrackInspector(track.id);
    });
  }

  if (soloBtn) {
    const syncSoloBtn = () => {
      soloBtn.textContent = track.soloed ? 'Soloed' : 'Solo';
      soloBtn.classList.toggle('btn-primary', track.soloed);
      soloBtn.classList.toggle('btn-secondary', !track.soloed);
    };
    syncSoloBtn();
    soloBtn.addEventListener('click', async () => {
      await handleTrackAction(track, 'solo');
      openTrackInspector(track.id);
    });
  }

  if (monBtn) {
    if (!track.isExternalAudio) {
      monBtn.style.display = 'none';
    } else {
      const syncMonBtn = () => {
        monBtn.textContent = track.inputMonitoring ? 'Monitor On' : 'Monitor Off';
        monBtn.classList.toggle('btn-primary', track.inputMonitoring);
        monBtn.classList.toggle('btn-secondary', !track.inputMonitoring);
      };
      syncMonBtn();
      monBtn.addEventListener('click', async () => {
        await handleTrackAction(track, 'monitor');
        openTrackInspector(track.id);
      });
    }
  }

  // On mobile, slide the inspector up into view
  if (window.innerWidth <= 768 && root) {
    root.classList.add('inspector-open');
  }
}

// Re-apply inspector selection after a re-render (mute/solo, undo, etc.)
function refreshInspectorSelection() {
  if (inspectorSelection.type === 'track' && inspectorSelection.trackId != null) {
    openTrackInspector(inspectorSelection.trackId);
  } else if (inspectorSelection.type === 'none') {
    resetInspector();
  }
}

// Wire close button + initial placeholder
function setupInspectorUI() {
  const { root } = getInspectorEls();
  if (!root) return;

  // Initial state
  resetInspector();

  const closeBtn = document.getElementById('closeInspectorBtn');
  if (closeBtn && !closeBtn.dataset._wired) {
    closeBtn.dataset._wired = 'true';
    closeBtn.addEventListener('click', () => {
      if (window.innerWidth <= 768) {
        root.classList.remove('inspector-open'); // close bottom sheet
      } else {
        resetInspector(); // desktop: keep panel but clear selection
      }
    });
  }
}

// Run once DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  try {
    setupInspectorUI();
  } catch (err) {
    console.warn('Inspector setup failed:', err);
  }
});

function showAddTrackDialog() {
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());

  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';

  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âž• Add Track</div>
      <button class="modal-close">âœ•</button>
    </div>

    <div class="modal-body">
      <div style="display:grid; gap:var(--space-4);">

        <!-- ðŸ·ï¸ Track Name -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Name
          </label>
          <input type="text" class="track-name-input"
                 placeholder="e.g., Vocals, Guitar, Drums..."
                 style="width:100%; padding:var(--space-3); font-size:var(--text-base);
                        border-radius:var(--radius-sm); border:1px solid var(--glass-border);
                        background:var(--glass-bg); color:var(--text-primary);">
        </div>

        <!-- ðŸŽšï¸ Track Type -->
        <div class="param-control">
          <label style="font-weight:700; color:var(--text-primary); margin-bottom:var(--space-2); display:block;">
            Track Type
          </label>
          <select class="track-type-select" style="font-size:var(--text-base); padding:var(--space-3); width:100%;">
            <option value="internal">ðŸŽ§ Internal Audio Track</option>
            <option value="external">ðŸŽ¤ External Audio (Mic / Line In)</option>
          </select>
        </div>

        <!-- ðŸŽ¤ External Info -->
        <div class="external-info" style="display:none; padding:var(--space-4);
             background:var(--glass-bg); border-radius:var(--radius-md);
             border:1px solid var(--glass-border);">
          <div style="font-weight:700; margin-bottom:var(--space-2); color:var(--text-primary);">
            ðŸŽ¤ External Audio Input
          </div>
          <div style="font-size:var(--text-sm); color:var(--text-secondary); line-height:1.6;">
            <p style="margin-bottom:var(--space-2);">
              This will create a track that records from your microphone or audio interface.
            </p>
            <ul style="margin-left:var(--space-5); margin-bottom:var(--space-2);">
              <li>Real-time monitoring with effects</li>
              <li>Record vocals, guitar, or any external source</li>
              <li>Syncs perfectly with other tracks</li>
            </ul>
            <p style="font-size:var(--text-xs); color:var(--text-tertiary);">
              âš ï¸ Your browser will request microphone access
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-secondary cancel-btn">Cancel</button>
      <button class="btn btn-primary confirm-btn">Add Track</button>
    </div>
  `;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const close = () => backdrop.remove();
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-btn').onclick = close;

  const nameInput = modal.querySelector('.track-name-input');
  const trackTypeSelect = modal.querySelector('.track-type-select');
  const externalInfo = modal.querySelector('.external-info');
  const confirmBtn = modal.querySelector('.confirm-btn');

  // Toggle external info panel
  trackTypeSelect.onchange = () => {
    const isExternal = trackTypeSelect.value === 'external';
    externalInfo.style.display = isExternal ? 'block' : 'none';
  };

  confirmBtn.onclick = async () => {
    const isExternal = trackTypeSelect.value === 'external';
    const userName = nameInput.value.trim();

    // ðŸ§  Smart default naming logic
    const countInternal = multitrack.tracks.filter(t => !t.isExternalAudio).length + 1;
    const countExternal = multitrack.tracks.filter(t => t.isExternalAudio).length + 1;
    const defaultName = isExternal ? `Mic ${countExternal}` : `Track ${countInternal}`;
    const name = userName || defaultName;

    confirmBtn.disabled = true;
    confirmBtn.textContent = isExternal ? 'Requesting access...' : 'Adding...';

    try {
      const track = await createTrack(null, isExternal);
      if (track) {
        track.rename(name);
        renderMultitrack();
        showToast(`âœ… ${isExternal ? 'External' : 'Internal'} track "${track.name}" added!`, 'success');
        close();
      } else {
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Add Track';
      }
    } catch (err) {
      console.error('âŒ Failed to add track:', err);
      showToast(`âŒ Failed to add track: ${err.message}`, 'error');
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Add Track';
    }
  };

  backdrop.onclick = e => { if (e.target === backdrop) close(); };
}

// === PLAYHEAD FOLLOW + TIME DISPLAY ===

let playheadFollowActive = true;
let playheadUpdateInterval = null;

// Call this once after your DAW tab is ready
function initPlayheadFollow() {
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const playheadEl = document.getElementById('dawPlayhead');

  if (!playheadEl || !arrangementScroll) return;

  clearInterval(playheadUpdateInterval);

  playheadUpdateInterval = setInterval(() => {
    if (!multitrack.isPlaying) return;

    const ctx = Tone?.Transport || null;
    let seconds = multitrack.playheadSeconds || 0;

    // ðŸŽ› For recording: follow the Transport clock if it's actually running
    if (ctx && ctx.state === 'started') {
      seconds = ctx.seconds;
    }

    updatePlayheadAndScroll(seconds);
  }, 50); // ~20fps is plenty
}


function formatTimecode(sec) {
  const ms = Math.floor((sec % 1) * 1000);
  const s = Math.floor(sec) % 60;
  const m = Math.floor(sec / 60) % 60;
  const h = Math.floor(sec / 3600);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
}

function formatBars(sec) {
  const bpm = parseFloat(document.getElementById('dawBpmInput')?.value) || 120;
  const beatDur = 60 / bpm;
  const beats = sec / beatDur;
  const bar = Math.floor(beats / 4) + 1;
  const beat = Math.floor(beats % 4) + 1;
  return `${bar}.${beat}.1`;
}

// Optionally toggle follow mode
function togglePlayheadFollow() {
  playheadFollowActive = !playheadFollowActive;
  showToast(playheadFollowActive ? 'ðŸŽ¥ Follow Mode ON' : 'ðŸŽ¥ Follow Mode OFF', 'info');
}

// Helper: ensure playhead stays visible when manually scrubbed
function updatePlayheadUI(seconds) {
  const playhead = document.getElementById('dawPlayhead');
  const projDur = multitrack.projectDuration || (state.duration * 60);
  const pct = Math.max(0, Math.min(1, seconds / projDur));
  playhead.style.left = `${pct * 100}%`;
}

function renderMultitrack() {
  // Force container visibility
  const container = document.getElementById('dawMainContainer') || 
                    document.querySelector('.daw-main-container');
  if (container) {
    container.style.display = 'grid';
    container.style.visibility = 'visible';
  }

  const trackHeaders = document.getElementById('dawTrackList');
  const arrangementGrid = document.getElementById('dawArrangementGrid');
  const arrangementScroll = document.getElementById('dawArrangementScroll');
  const rulerContainer = document.getElementById('dawRuler');

  if (!trackHeaders || !arrangementGrid) {
    console.warn('renderMultitrack: missing containers');
    return;
  }

  const durationMinutes = typeof state.duration === 'number' && state.duration > 0 ? state.duration : 1;
  const projectDurationSeconds = durationMinutes * 60;
  const zoom = multitrack.zoom || 100;
  const timelineWidth = projectDurationSeconds * zoom;

  multitrack.projectDuration = projectDurationSeconds;
  multitrack.timelineWidth = timelineWidth;

  document.documentElement.style.setProperty('--timeline-width', timelineWidth + 'px');

  trackHeaders.innerHTML = '';
  arrangementGrid.innerHTML = '';

  arrangementGrid.style.width = timelineWidth + 'px';
  const ruler = rulerContainer?.querySelector('.daw-ruler');
  if (ruler) {
    ruler.style.width = timelineWidth + 'px';
  }

  // Format pan display helper
  const formatPan = (pan) => {
    if (pan === 0) return 'C';
    return (pan > 0 ? 'R' : 'L') + Math.abs(pan);
  };

  // Render each track
  multitrack.tracks.forEach(track => {
    const instData = track.isExternalAudio ? 
      { icon: 'ðŸŽ¤', name: 'External' } : 
      instruments[track.instrument];

    // CREATE TRACK HEADER (LEFT SIDE)
    const headerDiv = document.createElement('div');
    headerDiv.className = 'track-header';
    headerDiv.dataset.trackId = track.id;   // ðŸ” link header to specific track
    headerDiv.tabIndex = 0;                  // keyboard focusable for accessibility
    if (track.recording) headerDiv.classList.add('recording');
    if (track.armed) headerDiv.classList.add('armed');
    if (track.isExternalAudio) headerDiv.classList.add('external-audio');

    
    headerDiv.innerHTML = `
      <div class="track-header-top">
        <div class="track-icon">${instData?.icon || 'ðŸŽšï¸'}</div>
        <div class="track-name" contenteditable="true"
             onblur="const newName=this.textContent; multitrack.tracks.find(t=>t.id===${track.id})?.rename(newName);">
          ${track.name}
        </div>
      </div>
      
      <div class="track-meters">
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
        <div class="track-meter">
          <div class="track-meter-fill" data-meter-track="${track.id}"></div>
        </div>
      </div>
      
      <div class="track-controls-grid">
        <button class="track-mini-btn rec ${track.recording ? 'active' : ''}" data-track-id="${track.id}" data-action="rec">
          ${track.recording ? 'âºï¸' : 'âšª'} REC
        </button>
        <button class="track-mini-btn arm ${track.armed ? 'active' : ''}" data-track-id="${track.id}" data-action="arm">
          ${track.armed ? 'ðŸ”´' : 'âšª'} ARM
        </button>
        ${track.isExternalAudio ? `
          <button class="track-mini-btn mon ${track.inputMonitoring ? 'active' : ''}" data-track-id="${track.id}" data-action="monitor">
            ${track.inputMonitoring ? 'ðŸ”Š' : 'ðŸ”‡'} MON
          </button>
        ` : `
          <button class="track-mini-btn mute ${track.muted ? 'active' : ''}" data-track-id="${track.id}" data-action="mute">
            M
          </button>
        `}
        <button class="track-mini-btn solo ${track.soloed ? 'active' : ''}" data-track-id="${track.id}" data-action="solo">
          S
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="fx">
          ðŸŽ›ï¸ FX
        </button>
        <button class="track-mini-btn" data-track-id="${track.id}" data-action="delete">
          ðŸ—‘ï¸
        </button>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          VOL
        </label>
        <input type="range" min="-40" max="10" value="${track.volume}" step="0.1"
               class="track-volume-slider" data-track-id="${track.id}" data-param="volume">
        <span class="track-volume-value">${track.volume.toFixed(1)}dB</span>
      </div>
      
      <div class="track-volume-control">
        <label style="font-size: var(--text-xs); color: var(--text-tertiary); font-weight: 700; margin-bottom: var(--space-1); display: block;">
          PAN
        </label>
        <input type="range" min="-100" max="100" value="${track.pan}" step="1"
               class="track-pan-slider" data-track-id="${track.id}" data-param="pan">
        <span class="track-pan-value">${formatPan(track.pan)}</span>
      </div>
    `;
    
    trackHeaders.appendChild(headerDiv);
    
    // CREATE TRACK LANE (RIGHT SIDE)
    // CREATE TRACK LANE (RIGHT SIDE)
    const laneDiv = document.createElement('div');
    laneDiv.className = 'daw-track-lane';
    laneDiv.dataset.trackId = track.id;
    laneDiv.style.width = timelineWidth + 'px';

    
    // Add regions
    track.takes.forEach((take, idx) => {
      const isSelected = idx === track.selectedTakeIndex;
      const isMuted = take.muted;
      
      const startPos = (take.startTime || 0) * zoom;
      const width = take.duration * zoom;
      
      const regionDiv = document.createElement('div');
      regionDiv.className = `audio-region ${isSelected ? 'selected' : ''} ${isMuted ? 'muted' : ''}`;
      regionDiv.dataset.trackId = track.id;
      regionDiv.dataset.takeIndex = idx;
      regionDiv.dataset.regionId = take.id;
      regionDiv.style.left = startPos + 'px';
      regionDiv.style.width = width + 'px';
      
      regionDiv.innerHTML = `
        <div class="region-header">
          <div class="region-actions">
            <button class="region-action-btn" data-action="split-region" title="Split">âœ‚ï¸</button>
            <button class="region-action-btn" data-action="toggle-mute-region" title="Mute">
              ${isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
            </button>
            <button class="region-action-btn" data-action="edit-waveform" title="Edit">âœï¸</button>
            <button class="region-action-btn" data-action="delete-region" title="Delete">ðŸ—‘ï¸</button>
          </div>
          <div class="region-name">Take ${idx + 1}</div>
        </div>
        
        <div class="region-waveform">
          <canvas class="region-waveform-canvas" 
                  data-take-id="${take.id}"
                  width="${Math.max(100, width)}" 
                  height="20"></canvas>
        </div>
        
        <div class="region-resize-handle left" data-handle="left"></div>
        <div class="region-resize-handle right" data-handle="right"></div>
        
        <div style="position: absolute; bottom: 2px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.7); pointer-events: none;">
          ${formatTime(take.startTime || 0)}
        </div>
      `;
      
      laneDiv.appendChild(regionDiv);
    });
    
    // Empty state
    if (track.takes.length === 0 && !track.recording) {
      const emptyDiv = document.createElement('div');
      emptyDiv.className = 'track-empty-state';
      emptyDiv.innerHTML = `
        <div class="track-empty-state-icon">ðŸŽ™ï¸</div>
        <div>Arm and record to create takes</div>
      `;
      laneDiv.appendChild(emptyDiv);
    }
    
    // Recording indicator
    if (track.recording) {
      const recDiv = document.createElement('div');
      recDiv.className = 'recording-indicator';
      recDiv.innerHTML = `
        <div class="recording-indicator-dot"></div>
        <span>Recording...</span>
      `;
      laneDiv.appendChild(recDiv);
    }
    
    arrangementGrid.appendChild(laneDiv);
    
    // Volume slider
    const volumeSlider = headerDiv.querySelector('.track-volume-slider');
    if (volumeSlider) {
      volumeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        track.volume = value;
        if (track.channel && track.channel.volume) {
          track.channel.volume.rampTo(value, 0.05);
        }
        const label = headerDiv.querySelector('.track-volume-value');
        if (label) label.textContent = value.toFixed(1) + 'dB';
      });
    }
    
    // Pan slider - WORKING VERSION
    const panSlider = headerDiv.querySelector('.track-pan-slider');
    if (panSlider) {
      panSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        track.pan = value;
        
        if (track.channel && track.channel.pan) {
          track.channel.pan.rampTo(value / 100, 0.05);
        }
        
        const label = headerDiv.querySelector('.track-pan-value');
        if (label) {
          label.textContent = formatPan(value);
        }
      });
    }

        // Clicking the header (but not the buttons/sliders) opens the inspector
    headerDiv.addEventListener('click', (e) => {
      if (e.target.closest('.track-mini-btn') || e.target.closest('input[type="range"]')) {
        return; // don't double-handle button/slider clicks
      }
      if (typeof openTrackInspector === 'function') {
        openTrackInspector(track.id);
      }
    });

    // Keyboard: Enter/Space also open inspector when header is focused
    headerDiv.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (typeof openTrackInspector === 'function') {
          openTrackInspector(track.id);
        }
      }
    });

    // Setup region interactions
    setupRegionInteractions(laneDiv, track);
    
    // Start meter animation
    if (track.meter) {
      const updateMeters = () => {
        if (!track.meter) return;

        const fills = headerDiv.querySelectorAll(`[data-meter-track="${track.id}"]`);
        if (fills.length === 0) return;
        
        const value = track.meter.getValue();
        const channels = Array.isArray(value) ? value : [value, value];
        
        fills.forEach((fill, idx) => {
          const db = (idx < channels.length ? channels[idx] : channels[0]) ?? -60;
          const normalized = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
          fill.style.height = normalized + '%';
        });

        requestAnimationFrame(updateMeters);
      };

      requestAnimationFrame(updateMeters);
    }
  });

  if (typeof updateTimelineRuler === 'function') {
    updateTimelineRuler();
  }
  
  // If the inspector already had something selected, re-apply it
  if (typeof refreshInspectorSelection === 'function') {
    refreshInspectorSelection();
  }
}

function updatePlayheadAndScroll(currentSeconds) {
  const wrapper = document.getElementById('dawArrangementScroll');
  const playhead = document.getElementById('dawPlayhead');
  const timecodeEl = document.getElementById('dawTimecode');
  const barsEl = document.getElementById('dawBars');

  if (!wrapper || !playhead) return;

  const projDur = multitrack.projectDuration || (state.duration * 60);
  let sec = Number(currentSeconds);

  if (!Number.isFinite(sec) || sec < 0) sec = 0;
  if (projDur > 0) sec = Math.min(sec, projDur);

  // ðŸ”‘ Remember this globally so PAUSE / SKIM can use it
  multitrack.playheadSeconds = sec;
  state.cursorSeconds = sec;

  // Position playhead in pixels
  const zoom = multitrack.zoom || 100;
  const x = sec * zoom;
  playhead.style.left = x + 'px';

  // Auto-scroll to keep playhead visible
  const padding = 80;
  const visibleStart = wrapper.scrollLeft;
  const visibleEnd = visibleStart + wrapper.clientWidth;

  if (x < visibleStart + padding) {
    wrapper.scrollLeft = Math.max(0, x - padding);
  } else if (x > visibleEnd - padding) {
    wrapper.scrollLeft = x - wrapper.clientWidth + padding;
  }

  // â±ï¸ Update transport displays
  if (timecodeEl) timecodeEl.textContent = formatTimecode(sec);
  if (barsEl) barsEl.textContent = formatBars(sec);
}


let playheadAnimationId = null;

function startPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
  }

  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.getElementById('dawArrangementScroll'); // âœ… fixed selector

  if (!playhead || !wrapper) return;

  const animate = () => {
    if (!state.isPlaying) {
      playheadAnimationId = null;
      return;
    }

    const currentTime = Tone.Transport.seconds;
    state.cursorSeconds = currentTime;
    updatePlayheadAndScroll(currentTime);

    playheadAnimationId = requestAnimationFrame(animate);
  };

  playheadAnimationId = requestAnimationFrame(animate);
}

function stopPlayheadAnimation() {
  if (playheadAnimationId) {
    cancelAnimationFrame(playheadAnimationId);
    playheadAnimationId = null;
    console.log('â¹ï¸ Playhead animation stopped');
  }
}
  
let previewPlayheadId = null;
let previewStartTime = 0;

function startPreviewPlayhead(startOffset, duration) {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
  }
  
  const playhead = document.getElementById('dawPlayhead');
  const wrapper = document.getElementById('dawArrangementScroll');
  
  if (!playhead || !wrapper) {
    console.error('âŒ Missing playhead or wrapper for preview');
    return;
  }
  
  previewStartTime = performance.now();
  
  const animate = () => {
    const elapsed = (performance.now() - previewStartTime) / 1000;
    
    if (elapsed >= duration) {
      previewPlayheadId = null;
      return;
    }
    
    const currentTime = startOffset + elapsed; // ðŸ”‘ real project time
    state.cursorSeconds = currentTime; 
    updatePlayheadAndScroll(currentTime);
    
    previewPlayheadId = requestAnimationFrame(animate);
  };
  
  previewPlayheadId = requestAnimationFrame(animate);
  console.log('âœ… Preview playhead started at', startOffset, 'for', duration, 'seconds');
}

function stopPreviewPlayhead() {
  if (previewPlayheadId) {
    cancelAnimationFrame(previewPlayheadId);
    previewPlayheadId = null;
    console.log('â¹ï¸ Preview playhead stopped');
  }
}

function setupPreviewButton() {
  const btn = document.getElementById('previewMultitrackBtn');
  if (!btn) return;

  btn.addEventListener('click', () => {
    // Just call with no args â†’ uses last cursor/playhead position
    previewMultitrack();
  });
}
  
// === MASTER OUTPUT CHAIN ===
// master volume ~ -4 dB
const masterGain = new Tone.Gain(0.8);

// limiter protects against clipping
const limiter = new Tone.Limiter(-1);

// master high-pass filter (neutral in normal playback)
window.masterHP = new Tone.Filter({
  type: 'highpass',
  frequency: 30,   // stays flat until riser automation lifts it
  Q: 0.7
});

// chain: all tracks â†’ masterGain â†’ HP â†’ limiter â†’ speakers
masterGain.connect(window.masterHP);
window.masterHP.connect(limiter);
limiter.toDestination();


// Attach to both systems
if (!multitrack.masterBus) multitrack.masterBus = masterGain;
window.SEQUENCER_MASTER_BUS = masterGain;

// Normalizes based on measured RMS (~perceived loudness)
function normalizeBufferVolume(audioBuffer) {
  const data = audioBuffer.getChannelData(0);
  let sumSq = 0;
  for (let i = 0; i < data.length; i++) {
    const v = data[i];
    sumSq += v * v;
  }
  const rms = Math.sqrt(sumSq / data.length) || 1e-6;

  // Much more conservative target
  const targetRms = 0.12; // was 0.25

  // Convert gain ratio â†’ dB
  return Tone.gainToDb(targetRms / rms);
}

  
async function previewMultitrack(startAtSeconds) {
  // If no explicit start is passed, use the last playhead/cursor position
  const startFrom =
    typeof startAtSeconds === 'number'
      ? startAtSeconds
      : (typeof state.cursorSeconds === 'number' ? state.cursorSeconds : 0);

  const activeTracks = multitrack.tracks.filter(t =>
    t.selectedTakeIndex >= 0 && !t.muted
  );
  
  if (activeTracks.length === 0) {
    showToast('âŒ No active takes to preview', 'error');
    return;
  }

  // ðŸ§© Stop any existing preview first - CRITICAL for looping
  // ðŸ§  Only fully stop if we're not resuming from pause
  if (!multitrack.isPaused) {
    await stopMultitrackPreview();
  }

  await Tone.start();
  if (Tone.context.state !== 'running') {
    await Tone.context.resume();
  }
  
  multitrack.lastStartTime = Tone.now();
  multitrack.isPaused = false;
  multitrack.previewPlayers = [];

  const projectDurationSeconds = multitrack.projectDuration || (state.duration * 60);
  
  // ðŸ”‘ Clamp start offset to project bounds
  const previewStart = Math.max(0, Math.min(startFrom, projectDurationSeconds));
  let previewEnd = previewStart;

  // Update cursor + visually move playhead to the preview start
  state.cursorSeconds = previewStart;
  updatePlayheadAndScroll(previewStart);

  showToast(`â³ Loading takes (from ${previewStart.toFixed(2)}s)...`, 'info');

  for (const track of activeTracks) {
    const take = track.takes[track.selectedTakeIndex];
    if (!take || take.muted) continue;
  
    if (!take.buffer || !take.buffer.length || take.buffer.length === 0) {
      console.error(`âŒ ${track.name}: Invalid buffer`);
      continue;
    }
  
    const regionStart = take.startTime || 0;
    const regionEnd = regionStart + take.duration;
  
    if (regionEnd <= previewStart) continue;
  
    try {
      const player = new Tone.Player({
        context: Tone.context,
        loop: false,
        fadeOut: 0.01
      }).connect(track.channel);
  
      player.buffer = take.buffer;
  
      const relativeStart = Math.max(0, regionStart - previewStart);
  
      multitrack.previewPlayers.push({
        player,
        track,
        regionStart,     // ðŸ‘ˆ added
        regionEnd,       // ðŸ‘ˆ added (optional but useful)
        relativeStart
      });
  
      if (regionEnd > previewEnd) previewEnd = regionEnd;
  
    } catch (err) {
      console.error(`âŒ ${track.name} failed:`, err);
    }
  }

  if (!multitrack.previewPlayers.length) {
    showToast('âš ï¸ No regions overlap this preview range', 'warning');
    return;
  }

  const totalDuration = Math.max(0.1, previewEnd - previewStart);
  console.log(`â–¶ï¸ Preview from ${previewStart.toFixed(3)}s for ${totalDuration.toFixed(3)}s`);

  const now = Tone.now() + 0.1;

  multitrack.previewPlayers.forEach(({ player, track, relativeStart, regionStart }) => {
    try {
      const offsetInBuffer = Math.max(0, previewStart - regionStart);
      player.start(now + relativeStart, offsetInBuffer);
      console.log(`â–¶ï¸ ${track.name} resume at buffer offset ${offsetInBuffer.toFixed(3)}s`);
    } catch (err) {
      console.error(`âŒ Failed to start ${track.name}:`, err);
    }
  });

  showToast(
    `â–¶ï¸ Previewing ${multitrack.previewPlayers.length} track(s) from ${previewStart.toFixed(2)}s`,
    'success'
  );

  // === ðŸ§­ Activate playhead + follow mode ===
  multitrack.isPlaying = true;
  multitrack.playheadSeconds = previewStart;
  initPlayheadFollow();
  startPreviewPlayhead(previewStart, totalDuration);

  // === ðŸŒ€ LOOP SUPPORT (Selection or Full Project) ===
  multitrack.previewTimeout = setTimeout(async () => {
    // Stop current preview and WAIT for cleanup
    await stopMultitrackPreview();
    
    const btn = document.getElementById('previewMultitrackBtn');

    if (!multitrack.loopEnabled) {
      if (btn) btn.textContent = 'â–¶ï¸ Preview Mix';
      return;
    }

    const hasSelection =
      typeof multitrack.loopStart === 'number' &&
      typeof multitrack.loopEnd === 'number' &&
      multitrack.loopEnd > multitrack.loopStart;

    const restartAt = hasSelection ? multitrack.loopStart : 0;

    console.log(
      hasSelection
        ? `ðŸ” Looping selected region: ${restartAt.toFixed(2)}s â†’ ${multitrack.loopEnd.toFixed(2)}s`
        : 'ðŸ” Looping entire projectâ€¦'
    );

    multitrack.playheadSeconds = restartAt;
    
    // Small buffer to ensure Tone.js is ready
    await new Promise(resolve => setTimeout(resolve, 50));
    
    await previewMultitrack(restartAt);
  }, (totalDuration + 0.25) * 1000);
}

async function stopMultitrackPreview(resetOrOptions) {
  // Allow both: stopMultitrackPreview(true) and stopMultitrackPreview({ resetToZero: true })
  const resetToZero =
    typeof resetOrOptions === 'boolean'
      ? resetOrOptions
      : resetOrOptions && typeof resetOrOptions.resetToZero === 'boolean'
        ? resetOrOptions.resetToZero
        : false;

  if (multitrack.previewPlayers && multitrack.previewPlayers.length > 0) {
    // Stop all players first (synchronous)
    multitrack.previewPlayers.forEach(({ player }) => {
      try {
        if (player.state === 'started') {
          player.stop();
        }
      } catch (err) {
        console.warn('Error stopping preview player:', err);
      }
    });

    // Then dispose all players (async) - wait for all to complete
    await Promise.all(
      multitrack.previewPlayers.map(async ({ player }) => {
        try {
          await player.dispose();
        } catch (err) {
          console.warn('Error disposing preview player:', err);
        }
      })
    );

    multitrack.previewPlayers = [];
    console.log('â¹ï¸ Preview stopped');
  }

  // Stop playhead follow + display updates
  multitrack.isPlaying = false;
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  stopPreviewPlayhead();

  if (multitrack.previewTimeout) {
    clearTimeout(multitrack.previewTimeout);
    multitrack.previewTimeout = null;
  }

  // Remember where we stopped so PAUSE can resume
  let lastSeconds = 0;

  if (resetToZero) {
    lastSeconds = 0;
  } else if (
    typeof state.cursorSeconds === 'number' &&
    !Number.isNaN(state.cursorSeconds)
  ) {
    lastSeconds = state.cursorSeconds;
  } else if (
    typeof multitrack.playheadSeconds === 'number' &&
    !Number.isNaN(multitrack.playheadSeconds)
  ) {
    lastSeconds = multitrack.playheadSeconds;
  }

  multitrack.playheadSeconds = lastSeconds;
  multitrack.lastPreviewCursor = lastSeconds;
  // This updates playhead position, scroll, and timecode/bars
  updatePlayheadAndScroll(lastSeconds);
}

// ðŸ” PURE WEB AUDIO MASTER CHAIN FOR OFFLINE BOUNCE
function createOfflineMasterChain(offlineContext) {
  // Entry point for all tracks
  const input = offlineContext.createGain();
  input.gain.value = 1.0; // ðŸ”Š no pre-attenuation (was 0.25 â‰ˆ -12 dB)

  // High-pass (low cut)
  const lowCut = offlineContext.createBiquadFilter();
  lowCut.type = 'highpass';
  lowCut.frequency.value = typeof state.lowCut === 'number' ? state.lowCut : 20;
  lowCut.Q.value = 0.707;

  // Low-pass (high cut)
  const highCut = offlineContext.createBiquadFilter();
  highCut.type = 'lowpass';
  highCut.frequency.value = typeof state.highCut === 'number' ? state.highCut : 20000;
  highCut.Q.value = 0.707;

  // Tape-style soft clip
  const tape = offlineContext.createWaveShaper();
  const satAmt = ((state.tapeSaturation || 0) / 100) * 0.8; // 0â€“0.8
  const curveLen = 4096;
  const curve = new Float32Array(curveLen);
  for (let i = 0; i < curveLen; i++) {
    const x = (i / (curveLen - 1)) * 2 - 1; // -1..1
    curve[i] = ((1 + satAmt) * x) / (1 + satAmt * Math.abs(x));
  }
  tape.curve = curve;

  // Bus compressor
  const comp = offlineContext.createDynamicsCompressor();
  comp.threshold.value =
    typeof state.compressor === 'number' ? state.compressor : -18; // a bit gentler than -24
  comp.ratio.value = 3;       // 3:1 instead of 4:1
  comp.attack.value = 0.005;
  comp.release.value = 0.2;

  // Limiter approximation
  const limiter = offlineContext.createDynamicsCompressor();
  limiter.threshold.value = -1;  // let it sit closer to 0 dBFS
  limiter.ratio.value = 20;
  limiter.attack.value = 0.001;
  limiter.release.value = 0.1;

  // Final output gain (makeup)
  const outGain = offlineContext.createGain();
  // 1.0 = no change. 1.4 â‰ˆ +3 dB, 2.0 â‰ˆ +6 dB
  outGain.gain.value = 1.6; // tweak to taste

  // Chain: input â†’ lowCut â†’ highCut â†’ tape â†’ comp â†’ limiter â†’ outGain â†’ destination
  input.connect(lowCut);
  lowCut.connect(highCut);
  highCut.connect(tape);
  tape.connect(comp);
  comp.connect(limiter);
  limiter.connect(outGain);
  outGain.connect(offlineContext.destination);

  return input;
}

function createOfflineFxNode(fxDef, offlineContext) {
  const { type, params } = fxDef;
  
  switch (type) {
    case 'reverb':
      return new Tone.Reverb({ 
        decay: params.decay, 
        wet: params.wet,
        context: offlineContext 
      });
    
    case 'delay':
      return new Tone.FeedbackDelay({
        delayTime: params.time,
        feedback: params.feedback,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'chorus':
      return new Tone.Chorus({
        frequency: params.frequency,
        delayTime: params.delayTime,
        depth: params.depth,
        wet: params.wet,
        context: offlineContext
      }).start();
    
    case 'distortion':
      return new Tone.Distortion({
        distortion: params.amount,
        wet: params.wet,
        context: offlineContext
      });
    
    case 'filter':
      return new Tone.Filter({
        type: params.type,
        frequency: params.frequency,
        Q: params.q,
        context: offlineContext
      });
    
    case 'compressor':
      return new Tone.Compressor({
        threshold: params.threshold,
        ratio: params.ratio,
        attack: params.attack,
        release: params.release,
        context: offlineContext
      });
    
    case 'eq':
      return new Tone.EQ3({
        low: params.low,
        mid: params.mid,
        high: params.high,
        context: offlineContext
      });
    
    case 'bitcrusher':
      return new Tone.BitCrusher({
        bits: params.bits,
        context: offlineContext
      });
    
    default:
      return null;
  }
}
  
// =============================================================
// ðŸŽµ BOUNCE ALL TRACKS â€” DAW-Optimized Professional Export
// Tailored for 8-Beat Studio (Tone.js / Multitrack Integration)
// =============================================================
async function bounceAllTracks() {
  const activeTracks = multitrack.tracks.filter(track => {
    if (track.muted) return false;

    // Check for valid takes
    const activeTake = track.selectedTakeIndex >= 0
      ? track.takes[track.selectedTakeIndex]
      : (track.takes?.find(tk => tk && tk.buffer && tk.buffer.length && !tk.muted) || null);

    return activeTake && activeTake.buffer && activeTake.buffer.length && !activeTake.muted;
  });

  if (!activeTracks.length) {
    showToast('âŒ No tracks to bounce!', 'error');
    return;
  }

  // ==== UI ====
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '480px';
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">ðŸŽ§ Bouncing Mix</div>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4);">
        <div id="bounceStatus" style="font-weight:700;margin-bottom:var(--space-2);">Preparingâ€¦</div>
        <div class="progress">
          <div id="bounceProgress" class="progress-value" style="width:0%;transition:width 0.3s;"></div>
        </div>
        <div id="bounceDetails" style="font-size:var(--text-sm);color:var(--text-tertiary);margin-top:var(--space-2);"></div>
      </div>
    </div>`;
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);

  const updateProgress = (percent, status, details = '') => {
    const p = document.getElementById('bounceProgress');
    const s = document.getElementById('bounceStatus');
    const d = document.getElementById('bounceDetails');
    if (p) p.style.width = `${percent}%`;
    if (s) s.textContent = status;
    if (d) d.textContent = details;
  };

  try {
    updateProgress(10, 'Analyzing tracksâ€¦', `${activeTracks.length} tracks detected`);

    // === Find timeline bounds ===
    let minStart = Infinity;
    let maxEnd = 0;
    activeTracks.forEach(t => {
      const take = t.selectedTakeIndex >= 0
        ? t.takes[t.selectedTakeIndex]
        : t.takes?.find(x => x && x.buffer && !x.muted);
      if (!take) return;
      const start = take.startTime || 0;
      const end = start + take.duration;
      if (start < minStart) minStart = start;
      if (end > maxEnd) maxEnd = end;
    });

    if (minStart === Infinity || maxEnd === 0) {
      backdrop.remove();
      showToast('âŒ No audio content to bounce', 'error');
      return;
    }

    const totalDuration = maxEnd - minStart;
    const sampleRate = Tone.context.sampleRate || 48000;
    const numFrames = Math.ceil(totalDuration * sampleRate);
    updateProgress(20, 'Setting up rendererâ€¦', `${totalDuration.toFixed(1)}s of audio`);

    // === Create Offline Context ===
    const offlineCtx = new OfflineAudioContext({
      numberOfChannels: 2,
      length: numFrames,
      sampleRate
    });

    // === Master Chain ===
    updateProgress(30, 'Building master chainâ€¦');
    const offlineMasterIn = createOfflineMasterChain(offlineCtx);

    // === Professional Gain Staging ===
    const trackCount = activeTracks.length;

    // Per-track attenuation to prevent summing overload
    // Formula: base -3 dB, minus 0.5 dB per extra track past 4
    const perTrackAttenDb = -3 - Math.max(0, trackCount - 4) * 0.5;
    const perTrackAtten = Math.pow(10, perTrackAttenDb / 20);

    // Master headroom for limiter / mastering
    const masterGain = offlineCtx.createGain();
    masterGain.gain.value = 0.9; // â‰ˆ -1 dB headroom
    offlineMasterIn.connect(masterGain);
    masterGain.connect(offlineCtx.destination);

    updateProgress(40, 'Scheduling tracksâ€¦');

    // === Render each active track ===
    for (const track of activeTracks) {
      const take = track.selectedTakeIndex >= 0
        ? track.takes[track.selectedTakeIndex]
        : track.takes?.find(x => x && x.buffer && !x.muted);
      if (!take?.buffer) continue;

      const src = offlineCtx.createBufferSource();
      src.buffer = take.buffer;

      // Volume / Pan conversion (Tone.js compatible)
      const gainNode = offlineCtx.createGain();
      const panNode = offlineCtx.createStereoPanner();

      const volDb = track.volume || 0;
      const gain = Tone.dbToGain(volDb) * perTrackAtten;
      gainNode.gain.value = gain;
      panNode.pan.value = (track.pan || 0) / 100;

      src.connect(gainNode);
      gainNode.connect(panNode);
      panNode.connect(offlineMasterIn);

      const relStart = Math.max(0, (take.startTime || 0) - minStart);
      src.start(relStart);
    }

    updateProgress(60, 'Rendering audioâ€¦');

    const renderedBuffer = await offlineCtx.startRendering();

    updateProgress(90, 'Converting to WAVâ€¦');

    const wavData = bufferToWavImproved(renderedBuffer);
    const blob = new Blob([wavData], { type: 'audio/wav' });

    const projectName = document.getElementById('projectName')?.value || 'mix';
    const filename = `${projectName.replace(/\s+/g, '_')}_bounce_${Date.now()}.wav`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 4000);

    updateProgress(100, 'âœ… Export complete', filename);

    setTimeout(() => {
      backdrop.remove();
      showToast(`âœ… Bounce complete! ${totalDuration.toFixed(1)}s exported (trimmed)`, 'success');
    }, 1000);

  } catch (err) {
    console.error('âŒ Bounce failed:', err);
    backdrop.remove();
    showToast(`âŒ Bounce failed: ${err.message}`, 'error');
  }
}
  
// Add this NEW function
async function validateAllArmedTracks() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const errors = [];
  
  for (const track of armedTracks) {
    // Check if drum samples are loaded
    if (!track.isExternalAudio && instruments[track.instrument]?.type === 'drum') {
      const synth = synths[track.instrument];
      if (synth && !synth.loaded) {
        errors.push(`${track.instrument} sample not loaded`);
      }
    }
    
    // Check external audio setup
    if (track.isExternalAudio && !track.mediaStream) {
      errors.push(`${track.name} has no audio input`);
    }
  }
  
  if (errors.length > 0) {
    throw new Error(errors.join('\n'));
  }
}
  
async function toggleRecordAllArmed() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  const recordingTracks = multitrack.tracks.filter(t => t.recording);

  if (recordingTracks.length > 0) {
    recordingTracks.forEach(track => track.stopRecording());
    stopPlayheadAnimation(); // Stop scroll during recording
    showToast(`â¹ï¸ Stopped recording ${recordingTracks.length} track(s)`, 'info');
    renderMultitrack();
    return;
  }

  if (armedTracks.length === 0) {
    showToast('âŒ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`âŒ Cannot record:\n${err.message}`, 'error');
    return;
  }

  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();

  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  console.log(`ðŸŽ¬ GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    await track.startRecording({ forcedStartTime: globalStart });
  }

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`ðŸŽ™ï¸ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`ðŸŽ™ï¸ Recording ${armedTracks.length} track(s)`, 'success');
  
  // Start playhead animation for recording
  startPlayheadAnimation();
  
  renderMultitrack();
}
  
// Toggle recording for a single track
async function toggleRecordTrack(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.recording) {
    track.stopRecording();
    showToast(`â¹ï¸ Stopped recording ${track.name}`, 'info');
  } else {
    if (!track.armed) {
      track.armed = true;
    }

    if (!state.isPlaying) {
      await togglePlay();
    }

    await Tone.start();
    const start = Tone.now();
    await track.startRecording({ forcedStartTime: start });

    showToast(`ðŸŽ™ï¸ Recording ${track.name}...`, 'success');
  }
  
  renderMultitrack();
}

// Add these functions after the toggleRecordTrack function (around line 4630):

// Global recording control
async function startGlobalRecording() {
  const armedTracks = multitrack.tracks.filter(t => t.armed && !t.recording);
  
  if (armedTracks.length === 0) {
    showToast('âŒ No armed tracks to record', 'error');
    return;
  }

  try {
    await validateAllArmedTracks();
  } catch (err) {
    showToast(`âŒ Cannot record:\n${err.message}`, 'error');
    return;
  }

  // Start transport if not playing
  if (!state.isPlaying) {
    await togglePlay();
  }

  await Tone.start();
  const globalStart = Tone.now();
  multitrack.globalRecordStartTime = globalStart;
  multitrack.isPlaying = true;

  console.log(`ðŸŽ¬ GLOBAL RECORD START: ${globalStart.toFixed(3)}s`);

  for (const track of armedTracks) {
    track.recordStartTime = globalStart;
    await track.startRecording();
  }

  // Start playhead animation
  initPlayheadFollow();

  const trackList = armedTracks.map(t => t.name).join(', ');
  console.log(`ðŸŽ™ï¸ Recording ${armedTracks.length} tracks: ${trackList}`);
  showToast(`ðŸŽ™ï¸ Recording ${armedTracks.length} track(s)`, 'success');
  
  renderMultitrack();
}

function stopGlobalRecording() {
  const recordingTracks = multitrack.tracks.filter(t => t.recording);
  
  if (recordingTracks.length === 0) return;

  recordingTracks.forEach(track => {
    track.stopRecording();
  });

  multitrack.globalRecordStartTime = null;
  multitrack.isPlaying = false;

  // Stop playhead
  clearInterval(playheadUpdateInterval);
  playheadUpdateInterval = null;

  showToast(`â¹ï¸ Stopped recording ${recordingTracks.length} track(s)`, 'info');
  renderMultitrack();
}

// BPM and time signature controls
function setBPM(newBpm) {
  const bpm = Math.max(30, Math.min(300, parseFloat(newBpm) || 120));
  state.bpm = bpm;
  Tone.Transport.bpm.value = bpm;
  
  const bpmSlider = document.getElementById('bpmSlider');
  const bpmValue = document.getElementById('bpmValue');
  if (bpmSlider) bpmSlider.value = bpm;
  if (bpmValue) bpmValue.textContent = bpm;
  
  console.log(`ðŸŽµ BPM set to ${bpm}`);
}

function setTimeSignature(timeSig) {
  const [beats, noteValue] = timeSig.split('/').map(n => parseInt(n));
  Tone.Transport.timeSignature = [beats, noteValue];
  console.log(`ðŸŽµ Time signature: ${timeSig}`);
  showToast(`â±ï¸ Time signature: ${timeSig}`, 'info');
}

function applySnap(seconds) {
  if (!multitrack.snapEnabled) return seconds;
  const grid = multitrack.snapInterval * (60 / state.bpm); // convert beatsâ†’seconds
  return Math.round(seconds / grid) * grid;
}

// Session management
function newMultitrackSession() {
  if (!confirm('Create new session? Unsaved changes will be lost.')) return;
  
  // Stop everything
  if (state.isPlaying) stop();
  stopMultitrackPreview();
  
  // Clear all tracks
  multitrack.tracks.forEach(t => t.dispose());
  multitrack.tracks = [];
  multitrack.nextTrackId = 1;
  multitrack.globalRecordStartTime = null;
  
  // Reset state
  state.cursorSeconds = 0;
  multitrack.playheadSeconds = 0;

  multitrackHistory.clear();
  
  renderMultitrack();
  showToast('âœ… New session created', 'success');
}

function saveMultitrackSession() {
  // Reuse the full project save
  saveProject();
}

function loadMultitrackSession() {
  // Reuse the full project load
  loadProject();
}

// Grid and automation toggles
function toggleGrid() {
  const gridBtn = document.getElementById('dawGridBtn');
  if (!gridBtn) return;
  
  const isActive = gridBtn.classList.toggle('active');
  
  // Toggle snap grid visibility
  document.querySelectorAll('.snap-grid').forEach(grid => {
    grid.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? 'âŠž Grid: On' : 'âŠž Grid: Off', 'info');
}

function toggleAutomationView() {
  const autoBtn = document.getElementById('dawAutomationBtn');
  if (!autoBtn) return;
  
  const isActive = autoBtn.classList.toggle('active');
  
  // Toggle automation lanes
  document.querySelectorAll('.automation-lane').forEach(lane => {
    lane.style.display = isActive ? 'block' : 'none';
  });
  
  showToast(isActive ? 'ðŸ“ˆ Automation: On' : 'ðŸ“ˆ Automation: Off', 'info');
}

// CPU and status monitoring
function updateDAWStatus() {
  const cpuEl = document.getElementById('dawCpuLoad');
  const latencyEl = document.getElementById('dawLatency');
  const trackCountEl = document.getElementById('dawTrackCount');
  const statusEl = document.getElementById('dawStatusMessage');
  
  if (cpuEl) {
    // Approximate CPU usage based on active tracks
    const activeTracks = multitrack.tracks.filter(t => !t.muted).length;
    const cpuPercent = Math.min(100, activeTracks * 3 + Math.random() * 5);
    cpuEl.textContent = cpuPercent.toFixed(0) + '%';
  }
  
  if (latencyEl) {
    const ctx = Tone.context.rawContext;
    const latencyMs = (ctx.baseLatency || 0) * 1000;
    latencyEl.textContent = latencyMs.toFixed(1) + 'ms';
  }
  
  if (trackCountEl) {
    trackCountEl.textContent = multitrack.tracks.length.toString();
  }
  
  if (statusEl && multitrack.isPlaying) {
    const recordingCount = multitrack.tracks.filter(t => t.recording).length;
    if (recordingCount > 0) {
      statusEl.textContent = `Recording ${recordingCount} track(s)...`;
    } else {
      statusEl.textContent = 'Playing';
    }
  } else if (statusEl) {
    statusEl.textContent = 'Ready';
  }
}
  
// Replace openFxChainEditor function (around line 3285)
function openFxChainEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;

  // Remember which track we're editing
  multitrack.currentFxTrackId = trackId;

  const panel = document.getElementById('fxChainPanel');
  if (!panel) return;

  // Use the actual label ID from the HTML: fxChainTrackLabel
  const labelEl = document.getElementById('fxChainTrackLabel');
  if (labelEl) {
    labelEl.textContent = track.name;
  }

  // Render that track's FX chain into the panel
  renderFxChain(track);

  // Open the panel
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
}

function renderFxChain(track) {
  const slots = document.getElementById('fxChainSlots');

  if (!slots) return;
  
  slots.innerHTML = '';
  
  if (track.fxChain.length === 0) {
    slots.innerHTML = `
      <div style="padding: var(--space-8); text-align: center; color: var(--text-tertiary);">
        <div style="font-size: var(--text-xl); margin-bottom: var(--space-2);">ðŸŽ›ï¸</div>
        <div>No effects on this track</div>
        <div style="font-size: var(--text-sm); margin-top: var(--space-2);">Click an effect pill above to add</div>
      </div>
    `;
    return;
  }
  
  track.fxChain.forEach((fx, idx) => {
    const fxSlot = document.createElement('div');
    fxSlot.className = 'fx-unit';
    fxSlot.style.opacity = fx.enabled ? '1' : '0.5';
    
    let paramsHTML = '';
    
    // Define parameter ranges for each FX type
    const paramConfig = {
      reverb: {
        decay: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 's' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      delay: {
        time: { min: 0, max: 3, options: ['16n', '8n', '4n', '2n', '1n'], default: '8n', format: (v) => v },
        feedback: { min: 0, max: 0.9, default: 0.3, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.3, format: (v) => Math.round(v * 100) + '%' }
      },
      chorus: {
        frequency: { min: 0.1, max: 10, default: 1.5, format: (v) => v.toFixed(1) + 'Hz' },
        delayTime: { min: 2, max: 20, default: 3.5, format: (v) => v.toFixed(1) + 'ms' },
        depth: { min: 0, max: 1, default: 0.7, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      distortion: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      saturation: {
        amount: { min: 0, max: 1, default: 0.4, format: (v) => Math.round(v * 100) + '%' },
        wet: { min: 0, max: 1, default: 0.5, format: (v) => Math.round(v * 100) + '%' }
      },
      filter: {
        type: { options: ['lowpass', 'highpass', 'bandpass'], default: 'lowpass', format: (v) => v },
        frequency: { min: 20, max: 20000, default: 5000, format: (v) => Math.round(v) + 'Hz' },
        q: { min: 0.1, max: 10, default: 1, format: (v) => v.toFixed(1) }
      },
      compressor: {
        threshold: { min: -60, max: 0, default: -24, format: (v) => Math.round(v) + 'dB' },
        ratio: { min: 1, max: 20, default: 4, format: (v) => v.toFixed(1) + ':1' },
        attack: { min: 0.001, max: 1, default: 0.003, format: (v) => (v * 1000).toFixed(1) + 'ms' },
        release: { min: 0.01, max: 1, default: 0.25, format: (v) => (v * 1000).toFixed(0) + 'ms' }
      },
      eq: {
        low: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        mid: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' },
        high: { min: -24, max: 24, default: 0, format: (v) => (v > 0 ? '+' : '') + Math.round(v) + 'dB' }
      },
      bitcrusher: {
        bits: { min: 1, max: 16, default: 4, format: (v) => Math.round(v) + ' bits' }
      }
    };
    
    const typeConfig = paramConfig[fx.type] || {};
    
    Object.entries(fx.params).forEach(([param, value]) => {
      const config = typeConfig[param] || { min: 0, max: 100, default: 50, format: (v) => v };
      
      let sliderVal = 50;
      let displayVal = value;
      
      // Handle special cases
      if (config.options) {
        // Discrete options (like delay time or filter type)
        const optIndex = config.options.indexOf(value);
        sliderVal = optIndex >= 0 ? (optIndex / (config.options.length - 1)) * 100 : 50;
      } else {
        // Continuous values
        sliderVal = ((value - config.min) / (config.max - config.min)) * 100;
        sliderVal = Math.max(0, Math.min(100, sliderVal));
      }
      
      paramsHTML += `
        <div class="param-control">
          <div class="param-label">
            <span>${param}</span>
            <span class="param-value" data-fx-id="${fx.id}" data-param="${param}">${config.format(value)}</span>
          </div>
          <input type="range" min="0" max="100" value="${sliderVal}" 
                 data-fx-id="${fx.id}" 
                 data-param="${param}"
                 data-fx-type="${fx.type}"
                 class="fx-param-slider">
        </div>
      `;
    });
    
    fxSlot.innerHTML = `
      <div class="fx-header">
        <div class="fx-name">${fx.type.toUpperCase()}</div>
        <div style="display: flex; gap: var(--space-2); align-items: center;">
          <div class="fx-toggle ${fx.enabled ? 'active' : ''}" data-fx-id="${fx.id}"></div>
          <button class="btn btn-ghost btn-sm" data-action="remove-fx" data-fx-id="${fx.id}">âœ•</button>
        </div>
      </div>
      ${paramsHTML}
    `;
    
    slots.appendChild(fxSlot);
  });
  
  // Attach listeners AFTER all DOM is ready
  setTimeout(() => {
    // Toggle switches
    slots.querySelectorAll('.fx-toggle').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const fxId = parseFloat(toggle.dataset.fxId);
        track.toggleFx(fxId);
        renderFxChain(track);
      });
    });
    
    // Remove buttons
    slots.querySelectorAll('[data-action="remove-fx"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const fxId = parseFloat(btn.dataset.fxId);
        if (confirm('Remove this effect?')) {
          track.removeFx(fxId);
          renderFxChain(track);
        }
      });
    });
    
    // Parameter sliders with proper mapping
    slots.querySelectorAll('.fx-param-slider').forEach(slider => {
      slider.addEventListener('input', (e) => {
        const fxId = parseFloat(e.target.dataset.fxId);
        const param = e.target.dataset.param;
        const fxType = e.target.dataset.fxType;
        const sliderPercent = parseInt(e.target.value, 10);
        
        const fx = track.fxChain.find(f => f.id === fxId);
        if (!fx) return;
        
        const typeConfig = {
          reverb: {
            decay: { min: 0.1, max: 10 },
            wet: { min: 0, max: 1 }
          },
          delay: {
            time: { options: ['16n', '8n', '4n', '2n', '1n'] },
            feedback: { min: 0, max: 0.9 },
            wet: { min: 0, max: 1 }
          },
          chorus: {
            frequency: { min: 0.1, max: 10 },
            delayTime: { min: 2, max: 20 },
            depth: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          distortion: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          saturation: {
            amount: { min: 0, max: 1 },
            wet: { min: 0, max: 1 }
          },
          filter: {
            type: { options: ['lowpass', 'highpass', 'bandpass'] },
            frequency: { min: 20, max: 20000 },
            q: { min: 0.1, max: 10 }
          },
          compressor: {
            threshold: { min: -60, max: 0 },
            ratio: { min: 1, max: 20 },
            attack: { min: 0.001, max: 1 },
            release: { min: 0.01, max: 1 }
          },
          eq: {
            low: { min: -24, max: 24 },
            mid: { min: -24, max: 24 },
            high: { min: -24, max: 24 }
          },
          bitcrusher: {
            bits: { min: 1, max: 16 }
          }
        };
        
        const config = typeConfig[fxType]?.[param];
        if (!config) return;
        
        let value;
        
        if (config.options) {
          // Discrete options
          const index = Math.round((sliderPercent / 100) * (config.options.length - 1));
          value = config.options[index];
        } else {
          // Continuous value
          value = config.min + (sliderPercent / 100) * (config.max - config.min);
        }
        
        track.updateFxParam(fxId, param, value);
        
        // Update display
        const label = e.target.closest('.param-control').querySelector('.param-value');
        if (label) {
          if (param === 'decay' || param === 'frequency' || param === 'delayTime') {
            label.textContent = typeof value === 'number' ? value.toFixed(1) : value;
            if (param === 'decay') label.textContent += 's';
            if (param === 'frequency') label.textContent += 'Hz';
            if (param === 'delayTime') label.textContent += 'ms';
          } else if (param === 'wet' || param === 'feedback' || param === 'depth' || param === 'amount') {
            label.textContent = Math.round(value * 100) + '%';
          } else if (param === 'threshold' || param === 'low' || param === 'mid' || param === 'high') {
            label.textContent = (value > 0 ? '+' : '') + Math.round(value) + 'dB';
          } else if (param === 'ratio') {
            label.textContent = value.toFixed(1) + ':1';
          } else if (param === 'attack' || param === 'release') {
            label.textContent = (value * 1000).toFixed(param === 'attack' ? 1 : 0) + 'ms';
          } else if (param === 'bits') {
            label.textContent = Math.round(value) + ' bits';
          } else if (param === 'q') {
            label.textContent = value.toFixed(1);
          } else {
            label.textContent = value.toString();
          }
        }
      });
    });
  }, 0);
}

// Open take editor for a track
function openTakeEditor(trackId) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) return;
  
  if (track.takes.length === 0) {
    showToast('âŒ No takes to edit', 'error');
    return;
  }
  
  // Create modal
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '9999';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '700px';
  
  let takesHTML = '';
  track.takes.forEach((take, idx) => {
    const isSelected = idx === track.selectedTakeIndex;
    takesHTML += `
      <div class="take-region ${isSelected ? 'selected' : ''} ${take.muted ? 'muted' : ''}" 
           style="margin-bottom: var(--space-3); padding: var(--space-4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="flex: 1;">
            <div style="font-weight: 800; font-size: var(--text-base); margin-bottom: var(--space-2);">
              Take ${idx + 1} ${isSelected ? '(Active)' : ''}
            </div>
            <div style="font-size: var(--text-sm); color: var(--text-tertiary);">
              ${take.duration.toFixed(2)}s â€¢ ${new Date(take.timestamp).toLocaleString()}
            </div>
          </div>
          <div style="display: flex; gap: var(--space-2);">
            <button class="btn btn-secondary btn-sm" data-action="play-take" data-index="${idx}">
              â–¶ï¸ Play
            </button>
            <button class="btn btn-secondary btn-sm" data-action="select-take" data-index="${idx}">
              ${isSelected ? 'âœ“ Active' : 'Set Active'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="toggle-mute-take" data-index="${idx}">
              ${take.muted ? 'ðŸ”‡ Unmute' : 'ðŸ”Š Mute'}
            </button>
            <button class="btn btn-secondary btn-sm" data-action="export-take" data-index="${idx}">
              ðŸ’¾
            </button>
            <button class="btn btn-ghost btn-sm" data-action="delete-take" data-index="${idx}">
              ðŸ—‘ï¸
            </button>
          </div>
        </div>
      </div>
    `;
  });
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Edit Takes: ${track.name}</div>
      <button class="modal-close">âœ•</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: var(--space-4); padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-md);">
        <div style="font-size: var(--text-sm); color: var(--text-secondary);">
          <strong>${track.takes.length}</strong> take${track.takes.length !== 1 ? 's' : ''} recorded
        </div>
      </div>
      ${takesHTML}
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary close-btn">Close</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const close = () => {
    backdrop.remove();
    renderMultitrack();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.close-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
  
  // Handle take actions
  modal.querySelectorAll('[data-action]').forEach(btn => {
    btn.addEventListener('click', () => {
      const action = btn.dataset.action;
      const index = parseInt(btn.dataset.index);
      
      if (action === 'play-take') {
        track.playTake(index);
      } else if (action === 'select-take') {
        track.selectTake(index);
        close();
      } else if (action === 'toggle-mute-take') {
        track.toggleTakeMute(index);
        close();
      } else if (action === 'export-take') {
        track.exportTake(index);
      } else if (action === 'delete-take') {
        if (confirm('Delete this take?')) {
          track.deleteTake(index);
          if (track.takes.length === 0) {
            close();
          } else {
            close();
          }
        }
      }
    });
  });
}

function openWaveformEditor(trackId, takeIndex) {
  const track = multitrack.tracks.find(t => t.id === trackId);
  if (!track) {
    console.error('Track not found:', trackId);
    return;
  }
  
  const take = track.takes[takeIndex];
  if (!take || !take.buffer) {
    console.error('Take or buffer not found');
    showToast('âŒ Cannot edit: invalid take', 'error');
    return;
  }
  
  // Remove any existing modal
  document.querySelectorAll('.modal-backdrop').forEach(m => m.remove());
  
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.zIndex = '10000';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '900px';
  modal.style.maxHeight = '90vh';
  
  const buffer = take.buffer;
  const duration = buffer.duration;
  
  modal.innerHTML = `
    <div class="modal-header">
      <div class="modal-title">âœ‚ï¸ Waveform Editor: ${track.name} - Take ${takeIndex + 1}</div>
      <button class="modal-close">âœ•</button>
    </div>
    
    <div class="modal-body" style="overflow: visible;">
      <div style="margin-bottom: var(--space-4);">
        <canvas id="waveformCanvas" 
                width="800" 
                height="200" 
                style="width: 100%; height: 200px; background: var(--glass-bg); border-radius: var(--radius-md); border: 1px solid var(--glass-border); cursor: crosshair;">
        </canvas>
      </div>
      
      <div class="grid grid-2" style="margin-bottom: var(--space-4);">
        <div class="param-control">
          <div class="param-label">
            <span>Trim Start</span>
            <span class="param-value" id="trimStartValue">0.00s</span>
          </div>
          <input type="range" id="trimStartSlider" min="0" max="100" value="0" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Trim End</span>
            <span class="param-value" id="trimEndValue">${duration.toFixed(2)}s</span>
          </div>
          <input type="range" id="trimEndSlider" min="0" max="100" value="100" step="0.1">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade In</span>
            <span class="param-value" id="fadeInValue">0ms</span>
          </div>
          <input type="range" id="fadeInSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Fade Out</span>
            <span class="param-value" id="fadeOutValue">0ms</span>
          </div>
          <input type="range" id="fadeOutSlider" min="0" max="1000" value="0" step="10">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Gain</span>
            <span class="param-value" id="gainValue">0dB</span>
          </div>
          <input type="range" id="gainSlider" min="-24" max="24" value="0" step="0.5">
        </div>
        
        <div class="param-control">
          <div class="param-label">
            <span>Reverse</span>
            <span class="param-value"></span>
          </div>
          <label style="display: flex; align-items: center; gap: var(--space-2);">
            <input type="checkbox" id="reverseCheckbox">
            <span style="font-size: var(--text-sm);">Reverse audio</span>
          </label>
        </div>
      </div>
      
      <div style="display: flex; gap: var(--space-3); margin-bottom: var(--space-4); flex-wrap: wrap;">
        <button class="btn btn-secondary" id="previewEditBtn">â–¶ï¸ Preview</button>
        <button class="btn btn-secondary" id="normalizeBtn">ðŸ“Š Normalize</button>
        <button class="btn btn-ghost" id="resetEditsBtn">â†» Reset</button>
      </div>
      
      <div style="padding: var(--space-3); background: var(--glass-bg); border-radius: var(--radius-sm); font-size: var(--text-sm); color: var(--text-tertiary);">
        <strong>Original:</strong> ${duration.toFixed(2)}s â€¢ 
        <strong>After edits:</strong> <span id="editedDurationLabel">${duration.toFixed(2)}s</span>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-secondary cancel-edit-btn">Cancel</button>
      <button class="btn btn-success apply-edit-btn">âœ… Apply Changes</button>
    </div>
  `;
  
  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');
  
  // Editor state
  const editorState = {
    trimStart: 0,
    trimEnd: duration,
    fadeIn: 0,
    fadeOut: 0,
    gain: 0,
    reverse: false
  };
  
  // Draw waveform function
  function drawWaveform() {
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const channelData = buffer.getChannelData(0);
    const step = Math.ceil(channelData.length / width);
    const amp = height / 2;
    
    // Draw waveform
    ctx.fillStyle = 'rgba(124, 131, 255, 0.3)';
    ctx.strokeStyle = 'rgb(124, 131, 255)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;
      
      for (let j = 0; j < step; j++) {
        const index = (i * step) + j;
        if (index < channelData.length) {
          const datum = channelData[index];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
      }
      
      const x = i;
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      
      ctx.fillRect(x, yMin, 1, Math.max(1, yMax - yMin));
    }
    
    // Draw trim markers
    const startX = (editorState.trimStart / duration) * width;
    const endX = (editorState.trimEnd / duration) * width;
    
    // Grayed out regions
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    if (startX > 0) ctx.fillRect(0, 0, startX, height);
    if (endX < width) ctx.fillRect(endX, 0, width - endX, height);
    
    // Trim lines
    ctx.strokeStyle = 'var(--warning)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, 0);
    ctx.lineTo(startX, height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(endX, 0);
    ctx.lineTo(endX, height);
    ctx.stroke();
    
    // Fade curves
    if (editorState.fadeIn > 0) {
      const fadeInDuration = editorState.fadeIn / 1000;
      const fadeInX = startX + (fadeInDuration / duration) * width;
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX, height);
      ctx.lineTo(Math.min(fadeInX, endX), 0);
      ctx.stroke();
    }
    
    if (editorState.fadeOut > 0) {
      const fadeOutDuration = editorState.fadeOut / 1000;
      const fadeOutX = endX - (fadeOutDuration / duration) * width;
      ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(Math.max(fadeOutX, startX), 0);
      ctx.lineTo(endX, height);
      ctx.stroke();
    }
  }
  
  // Initial draw
  setTimeout(() => drawWaveform(), 0);
  
  // Get controls
  const trimStartSlider = document.getElementById('trimStartSlider');
  const trimEndSlider = document.getElementById('trimEndSlider');
  const fadeInSlider = document.getElementById('fadeInSlider');
  const fadeOutSlider = document.getElementById('fadeOutSlider');
  const gainSlider = document.getElementById('gainSlider');
  const reverseCheckbox = document.getElementById('reverseCheckbox');
  
  function updateEditedDuration() {
    const newDuration = Math.max(0, editorState.trimEnd - editorState.trimStart);
    document.getElementById('editedDurationLabel').textContent = newDuration.toFixed(2) + 's';
  }
  
  // Trim start
  trimStartSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimStart = percent * duration;
    editorState.trimStart = Math.min(editorState.trimStart, editorState.trimEnd - 0.01);
    document.getElementById('trimStartValue').textContent = editorState.trimStart.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Trim end
  trimEndSlider.addEventListener('input', (e) => {
    const percent = parseFloat(e.target.value) / 100;
    editorState.trimEnd = percent * duration;
    editorState.trimEnd = Math.max(editorState.trimEnd, editorState.trimStart + 0.01);
    document.getElementById('trimEndValue').textContent = editorState.trimEnd.toFixed(2) + 's';
    updateEditedDuration();
    drawWaveform();
  });
  
  // Fade in
  fadeInSlider.addEventListener('input', (e) => {
    editorState.fadeIn = parseInt(e.target.value);
    document.getElementById('fadeInValue').textContent = editorState.fadeIn + 'ms';
    drawWaveform();
  });
  
  // Fade out
  fadeOutSlider.addEventListener('input', (e) => {
    editorState.fadeOut = parseInt(e.target.value);
    document.getElementById('fadeOutValue').textContent = editorState.fadeOut + 'ms';
    drawWaveform();
  });
  
  // Gain
  gainSlider.addEventListener('input', (e) => {
    editorState.gain = parseFloat(e.target.value);
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
  });
  
  // Reverse
  reverseCheckbox.addEventListener('change', (e) => {
    editorState.reverse = e.target.checked;
  });
  
  // Preview button
  let previewPlayer = null;
  document.getElementById('previewEditBtn').addEventListener('click', async () => {
    try {
      if (previewPlayer) {
        previewPlayer.stop();
        previewPlayer.dispose();
      }
      
      showToast('â³ Rendering preview...', 'info');
      const editedBuffer = await applyEdits(buffer, editorState);
      
      previewPlayer = new Tone.Player(editedBuffer).toDestination();
      await Tone.start();
      previewPlayer.start();
      
      showToast('â–¶ï¸ Previewing edits', 'info');
      
      setTimeout(() => {
        if (previewPlayer) {
          previewPlayer.stop();
          previewPlayer.dispose();
          previewPlayer = null;
        }
      }, editedBuffer.duration * 1000 + 100);
      
    } catch (err) {
      console.error('Preview failed:', err);
      showToast(`âŒ Preview failed: ${err.message}`, 'error');
    }
  });
  
  // Normalize button
  document.getElementById('normalizeBtn').addEventListener('click', () => {
    let peak = 0;
    for (let c = 0; c < buffer.numberOfChannels; c++) {
      const data = buffer.getChannelData(c);
      for (let i = 0; i < data.length; i++) {
        const abs = Math.abs(data[i]);
        if (abs > peak) peak = abs;
      }
    }
    
    if (peak === 0) {
      showToast('âš ï¸ Audio is silent, cannot normalize', 'warning');
      return;
    }
    
    const targetPeak = 0.891; // -1dB
    const gainDb = 20 * Math.log10(targetPeak / peak);
    
    gainSlider.value = gainDb.toFixed(1);
    editorState.gain = parseFloat(gainDb.toFixed(1));
    const sign = editorState.gain > 0 ? '+' : '';
    document.getElementById('gainValue').textContent = sign + editorState.gain.toFixed(1) + 'dB';
    
    showToast(`âœ… Normalized: ${gainDb.toFixed(1)}dB gain`, 'success');
  });
  
  // Reset button
  document.getElementById('resetEditsBtn').addEventListener('click', () => {
    editorState.trimStart = 0;
    editorState.trimEnd = duration;
    editorState.fadeIn = 0;
    editorState.fadeOut = 0;
    editorState.gain = 0;
    editorState.reverse = false;
    
    trimStartSlider.value = 0;
    trimEndSlider.value = 100;
    fadeInSlider.value = 0;
    fadeOutSlider.value = 0;
    gainSlider.value = 0;
    reverseCheckbox.checked = false;
    
    document.getElementById('trimStartValue').textContent = '0.00s';
    document.getElementById('trimEndValue').textContent = duration.toFixed(2) + 's';
    document.getElementById('fadeInValue').textContent = '0ms';
    document.getElementById('fadeOutValue').textContent = '0ms';
    document.getElementById('gainValue').textContent = '0dB';
    
    updateEditedDuration();
    drawWaveform();
    
    showToast('â†» Edits reset', 'info');
  });
  
  // Apply button
  document.querySelector('.apply-edit-btn').addEventListener('click', async () => {
    try {
      showToast('â³ Processing audio...', 'info');
      
      const editedBuffer = await applyEdits(buffer, editorState);
      
      // Create new blob
      const offlineCtx = new OfflineAudioContext(
        editedBuffer.numberOfChannels,
        editedBuffer.length,
        editedBuffer.sampleRate
      );
      
      const source = offlineCtx.createBufferSource();
      source.buffer = editedBuffer;
      source.connect(offlineCtx.destination);
      source.start(0);
      
      const renderedBuffer = await offlineCtx.startRendering();
      const wavData = bufferToWavImproved(renderedBuffer);
      const newBlob = new Blob([wavData], { type: 'audio/wav' });
      
      // Update take
      take.buffer = editedBuffer;
      take.duration = editedBuffer.duration;
      take.blob = newBlob;
      
      backdrop.remove();
      renderMultitrack();
      showToast('âœ… Waveform edited successfully!', 'success');
      
      console.log(`âœ… Edited take ${takeIndex}: ${take.duration.toFixed(2)}s`);
      
    } catch (err) {
      console.error('Edit failed:', err);
      showToast(`âŒ Edit failed: ${err.message}`, 'error');
    }
  });
  
  // Close handlers
  const close = () => {
    if (previewPlayer) {
      previewPlayer.stop();
      previewPlayer.dispose();
    }
    backdrop.remove();
  };
  
  modal.querySelector('.modal-close').onclick = close;
  modal.querySelector('.cancel-edit-btn').onclick = close;
  backdrop.onclick = (e) => {
    if (e.target === backdrop) close();
  };
}

async function applyEdits(buffer, edits) {
  const { trimStart, trimEnd, fadeIn, fadeOut, gain, reverse } = edits;
  
  const sampleRate = buffer.sampleRate;
  const numChannels = buffer.numberOfChannels;
  
  const startSample = Math.floor(trimStart * sampleRate);
  const endSample = Math.floor(trimEnd * sampleRate);
  const newLength = endSample - startSample;
  
  const newBuffer = Tone.context.rawContext.createBuffer(
    numChannels,
    newLength,
    sampleRate
  );
  
  const gainLinear = Tone.dbToGain(gain);
  const fadeInSamples = Math.floor((fadeIn / 1000) * sampleRate);
  const fadeOutSamples = Math.floor((fadeOut / 1000) * sampleRate);
  
  for (let c = 0; c < numChannels; c++) {
    const oldData = buffer.getChannelData(c);
    const newData = newBuffer.getChannelData(c);
    
    for (let i = 0; i < newLength; i++) {
      const oldIndex = reverse ? (endSample - 1 - i) : (startSample + i);
      let sample = oldData[oldIndex] || 0;
      
      // Apply gain
      sample *= gainLinear;
      
      // Apply fade in
      if (i < fadeInSamples) {
        sample *= (i / fadeInSamples);
      }
      
      // Apply fade out
      if (i > newLength - fadeOutSamples) {
        sample *= ((newLength - i) / fadeOutSamples);
      }
      
      newData[i] = sample;
    }
  }
  
  return newBuffer;
}

function setupArrangementDragScroll() {
  const scroll = document.getElementById('dawArrangementScroll');
  if (!scroll || scroll.dataset._dragScrollWired) return;
  scroll.dataset._dragScrollWired = 'true';

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let startScrollLeft = 0;
  let startScrollTop = 0;

  const onMouseDown = (e) => {
    // Only left button
    if (e.button !== 0) return;

    // Don't steal drags from regions / resize handles
    if (e.target.closest('.audio-region') || e.target.closest('.region-resize-handle')) {
      return;
    }

    isDragging = true;
    scroll.classList.add('drag-scroll-active');
    startX = e.clientX;
    startY = e.clientY;
    startScrollLeft = scroll.scrollLeft;
    startScrollTop = scroll.scrollTop;
  };

  const onMouseMove = (e) => {
    if (!isDragging) return;
    e.preventDefault(); // so you don't select text
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    scroll.scrollLeft = startScrollLeft - dx;
    scroll.scrollTop = startScrollTop - dy;
  };

  const endDrag = () => {
    if (!isDragging) return;
    isDragging = false;
    scroll.classList.remove('drag-scroll-active');
  };

  scroll.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', endDrag);
}

// === Sync the timeline ruler with horizontal scroll ===
function syncTimelineRulerToScroll() {
  const arrangementScrollEl = document.getElementById('dawArrangementScroll');
  const ruler = document.getElementById('dawRuler');
  if (!arrangementScrollEl || !ruler) return;

  const offset = arrangementScrollEl.scrollLeft || 0;
  // Slide the ruler to match the arrangementâ€™s horizontal scroll
  ruler.style.transform = `translateX(${-offset}px)`;
}

  
async function setupMultitrackListeners() {
  // Drag-scroll in the arrangement view
  setupArrangementDragScroll();

  // NEW: keep timeline ruler in sync with any horizontal scroll
  const arrangementScrollEl = document.getElementById('dawArrangementScroll');
  if (arrangementScrollEl && !arrangementScrollEl.dataset._rulerSyncWired) {
    arrangementScrollEl.dataset._rulerSyncWired = 'true';
    syncTimelineRulerToScroll();
    arrangementScrollEl.addEventListener('scroll', () => {
      syncTimelineRulerToScroll();
    });
  }

  // === ADD TRACK BUTTON (DESKTOP) ===
  const addTrackBtn = document.getElementById('addTrackBtn');
  if (addTrackBtn && !addTrackBtn.dataset._wired) {
    addTrackBtn.dataset._wired = 'true';
    addTrackBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('ðŸŽšï¸ Add track clicked');
      showAddTrackDialog();
    });
  }

  // === ADD TRACK BUTTON (LEFT PANEL - MOBILE/DESKTOP) ===
  const addTrackBtnLeft = document.getElementById('addTrackBtnLeft');
  if (addTrackBtnLeft && !addTrackBtnLeft.dataset._wired) {
    addTrackBtnLeft.dataset._wired = 'true';
    addTrackBtnLeft.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('ðŸŽšï¸ Add track (left) clicked');
      showAddTrackDialog();
    });
  }

  // === IMPORT STEM BUTTON ===
  // Uses the helper you added earlier; it has its own _wired guard.
  if (typeof setupStemImport === 'function') {
    setupStemImport();
  }

  // === UNDO / REDO ===
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  if (undoBtn && !undoBtn.dataset._wired) {
    undoBtn.dataset._wired = 'true';
    undoBtn.addEventListener('click', () => multitrackHistory.undo());
  }

  if (redoBtn && !redoBtn.dataset._wired) {
    redoBtn.dataset._wired = 'true';
    redoBtn.addEventListener('click', () => multitrackHistory.redo());
  }

  // === LEGACY PREVIEW BUTTON (if still present) ===
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn && !previewBtn.dataset._wired) {
    previewBtn.dataset._wired = 'true';
    previewBtn.onclick = async () => {
      if (previewBtn.textContent.includes('Stop')) {
        stopMultitrackPreview();
        previewBtn.textContent = 'â–¶ï¸ Preview Mix';
      } else {
        await previewMultitrack(multitrack.playheadSeconds || 0);
        previewBtn.textContent = 'â¹ï¸ Stop Preview';
      }
    };
  }

  // === RECORD-ARM ALL ===
  const recordArmedBtn = document.getElementById('recordArmedBtn');
  if (recordArmedBtn && !recordArmedBtn.dataset._wired) {
    recordArmedBtn.dataset._wired = 'true';
    recordArmedBtn.onclick = async () => await toggleRecordAllArmed();
  }

  // === DAW TRANSPORT CONTROLS ===
  const playBtn    = document.getElementById('dawPlayBtn');
  const stopBtn    = document.getElementById('dawStopBtn');
  const rewindBtn  = document.getElementById('dawRewindBtn');
  const forwardBtn = document.getElementById('dawForwardBtn');
  const recordBtn  = document.getElementById('dawRecordBtn');

  if (playBtn && !playBtn.dataset._wired) {
    playBtn.dataset._wired = 'true';
    playBtn.onclick = async () => {
      if (playBtn.textContent.trim() === 'â–¶ï¸') {
        // â–¶ï¸ PLAY â†’ start / resume from current playhead
        playBtn.textContent = 'â¸ï¸';
        await previewMultitrack(multitrack.playheadSeconds || 0);
      } else {
        // â¸ï¸ PAUSE â†’ stop audio but keep position for resume
        playBtn.textContent = 'â–¶ï¸';
  
        // Use Tone.now() since we're not using Tone.Transport
        const elapsed = Tone.now() - (multitrack.lastStartTime || 0);
  
        // Update playhead to the new paused position
        multitrack.playheadSeconds = (multitrack.playheadSeconds || 0) + elapsed;
        multitrack.isPaused = true;
  
        // Stop playback but do NOT reset to start
        stopMultitrackPreview(false);
  
        // Store for resume consistency
        multitrack.lastPauseTime = multitrack.playheadSeconds;
      }
    };
  }

  if (stopBtn && !stopBtn.dataset._wired) {
    stopBtn.dataset._wired = 'true';
    stopBtn.onclick = () => {
      // STOP â†’ full reset to 0
      if (playBtn) playBtn.textContent = 'â–¶ï¸';
      stopMultitrackPreview(true); // resetToZero = true
      updatePlayheadAndScroll(0);  // visually + timecode reset
    };
  }

  if (rewindBtn && !rewindBtn.dataset._wired) {
    rewindBtn.dataset._wired = 'true';
    rewindBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target  = Math.max(0, current - 5);
      updatePlayheadAndScroll(target);
    };
  }

  if (forwardBtn && !forwardBtn.dataset._wired) {
    forwardBtn.dataset._wired = 'true';
    forwardBtn.onclick = () => {
      const projDur = multitrack.projectDuration || (state.duration * 60);
      const current = multitrack.playheadSeconds || 0;
      const target  = Math.min(projDur, current + 5);
      updatePlayheadAndScroll(target);
    };
  }

  if (recordBtn && !recordBtn.dataset._wired) {
    recordBtn.dataset._wired = 'true';
    recordBtn.onclick = () => {
      recordBtn.classList.toggle('active');
      if (recordBtn.classList.contains('active')) {
        startGlobalRecording();
      } else {
        stopGlobalRecording();
      }
    };
  }

  // === LOOP / CLICK / COUNT-IN ===
  const loopBtn    = document.getElementById('dawLoopBtn');
  const clickBtn   = document.getElementById('dawClickBtn');
  const countInBtn = document.getElementById('dawCountInBtn');

  if (typeof multitrack.loopEnabled === 'undefined') {
    multitrack.loopEnabled = false;
  }

  if (loopBtn && !loopBtn.dataset._wired) {
    loopBtn.dataset._wired = 'true';
    loopBtn.classList.toggle('active', !!multitrack.loopEnabled);
    loopBtn.onclick = () => {
      multitrack.loopEnabled = !multitrack.loopEnabled;
      loopBtn.classList.toggle('active', multitrack.loopEnabled);
      showToast(
        multitrack.loopEnabled
          ? 'ðŸ” Loop Enabled (multitrack preview)'
          : 'â¹ï¸ Loop Disabled',
        'info'
      );
    };
  }

  if (clickBtn && !clickBtn.dataset._wired) {
    clickBtn.dataset._wired = 'true';
    clickBtn.onclick = () => {
      state.metronomeEnabled = !state.metronomeEnabled;
      clickBtn.classList.toggle('active', state.metronomeEnabled);
      showToast(
        state.metronomeEnabled ? 'ðŸ¥ Click: On' : 'ðŸ¥ Click: Off',
        'info'
      );
    };
  }

  if (countInBtn && !countInBtn.dataset._wired) {
    countInBtn.dataset._wired = 'true';

    const labels = [
      'â±ï¸ Count: Off',
      'â±ï¸ Count: 1 bar',
      'â±ï¸ Count: 2 bars'
    ];

    const updateCountLabel = () => {
      const idx = Math.max(0, Math.min(2, state.countInBars || 0));
      countInBtn.textContent = labels[idx];
      countInBtn.classList.toggle('active', state.countInBars > 0);
      showToast(
        state.countInBars === 0
          ? 'â±ï¸ Count-in OFF'
          : `â±ï¸ Count-in: ${state.countInBars} bar(s)`,
        'info'
      );
    };

    countInBtn.onclick = () => {
      // 0 â†’ 1 â†’ 2 â†’ 0
      if (!state.countInBars) state.countInBars = 0;
      state.countInBars = state.countInBars === 0 ? 1 :
                          state.countInBars === 1 ? 2 : 0;
      updateCountLabel();
    };

    updateCountLabel();
  }

  // === LOOP REGION SELECTION (drag in empty timeline) ===
  const scrollEl      = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');

  if (scrollEl && loopHighlight && !scrollEl.dataset._loopWired) {
    scrollEl.dataset._loopWired = 'true';

    let dragStartX = null;

    scrollEl.addEventListener('scroll', () => {
      updateLoopRegionHighlight && updateLoopRegionHighlight();
    });

    scrollEl.addEventListener('mousedown', (e) => {
      // Only left-click + Select tool
      if (e.button !== 0) return;
      if (multitrack.currentTool !== 'select') return;

      // Ignore dragging on a region/clip
      if (e.target.closest('.audio-region') || e.target.closest('.daw-clip')) return;

      const rect = scrollEl.getBoundingClientRect();
      dragStartX = e.clientX - rect.left + scrollEl.scrollLeft;

      loopHighlight.style.display = 'block';
      loopHighlight.style.left = dragStartX + 'px';
      loopHighlight.style.width = '0px';
    });

    scrollEl.addEventListener('mousemove', (e) => {
      if (dragStartX === null) return;

      const rect = scrollEl.getBoundingClientRect();
      const currentX = e.clientX - rect.left + scrollEl.scrollLeft;
      const width    = currentX - dragStartX;

      loopHighlight.style.width = Math.abs(width) + 'px';
      loopHighlight.style.left  = (width < 0 ? currentX : dragStartX) + 'px';
    });

    const finishLoopDrag = (e) => {
      if (dragStartX === null) return;

      const rect     = scrollEl.getBoundingClientRect();
      const dragEndX = e.clientX - rect.left + scrollEl.scrollLeft;
      const zoom     = multitrack.zoom || 100;

      const startPx   = Math.min(dragStartX, dragEndX);
      const endPx     = Math.max(dragStartX, dragEndX);
      const startSec  = startPx / zoom;
      const endSec    = endPx / zoom;
      const dragLen   = endSec - startSec;

      loopHighlight.style.display = 'none';
      dragStartX = null;

      if (dragLen > 0.25) {
        setLoopRegion(startSec, endSec);
      } else {
        clearLoopRegion();
      }
    };

    scrollEl.addEventListener('mouseup', finishLoopDrag);
    scrollEl.addEventListener('mouseleave', (e) => {
      if (dragStartX !== null) finishLoopDrag(e);
    });
  }

  // === BPM + TIME SIG ===
  const bpmInput      = document.getElementById('dawBpmInput');
  const timeSigSelect = document.getElementById('dawTimeSigSelect');

  if (bpmInput && !bpmInput.dataset._wired) {
    bpmInput.dataset._wired = 'true';
    bpmInput.onchange = (e) => setBPM(parseFloat(e.target.value));
  }

  if (timeSigSelect && !timeSigSelect.dataset._wired) {
    timeSigSelect.dataset._wired = 'true';
    timeSigSelect.onchange = (e) => setTimeSignature(e.target.value);
  }

  // === ZOOM CONTROLS ===
  const zoomInBtn   = document.getElementById('dawZoomInBtn')  || document.getElementById('zoomInBtn');
  const zoomOutBtn  = document.getElementById('dawZoomOutBtn') || document.getElementById('zoomOutBtn');
  const zoomFitBtn  = document.getElementById('dawZoomFitBtn') || document.getElementById('zoomFitBtn');
  const zoomLabelEl = document.getElementById('dawZoomLevel');

  const updateZoomLabel = () => {
    if (zoomLabelEl) {
      // Rough % based on 100px/s baseline
      const pct = Math.round((multitrack.zoom || 100) / 100 * 100);
      zoomLabelEl.textContent = pct + '%';
    }
  };

  const applyZoom = (factor) => {
    multitrack.zoom = Math.max(20, Math.min(500, (multitrack.zoom || 100) * factor));
    renderMultitrack();
    updateZoomLabel();
    showToast(`ðŸ” Zoom: ${Math.round(multitrack.zoom)}px/s`, 'info');
  };

  if (zoomInBtn && !zoomInBtn.dataset._wired) {
    zoomInBtn.dataset._wired = 'true';
    zoomInBtn.onclick = () => applyZoom(1.5);
  }

  if (zoomOutBtn && !zoomOutBtn.dataset._wired) {
    zoomOutBtn.dataset._wired = 'true';
    zoomOutBtn.onclick = () => applyZoom(1 / 1.5);
  }

  if (zoomFitBtn && !zoomFitBtn.dataset._wired) {
    zoomFitBtn.dataset._wired = 'true';
    zoomFitBtn.onclick = () => {
      let maxDuration = 0;
      multitrack.tracks.forEach(t => {
        t.takes.forEach(take => {
          const end = (take.startTime || 0) + take.duration;
          if (end > maxDuration) maxDuration = end;
        });
      });
      if (maxDuration > 0) {
        const canvasWidth = 800; // simple baseline
        multitrack.zoom = canvasWidth / maxDuration;
        renderMultitrack();
        updateZoomLabel();
        showToast('âœ… Zoom to fit', 'success');
      }
    };
  }

  updateZoomLabel();

  // === TOOL BUTTONS (Select / Pencil / Split / Fade) ===
  const toolButtons = document.querySelectorAll('.tool-btn');
  if (toolButtons.length) {
    toolButtons.forEach(btn => {
      if (btn.dataset._wired) return;
      btn.dataset._wired = 'true';

      btn.addEventListener('click', () => {
        const tool = btn.dataset.tool || 'select';
        multitrack.currentTool = tool;

        toolButtons.forEach(b =>
          b.classList.toggle('active', b === btn)
        );

        showToast(`âœï¸ Tool: ${tool}`, 'info');
      });
    });
  }

  // === SNAP ===
  const snapSelect = document.getElementById('dawSnapSelect');
  if (snapSelect && !snapSelect.dataset._wired) {
    snapSelect.dataset._wired = 'true';

    const snapMapping = {
      bar: 4,      // 4 beats per bar (4/4)
      beat: 1,     // quarter-note
      '1/8': 0.5,  // eighth-note
      '1/16': 0.25,
      '1/32': 0.125
    };

    snapSelect.addEventListener('change', (e) => {
      const value = e.target.value;

      if (value === 'off') {
        multitrack.snapEnabled = false;
        showToast('ðŸ§² Snap OFF', 'info');
      } else {
        multitrack.snapEnabled = true;
        multitrack.snapMode    = value;
        multitrack.snapInterval = snapMapping[value] ?? 1;
        showToast(`ðŸ§² Snap: ${value}`, 'info');
      }
    });

    // Default: bar snap
    if (!snapSelect.value || snapSelect.value === 'off') {
      snapSelect.value = 'bar';
    }
    // Initialize immediately
    snapSelect.dispatchEvent(new Event('change'));
  }

  // === SESSION MANAGEMENT ===
  const newBtn  = document.getElementById('newSessionBtn');
  const saveBtn = document.getElementById('saveSessionBtn');
  const loadBtn = document.getElementById('loadSessionBtn');

  if (newBtn && !newBtn.dataset._wired) {
    newBtn.dataset._wired = 'true';
    newBtn.onclick = () => newMultitrackSession();
  }

  if (saveBtn && !saveBtn.dataset._wired) {
    saveBtn.dataset._wired = 'true';
    saveBtn.onclick = () => saveMultitrackSession();
  }

  if (loadBtn && !loadBtn.dataset._wired) {
    loadBtn.dataset._wired = 'true';
    loadBtn.onclick = () => loadMultitrackSession();
  }

  // === GRID / AUTOMATION ===
  const gridBtn = document.getElementById('dawGridBtn');
  const autoBtn = document.getElementById('dawAutomationBtn');

  if (gridBtn && !gridBtn.dataset._wired) {
    gridBtn.dataset._wired = 'true';
    gridBtn.onclick = () => toggleGrid();
  }

  if (autoBtn && !autoBtn.dataset._wired) {
    autoBtn.dataset._wired = 'true';
    autoBtn.onclick = () => toggleAutomationView();
  }

  // === BOUNCE / CLEAR ===
  const bounceBtn = document.getElementById('bounceAllBtn');
  if (bounceBtn && !bounceBtn.dataset._wired) {
    bounceBtn.dataset._wired = 'true';
    bounceBtn.onclick = () => bounceAllTracks();
  }

  const clearBtn = document.getElementById('clearAllTracksBtn');
  if (clearBtn && !clearBtn.dataset._wired) {
    clearBtn.dataset._wired = 'true';
    clearBtn.onclick = () => {
      if (confirm('Delete all tracks? This cannot be undone.')) {
        multitrack.tracks.forEach(t => t.dispose());
        multitrack.tracks = [];
        multitrack.nextTrackId = 1;
        renderMultitrack();
      }
    };
  }

  // === FX CHAIN EDITOR (inline version) ===
  const fxPanel    = document.getElementById('fxChainPanel');
  const fxAddList  = document.getElementById('fxAddList');
  const closeFxBtn = document.getElementById('closeFxPanelBtn');
  if (fxAddList && !fxAddList.dataset._wired) {
    fxAddList.dataset._wired = 'true';
    fxAddList.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-fx]');
      if (!btn) return;
      const fxType = btn.dataset.fx;
      const trackId = multitrack.currentFxTrackId;
      const track = multitrack.tracks.find(t => t.id === trackId);
      if (!track) {
        showToast('âš ï¸ Click a track\'s FX button first', 'warning');
        return;
      }
      try {
        track.addFx(fxType);
        renderFxChain(track);
        showToast(`âœ¨ Added ${fxType} to ${track.name}`, 'success');  // â† FIXED THIS LINE
      } catch (err) {
        console.error('Error adding FX:', err);
        showToast('âŒ Could not add effect', 'error');
      }
    });
  }
  if (closeFxBtn && !closeFxBtn.dataset._wired) {
    closeFxBtn.dataset._wired = 'true';
    closeFxBtn.onclick = () => {
      if (fxPanel) {
        fxPanel.classList.remove('open');
        fxPanel.setAttribute('aria-hidden', 'true');
      }
    };
  }

  initFAB();
}
  
function addTrackFX(trackIndex, fxType) {
  const trackStrip = document.querySelectorAll('.track-strip')[trackIndex];
  let fxPanel = trackStrip.querySelector('.track-fx-panel');
  
  if (!fxPanel) {
    fxPanel = document.createElement('div');
    fxPanel.className = 'track-fx-panel';
    fxPanel.innerHTML = `
      <div class="fx-chain-mini">
        <button class="btn btn-sm btn-primary add-fx-btn">+ Add FX</button>
        <div class="fx-slots-inline"></div>
      </div>
    `;
    trackStrip.appendChild(fxPanel);
  }
  
  fxPanel.style.display = 'block';
  
  const fxSlots = fxPanel.querySelector('.fx-slots-inline');
  const fxUnit = document.createElement('div');
  fxUnit.className = 'fx-unit-mini';
  fxUnit.innerHTML = `
    <span>${fxType}</span>
    <div class="fx-toggle" onclick="this.classList.toggle('active')"></div>
    <button class="fx-remove-btn" onclick="this.parentElement.remove()">Ã—</button>
  `;
  
  fxSlots.appendChild(fxUnit);
}
  
// Utility
function updatePlayheadUI(seconds) {
  const el = document.getElementById('dawPlayhead');
  if (!el) return;
  const dur = multitrack.projectDuration || (state.duration * 60);
  el.style.left = `${(seconds / dur) * 100}%`;
}
  
// -------------------- Preset System --------------------
function renderPresets() {
  const grid = document.getElementById('sidebarPresets');
  const fragment = document.createDocumentFragment();
  
  Object.keys(genrePresets).forEach(genre => {
    const preset = genrePresets[genre];
    const div = document.createElement('div');
    div.className = 'sidebar-preset';
    div.innerHTML = `
      <div class="sidebar-preset-icon">${preset.icon}</div>
      <div class="sidebar-preset-name">${preset.name}</div>
    `;
    div.addEventListener('click', () => {
      loadPreset(genre);
      closeSidebar();
    });
    fragment.appendChild(div);
  });
  
  grid.innerHTML = '';
  grid.appendChild(fragment);
}

function loadPreset(genre) {
  state.currentGenre = genre;
  document.querySelectorAll('.genre-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.genre === genre);
  });
  generateBeat();
}

function updateGenrePresets() {
  songBuilderState.isActive = false;
  renderPresets();
}

// -------------------- Transport Controls --------------------

// keep this near top of file so it's globally available
let harmonyCycle = null;

function startHarmonyCycle() {
  if (harmonyCycle) return; // already running
  let barIndex = 0;

  harmonyCycle = Tone.Transport.scheduleRepeat((time) => {
    if (state.progression && state.progression.length > 0) {
      state.currentChord = state.progression[barIndex % state.progression.length];
      barIndex++;
    }
  }, `${state.timeSignature || 4}m`); // one chord per bar
}

function stopHarmonyCycle() {
  if (harmonyCycle) {
    Tone.Transport.clear(harmonyCycle);
    harmonyCycle = null;
  }
}

async function togglePlay() {
  try {
    await Tone.start();
    const raw = Tone.getContext().rawContext;
    if (raw.state !== 'running') await raw.resume();
  } catch (e) {
    console.error('Could not start audio:', e);
    alert('Could not start audio. Click anywhere on the page, then press Play again.');
    return;
  }

  if (state.isPlaying) {
    // ðŸŸ¡ Pause
    Tone.Transport.pause();
    state.pausedAt = Tone.Transport.seconds;
    state.isPlaying = false;
    document.getElementById('playBtn').innerHTML = 'â–¶ï¸ Play';
    stopTimer();
    stopVisualizer();
    stopPlayheadAnimation();
    stopHarmonyCycle();              // â¹ï¸ stop chord cycling
    return;
  }

  // ðŸŸ¢ Check for active steps
  const hasActive = Object.keys(patterns).some(inst =>
    patterns[inst].some(s => s.active)
  );
  if (!hasActive) {
    alert('No active notes â€” click "Generate Beat" or add steps.');
    return;
  }

  // ðŸŸ¢ Resume playback
  const resumeTime = state.pausedAt || 0;
  Tone.Transport.seconds = resumeTime;
  Tone.Transport.start();

  startHarmonyCycle();               // ðŸŽ¼ begin chord progression cycling

  state.isPlaying = true;
  state.startTime = performance.now() - (resumeTime * 1000);
  document.getElementById('playBtn').innerHTML = 'â¸ï¸ Pause';
  startTimer();
  startPlayheadAnimation();
  document.getElementById('vizOverlay').style.display = 'none';
  updateVisualizer();
}

function stop() {
  // ðŸ”´ Full stop
  Tone.Transport.stop();
  state.isPlaying = false;
  state.pausedAt = 0;
  state.currentStep = 0;
  document.getElementById('playBtn').innerHTML = 'â–¶ï¸ Play';
  document.getElementById('timeDisplay').textContent = '00:00';
  document.getElementById('progressFill').style.width = '0%';
  document.querySelectorAll('.step').forEach(el => el.classList.remove('playing'));
  stopTimer();
  stopVisualizer();
  stopPlayheadAnimation();

  const playhead = document.getElementById('dawPlayhead');
  if (playhead) playhead.style.left = '0px';

  stopHarmonyCycle();                // â¹ï¸ ensure progression stops

  stopMultitrackPreview();
  const previewBtn = document.getElementById('previewMultitrackBtn');
  if (previewBtn) previewBtn.textContent = 'â–¶ï¸ Preview Mix';
}

// -------------------- Timer System --------------------
let progressRAF = 0;

function startTimer() {
  cancelAnimationFrame(progressRAF);
  
  const totalSeconds = state.duration * 60;
  const updateProgress = throttle(() => {
    const seconds = Tone.Transport.seconds;
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    
    document.getElementById('timeDisplay').textContent = 
      String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
    
    document.getElementById('progressFill').style.width = 
      Math.min(100, (seconds / totalSeconds) * 100) + '%';
  }, CONFIG.PROGRESS_UPDATE_MS);
  
  const tick = () => {
    updateProgress();
    progressRAF = requestAnimationFrame(tick);
  };
  
  progressRAF = requestAnimationFrame(tick);
}

function stopTimer() {
  cancelAnimationFrame(progressRAF);
  progressRAF = 0;
}

// -------------------- Visualizer System --------------------
let visualizerRAF = 0;
let lastVisualizerUpdate = 0;

function initVisualizerOnce() {
  const viz = document.getElementById('visualizer');
  if (viz.dataset.ready) return;
  
  viz.dataset.ready = '1';
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < CONFIG.VISUALIZER_BARS; i++) {
    const bar = document.createElement('div');
    bar.className = 'viz-bar';
    bar.style.left = (i * 100 / CONFIG.VISUALIZER_BARS) + '%';
    bar.style.height = '10%';
    fragment.appendChild(bar);
  }
  
  viz.appendChild(fragment);
}

function updateVisualizer() {
  if (state.isSongBuilding) return;
  if (visualizerRAF) return;
  
  const viz = document.getElementById('visualizer');
  const bars = viz ? viz.querySelectorAll('.viz-bar') : [];
  const barCount = bars.length || 0;
  
  const updateInterval = 1000 / CONFIG.VISUALIZER_FPS;
  
  const loop = (timestamp) => {
    visualizerRAF = requestAnimationFrame(loop);
    
    if (!lastVisualizerUpdate || (timestamp - lastVisualizerUpdate) >= updateInterval) {
      lastVisualizerUpdate = timestamp;
      
      let heights;
      if (master.analyser) {
        const values = master.analyser.getValue();
        heights = new Array(barCount).fill(0).map((_, i) => {
          const index = Math.floor((i / barCount) * values.length);
          const value = values[clamp(index, 0, values.length - 1)];
          
          if (master.analyser.type === 'fft') {
            const db = clamp(value, -100, 0);
            const normalized = (db + 100) / 100;
            return (5 + normalized * 90).toFixed(1) + '%';
          } else {
            const normalized = (value + 1) / 2;
            return (5 + normalized * 90).toFixed(1) + '%';
          }
        });
      } else {
        heights = Array.from({ length: barCount }, () => 
          (Math.random() * 60 + 10).toFixed(1) + '%'
        );
      }
      
      bars.forEach((bar, i) => {
        bar.style.height = heights[i];
        bar.style.transform = '';
      });
    }
  };
  
  visualizerRAF = requestAnimationFrame(loop);
}

function stopVisualizer() {
  cancelAnimationFrame(visualizerRAF);
  visualizerRAF = 0;
}

// -------------------- Project Management --------------------
function getSerializableInstruments() {
  const keep = ['name', 'icon', 'mute', 'solo', 'volume', 'pan', 'type', 'note'];
  const cleaned = {};
  
  Object.keys(instruments).forEach(key => {
    cleaned[key] = {};
    keep.forEach(field => {
      cleaned[key][field] = instruments[key][field];
    });
  });
  
  return cleaned;
}

async function saveProject() {
  const projectName = document.getElementById('projectName').value || 'Untitled';
  
  showToast('ðŸ’¾ Saving project (with all audio)...', 'info');
  
  // Serialize patterns
  const plainPatterns = {};
  Object.keys(patterns).forEach(inst => {
    plainPatterns[inst] = patterns[inst].map(step => ({
      active: !!step.active,
      velocity: step.velocity ?? 0.8,
      probability: step.probability ?? 100,
      note: step.note ?? instruments[inst].note ?? null,
      duration: step.duration ?? '8n'
    }));
  });
  
  // Serialize FX config
  const fxState = {};
  Object.keys(fxConfig).forEach(fx => {
    fxState[fx] = { ...fxConfig[fx] };
  });
  
  // Serialize multitrack WITH AUDIO
  const multitrackData = {
    tracks: [],
    nextTrackId: multitrack.nextTrackId,
    zoom: multitrack.zoom,
    snapEnabled: multitrack.snapEnabled,
    snapInterval: multitrack.snapInterval
  };
  
  // Convert audio blobs to base64 for each track
  for (const track of multitrack.tracks) {
    const trackData = {
      id: track.id,
      name: track.name,
      instrument: track.instrument,
      isExternalAudio: track.isExternalAudio,
      volume: track.volume,
      pan: track.pan,
      muted: track.muted,
      soloed: track.soloed,
      armed: track.armed,
      inputMonitoring: track.inputMonitoring,
      selectedTakeIndex: track.selectedTakeIndex,
      fxChain: track.fxChain.map(fx => ({
        type: fx.type,
        params: fx.params,
        enabled: fx.enabled
      })),
      takes: []
    };
    
    // Convert each take's audio blob to base64
    for (const take of track.takes) {
      try {
        const base64Audio = await blobToBase64(take.blob);
        
        trackData.takes.push({
          id: take.id,
          duration: take.duration,
          timestamp: take.timestamp,
          muted: take.muted,
          startTime: take.startTime,
          trimStart: take.trimStart,
          trimEnd: take.trimEnd,
          recordedAt: take.recordedAt,
          audioData: base64Audio,
          mimeType: take.blob.type
        });
      } catch (err) {
        console.error(`Failed to encode take ${take.id}:`, err);
      }
    }
    
    multitrackData.tracks.push(trackData);
  }
  
  const project = {
    version: '2.1', // Increment for complete state save
    name: projectName,
    state: {
      bpm: state.bpm,
      swing: state.swing,
      duration: state.duration,
      complexity: state.complexity,
      humanize: state.humanize,
      sequenceLength: state.sequenceLength,
      resolution: state.resolution,
      currentGenre: state.currentGenre,
      key: state.key,
      scale: state.scale,
      octave: state.octave,
      progression: state.progression,
      masterVolume: state.masterVolume,
      tapeSaturation: state.tapeSaturation,
      vinylNoise: state.vinylNoise,
      lowCut: state.lowCut,
      highCut: state.highCut,
      compressor: state.compressor,
      metronomeEnabled: state.metronomeEnabled,
      metronomeVolume: state.metronomeVolume,
      countInBars: state.countInBars,
      aiMixing: state.aiMixing
    },
    patterns: plainPatterns,
    instruments: getSerializableInstruments(),
    fxConfig: fxState,
    multitrack: multitrackData,
    timestamp: Date.now(),
    savedVibe: document.body.getAttribute('data-vibe')
  };
  
  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  
  const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
  
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${projectName.replace(/\s+/g, '_')}_${Date.now()}.8beat.json`;
  link.click();
  
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  console.log(`ðŸ’¾ Full project saved: ${projectName} (${sizeMB}MB)`);
  showToast(`âœ… Complete project saved! (${sizeMB}MB with ${multitrackData.tracks.length} tracks)`, 'success');
}

// Helper function to convert Blob to Base64
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      // Remove the data URL prefix (e.g., "data:audio/webm;base64,")
      const base64 = reader.result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert Base64 back to Blob
function base64ToBlob(base64, mimeType) {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

function applyLoadedInstruments(loaded) {
  Object.keys(loaded).forEach(inst => {
    const source = loaded[inst];
    if (!instruments[inst]) return;
    
    instruments[inst].mute = !!source.mute;
    instruments[inst].solo = !!source.solo;
    instruments[inst].volume = source.volume ?? instruments[inst].volume;
    instruments[inst].pan = source.pan ?? instruments[inst].pan;
    instruments[inst].note = source.note ?? instruments[inst].note;
    
    if (instruments[inst].channel) {
      instruments[inst].channel.volume.value = instruments[inst].volume;
      instruments[inst].channel.pan.value = (instruments[inst].pan || 0) / 100;
    }
  });
}

function loadProject() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.8beat.json';
  
  input.onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async ev => {
      try {
        const project = JSON.parse(ev.target.result);
        
        console.log('ðŸ“‚ Loading project:', project.name, 'version:', project.version);
        showToast('â³ Loading complete project...', 'info');
        
        // Stop playback
        if (state.isPlaying) {
          stop();
        }
        
        // Load ALL state
        Object.assign(state, {
          ...state,
          ...project.state,
          isPlaying: false,
          currentStep: 0
        });
        
        // Load patterns
        Object.keys(patterns).forEach(k => delete patterns[k]);
        Object.assign(patterns, project.patterns || {});
        
        // Load instruments
        if (project.instruments) {
          applyLoadedInstruments(project.instruments);
        }
        
        // Load FX config
        if (project.fxConfig) {
          Object.assign(fxConfig, project.fxConfig);
        }
        
        // Load vibe/theme
        if (project.savedVibe) {
          applyVibe(project.savedVibe);
        }
        
        // Load multitrack
        if (project.multitrack) {
          multitrack.tracks.forEach(t => t.dispose());
          multitrack.tracks = [];
          
          multitrack.zoom = project.multitrack.zoom || 100;
          multitrack.snapEnabled = project.multitrack.snapEnabled ?? true;
          multitrack.snapInterval = project.multitrack.snapInterval || 0.25;
          
          for (const trackData of project.multitrack.tracks) {
            const track = new AudioTrack(
              trackData.id,
              trackData.name,
              trackData.instrument,
              trackData.isExternalAudio
            );
            
            track.volume = trackData.volume;
            track.pan = trackData.pan;
            track.muted = trackData.muted;
            track.soloed = trackData.soloed;
            track.armed = trackData.armed;
            track.inputMonitoring = trackData.inputMonitoring || false;
            track.selectedTakeIndex = trackData.selectedTakeIndex;
            
            track.channel.volume.value = track.volume;
            track.channel.pan.value = track.pan / 100;
            
            // Restore FX chain
            if (trackData.fxChain && trackData.fxChain.length > 0) {
              trackData.fxChain.forEach(fxData => {
                track.addFx(fxData.type, fxData.params);
                const fx = track.fxChain[track.fxChain.length - 1];
                if (fx) {
                  fx.enabled = fxData.enabled;
                }
              });
            }
            
            // Restore takes with audio
            if (trackData.takes && trackData.takes.length > 0) {
              showToast(`ðŸŽµ Restoring ${trackData.takes.length} take(s) for ${track.name}...`, 'info');
              
              for (const takeData of trackData.takes) {
                try {
                  const blob = base64ToBlob(takeData.audioData, takeData.mimeType);
                  const arrayBuffer = await blob.arrayBuffer();
                  const audioBuffer = await Tone.context.rawContext.decodeAudioData(arrayBuffer);
                  
                  const take = {
                    id: takeData.id,
                    buffer: audioBuffer,
                    blob: blob,
                    duration: takeData.duration,
                    timestamp: takeData.timestamp,
                    muted: takeData.muted,
                    startTime: takeData.startTime,
                    trimStart: takeData.trimStart,
                    trimEnd: takeData.trimEnd,
                    recordedAt: takeData.recordedAt
                  };
                  
                  track.takes.push(take);
                  console.log(`âœ… Restored take ${take.id} (${take.duration.toFixed(2)}s)`);
                  
                } catch (err) {
                  console.error(`Failed to restore take ${takeData.id}:`, err);
                }
              }
            }
            
            multitrack.tracks.push(track);
          }
          
          multitrack.nextTrackId = project.multitrack.nextTrackId;
        }
        
        // Update ALL displays
        updateAllDisplays();
        ensurePatternLength(state.sequenceLength);
        
        // Set genre selector
        if (state.currentGenre) {
          document.querySelectorAll('.genre-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.genre === state.currentGenre);
          });
        }
        
        // Update BPM in transport
        Tone.Transport.bpm.value = state.bpm;
        Tone.Transport.swing = state.swing / 100;
        
        renderSequencer();
        renderMixer();
        renderFX();
        renderHarmony();
        renderMultitrack();
        
        document.getElementById('projectName').value = project.name || 'Untitled';
        
        const totalTakes = multitrack.tracks.reduce((sum, t) => sum + t.takes.length, 0);
        console.log('âœ… Complete project loaded successfully');
        showToast(`âœ… Project loaded: ${totalTakes} recording(s), ${multitrack.tracks.length} tracks!`, 'success');
        
      } catch (err) {
        console.error('âŒ Load project error:', err);
        showToast('âŒ Error loading project: ' + err.message, 'error');
      }
    };
    
    reader.readAsText(file);
  };
  
  input.click();
}

// Keep transport + simple UI in sync with state.bpm / state.swing
function syncTempoControlsFromState() {
  // --- Main transport (Pro UI) ---
  const bpmSlider    = document.getElementById('bpmSlider');
  const bpmValue     = document.getElementById('bpmValue');
  const swingSlider  = document.getElementById('swingSlider');
  const swingValue   = document.getElementById('swingValue');

  if (bpmSlider) bpmSlider.value = state.bpm;
  if (bpmValue)  bpmValue.textContent = String(state.bpm);

  if (swingSlider) swingSlider.value = state.swing;
  if (swingValue)  swingValue.textContent = `${state.swing}%`;

  // --- Simple Mode controls ---
  const simpBpm        = document.getElementById('simpBpm');
  const simpBpmSlider  = document.getElementById('simpBpmSlider');
  const simpSwing      = document.getElementById('simpSwing');

  if (simpBpm)       simpBpm.value = state.bpm;
  if (simpBpmSlider) simpBpmSlider.value = state.bpm;
  if (simpSwing)     simpSwing.value = state.swing;
}

function updateAllDisplays() {
  state.bpm = Math.min(CONFIG.MAX_BPM, state.bpm);
  
  document.getElementById('bpmSlider').value = state.bpm;
  document.getElementById('bpmValue').textContent = state.bpm;
  document.getElementById('swingSlider').value = state.swing;
  document.getElementById('swingValue').textContent = state.swing + '%';
  document.getElementById('durSlider').value = state.duration;
  document.getElementById('durValue').textContent = state.duration + ' min';
  document.getElementById('durationDisplay').textContent = 
    '/ ' + String(state.duration).padStart(2, '0') + ':00';
  document.getElementById('complexSlider').value = state.complexity;
  document.getElementById('complexValue').textContent = 
    ['Simple', 'Medium', 'Complex'][state.complexity - 1];
  document.getElementById('humanSlider').value = state.humanize;
  document.getElementById('humanValue').textContent = state.humanize + 'ms';
  
  Tone.Transport.bpm.value = state.bpm;
  Tone.Transport.swing = state.swing / 100;
  Tone.Transport.swingSubdivision = '8n';
}

// -------------------- Audio Export --------------------
function bufferToWav(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = clamp(channels[c][i], -1, 1);
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

async function exportAudio() {
  // Live recording only - captures real-time output
  await exportLiveRecording();
}

// Improved WAV converter with peak normalization
function bufferToWavImproved(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const numFrames = audioBuffer.length;
  const bytesPerSample = 2;
  
  // Find peak for normalization
  let peak = 0;
  for (let c = 0; c < numChannels; c++) {
    const channelData = audioBuffer.getChannelData(c);
    for (let i = 0; i < numFrames; i++) {
      const abs = Math.abs(channelData[i]);
      if (abs > peak) peak = abs;
    }
  }
  
  // Calculate normalization factor (leave 1dB headroom)
  const targetPeak = 0.891; // -1dB
  const normFactor = peak > 0 ? Math.min(targetPeak / peak, 1) : 1;
  
  console.log(`ðŸŽšï¸ Normalizing: peak=${peak.toFixed(3)}, factor=${normFactor.toFixed(3)}`);
  
  const dataSize = numFrames * numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  
  let offset = 0;
  
  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset++, str.charCodeAt(i));
    }
  }
  
  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }
  
  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }
  
  // WAV header
  writeString('RIFF');
  writeUint32(36 + dataSize);
  writeString('WAVE');
  
  // fmt chunk
  writeString('fmt ');
  writeUint32(16);
  writeUint16(1); // PCM
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample);
  writeUint16(numChannels * bytesPerSample);
  writeUint16(16);
  
  // data chunk
  writeString('data');
  writeUint32(dataSize);
  
  // Interleave samples with normalization
  const channels = [];
  for (let c = 0; c < numChannels; c++) {
    channels.push(audioBuffer.getChannelData(c));
  }
  
  for (let i = 0; i < numFrames; i++) {
    for (let c = 0; c < numChannels; c++) {
      let sample = channels[c][i] * normFactor;
      sample = Math.max(-1, Math.min(1, sample)); // Hard clip
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  
  return new Uint8Array(buffer);
}

// Live recording - captures what you hear in real-time
async function exportLiveRecording() {
  // if we're already recording, this call means "stop & download"
  if (master.mediaRecorder && master.mediaRecorder.state === 'recording') {
    master.mediaRecorder.stop();
    return;
  }

  await Tone.start();

  const stream = master.mediaDest?.stream;
  if (!stream) {
    alert('âŒ No recording stream available.');
    return;
  }

  let mimeType = '';
  if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
    mimeType = 'audio/webm;codecs=opus';
  } else if (MediaRecorder.isTypeSupported('audio/webm')) {
    mimeType = 'audio/webm';
  }

  master.recordedChunks = [];
  const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
  master.mediaRecorder = rec;

  rec.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) {
      master.recordedChunks.push(e.data);
    }
  };

  rec.onstop = () => {
    const blob = new Blob(master.recordedChunks, {
      type: rec.mimeType || 'audio/webm'
    });

    const name = (document.getElementById('projectName')?.value || 'live_mix')
      .replace(/\s+/g, '_') + `_${Date.now()}`;

    let ext = 'webm';
    if ((rec.mimeType || '').includes('ogg')) ext = 'ogg';

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.${ext}`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    const btn = document.getElementById('exportBtn');
    if (btn) btn.textContent = 'ðŸŽ§ DJ Export';
    
    showToast('âœ… Live mix exported!', 'success');
  };

  rec.start();

  const btn = document.getElementById('exportBtn');
  if (btn) btn.textContent = 'â¹ï¸ Stop Recording';
  
  showToast('ðŸŽ™ï¸ Recording live output...', 'info');
}

function updateLoopRegionHighlight() {
  const scroll = document.getElementById('dawArrangementScroll');
  const loopHighlight = document.getElementById('loopRegionHighlight');
  if (!scroll || !loopHighlight) return;

  const zoom = multitrack.zoom || 100;
  const { loopStart, loopEnd } = multitrack;

  const hasRegion =
    typeof loopStart === 'number' &&
    typeof loopEnd === 'number' &&
    loopEnd > loopStart;

  if (!hasRegion) {
    loopHighlight.style.display = 'none';
    return;
  }

  const startPx = loopStart * zoom;
  const widthPx = (loopEnd - loopStart) * zoom;

  loopHighlight.style.display = 'block';
  // because loopHighlight lives inside the scroll container,
  // we compensate for scrollLeft so it lines up with content
  loopHighlight.style.left = (startPx - scroll.scrollLeft) + 'px';
  loopHighlight.style.width = widthPx + 'px';
}

function setLoopRegion(startSeconds, endSeconds) {
  if (typeof startSeconds !== 'number' || typeof endSeconds !== 'number') {
    showToast('âš ï¸ Invalid loop region.', 'warning');
    return;
  }
  if (endSeconds <= startSeconds) {
    showToast('âš ï¸ Loop end must be after start.', 'warning');
    return;
  }
  multitrack.loopStart = startSeconds;
  multitrack.loopEnd = endSeconds;
  updateLoopRegionHighlight();
  showToast(`ðŸ” Loop set: ${startSeconds.toFixed(2)}s â†’ ${endSeconds.toFixed(2)}s`, 'info');
}

function clearLoopRegion() {
  multitrack.loopStart = null;
  multitrack.loopEnd = null;
  updateLoopRegionHighlight();
  showToast('â¹ï¸ Loop region cleared.', 'info');
}

// -------------------- PWA Installation --------------------
let deferredPrompt;

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBtn').hidden = false;
});

document.getElementById('installBtn').addEventListener('click', async () => {
  if (!deferredPrompt) return;
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  
  if (outcome === 'accepted') {
    document.getElementById('installBtn').hidden = true;
  }
  
  deferredPrompt = null;
});

function checkSamplesLoaded() {
  const drumInsts = Object.keys(instruments).filter(k => instruments[k].type === 'drum');
  const totalDrums = drumInsts.length;
  let loadedCount = 0;
  let lastLoggedCount = -1;
  
  const checkInterval = setInterval(() => {
    loadedCount = 0;
    const statusList = [];
    
    drumInsts.forEach(inst => {
      const synth = synths[inst];
      if (synth && synth.loaded) {
        loadedCount++;
        statusList.push(`âœ… ${inst}`);
      } else {
        statusList.push(`â³ ${inst}`);
      }
    });
    
    // Only log when count changes
    if (loadedCount !== lastLoggedCount) {
      console.log(`ðŸ“¦ Drum samples: ${loadedCount}/${totalDrums}`);
      console.log(statusList.join(', '));
      lastLoggedCount = loadedCount;
    }
    
    if (loadedCount === totalDrums) {
      clearInterval(checkInterval);
      console.log('âœ… All drum samples ready!');
      document.getElementById('vizOverlay').textContent = 'All Samples Loaded - Generate & Press Play';
    }
  }, 500);
  
  // Stop checking after 15 seconds
  setTimeout(() => {
    clearInterval(checkInterval);
    if (loadedCount < totalDrums) {
      console.warn(`âš ï¸ Only ${loadedCount}/${totalDrums} samples loaded after timeout`);
      console.warn('Missing samples:', drumInsts.filter(inst => !synths[inst]?.loaded));
    }
  }, 15000);
}

// -------------------- Sidebar Controls --------------------
function openSidebar() {
  document.getElementById('sidebarNav').classList.add('open');
  document.getElementById('sidebarBackdrop').classList.add('open');
  document.body.style.overflow = 'hidden';
}

function closeSidebar() {
  document.getElementById('sidebarNav').classList.remove('open');
  document.getElementById('sidebarBackdrop').classList.remove('open');
  document.body.style.overflow = '';
}

function toggleSidebar() {
  const nav = document.getElementById('sidebarNav');
  if (nav.classList.contains('open')) {
    closeSidebar();
  } else {
    openSidebar();
  }
}

const LICENSE_API_URL = 'https://script.google.com/macros/s/AKfycbxnQHpQ-oym0WbITYsj3xzu-U6sHRcSKMlziMYAdcPfxquo8bvPL3H6sC3wApm2_1x1/exec'; // no query string

function mapLicenseError(code) {
  switch (code) {
    case 'missing_parameters':
      return 'Missing email or license key.';
    case 'license_not_found':
      return 'License key not found. Double-check your key.';
    case 'license_inactive':
      return 'This license is inactive. Contact support.';
    case 'email_mismatch':
      return 'Email does not match the purchase email.';
    case 'otp_invalid_or_expired':
      return 'Code invalid or expired. Request a new one.';
    case 'device_limit':
      return 'This license is already used on the maximum number of devices.';
    case 'invalid_token':
      return 'Your license token is invalid. Please activate again.';
    case 'device_mismatch':
      return 'This token belongs to a different device.';
    case 'license_server':
    case 'server_error':
      return 'Server error. Please try again in a minute.';
    default:
      return `Unknown error (${code || 'no code'}).`;
  }
}

function isPro() {
  return localStorage.getItem('8beat.pro') === 'true';
}

function getSavedLicenseKey() {
  return localStorage.getItem('8beat.licenseKey') || '';
}

// --- Compact validator: true/false only ---
async function validateLicenseKey(key) {
  const ADMIN_KEYS = [];
  const k = (key || '').trim();
  if (!k) return false;

  // instant unlock for admin keys
  if (ADMIN_KEYS.includes(k)) return true;

  // JSONP call to Apps Script
  return new Promise((resolve) => {
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    let done = false;

    const cleanup = () => {
      if (done) return;
      done = true;
      try { delete window[cb]; } catch (e) {}
      try { s.remove(); } catch (e) {}
    };

    window[cb] = (resp) => {
      cleanup();
      console.log('[license] backend response:', resp);
      resolve(!!(resp && resp.valid));
    };

    const s = document.createElement('script');
    s.src = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(k)}&callback=${cb}`;
    (document.head || document.documentElement).appendChild(s);

    // failsafe timeout
    setTimeout(() => { cleanup(); resolve(false); }, 8000);
  });
}

// --- Detailed validator: returns full JSON ---
async function validateLicenseKeyDetailed(key) {
  const k = (key || '').trim();
  if (!k) return { valid: false };

  return new Promise((resolve) => {
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    let done = false;

    const cleanup = () => {
      if (done) return;
      done = true;
      try { delete window[cb]; } catch (e) {}
      try { s.remove(); } catch (e) {}
    };

    window[cb] = (resp) => {
      cleanup();
      console.log('[license] backend response (detailed):', resp);
      resolve(resp || { valid: false });
    };

    const s = document.createElement('script');
    s.src = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(k)}&callback=${cb}`;
    (document.head || document.documentElement).appendChild(s);

    // failsafe timeout
    setTimeout(() => { cleanup(); resolve({ valid: false, timeout: true }); }, 8000);
  });
}

// One place to verify + persist + flip UI (Pro/Admin)
async function verifyAndUnlock(key, { silent = false } = {}) {
  const resp = await validateLicenseKeyDetailed(key);
  if (!resp || !resp.valid) {
    if (!silent && window.showToast) showToast('âŒ Invalid or inactive license key');
    return false;
  }

  // Persist
  localStorage.setItem('8beat.licenseKey', key);
  localStorage.setItem('8beat.pro', 'true');
  if (resp.type === 'admin') {
    localStorage.setItem('8beat.admin', 'true');
    document.body.classList.add('admin');
  }

  // UI
  enableProFeatures(); // reuse your existing unlocker
  if (!silent && window.showToast) {
    if (resp.justValidated) {
      showToast('âœ… License verified');
    } else {
      showToast(resp.type === 'admin' ? 'ðŸ”“ Admin unlocked' : 'ðŸ”“ Pro unlocked');
    }
  }
  return true;
}

// ===== Robust activation param reader (handles search + hash routers) =====
function extractActivationKeyFromUrl() {
  try {
    const u = new URL(location.href);

    // Case A: normal query string â†’ /?activate=KEY
    const direct = u.searchParams.get('activate');
    if (direct) return direct;

    // Case B: SPA/hash router â†’ /#/?activate=KEY or /#/home?activate=KEY
    const h = u.hash || '';
    if (h) {
      const qIndex = h.indexOf('?');
      if (qIndex !== -1) {
        const qs = new URLSearchParams(h.slice(qIndex + 1));
        const hk = qs.get('activate');
        if (hk) return hk;
      }
      // Fallback: loose regex if the hash is oddly formatted
      const m = /(?:\?|&)activate=([^&]+)/.exec(h);
      if (m) return decodeURIComponent(m[1]);
    }
  } catch (e) {
    console.warn('[license] URL parse error', e);
  }
  return null;
}

// ===== Auto-activate early (before router/UI mounts) =====
(async function autoActivateFromUrl() {
  const key = extractActivationKeyFromUrl();
  if (!key) return;
  // Just cache it so the modal shows it
  localStorage.setItem('8beat.licenseKey', key);
  showToast?.('License key detected. Enter your purchase email and request the code.', 'info');
  // Clean URL after
  const u = new URL(location.href);
  if (u.search) history.replaceState({}, document.title, u.pathname + u.hash);
  else if (u.hash) history.replaceState({}, document.title, u.pathname + u.hash.replace(/\?.*$/, ''));
})();
  
function enableProFeatures() {
  document.body.classList.add('pro');

  // Unlock sidebar tabs
  document.querySelectorAll('.sidebar-tab.locked').forEach(btn => {
    btn.classList.remove('locked');
  });

  // Remove "pro-locked" overlays on content panels
  document.querySelectorAll('.pro-locked').forEach(el => {
    el.classList.remove('pro-locked');
  });
}

// --- Ensure modal is visible even in Simple Mode ---
function ensureUnlockModalInBody() {
  const modal = document.getElementById('unlockModal');
  if (!modal) return null;
  if (modal.parentElement !== document.body) {
    document.body.appendChild(modal);      // move out of hidden sidebar
    modal.classList.add('modal-portal');   // optional styling hook
  }
  return modal;
}

function jsonp(endpoint, params = {}, timeoutMs = 10000) {
  return new Promise((resolve, reject) => {
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    const s = document.createElement('script');
    let done = false;

    params = { ...params, action: endpoint, callback: cb };
    const qs = Object.entries(params)
      .map(([k,v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v==null?'':v)}`)
      .join('&');

    window[cb] = (resp) => { cleanup(); resolve(resp); };

    const cleanup = () => {
      if (done) return;
      done = true;
      try { delete window[cb]; } catch(e){}
      try { s.remove(); } catch(e){}
    };

    s.src = `${LICENSE_API_URL}?${qs}`;
    (document.head || document.documentElement).appendChild(s);

    setTimeout(() => { cleanup(); reject(new Error('JSONP timeout')); }, timeoutMs);
  });
}

function deviceId() {
  let id = localStorage.getItem('8beat.deviceId');
  if (!id) {
    const bytes = new Uint8Array(16);
    (window.crypto || window.msCrypto).getRandomValues(bytes);
    id = 'dev_' + Array.from(bytes).map(b=>('0'+b.toString(16)).slice(-2)).join('');
    localStorage.setItem('8beat.deviceId', id);
  }
  return id;
}

function initLicenseUI() {
  const modal      = document.getElementById('unlockModal');
  const inputKey   = document.getElementById('licenseInput');
  const statusEl   = document.getElementById('licenseStatus');
  const confirmBtn = document.getElementById('confirmLicenseBtn');
  const cancelBtn  = document.getElementById('cancelLicenseBtn');

  // Grab BOTH unlock buttons: sidebar + simple mode
  const unlockButtons = Array.from(
    document.querySelectorAll('#unlockProBtn, #simpUnlockProBtn')
  );

  // Guard: if modal basics are missing, bail
  if (!modal || !inputKey || !statusEl || !confirmBtn || !cancelBtn) return;

  // --- Create Email + OTP fields (once) ---
  let emailInput = document.getElementById('licenseEmailInput');
  if (!emailInput) {
    emailInput = document.createElement('input');
    emailInput.id = 'licenseEmailInput';
    emailInput.type = 'email';
    emailInput.placeholder = 'Purchase email (exact)';
    emailInput.className = 'input';
    inputKey.parentElement?.insertBefore(emailInput, inputKey); // above license key
  }

  let otpInput = document.getElementById('licenseOtpInput');
  if (!otpInput) {
    otpInput = document.createElement('input');
    otpInput.id = 'licenseOtpInput';
    otpInput.type = 'text';
    otpInput.placeholder = '6-digit code';
    otpInput.inputMode = 'numeric';
    otpInput.maxLength = 6;
    otpInput.className = 'input';
    inputKey.parentElement?.appendChild(otpInput); // below license key
  }

  let sendCodeBtn = document.getElementById('sendOtpBtn');
  if (!sendCodeBtn) {
    sendCodeBtn = document.createElement('button');
    sendCodeBtn.id = 'sendOtpBtn';
    sendCodeBtn.className = 'btn btn-secondary';
    sendCodeBtn.textContent = 'Send Code';
    // place it just before Confirm
    confirmBtn.parentElement?.insertBefore(sendCodeBtn, confirmBtn);
  }

  // Hide OTP until requested
  otpInput.style.display = 'none';

  // --- Open / Close modal (shared for Pro + Simple) ---
  function openModal() {
    modal.classList.remove('hidden');
    statusEl.textContent = '';
    const savedKey = localStorage.getItem('8beat.licenseKey') || '';
    if (savedKey) inputKey.value = savedKey;

    // If email is already filled, focus key; otherwise focus email
    if (emailInput.value.trim()) {
      inputKey.focus();
    } else {
      emailInput.focus();
    }
  }

  function closeModal() {
    modal.classList.add('hidden');
  }

  // Expose for simple UI if you ever want it globally
  window.__openLicenseModal  = openModal;
  window.__closeLicenseModal = closeModal;

  // --- Wire BOTH unlock buttons (Pro + Simple) ---
  unlockButtons.forEach(btn => {
    if (!btn) return;
    if (btn.dataset._wired) return;
    btn.dataset._wired = '1';
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      openModal();
    });
  });

  // --- Cancel always closes the modal ---
  if (!cancelBtn.dataset._wired) {
    cancelBtn.dataset._wired = '1';
    
    const handleClose = (e) => {
      e.preventDefault();
      e.stopPropagation(); // Prevent event from bubbling to backdrop
      closeModal();
    };
    
    cancelBtn.addEventListener('click', handleClose);
    cancelBtn.addEventListener('touchend', handleClose); // Mobile touch support
  }

  // --- Send OTP (idempotent) ---
  if (!sendCodeBtn.dataset._wired) {
    sendCodeBtn.dataset._wired = '1';
    sendCodeBtn.addEventListener('click', async () => {
      const email = emailInput.value.trim().toLowerCase();
      const key   = inputKey.value.trim();
      if (!email || !key) {
        statusEl.textContent = 'Enter email and key first.';
        return;
      }
      statusEl.textContent = 'Sending codeâ€¦';
      try {
        await requestEmailOtp(email, key); // calls Apps Script ?action=request_otp
        statusEl.textContent = 'Code sent. Check your email.';
        otpInput.style.display = '';
        otpInput.focus();
      } catch (err) {
        console.error(err);
        statusEl.textContent = (err && err.message)
          ? `âŒ ${err.message}`
          : 'âŒ Could not send code.';
      }
    });
  }

  // --- Activate with OTP (override any old Confirm behavior) ---
  confirmBtn.textContent = 'Activate';
  confirmBtn.onclick = null;                 // clear any older handler
  if (!confirmBtn.dataset._wired) {
    confirmBtn.dataset._wired = '1';
    confirmBtn.addEventListener('click', async () => {
      const email = emailInput.value.trim().toLowerCase();
      const key   = inputKey.value.trim();
      const otp   = otpInput.value.trim();
      if (!email || !key || !otp) {
        statusEl.textContent = 'Enter email, key, and code.';
        return;
      }
      statusEl.textContent = 'Activatingâ€¦';
      try {
        await activatePro(email, key, otp);  // calls ?action=activate
        enableProFeatures();
        statusEl.textContent = 'âœ… Pro unlocked on this device.';
        setTimeout(closeModal, 900);
      } catch (err) {
        console.error(err);
        statusEl.textContent = (err && err.message)
          ? `âŒ ${err.message}`
          : 'âŒ Activation failed.';
      }
    });
  }

  // Enter key submits activation
  [emailInput, inputKey, otpInput].forEach(inp => {
    if (!inp.dataset._enter) {
      inp.dataset._enter = '1';
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') confirmBtn.click();
      });
    }
  });

  // If already Pro (from previous activation/token), unlock immediately
  if (localStorage.getItem('8beat.pro') === 'true') {
    enableProFeatures();
  }
}

function gateTabsForFreeUsers() {
  // Tabs free for all users
  const freeTabs = ['generate', 'sequencer'];

  if (!isPro()) {
    document.querySelectorAll('.sidebar-tab').forEach(btn => {
      const tab = btn.getAttribute('data-tab');
      if (!freeTabs.includes(tab)) {
        btn.classList.add('locked');
      } else {
        btn.classList.remove('locked');
      }
    });
  } else {
    // Pro users get everything unlocked
    document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.remove('locked'));
  }
}
  
function isPro() {
  return localStorage.getItem('8beat.pro') === 'true';
}

function getSavedLicenseKey() {
  return localStorage.getItem('8beat.licenseKey') || '';
}

// --- Compact validator: true/false only ---
async function validateLicenseKey(key) {
  const ADMIN_KEYS = [];
  const k = (key || '').trim();
  if (!k) return false;

  // instant unlock for admin keys
  if (ADMIN_KEYS.includes(k)) return true;

  // JSONP call to Apps Script
  return new Promise((resolve) => {
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    let done = false;

    const cleanup = () => {
      if (done) return;
      done = true;
      try { delete window[cb]; } catch (e) {}
      try { s.remove(); } catch (e) {}
    };

    window[cb] = (resp) => {
      cleanup();
      console.log('[license] backend response:', resp);
      resolve(!!(resp && resp.valid));
    };

    const s = document.createElement('script');
    s.src = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(k)}&callback=${cb}`;
    (document.head || document.documentElement).appendChild(s);

    // failsafe timeout
    setTimeout(() => { cleanup(); resolve(false); }, 8000);
  });
}

// --- Detailed validator: returns full JSON ---
async function validateLicenseKeyDetailed(key) {
  const k = (key || '').trim();
  if (!k) return { valid: false };

  return new Promise((resolve) => {
    const cb = 'cb_' + Math.random().toString(36).slice(2);
    let done = false;

    const cleanup = () => {
      if (done) return;
      done = true;
      try { delete window[cb]; } catch (e) {}
      try { s.remove(); } catch (e) {}
    };

    window[cb] = (resp) => {
      cleanup();
      console.log('[license] backend response (detailed):', resp);
      resolve(resp || { valid: false });
    };

    const s = document.createElement('script');
    s.src = `${LICENSE_API_URL}?action=validate&key=${encodeURIComponent(k)}&callback=${cb}`;
    (document.head || document.documentElement).appendChild(s);

    // failsafe timeout
    setTimeout(() => { cleanup(); resolve({ valid: false, timeout: true }); }, 8000);
  });
}

// Tiny JSONP helper for Apps Script
function apiGet(params) {
  return new Promise((resolve, reject) => {
    const cbName = 'licenseCb_' + Math.random().toString(36).slice(2);
    const qs = new URLSearchParams({
      ...params,
      callback: cbName
    });

    const s = document.createElement('script');
    s.src = `${LICENSE_API_URL}?${qs.toString()}`;

    let finished = false;
    function cleanup() {
      if (finished) return;
      finished = true;
      try { delete window[cbName]; } catch (e) {}
      try { s.remove(); } catch (e) {}
    }

    window[cbName] = (resp) => {
      cleanup();
      resolve(resp || {});
    };

    s.onerror = () => {
      cleanup();
      reject(new Error('License server unreachable'));
    };

    (document.head || document.documentElement).appendChild(s);

    setTimeout(() => {
      if (!finished) {
        cleanup();
        reject(new Error('License server timeout'));
      }
    }, 8000);
  });
}


function getDeviceId() {
  let id = localStorage.getItem('8beat.deviceId');
  if (!id) {
    id = 'dev_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    localStorage.setItem('8beat.deviceId', id);
  }
  return id;
}

// --- Step 1: request_otp (email + licenseKey) ---
async function requestEmailOtp(email, key) {
  const resp = await apiGet({
    action: 'request_otp',
    email,
    licenseKey: key
  });

  if (!resp || !resp.ok) {
    // Surface backend error for debugging
    if (resp && resp.error === 'license_not_found') {
      throw new Error('License not found for that key.');
    }
    if (resp && resp.error === 'license_inactive') {
      throw new Error('This license is inactive.');
    }
    if (resp && resp.error === 'email_mismatch') {
      throw new Error('Email does not match the purchase email.');
    }
    throw new Error('Could not send code (server error).');
  }

  return true; // OTP mailed successfully
}

// --- Step 2: activate (OTP + deviceId -> token) ---
async function activatePro(email, key, otp) {
  const resp = await apiGet({
    action: 'activate',
    email,
    licenseKey: key,
    otp,
    deviceId: getDeviceId()
  });

  if (!resp || !resp.ok) {
    // map backend errors to friendly messages
    if (resp && resp.error === 'otp_invalid_or_expired') {
      throw new Error('Code invalid or expired');
    }
    if (resp && resp.error === 'device_limit') {
      throw new Error('This license is already used on too many devices.');
    }
    if (resp && resp.error === 'email_mismatch') {
      throw new Error('Email does not match the purchase email.');
    }
    if (resp && resp.error === 'license_not_found') {
      throw new Error('License not found.');
    }
    if (resp && resp.error === 'license_inactive') {
      throw new Error('This license is inactive.');
    }
    throw new Error('Activation failed (server error).');
  }

  // Save local state
  localStorage.setItem('8beat.pro', 'true');
  localStorage.setItem('8beat.licenseKey', key);
  if (resp.token) {
    localStorage.setItem('8beat.proToken', resp.token);
  }

  window.dispatchEvent(new Event('license:activated'));
  return true;
}

// --- Step 3: on startup, validate existing token (if any) ---
async function validateProTokenIfAny() {
  const token = localStorage.getItem('8beat.proToken') || '';
  if (!token) return false;

  try {
    const resp = await apiGet({
      action: 'validate_token',
      token,
      deviceId: getDeviceId()
    });

    if (!resp || !resp.ok) {
      console.warn('[license] token invalid, clearing');
      localStorage.removeItem('8beat.proToken');
      localStorage.removeItem('8beat.pro');
      return false;
    }

    // If server rotated token, store the new one
    if (resp.token) {
      localStorage.setItem('8beat.proToken', resp.token);
    }

    localStorage.setItem('8beat.pro', 'true');
    return true;
  } catch (err) {
    console.warn('[license] token validation failed:', err);
    return false;
  }
}

// One place to verify + persist + flip UI (Pro/Admin)
async function verifyAndUnlock(key, { silent = false } = {}) {
  const resp = await validateLicenseKeyDetailed(key);
  if (!resp || !resp.valid) {
    if (!silent && window.showToast) showToast('âŒ Invalid or inactive license key');
    return false;
  }

  // Persist
  localStorage.setItem('8beat.licenseKey', key);
  localStorage.setItem('8beat.pro', 'true');
  if (resp.type === 'admin') {
    localStorage.setItem('8beat.admin', 'true');
    document.body.classList.add('admin');
  }

  // UI
  enableProFeatures(); // reuse your existing unlocker
  if (!silent && window.showToast) {
    if (resp.justValidated) {
      showToast('âœ… License verified');
    } else {
      showToast(resp.type === 'admin' ? 'ðŸ”“ Admin unlocked' : 'ðŸ”“ Pro unlocked');
    }
  }
  return true;
}

// ===== Robust activation param reader (handles search + hash routers) =====
function extractActivationKeyFromUrl() {
  try {
    const u = new URL(location.href);

    // Case A: normal query string â†’ /?activate=KEY
    const direct = u.searchParams.get('activate');
    if (direct) return direct;

    // Case B: SPA/hash router â†’ /#/?activate=KEY or /#/home?activate=KEY
    const h = u.hash || '';
    if (h) {
      const qIndex = h.indexOf('?');
      if (qIndex !== -1) {
        const qs = new URLSearchParams(h.slice(qIndex + 1));
        const hk = qs.get('activate');
        if (hk) return hk;
      }
      // Fallback: loose regex if the hash is oddly formatted
      const m = /(?:\?|&)activate=([^&]+)/.exec(h);
      if (m) return decodeURIComponent(m[1]);
    }
  } catch (e) {
    console.warn('[license] URL parse error', e);
  }
  return null;
}

// ===== Auto-activate early (before router/UI mounts) =====
(async function autoActivateFromUrl() {
  const key = extractActivationKeyFromUrl();
  if (!key) return;

  console.log('[license] Found activation key in URL');
  try {
    const ok = await verifyAndUnlock(key, { silent: false });
    if (ok && window.showToast) {
      showToast('âœ… License verified');
    }

    // Clean the URL: remove ?activate from search OR hash
    const u = new URL(location.href);
    if (u.search) {
      history.replaceState({}, document.title, u.pathname + u.hash);
    } else if (u.hash) {
      const cleanedHash = u.hash.replace(/\?.*$/, ''); // strip query inside hash
      history.replaceState({}, document.title, u.pathname + cleanedHash);
    }
  } catch (e) {
    console.error('[license] Auto-activate failed', e);
  }
})();

  
function enableProFeatures() {
  document.body.classList.add('pro');

  // Unlock sidebar tabs
  document.querySelectorAll('.sidebar-tab.locked').forEach(btn => {
    btn.classList.remove('locked');
  });

  // Remove "pro-locked" overlays on content panels
  document.querySelectorAll('.pro-locked').forEach(el => {
    el.classList.remove('pro-locked');
  });
}

function initLicenseUI() {
  const unlockButtons = Array.from(
    document.querySelectorAll('#unlockProBtn, #simpUnlockProBtn')
  );   // exists in Pro sidebar and Simple transport
  
  const modal      = document.getElementById('unlockModal');
  const inputKey   = document.getElementById('licenseInput');
  const statusEl   = document.getElementById('licenseStatus');
  const confirmBtn = document.getElementById('confirmLicenseBtn');
  const cancelBtn  = document.getElementById('cancelLicenseBtn');
  // Basic guard
  if (!modal || !inputKey || !statusEl || !confirmBtn || !cancelBtn) return;
  // --- Create Email + OTP fields (once) ---
  let emailInput = document.getElementById('licenseEmailInput');
  if (!emailInput) {
    emailInput = document.createElement('input');
    emailInput.id = 'licenseEmailInput';
    emailInput.type = 'email';
    emailInput.placeholder = 'Purchase email (exact)';
    emailInput.className = 'input';
    inputKey.parentElement?.insertBefore(emailInput, inputKey); // above license key
  }
  let otpInput = document.getElementById('licenseOtpInput');
  if (!otpInput) {
    otpInput = document.createElement('input');
    otpInput.id = 'licenseOtpInput';
    otpInput.type = 'text';
    otpInput.placeholder = '6-digit code';
    otpInput.inputMode = 'numeric';
    otpInput.maxLength = 6;
    otpInput.className = 'input';
    inputKey.parentElement?.appendChild(otpInput); // below license key
  }
  let sendCodeBtn = document.getElementById('sendOtpBtn');
  if (!sendCodeBtn) {
    sendCodeBtn = document.createElement('button');
    sendCodeBtn.id = 'sendOtpBtn';
    sendCodeBtn.className = 'btn btn-secondary';
    sendCodeBtn.textContent = 'Send Code';
    // place it just before Confirm
    confirmBtn.parentElement?.insertBefore(sendCodeBtn, confirmBtn);
  }
  // Hide OTP until requested
  otpInput.style.display = 'none';
  // --- Open / Close modal (idempotent wiring) ---
  function openModal() {
    modal.classList.remove('hidden');
    statusEl.textContent = '';
    const savedKey = localStorage.getItem('8beat.licenseKey') || '';
    if (savedKey) inputKey.value = savedKey;
    (emailInput.value ? inputKey : emailInput).focus();
  }
  function closeModal() {
    modal.classList.add('hidden');
  }

  // --- Wire BOTH unlock buttons (Pro + Simple) - PUT IT HERE ---
  unlockButtons.forEach(btn => {
    if (!btn) return;
    if (btn.dataset._wired) return;
    btn.dataset._wired = '1';
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      openModal();
    });
  });

  if (!cancelBtn.dataset._wired) {
    cancelBtn.dataset._wired = '1';
  
    const handleClose = (e) => {
      e.preventDefault();
      e.stopPropagation(); // make sure it doesn't bubble to the backdrop
      closeModal();
    };
  
    cancelBtn.addEventListener('click', handleClose);
    cancelBtn.addEventListener('touchend', handleClose); // mobile support
  }

  // --- Send OTP (idempotent) ---
  if (!sendCodeBtn.dataset._wired) {
    sendCodeBtn.dataset._wired = '1';
    sendCodeBtn.addEventListener('click', async () => {
      const email = emailInput.value.trim().toLowerCase();
      const key   = inputKey.value.trim();
      if (!email || !key) {
        statusEl.textContent = 'Enter email and key first.';
        return;
      }
      statusEl.textContent = 'Sending codeâ€¦';
      try {
        await requestEmailOtp(email, key); // calls your Apps Script 'request_otp'
        statusEl.textContent = 'Code sent. Check your email.';
        otpInput.style.display = '';
        otpInput.focus();
      } catch (err) {
        statusEl.textContent = (err && err.message) ? `âŒ ${err.message}` : 'âŒ Could not send code.';
      }
    });
  }
  
  // --- Activate with OTP (override any old Confirm behavior) ---
  confirmBtn.textContent = 'Activate';
  confirmBtn.onclick = null;                 // ensure no stale handlers
  confirmBtn.dataset._wired = '1';
  confirmBtn.addEventListener('click', async () => {
    const email = emailInput.value.trim().toLowerCase();
    const key   = inputKey.value.trim();
    const otp   = otpInput.value.trim();
    if (!email || !key || !otp) {
      statusEl.textContent = 'Enter email, key, and code.';
      return;
    }
    statusEl.textContent = 'Activatingâ€¦';
    try {
      await activatePro(email, key, otp);    // calls your Apps Script 'activate'
      enableProFeatures();
      statusEl.textContent = 'âœ… Pro unlocked on this device.';
      setTimeout(closeModal, 900);
    } catch (err) {
      statusEl.textContent = (err && err.message) ? `âŒ ${err.message}` : 'âŒ Activation failed.';
    }
  });

  // Enter key submits activation when any input focused
  [emailInput, inputKey, otpInput].forEach(inp => {
    if (!inp.dataset._enter) {
      inp.dataset._enter = '1';
      inp.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') confirmBtn.click();
      });
    }
  });

  // If already Pro (from token/previous session), unlock immediately
  if (localStorage.getItem('8beat.pro') === 'true') {
    enableProFeatures();
  }
}

function gateTabsForFreeUsers() {
  // Tabs free for all users
  const freeTabs = ['generate', 'sequencer'];

  if (!isPro()) {
    document.querySelectorAll('.sidebar-tab').forEach(btn => {
      const tab = btn.getAttribute('data-tab');
      if (!freeTabs.includes(tab)) {
        btn.classList.add('locked');
      } else {
        btn.classList.remove('locked');
      }
    });
  } else {
    // Pro users get everything unlocked
    document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.remove('locked'));
  }
}

// Simple in-place normaliser with headroom
function normalizeBufferInPlace(buffer, targetDb = -6) {
  if (!buffer) return;
  const ch = buffer.getChannelData(0);
  if (!ch || !ch.length) return;

  // Find peak
  let peak = 0;
  for (let i = 0; i < ch.length; i++) {
    const v = Math.abs(ch[i]);
    if (v > peak) peak = v;
  }
  if (peak === 0) return;

  const targetLinear = Math.pow(10, targetDb / 20); // dB â†’ linear
  const gain = targetLinear / peak;

  for (let i = 0; i < ch.length; i++) {
    ch[i] *= gain;
  }
}

// High-quality sample synthesis engine (more natural, less buzzy)
class SampleSynthesizer {
  constructor() {
    // Prefer Tone's context so buffers are compatible with the DAW
    const toneCtx =
      (window.Tone && Tone.context && Tone.context.rawContext) ||
      (window.Tone && Tone.context) ||
      null;

    this.audioContext =
      toneCtx || new (window.AudioContext || window.webkitAudioContext)();

    this.currentSource = null;
  }

  // --- small helpers ------------------------------------

  envAD(t, attack, decay) {
    const a = attack > 0 ? Math.min(1, t / attack) : 1;
    const d = Math.exp(-t / Math.max(0.000001, decay));
    return a * d;
  }

  fastSmooth(last, sample, amt) {
    return last + amt * (sample - last);
  }

  applyLoFi(sample, lofi) {
    if (!lofi || lofi <= 0) return sample;
    const depth = 16 - (lofi / 100) * 12; // 16 â†’ 4 bits
    const bitDepth = Math.max(4, depth);
    const steps = Math.pow(2, bitDepth);
    return Math.round(sample * steps) / steps;
  }

  applyDist(sample, dist, driveFactor) {
    if (!dist || dist <= 0) return sample;
    const norm = Math.pow(dist / 100, 1.3);
    const drive = 1 + driveFactor * norm;
    return Math.tanh(sample * drive) / (1 + norm * 1.5);
  }

  // --- DRUMS --------------------------------------------

  // Kick: authentic 808/909-style with proper phase modeling
  generateKick(params = {}) {
    const {
      pitch = 0,
      decay = 0.25,
      tone = 60,
      noise = 10,
      attack = 0.003,
      lofi = 0,
      dist = 5
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.06, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const base = 55 * Math.pow(2, pitch / 12);
    let phase = 0;
    let last = 0;
    const SMOOTH = 0.08;

    const noiseNorm = Math.pow(noise / 100, 2);

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);
      
      // Multi-stage pitch envelope for realistic thump
      const pitchEnv1 = Math.exp(-t * 80);
      const pitchEnv2 = Math.exp(-t * 15);
      const f = base * (1 + 4.5 * pitchEnv1 + 1.2 * pitchEnv2);
      
      // Phase accumulation for cleaner sine generation
      phase += (2 * Math.PI * f) / sr;
      
      const body = Math.sin(phase) * (tone / 100);
      const sub = Math.sin(phase * 0.5) * 0.45;
      
      // Click transient for attack
      const click = Math.sin(phase * 8) * Math.exp(-t * 200) * 0.15;

      // Shaped noise burst
      const nSample = (Math.random() * 2 - 1) * noiseNorm * Math.exp(-t * 120);

      let s = (body * 0.55 + sub * 0.35 + click + nSample * 0.1) * env;

      s = this.applyDist(s, dist, 4);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // Snare: layered approach with realistic shell resonance
  generateSnare(params = {}) {
    const {
      pitch  = 0,
      decay  = 0.15,
      tone   = 50,
      noise  = 70,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.05, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const basePitch = 200 * Math.pow(2, pitch / 12);
  
    // Multi-pole filter for noise (more realistic snare wire sound)
    let noiseHP1 = 0, noiseHP2 = 0;
    let noiseBP = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Shell resonance - multiple partials
      const shell1 = Math.sin(2 * Math.PI * basePitch * t);
      const shell2 = Math.sin(2 * Math.PI * basePitch * 1.47 * t);
      const shell3 = Math.sin(2 * Math.PI * basePitch * 1.89 * t);
      const toneComponent = (shell1 * 0.5 + shell2 * 0.3 + shell3 * 0.2) * (tone / 100);
  
      // Snare wire simulation with bandpass filtering
      const rawNoise = Math.random() * 2 - 1;
      
      // High-pass filter cascade
      noiseHP1 = noiseHP1 + 0.7 * (rawNoise - noiseHP1);
      noiseHP2 = noiseHP2 + 0.7 * (noiseHP1 - noiseHP2);
      
      // Band-emphasis around 3-5kHz
      const hpOut = rawNoise - noiseHP2;
      noiseBP = noiseBP + 0.15 * (hpOut - noiseBP);
      
      const noiseAmount = (noise / 100) * 0.8;
      const noiseComponent = noiseBP * noiseAmount;
  
      // Mix with emphasis on noise body
      let sample = (toneComponent * 0.35 + noiseComponent * 0.65) * envelope;
      
      // Transient click
      sample += Math.sin(2 * Math.PI * basePitch * 4 * t) * Math.exp(-t * 150) * 0.2;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 3)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.9;
    }
  
    return buffer;
  }

  // Hi-hat: metallic resonator model (more realistic cymbal sound)
  generateHihat(params = {}, closed = true) {
    const {
      pitch  = 0,
      decay  = closed ? 0.05 : 0.2,
      tone   = 50,
      noise  = 90,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.02, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const pitchMult = Math.pow(2, pitch / 12);
  
    // Resonator banks for metallic character
    let res1 = 0, res2 = 0, res3 = 0, res4 = 0;
    let noiseState = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Inharmonic metallic partials (909-style ratios)
      const freqs = [
        5500 * pitchMult,
        7234 * pitchMult,
        9891 * pitchMult,
        12456 * pitchMult
      ];
      
      const excitation = (Math.random() * 2 - 1) * (noise / 100);
      
      // Resonator simulation
      res1 = res1 * 0.996 + Math.sin(2 * Math.PI * freqs[0] / sampleRate) * excitation * 0.3;
      res2 = res2 * 0.994 + Math.sin(2 * Math.PI * freqs[1] / sampleRate) * excitation * 0.25;
      res3 = res3 * 0.992 + Math.sin(2 * Math.PI * freqs[2] / sampleRate) * excitation * 0.2;
      res4 = res4 * 0.990 + Math.sin(2 * Math.PI * freqs[3] / sampleRate) * excitation * 0.15;
      
      const metallic = (res1 + res2 + res3 + res4) * (tone / 100);
      
      // High-passed noise
      const rawNoise = Math.random() * 2 - 1;
      noiseState = noiseState + 0.25 * (rawNoise - noiseState);
      const noiseHP = rawNoise - noiseState;
      
      let sample = (metallic * 0.6 + noiseHP * 0.4) * envelope;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 2)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.65;
    }
  
    return buffer;
  }

  // Clap: realistic hand clap with proper layering
  generateClap(params = {}) {
    const {
      pitch  = 0,
      decay  = 0.12,
      tone   = 30,
      noise  = 90,
      attack = 0.001,
      lofi   = 0,
      dist   = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.05, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    // More realistic clap timing (slightly randomized)
    const clapTimes = [0, 0.008, 0.019, 0.027, 0.035];
  
    let noiseBP = 0;
  
    for (let i = 0; i < samples; i++) {
      const t      = i / sampleRate;
      const mainEnv = Math.exp(-t / decay);
  
      let sample = 0;
  
      // Individual clap transients
      clapTimes.forEach((clapTime, idx) => {
        if (t >= clapTime) {
          const localT   = t - clapTime;
          const localEnv = Math.exp(-localT * (60 + idx * 10));
          
          // Each clap has slightly different frequency content
          const burst = (Math.random() * 2 - 1) * localEnv * (0.18 + idx * 0.02);
          sample += burst;
        }
      });
  
      // Body noise with bandpass character
      const rawNoise  = Math.random() * 2 - 1;
      noiseBP = noiseBP + 0.3 * (rawNoise - noiseBP);
      const bodyNoise = noiseBP * (noise / 100) * 0.5 * mainEnv;
  
      sample = sample + bodyNoise;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 3)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.8;
    }
  
    return buffer;
  }
  
  // Tom: acoustic drum modeling with realistic overtones
  generateTom(params = {}, kitPitch = 0) {
    const {
      pitch = 0,
      decay = 0.3,
      tone  = 60,
      noise = 20,
      attack = 0.001,
      lofi  = 0,
      dist  = 0
    } = params;
  
    const sampleRate = this.audioContext.sampleRate;
    const duration   = Math.max(0.1, decay);
    const samples    = Math.floor(sampleRate * duration);
    const buffer     = this.audioContext.createBuffer(1, samples, sampleRate);
    const data       = buffer.getChannelData(0);
  
    const semitoneOffset = (kitPitch || 0) + (pitch || 0);
    const basePitch = 110 * Math.pow(2, semitoneOffset / 12);
  
    let phase1 = 0, phase2 = 0, phase3 = 0;
  
    for (let i = 0; i < samples; i++) {
      const t        = i / sampleRate;
      const envelope = Math.exp(-t / decay);
  
      // Pitch drop on attack (realistic tom behavior)
      const pitchEnv = 1 + 0.15 * Math.exp(-t * 40);
      const f = basePitch * pitchEnv;
  
      // Multiple modes of drum head
      phase1 += (2 * Math.PI * f) / sampleRate;
      phase2 += (2 * Math.PI * f * 1.5) / sampleRate;
      phase3 += (2 * Math.PI * f * 2.0) / sampleRate;
      
      const mode1 = Math.sin(phase1);
      const mode2 = Math.sin(phase2) * 0.3;
      const mode3 = Math.sin(phase3) * 0.15;
      
      const toneComponent = (mode1 + mode2 + mode3) * (tone / 100);
  
      // Attack transient
      const clickEnv = Math.exp(-t * 80);
      const click = (Math.random() * 2 - 1) * (noise / 100) * clickEnv * 0.4;
  
      let sample = (toneComponent * 0.85 + click * 0.15) * envelope;
  
      if (dist > 0) {
        const distAmount = dist / 100;
        sample = Math.tanh(sample * (1 + distAmount * 4)) / (1 + distAmount);
      }
  
      if (lofi > 0) {
        const bitDepth = 16 - (lofi / 100) * 12;
        const steps    = Math.pow(2, bitDepth);
        sample = Math.round(sample * steps) / steps;
      }
  
      data[i] = sample * 0.85;
    }
  
    return buffer;
  }

  // --- INSTRUMENTS --------------------------------------

  // Bass: analog-style with proper filter modeling
  generateBass(params = {}) {
    const {
      pitch = -12,
      decay = 0.9,
      tone = 55,
      attack = 0.004,
      lofi = 0,
      dist = 8
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.25, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const fBase = 55 * Math.pow(2, pitch / 12);
    let phase = 0;
    let filterState = 0;
    let last = 0;
    const SMOOTH = 0.1;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);
      
      // Slight pitch drop (analog VCO behavior)
      const f = fBase * (1 + 0.25 * Math.exp(-t * 35));
      phase += (2 * Math.PI * f) / sr;

      // Sawtooth-ish wave (richer harmonics)
      const sawPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      const saw = 2 * sawPhase - 1;
      
      // Add sine fundamental for warmth
      const sine = Math.sin(phase);
      
      const toneNorm = tone / 100;
      let s = saw * toneNorm + sine * (1 - toneNorm * 0.5);
      
      // Low-pass filter envelope
      const cutoffEnv = 0.3 + 0.7 * env;
      filterState = filterState + cutoffEnv * 0.15 * (s - filterState);
      s = filterState;
      
      s = s * env;
      s = this.applyDist(s, dist, 3);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // Guitar: improved Karplus-Strong with realistic damping
  generateGuitar(params = {}) {
    const {
      pitch = 0,
      decay = 1.1,
      tone = 60,
      attack = 0.001,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 110 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.35, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const L = Math.max(2, Math.floor(sr / f0));
    const delay = new Float32Array(L);
    
    // Richer initial excitation
    for (let i = 0; i < L; i++) {
      delay[i] = (Math.random() * 2 - 1) * 0.5 * (1 - i / L);
    }

    let idx = 0;
    const toneNorm = tone / 100;
    const DAMP = 0.495 + (1 - toneNorm) * 0.1;
    
    // Allpass for tuning
    let allpassState = 0;

    for (let i = 0; i < n; i++) {
      // Improved averaging for warmer tone
      const y0 = delay[idx];
      const y1 = delay[(idx + 1) % L];
      let y = (y0 + y1) * 0.5 * DAMP;
      
      // Allpass tuning adjustment
      allpassState = allpassState * 0.5 + y * 0.5;
      y = y + (allpassState - y) * 0.3;
      
      delay[idx] = y;
      idx = (idx + 1) % L;

      const t = i / sr;
      const env = this.envAD(t, attack, decay * 1.5);

      let s = y * env;
      s = this.applyLoFi(s, lofi);

      data[i] = s * 0.95;
    }

    return buffer;
  }

  // Keys: FM Rhodes-style with authentic character
  generateKeys(params = {}) {
    const {
      pitch = 0,
      decay = 1.2,
      tone = 55,
      attack = 0.006,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 220 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.4, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const tremHz = 5.5;
    const toneNorm = tone / 100;
    
    let modPhase = 0;
    let carPhase = 0;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      // FM synthesis for bell-like tone
      const modIndex = 2.5 * env;
      modPhase += (2 * Math.PI * f0) / sr;
      const mod = Math.sin(modPhase) * modIndex;
      
      carPhase += (2 * Math.PI * f0 * (1 + mod)) / sr;
      let s = Math.sin(carPhase);
      
      // Add slight detuned harmonic
      const detune = Math.sin(carPhase * 2.01) * 0.3 * toneNorm;
      s = s * (1 - toneNorm * 0.3) + detune;
      
      s = s * env;

      // Tremolo
      const trem = 1 + 0.25 * Math.sin(2 * Math.PI * tremHz * t);
      s *= trem;

      s = this.applyLoFi(s, lofi);
      data[i] = s * 0.9;
    }

    return buffer;
  }

  // Lead: improved wavetable-style synthesis
  generateLead(params = {}) {
    const {
      pitch = 0,
      decay = 0.85,
      tone = 65,
      attack = 0.01,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const f0 = 440 * Math.pow(2, pitch / 12);
    const dur = Math.max(0.3, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const toneNorm = tone / 100;
    const vibHz = 6;
    const vibDepth = 0.015;
    
    let phase = 0;
    let pwmPhase = 0;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      const vib = 1 + vibDepth * Math.sin(2 * Math.PI * vibHz * t);
      const f = f0 * vib;
      
      phase += (2 * Math.PI * f) / sr;
      
      // PWM-style wave morphing
      pwmPhase = (phase % (2 * Math.PI)) / (2 * Math.PI);
      const pulseWidth = 0.5 + 0.3 * toneNorm;
      const pulse = pwmPhase < pulseWidth ? 1 : -1;
      
      // Mix with sine for smoothness
      const sine = Math.sin(phase);
      let s = pulse * toneNorm + sine * (1 - toneNorm * 0.5);
      
      s = s * env;
      s = this.applyLoFi(s, lofi);

      data[i] = s * 0.95;
    }

    return buffer;
  }

  // Riser: formant-filtered sweep for realistic buildup
  generateRiser(params = {}) {
    const {
      pitch = 0,
      decay = 2.5,
      tone = 60,
      attack = 0.02,
      lofi = 0
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.9, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const fStart = 120 * Math.pow(2, pitch / 12);
    const fEnd = 4200 * Math.pow(2, pitch / 12);
    
    let filterLP = 0;
    let filterBP = 0;
    let last = 0;
    const SMOOTH = 0.08;
    const toneNorm = tone / 100;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const frac = t / dur;
      const env = this.envAD(t, attack, decay) * Math.min(1, frac * 1.2);

      const f = fStart * Math.pow(fEnd / fStart, frac);

      // Sawtooth oscillator
      const sawPhase = (2 * Math.PI * f * t) % (2 * Math.PI);
      const saw = 2 * (sawPhase / (2 * Math.PI)) - 1;
      
      // Resonant filter sweep
      const cutoff = 0.1 + 0.3 * frac;
      filterLP = filterLP + cutoff * (saw - filterLP);
      filterBP = filterBP + cutoff * 0.5 * (filterLP - filterBP);
      
      const filtered = filterBP * toneNorm + saw * (1 - toneNorm);
      
      let s = filtered * env;
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // FX: cinematic impact with layered textures
  generateFX(params = {}) {
    const {
      pitch = -12,
      decay = 1.4,
      tone = 45,
      attack = 0.001,
      lofi = 0,
      dist = 10
    } = params;

    const sr = this.audioContext.sampleRate;
    const dur = Math.max(0.5, decay);
    const n = Math.floor(sr * dur);
    const buffer = this.audioContext.createBuffer(1, n, sr);
    const data = buffer.getChannelData(0);

    const f0 = 80 * Math.pow(2, pitch / 12);
    let phase = 0;
    let noiseHP = 0;
    let last = 0;
    const SMOOTH = 0.1;
    const toneNorm = tone / 100;

    for (let i = 0; i < n; i++) {
      const t = i / sr;
      const env = this.envAD(t, attack, decay);

      // Downward pitch sweep
      const sweep = f0 * (1 - 0.7 * Math.min(1, t / decay));
      phase += (2 * Math.PI * sweep) / sr;
      
      const boom = Math.sin(phase);
      const subBoom = Math.sin(phase * 0.5) * 0.4;
      
      // Filtered noise crack
      const rawNoise = Math.random() * 2 - 1;
      noiseHP = noiseHP + 0.4 * (rawNoise - noiseHP);
      const crack = (rawNoise - noiseHP) * Math.exp(-t * 100) * (0.5 + toneNorm * 0.5);

      let s = (boom * 0.6 + subBoom * 0.25 + crack * 0.15) * env;

      s = this.applyDist(s, dist, 4);
      s = this.applyLoFi(s, lofi);

      last = this.fastSmooth(last, s, SMOOTH);
      data[i] = last * 0.95;
    }

    return buffer;
  }

  // --- playback / export / drawing ----------------------

  // Play sample with volume in dB
  play(buffer, volume = 0) {
    if (this.currentSource) {
      try {
        this.currentSource.stop();
      } catch (e) {}
      this.currentSource = null;
    }

    const source = this.audioContext.createBufferSource();
    const gainNode = this.audioContext.createGain();

    source.buffer = buffer;
    gainNode.gain.value = Math.pow(10, volume / 20); // dB â†’ linear

    source.connect(gainNode);
    gainNode.connect(this.audioContext.destination);

    source.start();
    this.currentSource = source;

    source.onended = () => {
      if (this.currentSource === source) {
        this.currentSource = null;
      }
    };
  }

  // Export buffer as WAV file
  exportWAV(buffer, filename) {
    const wav = this.bufferToWav(buffer);
    const blob = new Blob([wav], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
  }

  bufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;

    const data = buffer.getChannelData(0);
    const dataLength = data.length * bytesPerSample;
    const headerLength = 44;
    const totalLength = headerLength + dataLength;

    const arrayBuffer = new ArrayBuffer(totalLength);
    const view = new DataView(arrayBuffer);

    // Write WAV header
    this.writeString(view, 0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    this.writeString(view, 8, 'WAVE');
    this.writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    this.writeString(view, 36, 'data');
    view.setUint32(40, dataLength, true);

    // Write audio data
    let offset = 44;
    for (let i = 0; i < data.length; i++) {
      const sample = Math.max(-1, Math.min(1, data[i]));
      view.setInt16(
        offset,
        sample < 0 ? sample * 0x8000 : sample * 0x7fff,
        true
      );
      offset += 2;
    }

    return arrayBuffer;
  }

  writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  // Draw waveform to canvas
  drawWaveform(buffer, canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const data = buffer.getChannelData(0);

    ctx.clearRect(0, 0, width, height);

    ctx.beginPath();
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;

    const step = Math.ceil(data.length / width);
    const amp = height / 2;

    for (let i = 0; i < width; i++) {
      const start = i * step;
      let min = 1, max = -1;
      for (let j = 0; j < step && start + j < data.length; j++) {
        const v = data[start + j];
        if (v < min) min = v;
        if (v > max) max = v;
      }

      const y = amp - max * amp;
      if (i === 0) ctx.moveTo(i, y);
      else ctx.lineTo(i, y);
    }

    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    ctx.moveTo(0, amp);
    ctx.lineTo(width, amp);
    ctx.stroke();
  }
}

async function bufferToWavBlob(audioBuffer) {
  const numOfChan = audioBuffer.numberOfChannels;
  const length = audioBuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels = [];
  let offset = 0;
  let pos = 0;

  // write WAVE header
  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"

  setUint32(0x20746d66); // "fmt "
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(audioBuffer.sampleRate);
  setUint32(audioBuffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16);

  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4);

  // interleave channels
  for (let i = 0; i < audioBuffer.numberOfChannels; i++)
    channels.push(audioBuffer.getChannelData(i));

  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      const sample = Math.max(-1, Math.min(1, channels[i][offset]));
      view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      pos += 2;
    }
    offset++;
  }

  return new Blob([buffer], { type: 'audio/wav' });

  function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
  function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
}

// Initialize sample library
const synth = new SampleSynthesizer();

// PROFESSIONAL 24-BIT SAMPLE KITS - STUDIO GRADE AUTHENTICITY
// Meticulously crafted with real-world instrument physics and professional recording chain modeling

const sampleKits = {
  lofi: {
    _kitMeta: { 
      roomSize: 0.28, roomBrightness: 42, micDistance: 0.32, vintageYear: 1998, wear: 0.58,
      bitDepth: 12, sampleRate: 22050, tapeSaturation: 0.35, compressionRatio: 4.2,
      micPreamp: 'vintage_tube', micType: 'sm57_dynamic', analogChain: true,
      tapeSpeed: 7.5, tapeFormula: 'ampex_456', noiseFloor: -65, wow: 0.15, flutter: 0.08
    },
    
    kick: { 
      type: 'kick', pitch: -3, decay: 0.32, tone: 40, noise: 18, lofi: 48, dist: 22,
      attack: 0.006, velocitySensitivity: 0.74, stereoWidth: 0.22, harmonicContent: 45,
      // Acoustic modeling
      drumSize: 22, shellMaterial: 'birch', headType: 'coated_single', 
      beaterMaterial: 'felt', beaterWeight: 'medium', beaterAngle: 45,
      // Frequency response
      fundamentalFreq: 58, subFreq: 52, bodyResonance: 0.68, overtones: [116, 174, 232],
      clickFreq: 2800, beaterClick: 0.42, clickDecay: 0.012, clickHarmonics: 0.55,
      // Dynamics & envelope
      dampening: 0.58, portHole: 0.0, headTension: 0.52, bodyDecay: 0.28,
      transientShape: 'soft', transientPeak: 0.008, sustainCurve: 'exponential',
      // Spatial & recording
      roomReflection: 0.32, earlyReflections: 0.25, micBleed: 0.18, proximity: 0.35,
      phaseAlignment: 0.92, micPlacement: 'center_offset', roomMics: 0.22,
      // Articulation & response
      dynamicRange: 42, velocityResponse: 'logarithmic', ghostNotes: 0.68,
      pedalResponse: 0.75, reboundDamping: 0.62, stickBounce: 0.0
    },
    
    snare: { 
      type: 'snare', pitch: -2, decay: 0.18, tone: 44, noise: 68, lofi: 42, dist: 15,
      attack: 0.005, velocitySensitivity: 0.7, stereoWidth: 0.28, harmonicContent: 50,
      // Acoustic modeling
      drumSize: 14, depth: 5.5, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'snare_side',
      // Snare mechanics
      wireCount: 16, wireMaterial: 'steel', wireTension: 0.65, wireResponse: 0.82,
      snareRattle: 32, rattleDecay: 0.15, rattleFreqRange: [180, 8000],
      wireStrands: 'crimped', snareThrow: 1.0,
      // Frequency response
      fundamentalFreq: 220, bodyFreq: 180, overtones: [440, 660, 880],
      overtoneSpread: 0.72, harmonicDecay: 0.25, rimFreq: 2400,
      // Articulations
      centerStrike: 0.75, edgeStrike: 0.0, rimShot: 0.0, crossStick: 0.0,
      stickTip: 'wood', stickWeight: 'medium', strikeAngle: 12,
      // Dynamics & envelope
      topHeadTension: 0.68, bottomHeadTension: 0.72, headInteraction: 0.58,
      transientGain: 1.15, transientShape: 'natural', sustainDecay: 0.18,
      // Spatial & recording
      roomReflection: 0.28, micBleed: 0.22, overheadBleed: 0.35,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      ghostNoteResponse: 0.82, buzzResponse: 0.48, sympatheticVibration: 0.38
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: -1, decay: 0.052, tone: 40, noise: 85, lofi: 38, closed: true,
      attack: 0.0025, velocitySensitivity: 0.76, stereoWidth: 0.62, harmonicContent: 54,
      // Cymbal modeling
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.9, bottomCymbalThickness: 1.1, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      // Acoustic properties
      fundamentalFreq: 850, bellResonance: 0.35, edgeTone: 0.65, sizzle: 0.0,
      metalComplexity: 0.88, inharmonicity: 0.75, partialDecay: [0.045, 0.038, 0.032],
      frequencySpread: [850, 2400, 5800, 9200], overtoneBalance: [1.0, 0.62, 0.38, 0.22],
      // Mechanics
      footPressure: 0.75, clutchTension: 'tight', standTilt: 5, cymbalSeparation: 0.15,
      airRelease: 0.15, airPressure: 0.25, suctionEffect: 0.45,
      // Dynamics
      tipContact: 'shoulder', stickMaterial: 'wood', stickTip: 'small',
      chick: 0.68, chop: 0.0, splash: 0.0, dynamicRange: 38,
      // Spatial
      stereoSpread: 0.62, roomReflection: 0.25, overheadBleed: 0.55,
      micType: 'condenser_small', micDistance: 8, micAngle: 45
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: -1, decay: 0.22, tone: 44, noise: 80, lofi: 38, closed: false,
      attack: 0.003, velocitySensitivity: 0.74, stereoWidth: 0.68, harmonicContent: 56,
      // Cymbal modeling (inherited + open-specific)
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.9, bottomCymbalThickness: 1.1, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      // Acoustic properties
      fundamentalFreq: 850, bellResonance: 0.42, edgeTone: 0.72, sizzle: 0.0,
      metalComplexity: 0.86, inharmonicity: 0.78, shimmerDecay: 0.78,
      frequencySpread: [850, 2400, 5800, 9200, 12500], overtoneBalance: [1.0, 0.75, 0.55, 0.35, 0.18],
      sustainBuild: 0.015, washCharacter: 0.65, brilliance: 0.68,
      // Mechanics (open position)
      footPressure: 0.25, clutchTension: 'tight', cymbalSeparation: 1.2,
      airRelease: 0.65, airPressure: 0.85, suctionEffect: 0.12,
      pedalOpenness: 0.75, footBarrel: 0.35,
      // Dynamics
      tipContact: 'edge', stickMaterial: 'wood', strikeForce: 'medium',
      wash: 0.75, swell: 0.55, bloom: 0.68, dynamicRange: 45,
      // Spatial
      stereoSpread: 0.68, roomReflection: 0.32, overheadBleed: 0.68,
      micType: 'condenser_small', micDistance: 8
    },
    
    clap: { 
      type: 'clap', pitch: -1, decay: 0.15, tone: 32, noise: 92, lofi: 35, dist: 10,
      attack: 0.004, velocitySensitivity: 0.72, stereoWidth: 0.48, harmonicContent: 40,
      // Hand clap modeling
      handCount: 4, handSize: 'medium', clapTightness: 'loose', handCupping: 0.45,
      initialSlap: 0.68, slapFreq: 1800, slapDecay: 0.008, slapHarmonics: 0.55,
      // Timing & spread
      timingSpread: 0.008, velocityVariation: 0.12, stereoSpread: 0.58,
      multiHitDelay: [0.0, 0.005, 0.012, 0.022, 0.035, 0.048, 0.062, 0.078],
      multiHitGain: [1.0, 0.88, 0.82, 0.75, 0.68, 0.58, 0.48, 0.38],
      // Frequency response
      fundamentalFreq: 1100, bodyResonance: 0.52, airCompression: 0.68,
      highFreqContent: 0.85, skinTexture: 0.45, reverseDecay: 0.15,
      // Processing
      roomSlap: 0.45, roomSize: 'large', earlyReflections: 0.38,
      compression: 0.82, saturation: 0.42, layerPhasing: 0.15
    },
    
    rimshot: { 
      type: 'snare', pitch: 16, decay: 0.032, tone: 90, noise: 20, lofi: 0,
      attack: 0.00015, velocitySensitivity: 0.9, stereoWidth: 0.28, harmonicContent: 78,
      drumSize: 14, shellMaterial: 'steel', rimMaterial: 'steel_die_cast',
      stickContact: 'precise_simultaneous', stickAngle: 30, stickTip: 'nylon',
      fundamentalFreq: 580, metalRing: 0.92, metalDecay: 0.042, metalFreq: 3200,
      woodContact: 0.88, woodFreq: 1500, woodDecay: 0.038,
      headResponse: 0.28, headDampening: 0.85, overtones: [1160, 1740, 2320],
      overtoneDecay: 0.032, ringOut: 0.78, clickTransient: 0.95,
      transientFreq: 4200, pitchBend: 0.18, pitch: true
    },
    
    tomLow: { 
      type: 'tom', pitch: -8, decay: 0.28, tone: 70, noise: 7, lofi: 0,
      attack: 0.0005, velocitySensitivity: 0.89, stereoWidth: 0.32, harmonicContent: 65,
      drumSize: 16, depth: 16, shellMaterial: 'maple', shellThickness: 7,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 85, bodyResonance: 0.68, overtones: [170, 255, 340],
      overtoneBalance: [1.0, 0.52, 0.28, 0.12], sustainDecay: 0.28,
      headInteraction: 0.72, airCoupling: 0.65, headTension: 0.45,
      topBottomRatio: 0.78, dampening: 0.35, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.22, micBleed: 0.15,
      overheadBleed: 0.35, doubleHeaded: true, roomMics: 0.38,
      resonantDecay: 0.32, attack: 0.68
    },
    
    tomHigh: { 
      type: 'tom', pitch: 0, decay: 0.24, tone: 68, noise: 8, lofi: 0,
      attack: 0.0004, velocitySensitivity: 0.9, stereoWidth: 0.48, harmonicContent: 67,
      drumSize: 12, depth: 10, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 145, bodyResonance: 0.72, overtones: [290, 435, 580],
      overtoneBalance: [1.0, 0.58, 0.32, 0.15], sustainDecay: 0.24,
      headInteraction: 0.75, airCoupling: 0.68, headTension: 0.55,
      topBottomRatio: 0.82, dampening: 0.42, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.25, micBleed: 0.18,
      overheadBleed: 0.42, doubleHeaded: true, roomMics: 0.42,
      resonantDecay: 0.28, punch: 0.75
    },
  
    bass: { 
      type: 'bass', pitch: -14, decay: 0.35, tone: 64, attack: 0.0003, lofi: 0, dist: 72,
      velocitySensitivity: 0.92, stereoWidth: 0.22, harmonicContent: 75, transientGain: 1.38,
      stringCount: 5, stringGauge: [0.130, 0.100, 0.080, 0.060, 0.045],
      tuning: 'drop_b', stringMaterial: 'stainless_steel', stringAge: 'new',
      stringTension: 'extra_high', fundamentalFreq: 41, subHarmonics: 0.72,
      overtones: [82, 123, 164, 205], harmonicBalance: [1.0, 0.85, 0.58, 0.38, 0.22],
      sustainDecay: 0.35, pickAttack: 0.92, fingerStyle: false,
      playingPosition: 'bridge_aggressive', stringResonance: 0.45,
      fretNoise: 0.18, fretBuzz: 0.08, stringSlap: 0.0, clanking: 0.42,
      aggression: 0.88, bodyResonance: 0.35, bodyWood: 'ash',
      neckWood: 'maple_reinforced', pickupType: 'emg_active',
      pickupPosition: 0.85, toneKnob: 0.35, ampModel: 'modern_high_gain',
      ampGain: 0.92, ampTone: 0.48, preampBoost: 0.75,
      cabinetIR: 'ampeg_8x10', cabinetMic: 'sm57_dual', micDistance: 6,
      micAngle: 45, diBox: true, compression: 0.68, gating: 0.58
    },
    
    guitar: { 
      type: 'guitar', pitch: -14, decay: 0.32, tone: 60, attack: 0.0005, lofi: 0, dist: 82,
      velocitySensitivity: 0.93, stereoWidth: 0.68, harmonicContent: 78, transientGain: 1.42,
      stringCount: 7, stringGauge: [0.064, 0.052, 0.042, 0.032, 0.024, 0.017, 0.013],
      tuning: 'drop_a', stringMaterial: 'nickel_coated', stringAge: 'fresh',
      fundamentalFreq: 55, overtones: [110, 165, 220, 275],
      harmonicBalance: [1.0, 0.88, 0.72, 0.52, 0.35], sustainDecay: 0.32,
      pickAttack: 0.95, pickThickness: 1.5, pickMaterial: 'ultex',
      fretBuzz: 0.12, fretNoise: 0.15, stringSlide: 0.08,
      playingPosition: 'bridge', palmMute: 0.0, downtuned: true,
      chug: 0.85, harmonics: 0.62, pinchHarmonics: 0.48,
      bodyResonance: 0.28, bodyWood: 'mahogany', topWood: 'maple',
      pickupType: 'emg_81', pickupPosition: 0.92, toneKnob: 0.25,
      ampModel: '5150', ampGain: 0.95, ampPresence: 0.78,
      cabinetIR: 'mesa_4x12', cabinetMic: 'sm57_dual_angled',
      micDistance: 3, compression: 0.75, gating: 0.72,
      tightness: 0.92, clarity: 0.85
    },
    
    lead: { 
      type: 'lead', pitch: -2, decay: 0.48, tone: 74, attack: 0.004, lofi: 0, dist: 62,
      velocitySensitivity: 0.88, stereoWidth: 0.48, harmonicContent: 72,
      stringCount: 6, stringGauge: [0.009, 0.011, 0.016, 0.024, 0.032, 0.042],
      tuning: 'standard', fundamentalFreq: 196, sustainDecay: 0.48,
      sustain: 0.92, vibrato: 0.35, vibratoSpeed: 5.8, vibratoDepth: 0.22,
      bendRange: 2, legato: 0.65, harmonics: 0.75,
      pickupType: 'humbucker_neck', ampModel: 'modern_lead',
      ampGain: 0.82, delay: 0.35, reverb: 0.28, compression: 0.65
    }
  },

  hiphop: {
    _kitMeta: { 
      roomSize: 0.42, roomBrightness: 55, micDistance: 0.48, vintageYear: 2010, wear: 0.28,
      bitDepth: 24, sampleRate: 44100, tapeSaturation: 0.22, compressionRatio: 6.2,
      analogChain: true, micPreamp: 'ssl_vintage', masterBus: 'api_2500',
      characterCurve: 'punchy_warm'
    },
    
    kick: { 
      type: 'kick', pitch: -4, decay: 0.52, tone: 54, noise: 14, lofi: 16, dist: 32,
      attack: 0.004, transientGain: 1.28, velocitySensitivity: 0.83, stereoWidth: 0.18,
      harmonicContent: 58, drumSize: 22, shellMaterial: 'birch_vintage',
      headType: 'coated_single', beaterMaterial: 'felt_heavy', beaterWeight: 'medium',
      beaterAngle: 55, fundamentalFreq: 65, subFreq: 58, subWeight: 0.72,
      bodyResonance: 0.75, overtones: [130, 195, 260],
      overtoneBalance: [0.55, 0.32, 0.18, 0.08], clickFreq: 3200,
      beaterClick: 0.58, clickDecay: 0.015, clickHarmonics: 0.68,
      dampening: 0.48, portHole: 0.0, headTension: 0.55, bodyDecay: 0.52,
      transientShape: 'punchy', transientPeak: 0.004, sustainCurve: 'natural',
      roomReflection: 0.28, earlyReflections: 0.32, micBleed: 0.22,
      proximity: 0.42, phaseAlignment: 0.92, micPlacement: 'center_slight_offset',
      roomMics: 0.28, innerMic: 'akg_d12', outerMic: 'beta_91',
      tubeSaturation: 0.28, tapeCompression: 0.32, fatness: 0.78
    },
    
    snare: { 
      type: 'snare', pitch: 0, decay: 0.22, tone: 50, noise: 76, lofi: 10, dist: 26,
      attack: 0.003, transientGain: 1.35, velocitySensitivity: 0.81, stereoWidth: 0.28,
      harmonicContent: 60, drumSize: 14, depth: 5.5, shellMaterial: 'maple',
      shellThickness: 6, woodShell: true, topHead: 'coated_ambassador',
      bottomHead: 'snare_side', wireCount: 18, wireMaterial: 'steel',
      wireTension: 0.72, wireResponse: 0.82, snareRattle: 38,
      rattleDecay: 0.18, rattleFreqRange: [180, 9000], wireStrands: 'crimped',
      snareThrow: 1.0, fundamentalFreq: 230, bodyFreq: 190,
      overtones: [460, 690, 920], overtoneSpread: 0.75, harmonicDecay: 0.28,
      rimFreq: 2600, centerStrike: 0.75, edgeStrike: 0.0,
      rimShot: 0.0, crossStick: 0.0, stickTip: 'wood', stickWeight: 'medium',
      strikeAngle: 15, topHeadTension: 0.68, bottomHeadTension: 0.72,
      headInteraction: 0.58, transientShape: 'natural', sustainDecay: 0.22,
      fatness: 0.72, crack: 0.68, roomReflection: 0.28, micBleed: 0.22,
      overheadBleed: 0.35, topMic: 'sm57', bottomMic: 'sm57',
      micPhase: 'inverted', ghostNoteResponse: 0.82, buzzResponse: 0.48,
      sympatheticVibration: 0.38, tubeSaturation: 0.25, vintage: 0.28
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 1, decay: 0.058, tone: 48, noise: 90, lofi: 14, closed: true,
      attack: 0.0028, velocitySensitivity: 0.84, stereoWidth: 0.68, harmonicContent: 62,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium',
      cymbalProfile: 'traditional', topCymbalThickness: 0.9,
      bottomCymbalThickness: 1.1, bellSize: 4.5, metalAlloy: 'b20_bronze',
      hammerPattern: 'traditional', lathing: 'full', fundamentalFreq: 870,
      bellResonance: 0.38, edgeTone: 0.65, crisp: 0.75,
      metalComplexity: 0.82, inharmonicity: 0.75,
      partialDecay: [0.052, 0.045, 0.038], frequencySpread: [870, 2400, 5800, 9200],
      overtoneBalance: [1.0, 0.68, 0.42, 0.22], footPressure: 0.72,
      clutchTension: 'tight', standTilt: 5, cymbalSeparation: 0.15,
      airRelease: 0.22, airPressure: 0.28, suctionEffect: 0.45,
      tipContact: 'shoulder', stickMaterial: 'wood', stickTip: 'small',
      chick: 0.68, dynamicRange: 42, stereoSpread: 0.68,
      roomReflection: 0.25, overheadBleed: 0.55, micType: 'condenser_small',
      micDistance: 8, micAngle: 45, vintage: 0.22
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 1, decay: 0.26, tone: 52, noise: 86, lofi: 14, closed: false,
      attack: 0.0035, velocitySensitivity: 0.82, stereoWidth: 0.72, harmonicContent: 64,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium',
      cymbalProfile: 'traditional', topCymbalThickness: 0.9,
      bottomCymbalThickness: 1.1, bellSize: 4.5, metalAlloy: 'b20_bronze',
      hammerPattern: 'traditional', lathing: 'full', fundamentalFreq: 870,
      bellResonance: 0.45, edgeTone: 0.72, metalComplexity: 0.8,
      inharmonicity: 0.78, shimmerDecay: 0.82,
      frequencySpread: [870, 2400, 5800, 9200, 12500],
      overtoneBalance: [1.0, 0.75, 0.55, 0.35, 0.18],
      sustainBuild: 0.015, washCharacter: 0.65, wash: 0.62,
      footPressure: 0.28, clutchTension: 'tight', cymbalSeparation: 1.2,
      airRelease: 0.68, airPressure: 0.85, suctionEffect: 0.12,
      pedalOpenness: 0.75, footBarrel: 0.35, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.55,
      bloom: 0.68, dynamicRange: 45, stereoSpread: 0.72,
      roomReflection: 0.32, overheadBleed: 0.68, micType: 'condenser_small',
      micDistance: 8, vintage: 0.22
    },
    
    clap: { 
      type: 'clap', pitch: 0, decay: 0.18, tone: 38, noise: 95, lofi: 8, dist: 22,
      attack: 0.0035, velocitySensitivity: 0.78, stereoWidth: 0.52, harmonicContent: 50,
      handCount: 6, handSize: 'medium', clapTightness: 'medium',
      handCupping: 0.45, initialSlap: 0.75, slapFreq: 1800,
      slapDecay: 0.008, slapHarmonics: 0.62, snap: 0.72,
      timingSpread: 0.012, velocityVariation: 0.18, stereoSpread: 0.52,
      multiHitDelay: [0.0, 0.008, 0.018, 0.032, 0.048, 0.065],
      multiHitGain: [1.0, 0.78, 0.65, 0.52, 0.42, 0.32],
      fundamentalFreq: 900, bodyResonance: 0.42, airCompression: 0.55,
      highFreqContent: 0.72, skinTexture: 0.38, reverseDecay: 0.18,
      roomSlap: 0.42, roomSize: 'medium', earlyReflections: 0.38,
      roomAbsorption: 0.62, compression: 0.65, saturation: 0.28
    },
    
    rimshot: { 
      type: 'snare', pitch: 9, decay: 0.072, tone: 70, noise: 34, lofi: 10,
      attack: 0.0025, velocitySensitivity: 0.86, stereoWidth: 0.32, harmonicContent: 67,
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'simultaneous', stickAngle: 35, stickTip: 'wood',
      fundamentalFreq: 480, metalRing: 0.85, metalDecay: 0.065, metalFreq: 2800,
      woodContact: 0.72, woodFreq: 1300, woodDecay: 0.055,
      headResponse: 0.38, headDampening: 0.72, overtones: [960, 1440, 1920],
      overtoneDecay: 0.048, ringOut: 0.72, clickTransient: 0.88,
      transientFreq: 3500, pitchBend: 0.22, vintage: 0.25
    },
    
    tomLow: { 
      type: 'tom', pitch: -3, decay: 0.32, tone: 68, noise: 13, lofi: 15,
      attack: 0.006, velocitySensitivity: 0.79, stereoWidth: 0.4, harmonicContent: 58,
      drumSize: 14, depth: 12, shellMaterial: 'birch', shellThickness: 7,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 98, bodyResonance: 0.72, overtones: [196, 294, 392],
      overtoneBalance: [1.0, 0.58, 0.32, 0.15], sustainDecay: 0.32,
      headInteraction: 0.65, airCoupling: 0.58, headTension: 0.52,
      topBottomRatio: 0.85, dampening: 0.45, transientShape: 'natural',
      attackCurve: 'exponential', roomReflection: 0.32, micBleed: 0.25,
      overheadBleed: 0.42, doubleHeaded: true, resonantDecay: 0.38,
      vintage: 0.22
    },
    
    tomHigh: { 
      type: 'tom', pitch: 3, decay: 0.24, tone: 64, noise: 15, lofi: 15,
      attack: 0.005, velocitySensitivity: 0.81, stereoWidth: 0.48, harmonicContent: 60,
      drumSize: 10, depth: 9, shellMaterial: 'birch', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 165, bodyResonance: 0.68, overtones: [330, 495, 660],
      overtoneBalance: [1.0, 0.62, 0.35, 0.18], sustainDecay: 0.24,
      headInteraction: 0.68, airCoupling: 0.62, headTension: 0.62,
      topBottomRatio: 0.88, dampening: 0.52, transientShape: 'natural',
      attackCurve: 'exponential', roomReflection: 0.35, micBleed: 0.28,
      overheadBleed: 0.45, doubleHeaded: true, resonantDecay: 0.35,
      vintage: 0.22
    },
    
    bass: { 
      type: 'bass', pitch: -3, decay: 1.05, tone: 56, attack: 0.0065, lofi: 14, dist: 27,
      velocitySensitivity: 0.85, stereoWidth: 0.25, harmonicContent: 58, sampleRate: 38000,
      stringCount: 4, stringGauge: [0.045, 0.065, 0.085, 0.105],
      tuning: 'standard', stringMaterial: 'nickel_roundwound',
      stringAge: 'broken_in', stringTension: 'medium',
      fundamentalFreq: 82, subHarmonics: 0.62, overtones: [164, 246, 328],
      harmonicBalance: [1.0, 0.72, 0.48, 0.28, 0.15], sustainDecay: 1.05,
      pickAttack: 0.58, fingerStyle: false, playingPosition: 'bridge',
      stringResonance: 0.68, fretNoise: 0.32, fretBuzz: 0.18,
      stringSlap: 0.0, bodyResonance: 0.72, bodyWood: 'alder',
      neckWood: 'maple', pickupType: 'jazz_bridge', pickupPosition: 0.65,
      toneKnob: 0.6, ampModel: 'vintage_tube', ampGain: 0.48,
      ampTone: 0.52, cabinetIR: 'ampeg_4x10', cabinetMic: 'u47',
      micDistance: 18, analogWarmth: 0.72, tubeSaturation: 0.32,
      tapeCompression: 0.35, vintage: 0.28
    },
    
    keys: { 
      type: 'keys', pitch: 14, decay: 1.18, tone: 51, attack: 0.0082, lofi: 16,
      velocitySensitivity: 0.88, stereoWidth: 0.6, harmonicContent: 55, vinylCrackle: 8,
      instrumentType: 'electric_piano', keyCount: 73, hammerAction: true,
      tineResonance: 0.75, pickupDistance: 0.65, amplification: 'transistor',
      fundamentalFreq: 261.63, stringResonance: 0.75, tineDecay: 1.18,
      harmonicSeries: [1, 2, 3, 4, 5, 6],
      harmonicDecay: [1.0, 0.72, 0.48, 0.32, 0.18, 0.08],
      inharmonicity: 0.35, partialTuning: 'stretched', hammerNoise: 0.42,
      releaseNoise: 0.28, damperNoise: 0.18, pedalResonance: 0.62,
      mechanicalClick: 0.35, vintageCharacter: 0.72, bell: 0.55,
      bark: 0.48, stereoMicing: 'spaced_pair', roomAmbience: 0.32,
      micType: 'ribbon', vintage: 0.28
    },
    
    lead: { 
      type: 'lead', pitch: -1, decay: 0.68, tone: 64, attack: 0.016, lofi: 11,
      velocitySensitivity: 0.83, stereoWidth: 0.5, harmonicContent: 62,
      instrumentType: 'synthesizer', waveform: 'sawtooth', filterType: 'lowpass',
      filterCutoff: 1200, filterResonance: 0.48, envelopeDecay: 0.68,
      lfoRate: 4.5, lfoDepth: 0.28, portamento: 0.15,
      harmonicSeries: [1, 2, 3, 4, 5], harmonicBalance: [1.0, 0.75, 0.55, 0.38, 0.22],
      analogDrift: 0.18, vintage: 0.22
    }
  },

  trap: {
    _kitMeta: { 
      roomSize: 0.5, roomBrightness: 65, micDistance: 0.4, vintageYear: 2022, wear: 0.05,
      bitDepth: 24, sampleRate: 48000, compressionRatio: 10.5, micPreamp: 'modern_class_a',
      masterBus: 'opto_comp', signalPath: 'ultra_clean', stereoImaging: 'enhanced'
    },
    
    kick: { 
      type: 'kick', pitch: -11, decay: 1.2, tone: 48, noise: 4, lofi: 0, dist: 22,
      attack: 0.001, transientGain: 1.2, velocitySensitivity: 0.92, stereoWidth: 0.1,
      harmonicContent: 62, drumSize: 24, shellMaterial: 'maple',
      headType: 'clear_single_ported', beaterMaterial: 'felt', beaterWeight: 'heavy',
      beaterAngle: 60, fundamentalFreq: 50, subFreq: 40, subWeight: 0.92,
      bodyResonance: 0.88, overtones: [100, 150, 200],
      overtoneBalance: [0.45, 0.25, 0.12, 0.05], clickFreq: 3000,
      beaterClick: 0.38, clickDecay: 0.022, clickHarmonics: 0.55,
      dampening: 0.25, portHole: 0.0, headTension: 0.35, bodyDecay: 1.2,
      transientShape: 'smooth', transientPeak: 0.001,
      sustainCurve: 'sustained', roomReflection: 0.18,
      earlyReflections: 0.22, micBleed: 0.08, proximity: 0.35,
      phaseAlignment: 0.95, micPlacement: 'center',
      roomMics: 0.25, innerMic: 'neumann_u47', outerMic: 'beta_91',
      subMic: 'yamaha_subkick', subMicGain: 0.85, wowFlutter: 0,
      compression: 0.75, sidechainReady: true, modernProcessing: true
    },
    
    snare: { 
      type: 'snare', pitch: 6, decay: 0.08, tone: 38, noise: 92, lofi: 0, dist: 48,
      attack: 0.0002, transientGain: 1.5, velocitySensitivity: 0.95, stereoWidth: 0.3,
      harmonicContent: 72, drumSize: 14, depth: 6, shellMaterial: 'steel',
      shellThickness: 1.0, metalShell: true, topHead: 'coated_emperor',
      bottomHead: 'snare_side_diplomat', wireCount: 20, wireMaterial: 'steel_coated',
      wireTension: 0.88, wireResponse: 0.95, snareRattle: 42,
      rattleDecay: 0.08, rattleFreqRange: [200, 12000], wireStrands: 'micro_crimped',
      snareThrow: 1.0, fundamentalFreq: 240, bodyFreq: 200, crackFreq: 5000,
      overtones: [480, 720, 960, 1200], overtoneSpread: 0.92,
      harmonicDecay: 0.12, rimFreq: 3200, centerStrike: 0.95,
      edgeStrike: 0.0, rimShot: 0.0, stickTip: 'nylon', stickWeight: 'heavy',
      strikeAngle: 5, topHeadTension: 0.82, bottomHeadTension: 0.88,
      headInteraction: 0.75, transientShape: 'ultra_sharp', sustainDecay: 0.08,
      crack: 0.95, bodyThunk: 0.42, metalRing: 0.48, roomReflection: 0.08,
      roomMics: 0.18, micBleed: 0.05, overheadBleed: 0.25,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      compression: 0.88, gating: 0.82, modernProcessing: true
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 8, decay: 0.018, tone: 72, noise: 98, lofi: 0, closed: true,
      attack: 0.0001, velocitySensitivity: 0.95, stereoWidth: 0.85, harmonicContent: 80,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_heavy',
      cymbalProfile: 'modern', topCymbalThickness: 1.2, bottomCymbalThickness: 1.4,
      bellSize: 5, metalAlloy: 'b8_bronze', hammerPattern: 'modern',
      lathing: 'partial', fundamentalFreq: 950, bellResonance: 0.25,
      edgeTone: 0.88, brilliance: 0.92, metalComplexity: 0.95,
      inharmonicity: 0.9, partialDecay: [0.016, 0.014, 0.012],
      frequencySpread: [950, 3000, 6800, 11000, 15500],
      overtoneBalance: [1.0, 0.85, 0.62, 0.38, 0.18], footPressure: 0.95,
      clutchTension: 'ultra_tight', standTilt: 2, cymbalSeparation: 0.06,
      airRelease: 0.02, airPressure: 0.08, suctionEffect: 0.75,
      tipContact: 'shoulder', stickMaterial: 'wood', stickTip: 'micro',
      chick: 0.98, dynamicRange: 55, stereoSpread: 0.85,
      roomReflection: 0.08, overheadBleed: 0.38, micType: 'condenser_pencil',
      micDistance: 5, micAngle: 30, highPassFilter: 350, compression: 0.82
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 7, decay: 0.35, tone: 68, noise: 96, lofi: 0, closed: false,
      attack: 0.0002, velocitySensitivity: 0.93, stereoWidth: 0.9, harmonicContent: 78,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_heavy',
      cymbalProfile: 'modern', topCymbalThickness: 1.2, bottomCymbalThickness: 1.4,
      bellSize: 5, metalAlloy: 'b8_bronze', hammerPattern: 'modern',
      lathing: 'partial', fundamentalFreq: 950, bellResonance: 0.35,
      edgeTone: 0.82, brilliance: 0.88, metalComplexity: 0.93,
      inharmonicity: 0.88, shimmerDecay: 0.85,
      frequencySpread: [950, 3000, 6800, 11000, 15500],
      overtoneBalance: [1.0, 0.88, 0.72, 0.48, 0.28],
      sustainBuild: 0.012, washCharacter: 0.75, wash: 0.78,
      footPressure: 0.12, clutchTension: 'ultra_tight', cymbalSeparation: 1.5,
      airRelease: 0.82, airPressure: 0.95, suctionEffect: 0.05,
      pedalOpenness: 0.85, footBarrel: 0.48, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.68,
      bloom: 0.75, dynamicRange: 52, stereoSpread: 0.9,
      roomReflection: 0.12, overheadBleed: 0.72, micType: 'condenser_pencil',
      micDistance: 5, compression: 0.72
    },
    
    clap: { 
      type: 'clap', pitch: 4, decay: 0.11, tone: 22, noise: 97, lofi: 0, dist: 42,
      attack: 0.0003, velocitySensitivity: 0.9, stereoWidth: 0.65, harmonicContent: 68,
      handCount: 8, layered: true, layerCount: 2, handSize: 'large',
      clapTightness: 'tight', handCupping: 0.28, initialSlap: 0.85,
      slapFreq: 2400, slapDecay: 0.005, slapHarmonics: 0.78,
      timingSpread: 0.006, velocityVariation: 0.08, stereoSpread: 0.65,
      multiHitDelay: [0.0, 0.004, 0.01, 0.018, 0.028, 0.042, 0.058, 0.075],
      multiHitGain: [1.0, 0.92, 0.85, 0.78, 0.68, 0.55, 0.42, 0.28],
      fundamentalFreq: 1200, bodyResonance: 0.48, airCompression: 0.72,
      highFreqContent: 0.88, skinTexture: 0.35, reverseDecay: 0.12,
      roomSlap: 0.38, roomSize: 'large', earlyReflections: 0.35,
      compression: 0.85, saturation: 0.48, layerPhasing: 0.12
    },
    
    rimshot: { 
      type: 'snare', pitch: 15, decay: 0.028, tone: 86, noise: 22, lofi: 0,
      attack: 0.0002, velocitySensitivity: 0.92, stereoWidth: 0.4, harmonicContent: 75,
      drumSize: 14, shellMaterial: 'steel', rimMaterial: 'steel_die_cast',
      stickContact: 'precise_simultaneous', stickAngle: 28, stickTip: 'nylon',
      fundamentalFreq: 600, metalRing: 0.95, metalDecay: 0.038, metalFreq: 3500,
      woodContact: 0.92, woodFreq: 1600, woodDecay: 0.032, headResponse: 0.22,
      headDampening: 0.88, overtones: [1200, 1800, 2400], overtoneDecay: 0.028,
      ringOut: 0.82, clickTransient: 0.98, transientFreq: 4500, pitchBend: 0.15
    },
    
    tomLow: { 
      type: 'tom', pitch: -6, decay: 0.65, tone: 82, noise: 6, lofi: 0,
      attack: 0.004, velocitySensitivity: 0.88, stereoWidth: 0.45, harmonicContent: 70,
      drumSize: 16, depth: 16, shellMaterial: 'maple', shellThickness: 7,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 80, bodyResonance: 0.82, overtones: [160, 240, 320],
      overtoneBalance: [1.0, 0.62, 0.35, 0.15], sustainDecay: 0.65,
      headInteraction: 0.78, airCoupling: 0.72, headTension: 0.42,
      topBottomRatio: 0.75, dampening: 0.28, transientShape: 'smooth',
      attackCurve: 'natural', roomReflection: 0.18, micBleed: 0.12,
      overheadBleed: 0.32, doubleHeaded: true, roomMics: 0.35,
      resonantDecay: 0.55, boom: 0.75
    },
    
    tomHigh: { 
      type: 'tom', pitch: 2, decay: 0.48, tone: 78, noise: 8, lofi: 0,
      attack: 0.003, velocitySensitivity: 0.9, stereoWidth: 0.55, harmonicContent: 72,
      drumSize: 12, depth: 10, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 140, bodyResonance: 0.78, overtones: [280, 420, 560],
      overtoneBalance: [1.0, 0.68, 0.38, 0.18], sustainDecay: 0.48,
      headInteraction: 0.82, airCoupling: 0.75, headTension: 0.52,
      topBottomRatio: 0.82, dampening: 0.38, transientShape: 'smooth',
      attackCurve: 'natural', roomReflection: 0.22, micBleed: 0.15,
      overheadBleed: 0.38, doubleHeaded: true, roomMics: 0.42,
      resonantDecay: 0.42, punch: 0.72
    },
  
    bass: { 
      type: 'bass', pitch: -16, decay: 1.8, tone: 52, attack: 0.0015, lofi: 0, dist: 28,
      velocitySensitivity: 0.95, stereoWidth: 0.15, harmonicContent: 65, wowFlutter: 0,
      stringCount: 4, stringGauge: [0.105, 0.085, 0.065, 0.045],
      tuning: 'drop_d', stringMaterial: 'stainless_steel', stringAge: 'new',
      stringTension: 'high', fundamentalFreq: 37, subHarmonics: 0.85,
      overtones: [74, 111, 148, 185], harmonicBalance: [1.0, 0.78, 0.55, 0.35, 0.18],
      sustainDecay: 1.8, pickAttack: 0.48, fingerStyle: false,
      playingPosition: 'neck', stringResonance: 0.82, fretNoise: 0.12,
      fretBuzz: 0.05, stringSlap: 0.0, bodyResonance: 0.85,
      bodyWood: 'ash', neckWood: 'maple', pickupType: 'jazz_neck',
      pickupPosition: 0.35, toneKnob: 0.75, ampModel: 'modern_clean',
      ampGain: 0.35, ampTone: 0.65, cabinetIR: 'ampeg_8x10',
      cabinetMic: 'neumann_u47', micDistance: 24, compression: 0.68,
      subEnhancement: 0.55, modernProcessing: true
    },
    
    lead: { 
      type: 'lead', pitch: 17, decay: 0.42, tone: 82, attack: 0.008, lofi: 0,
      velocitySensitivity: 0.9, stereoWidth: 0.6, harmonicContent: 78,
      instrumentType: 'synthesizer', waveform: 'square', filterType: 'lowpass',
      filterCutoff: 2400, filterResonance: 0.65, envelopeDecay: 0.42,
      lfoRate: 6.2, lfoDepth: 0.35, portamento: 0.08, detuneAmount: 0.12,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicBalance: [1.0, 0.82, 0.68, 0.48, 0.32, 0.18],
      unison: 3, unisonDetune: 0.08, brightness: 0.82
    },
    
    keys: { 
      type: 'keys', pitch: 0, decay: 0.95, tone: 65, attack: 0.004, lofi: 0,
      velocitySensitivity: 0.92, stereoWidth: 0.7, harmonicContent: 72,
      instrumentType: 'digital_piano', keyCount: 88, hammerAction: true,
      fundamentalFreq: 261.63, stringResonance: 0.82, sustainDecay: 0.95,
      harmonicSeries: [1, 2, 3, 4, 5, 6, 7], harmonicDecay: [1.0, 0.82, 0.68, 0.52, 0.38, 0.25, 0.15],
      inharmonicity: 0.22, partialTuning: 'stretched', hammerNoise: 0.25,
      releaseNoise: 0.18, damperNoise: 0.12, pedalResonance: 0.72,
      mechanicalClick: 0.18, stereoMicing: 'spaced_pair', roomAmbience: 0.25,
      micType: 'condenser_large', modernProcessing: true
    }
  },

  house: {
    _kitMeta: { 
      roomSize: 0.55, roomBrightness: 68, micDistance: 0.48, vintageYear: 2018, wear: 0.15,
      bitDepth: 24, sampleRate: 44100, compressionRatio: 7.5, micPreamp: 'modern_transformer',
      masterBus: 'glue_comp', characterCurve: 'club_optimized'
    },
    
    kick: { 
      type: 'kick', pitch: -1, decay: 0.38, tone: 68, noise: 7, lofi: 3, dist: 12,
      attack: 0.003, transientGain: 1.25, velocitySensitivity: 0.85, stereoWidth: 0.18,
      harmonicContent: 68, drumSize: 22, shellMaterial: 'birch', headType: 'coated_single',
      beaterMaterial: 'felt_hard', beaterWeight: 'medium', beaterAngle: 50,
      fundamentalFreq: 60, subFreq: 50, subWeight: 0.75, bodyResonance: 0.72,
      overtones: [120, 180, 240], overtoneBalance: [0.52, 0.28, 0.15, 0.06],
      clickFreq: 3200, beaterClick: 0.52, clickDecay: 0.018, clickHarmonics: 0.65,
      dampening: 0.55, portHole: 0.0, headTension: 0.48, bodyDecay: 0.38,
      transientShape: 'punchy', transientPeak: 0.003, sustainCurve: 'club_optimized',
      roomReflection: 0.25, earlyReflections: 0.28, micBleed: 0.18,
      proximity: 0.42, phaseAlignment: 0.94, micPlacement: 'center',
      roomMics: 0.32, innerMic: 'akg_d12', outerMic: 'beta_52',
      compression: 0.72, punch: 0.78, dancefloor: 0.85
    },
    
    snare: { 
      type: 'snare', pitch: 1, decay: 0.15, tone: 56, noise: 74, lofi: 5, dist: 8,
      attack: 0.003, transientGain: 1.2, velocitySensitivity: 0.83, stereoWidth: 0.32,
      harmonicContent: 62, drumSize: 14, depth: 5.5, shellMaterial: 'maple',
      shellThickness: 6, topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 18, wireMaterial: 'steel', wireTension: 0.75, wireResponse: 0.85,
      snareRattle: 32, rattleDecay: 0.15, rattleFreqRange: [180, 8500],
      wireStrands: 'standard', snareThrow: 1.0, fundamentalFreq: 225,
      bodyFreq: 190, overtones: [450, 675, 900], overtoneSpread: 0.78,
      harmonicDecay: 0.22, rimFreq: 2700, centerStrike: 0.78, edgeStrike: 0.0,
      rimShot: 0.0, stickTip: 'wood', stickWeight: 'medium', strikeAngle: 12,
      topHeadTension: 0.72, bottomHeadTension: 0.78, headInteraction: 0.65,
      transientShape: 'natural', sustainDecay: 0.15, crack: 0.72,
      roomReflection: 0.28, micBleed: 0.22, overheadBleed: 0.38,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      compression: 0.68
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 2, decay: 0.042, tone: 62, noise: 86, lofi: 4, closed: true,
      attack: 0.002, velocitySensitivity: 0.87, stereoWidth: 0.75, harmonicContent: 70,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'modern',
      topCymbalThickness: 1.0, bottomCymbalThickness: 1.2, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'modern', lathing: 'full',
      fundamentalFreq: 900, bellResonance: 0.35, edgeTone: 0.72, brilliance: 0.78,
      metalComplexity: 0.88, inharmonicity: 0.8, partialDecay: [0.038, 0.035, 0.032],
      frequencySpread: [900, 2600, 6000, 9800], overtoneBalance: [1.0, 0.75, 0.48, 0.25],
      footPressure: 0.78, clutchTension: 'tight', standTilt: 4, cymbalSeparation: 0.12,
      airRelease: 0.18, airPressure: 0.25, suctionEffect: 0.52, tipContact: 'shoulder',
      stickMaterial: 'wood', stickTip: 'small', chick: 0.75, dynamicRange: 45,
      stereoSpread: 0.75, roomReflection: 0.25, overheadBleed: 0.52,
      micType: 'condenser_small', micDistance: 7, micAngle: 40
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 2, decay: 0.19, tone: 66, noise: 81, lofi: 4, closed: false,
      attack: 0.003, velocitySensitivity: 0.85, stereoWidth: 0.8, harmonicContent: 72,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'modern',
      topCymbalThickness: 1.0, bottomCymbalThickness: 1.2, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'modern', lathing: 'full',
      fundamentalFreq: 900, bellResonance: 0.42, edgeTone: 0.75, brilliance: 0.75,
      metalComplexity: 0.85, inharmonicity: 0.82, shimmerDecay: 0.75,
      frequencySpread: [900, 2600, 6000, 9800, 13000],
      overtoneBalance: [1.0, 0.78, 0.58, 0.38, 0.2], sustainBuild: 0.012,
      washCharacter: 0.68, wash: 0.72, footPressure: 0.22, clutchTension: 'tight',
      cymbalSeparation: 1.0, airRelease: 0.72, airPressure: 0.88, suctionEffect: 0.15,
      pedalOpenness: 0.72, footBarrel: 0.38, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.58, bloom: 0.68,
      dynamicRange: 48, stereoSpread: 0.8, roomReflection: 0.32,
      overheadBleed: 0.65, micType: 'condenser_small', micDistance: 7
    },
    
    clap: { 
      type: 'clap', pitch: 0, decay: 0.14, tone: 41, noise: 89, lofi: 2, dist: 13,
      attack: 0.004, velocitySensitivity: 0.8, stereoWidth: 0.6, harmonicContent: 58,
      handCount: 6, handSize: 'medium', clapTightness: 'medium', handCupping: 0.42,
      initialSlap: 0.72, slapFreq: 1900, slapDecay: 0.009, slapHarmonics: 0.65,
      timingSpread: 0.011, velocityVariation: 0.16, stereoSpread: 0.6,
      multiHitDelay: [0.0, 0.009, 0.02, 0.035, 0.052, 0.072],
      multiHitGain: [1.0, 0.75, 0.62, 0.48, 0.38, 0.28],
      fundamentalFreq: 950, bodyResonance: 0.45, airCompression: 0.58,
      highFreqContent: 0.75, skinTexture: 0.38, reverseDecay: 0.16,
      roomSlap: 0.42, roomSize: 'medium', earlyReflections: 0.38,
      compression: 0.72
    },
    
    rimshot: { 
      type: 'snare', pitch: 9, decay: 0.052, tone: 76, noise: 31, lofi: 4,
      attack: 0.002, velocitySensitivity: 0.88, stereoWidth: 0.38, harmonicContent: 72,
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'simultaneous', stickAngle: 35, stickTip: 'wood',
      fundamentalFreq: 500, metalRing: 0.88, metalDecay: 0.062, metalFreq: 2900,
      woodContact: 0.75, woodFreq: 1350, woodDecay: 0.052, headResponse: 0.35,
      headDampening: 0.75, overtones: [1000, 1500, 2000], overtoneDecay: 0.045,
      ringOut: 0.75, clickTransient: 0.92, transientFreq: 3600, pitchBend: 0.2
    },
    
    tomLow: { 
      type: 'tom', pitch: -1, decay: 0.34, tone: 74, noise: 10, lofi: 4,
      attack: 0.005, velocitySensitivity: 0.82, stereoWidth: 0.42, harmonicContent: 65,
      drumSize: 14, depth: 12, shellMaterial: 'birch', shellThickness: 7,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 110, bodyResonance: 0.75, overtones: [220, 330, 440],
      overtoneBalance: [1.0, 0.62, 0.35, 0.18], sustainDecay: 0.34,
      headInteraction: 0.68, airCoupling: 0.62, headTension: 0.55,
      topBottomRatio: 0.85, dampening: 0.48, transientShape: 'natural',
      attackCurve: 'exponential', roomReflection: 0.32, micBleed: 0.25,
      overheadBleed: 0.42, doubleHeaded: true, resonantDecay: 0.38
    },
    
    tomHigh: { 
      type: 'tom', pitch: 5, decay: 0.26, tone: 70, noise: 11, lofi: 4,
      attack: 0.004, velocitySensitivity: 0.84, stereoWidth: 0.52, harmonicContent: 68,
      drumSize: 10, depth: 9, shellMaterial: 'birch', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 185, bodyResonance: 0.72, overtones: [370, 555, 740],
      overtoneBalance: [1.0, 0.65, 0.38, 0.2], sustainDecay: 0.26,
      headInteraction: 0.72, airCoupling: 0.65, headTension: 0.65,
      topBottomRatio: 0.88, dampening: 0.55, transientShape: 'natural',
      attackCurve: 'exponential', roomReflection: 0.35, micBleed: 0.28,
      overheadBleed: 0.48, doubleHeaded: true, resonantDecay: 0.35
    },
    
    bass: { 
      type: 'bass', pitch: 1, decay: 0.78, tone: 66, attack: 0.0048, lofi: 0, dist: 9,
      velocitySensitivity: 0.88, stereoWidth: 0.22, harmonicContent: 68,
      stringCount: 4, stringGauge: [0.045, 0.065, 0.085, 0.105],
      tuning: 'standard', stringMaterial: 'nickel_roundwound', stringAge: 'good',
      stringTension: 'medium', fundamentalFreq: 82, subHarmonics: 0.68,
      overtones: [164, 246, 328], harmonicBalance: [1.0, 0.75, 0.52, 0.32, 0.18],
      sustainDecay: 0.78, pickAttack: 0.62, fingerStyle: false,
      playingPosition: 'bridge', stringResonance: 0.72, fretNoise: 0.28,
      fretBuzz: 0.15, stringSlap: 0.0, bodyResonance: 0.75, bodyWood: 'alder',
      neckWood: 'maple', pickupType: 'jazz_both', pickupPosition: 0.55,
      toneKnob: 0.65, ampModel: 'solid_state', ampGain: 0.55, ampTone: 0.58,
      cabinetIR: 'ampeg_4x10', cabinetMic: 'u47', micDistance: 16,
      compression: 0.65
    },
    
    keys: { 
      type: 'keys', pitch: -3, decay: 1.02, tone: 61, attack: 0.0052, lofi: 0,
      velocitySensitivity: 0.9, stereoWidth: 0.65, harmonicContent: 65,
      instrumentType: 'electric_piano', keyCount: 73, hammerAction: true,
      tineResonance: 0.78, pickupDistance: 0.62, amplification: 'transistor',
      fundamentalFreq: 261.63, stringResonance: 0.78, tineDecay: 1.02,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicDecay: [1.0, 0.75, 0.52, 0.35, 0.22, 0.12],
      inharmonicity: 0.32, partialTuning: 'stretched', hammerNoise: 0.38,
      releaseNoise: 0.25, damperNoise: 0.16, pedalResonance: 0.65,
      mechanicalClick: 0.32, stereoMicing: 'spaced_pair', roomAmbience: 0.32,
      micType: 'condenser_large'
    },
    
    lead: { 
      type: 'lead', pitch: 11, decay: 0.92, tone: 67, attack: 0.011, lofi: 0,
      velocitySensitivity: 0.86, stereoWidth: 0.58, harmonicContent: 70,
      instrumentType: 'synthesizer', waveform: 'sawtooth', filterType: 'lowpass',
      filterCutoff: 1800, filterResonance: 0.55, envelopeDecay: 0.92,
      lfoRate: 5.5, lfoDepth: 0.32, portamento: 0.12, detuneAmount: 0.015,
      harmonicSeries: [1, 2, 3, 4, 5], harmonicBalance: [1.0, 0.78, 0.58, 0.38, 0.22],
      unison: 2, unisonDetune: 0.015
    },
    
    rimshot: { 
      type: 'snare', pitch: 6, decay: 0.065, tone: 60, noise: 38, lofi: 28,
      attack: 0.0018, velocitySensitivity: 0.8, stereoWidth: 0.32, harmonicContent: 60,
      // Rimshot mechanics
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'simultaneous', stickAngle: 35, stickTip: 'wood',
      // Sound characteristics
      fundamentalFreq: 480, metalRing: 0.82, metalDecay: 0.055, metalFreq: 2800,
      woodContact: 0.65, woodFreq: 1200, woodDecay: 0.045,
      headResponse: 0.35, headDampening: 0.75,
      // Harmonic content
      overtones: [960, 1440, 1920], overtoneDecay: 0.038, ringOut: 0.68,
      clickTransient: 0.88, transientFreq: 3500, pitchBend: 0.22
    },
    
    tomLow: { 
      type: 'tom', pitch: -5, decay: 0.42, tone: 64, noise: 14, lofi: 32,
      attack: 0.006, velocitySensitivity: 0.76, stereoWidth: 0.38, harmonicContent: 52,
      // Tom modeling
      drumSize: 14, depth: 12, shellMaterial: 'birch', shellThickness: 7,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      // Acoustic properties
      fundamentalFreq: 98, bodyResonance: 0.72, overtones: [196, 294, 392],
      overtoneBalance: [1.0, 0.58, 0.32, 0.15], sustainDecay: 0.42,
      headInteraction: 0.65, airCoupling: 0.58,
      // Dynamics
      headTension: 0.52, topBottomRatio: 0.85, dampening: 0.45,
      transientShape: 'natural', attackCurve: 'exponential',
      // Spatial
      roomReflection: 0.32, micBleed: 0.25, overheadBleed: 0.42,
      doubleHeaded: true, resonantDecay: 0.38
    },
    
    tomHigh: { 
      type: 'tom', pitch: 1, decay: 0.32, tone: 60, noise: 16, lofi: 32,
      attack: 0.005, velocitySensitivity: 0.78, stereoWidth: 0.42, harmonicContent: 54,
      // Tom modeling
      drumSize: 10, depth: 9, shellMaterial: 'birch', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      // Acoustic properties
      fundamentalFreq: 165, bodyResonance: 0.68, overtones: [330, 495, 660],
      overtoneBalance: [1.0, 0.62, 0.35, 0.18], sustainDecay: 0.32,
      headInteraction: 0.68, airCoupling: 0.62,
      // Dynamics
      headTension: 0.62, topBottomRatio: 0.88, dampening: 0.52,
      transientShape: 'natural', attackCurve: 'exponential',
      // Spatial
      roomReflection: 0.35, micBleed: 0.28, overheadBleed: 0.45,
      doubleHeaded: true, resonantDecay: 0.35
    },
    
    bass: { 
      type: 'bass', pitch: -1, decay: 0.78, tone: 48, attack: 0.008, lofi: 40, dist: 18,
      velocitySensitivity: 0.84, stereoWidth: 0.18, harmonicContent: 48, bitDepth: 12,
      // Bass guitar modeling
      stringCount: 4, stringGauge: [0.045, 0.065, 0.085, 0.105], tuning: 'standard',
      stringMaterial: 'nickel_roundwound', stringAge: 'broken_in', stringTension: 'medium',
      // Acoustic properties
      fundamentalFreq: 82, subHarmonics: 0.58, overtones: [164, 246, 328],
      harmonicBalance: [1.0, 0.68, 0.42, 0.25, 0.15], sustainDecay: 0.78,
      // Playing characteristics
      pickAttack: 0.55, fingerStyle: false, playingPosition: 'bridge',
      stringResonance: 0.65, fretNoise: 0.28, fretBuzz: 0.15, stringSlap: 0.0,
      // Body & electronics
      bodyResonance: 0.68, bodyWood: 'alder', neckWood: 'maple',
      pickupType: 'jazz_bridge', pickupPosition: 0.65, toneKnob: 0.6,
      // Amp simulation
      ampModel: 'vintage_tube', ampGain: 0.42, ampTone: 0.48,
      cabinetIR: 'ampeg_4x10', cabinetMic: 'u47', micDistance: 18,
      // Vintage character
      analogWarmth: 0.72, tubeSaturation: 0.28, tapeCompression: 0.35,
      vinylCrackle: 0.0, wowFlutter: 0.12, noiseFloor: -62
    },
    
    keys: { 
      type: 'keys', pitch: 2, decay: 0.95, tone: 45, attack: 0.012, lofi: 44,
      velocitySensitivity: 0.87, stereoWidth: 0.52, harmonicContent: 50, vinylCrackle: 15,
      // Piano/keyboard modeling
      instrumentType: 'electric_piano_vintage', keyCount: 73, hammerAction: true,
      tineResonance: 0.75, pickupDistance: 0.65, amplification: 'transistor',
      // Acoustic properties
      fundamentalFreq: 261.63, stringResonance: 0.75, tineDecay: 0.95,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicDecay: [1.0, 0.72, 0.48, 0.32, 0.18, 0.08],
      inharmonicity: 0.35, partialTuning: 'stretched',
      // Mechanical noise
      hammerNoise: 0.42, releaseNoise: 0.28, damperNoise: 0.18,
      pedalResonance: 0.62, mechanicalClick: 0.35,
      // Effects & character
      tremolo: 0.0, chorus: 0.0, vibrato: 0.0,
      vintageCharacter: 0.72, bell: 0.55, bark: 0.48,
      // Recording
      stereoMicing: 'spaced_pair', roomAmbience: 0.32, micType: 'ribbon'
    },
    
    guitar: { 
      type: 'guitar', pitch: -2, decay: 0.88, tone: 51, attack: 0.006, lofi: 38,
      velocitySensitivity: 0.82, stereoWidth: 0.58, harmonicContent: 54,
      // Guitar modeling
      stringCount: 6, stringGauge: [0.010, 0.013, 0.017, 0.026, 0.036, 0.046],
      tuning: 'standard', stringMaterial: 'nickel_roundwound', stringAge: 'medium',
      // Acoustic properties
      fundamentalFreq: 196, overtones: [392, 588, 784, 980],
      harmonicBalance: [1.0, 0.68, 0.45, 0.28, 0.15], sustainDecay: 0.88,
      // Playing characteristics
      pickNoise: 0.35, pickThickness: 0.71, pickMaterial: 'nylon',
      fretBuzz: 0.22, fretNoise: 0.28, stringSlide: 0.18,
      playingPosition: 'middle', strikeDynamics: 0.82,
      // Body & construction
      bodyResonance: 0.78, bodyWood: 'mahogany', topWood: 'spruce',
      bodySize: 'dreadnought', bracing: 'x_braced', soundholeSize: 4,
      // Interaction
      stringInteraction: 0.48, sympatheticResonance: 0.42,
      neckResonance: 0.38, bodyVibration: 0.65,
      // Recording
      micType: 'condenser_large', micPosition: '12th_fret', micDistance: 12,
      roomAmbience: 0.35, stereoWidth: 0.58
    }
  },

  metal: {
    _kitMeta: { 
      roomSize: 0.68, roomBrightness: 82, micDistance: 0.58, vintageYear: 2024, wear: 0.05,
      bitDepth: 24, sampleRate: 96000, compressionRatio: 8.5, gateThreshold: -42,
      micPreamp: 'modern_fet', parallelCompression: 0.45, masterBus: 'ssl_comp',
      micType: 'multi_mic_array', roomTreatment: 'professional', signalPath: 'pristine'
    },
    
    kick: { 
      type: 'kick', pitch: -12, decay: 0.14, tone: 75, noise: 6, lofi: 0, dist: 68,
      attack: 0.0003, transientGain: 1.55, velocitySensitivity: 0.92, stereoWidth: 0.12,
      harmonicContent: 72,
      // Acoustic modeling
      drumSize: 24, shellMaterial: 'maple_reinforced', headType: 'clear_single_ported',
      beaterMaterial: 'hard_plastic', beaterWeight: 'heavy', beaterAngle: 90,
      doublePedal: true, pedalTension: 'high', pedalResponse: 'ultra_fast',
      // Frequency response
      fundamentalFreq: 55, subFreq: 45, subWeight: 0.85, bodyResonance: 0.38,
      overtones: [110, 165, 220], overtoneBalance: [0.35, 0.18, 0.08, 0.03],
      clickFreq: 3800, beaterClick: 0.88, clickDecay: 0.008, clickHarmonics: 0.92,
      attackClick: 0.95, metalBeater: true,
      // Extreme processing
      dampening: 0.82, portHole: 0.0, pillow: 'full_muffle', headTension: 0.35,
      bodyDecay: 0.14, transientShape: 'ultra_sharp', transientPeak: 0.0003,
      sustainCurve: 'brick_wall', gateRelease: 0.025,
      // Multi-mic setup
      innerMic: 'akg_d112', innerMicDistance: 3, innerMicGain: 1.0,
      outerMic: 'shure_beta91', outerMicPlacement: 'inside', outerMicGain: 0.85,
      subMic: 'yamaha_subkick', subMicGain: 0.75,
      // Spatial
      roomReflection: 0.12, roomMics: 0.22, roomMicCompression: 0.65,
      earlyReflections: 0.08, micBleed: 0.05, phaseAlignment: 0.98,
      // Dynamics
      dynamicRange: 55, velocityResponse: 'linear', ghostNotes: 0.25,
      pedalTechnique: 'slide', heelToe: true, swivel: false,
      reboundDamping: 0.88, footPosition: 'centered'
    },
    
    snare: { 
      type: 'snare', pitch: 8, decay: 0.095, tone: 86, noise: 90, lofi: 0, dist: 58,
      attack: 0.00025, transientGain: 1.62, velocitySensitivity: 0.94, stereoWidth: 0.22,
      harmonicContent: 80,
      // Acoustic modeling
      drumSize: 14, depth: 6.5, shellMaterial: 'steel', shellThickness: 1.2,
      metalShell: true, shellFinish: 'chrome',
      topHead: 'coated_emperor', bottomHead: 'snare_side_diplomat',
      // Snare mechanics
      wireCount: 20, wireMaterial: 'steel_coated', wireTension: 0.88,
      wireResponse: 0.95, snareRattle: 48, rattleDecay: 0.12,
      rattleFreqRange: [200, 10000], wireStrands: 'micro_crimped',
      snareThrow: 1.0, snaireBeds: 'precision_cut',
      // Frequency response
      fundamentalFreq: 240, bodyFreq: 200, crackFreq: 4200,
      overtones: [480, 720, 960, 1200], overtoneSpread: 0.88,
      harmonicDecay: 0.18, rimFreq: 2800, ringFreq: 3400,
      // Articulations
      centerStrike: 0.92, edgeStrike: 0.0, rimShot: 0.0, crossStick: 0.0,
      stickTip: 'nylon', stickWeight: 'heavy', strikeAngle: 8,
      strikeVelocity: 'extreme', edgeTone: 0.75,
      // Dynamics & processing
      topHeadTension: 0.78, bottomHeadTension: 0.85, headInteraction: 0.72,
      transientShape: 'explosive', sustainDecay: 0.095, crack: 0.92,
      bodyThunk: 0.65, metalRing: 0.58,
      // Multi-mic setup
      topMic: 'sm57', topMicDistance: 2, topMicAngle: 45, topMicGain: 1.0,
      bottomMic: 'sm57', bottomMicDistance: 3, bottomMicPhase: 'inverted',
      // Spatial
      roomReflection: 0.15, roomMics: 0.28, micBleed: 0.08,
      overheadBleed: 0.35, compression: 0.85, gating: 0.75,
      ghostNoteResponse: 0.35, buzzResponse: 0.22, sympatheticVibration: 0.18
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 9, decay: 0.016, tone: 94, noise: 98, lofi: 0, closed: true,
      attack: 0.00015, velocitySensitivity: 0.95, stereoWidth: 0.78, harmonicContent: 85,
      // Cymbal modeling
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'heavy', cymbalProfile: 'modern',
      topCymbalThickness: 1.4, bottomCymbalThickness: 1.6, bellSize: 5,
      metalAlloy: 'b8_bronze', hammerPattern: 'machine', lathing: 'minimal',
      // Acoustic properties
      fundamentalFreq: 920, bellResonance: 0.28, edgeTone: 0.85, brilliance: 0.88,
      metalComplexity: 0.96, inharmonicity: 0.88, partialDecay: [0.014, 0.012, 0.010],
      frequencySpread: [920, 2800, 6200, 10500, 15000],
      overtoneBalance: [1.0, 0.82, 0.58, 0.35, 0.18],
      // Mechanics
      footPressure: 0.92, clutchTension: 'ultra_tight', standTilt: 3,
      cymbalSeparation: 0.08, airRelease: 0.05, airPressure: 0.15,
      suctionEffect: 0.68, lockup: 0.85,
      // Dynamics
      tipContact: 'shoulder', stickMaterial: 'carbon_fiber', stickTip: 'micro',
      chick: 0.95, chop: 0.0, splash: 0.0, dynamicRange: 52,
      stick: 0.95, attack: 0.92,
      // Recording
      stereoSpread: 0.78, roomReflection: 0.12, overheadBleed: 0.45,
      micType: 'condenser_pencil', micDistance: 6, micAngle: 35,
      highPassFilter: 300, compression: 0.75
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 8, decay: 0.085, tone: 92, noise: 96, lofi: 0, closed: false,
      attack: 0.0002, velocitySensitivity: 0.93, stereoWidth: 0.82, harmonicContent: 83,
      // Cymbal modeling
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'heavy', cymbalProfile: 'modern',
      topCymbalThickness: 1.4, bottomCymbalThickness: 1.6, bellSize: 5,
      metalAlloy: 'b8_bronze', hammerPattern: 'machine', lathing: 'minimal',
      // Acoustic properties
      fundamentalFreq: 920, bellResonance: 0.38, edgeTone: 0.78, brilliance: 0.85,
      metalComplexity: 0.94, inharmonicity: 0.85, shimmerDecay: 0.65,
      frequencySpread: [920, 2800, 6200, 10500, 15000],
      overtoneBalance: [1.0, 0.88, 0.68, 0.45, 0.25],
      sustainBuild: 0.008, washCharacter: 0.45, sizzle: 0.0,
      // Mechanics
      footPressure: 0.15, clutchTension: 'ultra_tight', cymbalSeparation: 0.9,
      airRelease: 0.75, airPressure: 0.92, suctionEffect: 0.08,
      pedalOpenness: 0.68, footBarrel: 0.45,
      // Dynamics
      tipContact: 'edge', stickMaterial: 'carbon_fiber', strikeForce: 'heavy',
      wash: 0.55, swell: 0.48, bloom: 0.52, dynamicRange: 48,
      articulation: 0.88, crispness: 0.92,
      // Recording
      stereoSpread: 0.82, roomReflection: 0.15, overheadBleed: 0.55,
      micType: 'condenser_pencil', micDistance: 6, compression: 0.68
    },
    
    clap: { 
      type: 'clap', pitch: 4, decay: 0.075, tone: 50, noise: 96, lofi: 0, dist: 42,
      attack: 0.0003, velocitySensitivity: 0.88, stereoWidth: 0.58, harmonicContent: 68,
      // Layered clap modeling
      handCount: 8, layered: true, layerCount: 3,
      handSize: 'large', clapTightness: 'tight', handCupping: 0.35,
      initialSlap: 0.82, slapFreq: 2200, slapDecay: 0.006, slapHarmonics: 0.75,
      // Timing & spread
      timingSpread: 0.005, velocityVariation: 0.08, stereoSpread: 0.58,
      multiHitDelay: [0.0, 0.004, 0.009, 0.016, 0.026, 0.038, 0.052, 0.068],
      multiHitGain: [1.0, 0.92, 0.85, 0.75, 0.65, 0.52, 0.4, 0.28],
      fundamentalFreq: 1250, bodyResonance: 0.48, airCompression: 0.75,
      highFreqContent: 0.9, skinTexture: 0.35, reverseDecay: 0.12,
      roomSlap: 0.35, roomSize: 'large', earlyReflections: 0.32,
      compression: 0.88, saturation: 0.5
    },
  },
  
  techno: {
    _kitMeta: { 
      roomSize: 0.72, roomBrightness: 80, micDistance: 0.52, vintageYear: 2023, wear: 0.06,
      bitDepth: 24, sampleRate: 48000, compressionRatio: 9.2, micPreamp: 'modern_discrete',
      masterBus: 'digital_comp', signalPath: 'ultra_clean', stereoImaging: 'wide'
    },
    
    kick: { 
      type: 'kick', pitch: 1, decay: 0.28, tone: 80, noise: 2, lofi: 0, dist: 36,
      attack: 0.0006, transientGain: 1.45, velocitySensitivity: 0.93, stereoWidth: 0.1,
      harmonicContent: 78,
      drumSize: 22, shellMaterial: 'birch', headType: 'coated_single',
      beaterMaterial: 'felt_medium', beaterWeight: 'medium', beaterAngle: 52,
      fundamentalFreq: 62, subFreq: 52, subWeight: 0.68, bodyResonance: 0.65,
      overtones: [124, 186, 248], overtoneBalance: [0.48, 0.28, 0.15, 0.06],
      clickFreq: 3400, beaterClick: 0.65, clickDecay: 0.012, clickHarmonics: 0.72,
      dampening: 0.62, portHole: 0.0, headTension: 0.45, bodyDecay: 0.28,
      transientShape: 'sharp', transientPeak: 0.0006, sustainCurve: 'techno_optimized',
      roomReflection: 0.18, earlyReflections: 0.25, micBleed: 0.12,
      proximity: 0.42, phaseAlignment: 0.96, micPlacement: 'center_aggressive',
      roomMics: 0.28, innerMic: 'akg_d12', outerMic: 'beta_52',
      compression: 0.78, punch: 0.88, warehouse: 0.82
    },
    
    snare: { 
      type: 'snare', pitch: 6, decay: 0.082, tone: 48, noise: 86, lofi: 0, dist: 32,
      attack: 0.0003, transientGain: 1.48, velocitySensitivity: 0.94, stereoWidth: 0.25,
      harmonicContent: 70,
      drumSize: 14, depth: 5.5, shellMaterial: 'steel', shellThickness: 1.0,
      metalShell: true, topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 20, wireMaterial: 'steel', wireTension: 0.82, wireResponse: 0.92,
      snareRattle: 40, rattleDecay: 0.1, rattleFreqRange: [190, 9500],
      wireStrands: 'crimped', snareThrow: 1.0,
      fundamentalFreq: 235, bodyFreq: 195, crackFreq: 4800,
      overtones: [470, 705, 940], overtoneSpread: 0.85, harmonicDecay: 0.15,
      rimFreq: 3000, centerStrike: 0.88, edgeStrike: 0.0,
      rimShot: 0.0, stickTip: 'nylon', stickWeight: 'medium_heavy',
      strikeAngle: 10, topHeadTension: 0.75, bottomHeadTension: 0.82,
      headInteraction: 0.68, transientShape: 'sharp', sustainDecay: 0.082,
      crack: 0.85, roomReflection: 0.15, micBleed: 0.1, overheadBleed: 0.32,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      compression: 0.82, gating: 0.72
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 7, decay: 0.024, tone: 76, noise: 96, lofi: 0, closed: true,
      attack: 0.0002, velocitySensitivity: 0.95, stereoWidth: 0.8, harmonicContent: 84,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_heavy',
      cymbalProfile: 'modern', topCymbalThickness: 1.1, bottomCymbalThickness: 1.3,
      bellSize: 4.8, metalAlloy: 'b20_bronze', hammerPattern: 'modern',
      lathing: 'partial', fundamentalFreq: 930, bellResonance: 0.32,
      edgeTone: 0.82, brilliance: 0.88, metalComplexity: 0.92,
      inharmonicity: 0.85, partialDecay: [0.022, 0.02, 0.018],
      frequencySpread: [930, 2900, 6400, 10800, 14800],
      overtoneBalance: [1.0, 0.8, 0.58, 0.35, 0.18],
      footPressure: 0.88, clutchTension: 'tight', standTilt: 3,
      cymbalSeparation: 0.1, airRelease: 0.08, airPressure: 0.18,
      suctionEffect: 0.62, tipContact: 'shoulder', stickMaterial: 'wood',
      stickTip: 'small', chick: 0.88, dynamicRange: 50,
      stereoSpread: 0.8, roomReflection: 0.15, overheadBleed: 0.48,
      micType: 'condenser_pencil', micDistance: 6, micAngle: 38,
      compression: 0.78
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 6, decay: 0.12, tone: 78, noise: 94, lofi: 0, closed: false,
      attack: 0.0003, velocitySensitivity: 0.93, stereoWidth: 0.84, harmonicContent: 82,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_heavy',
      cymbalProfile: 'modern', topCymbalThickness: 1.1, bottomCymbalThickness: 1.3,
      bellSize: 4.8, metalAlloy: 'b20_bronze', hammerPattern: 'modern',
      lathing: 'partial', fundamentalFreq: 930, bellResonance: 0.4,
      edgeTone: 0.78, brilliance: 0.85, metalComplexity: 0.9,
      inharmonicity: 0.83, shimmerDecay: 0.72,
      frequencySpread: [930, 2900, 6400, 10800, 14800],
      overtoneBalance: [1.0, 0.85, 0.65, 0.42, 0.22],
      sustainBuild: 0.01, washCharacter: 0.68, wash: 0.72,
      footPressure: 0.18, clutchTension: 'tight', cymbalSeparation: 1.1,
      airRelease: 0.78, airPressure: 0.92, suctionEffect: 0.12,
      pedalOpenness: 0.72, footBarrel: 0.42, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.62,
      bloom: 0.7, dynamicRange: 48, stereoSpread: 0.84,
      roomReflection: 0.18, overheadBleed: 0.65, micType: 'condenser_pencil',
      micDistance: 6, compression: 0.72
    },
    
    clap: { 
      type: 'clap', pitch: 4, decay: 0.095, tone: 30, noise: 96, lofi: 0, dist: 36,
      attack: 0.0003, velocitySensitivity: 0.9, stereoWidth: 0.62, harmonicContent: 66,
      handCount: 7, layered: true, layerCount: 2, handSize: 'medium',
      clapTightness: 'tight', handCupping: 0.32, initialSlap: 0.82,
      slapFreq: 2100, slapDecay: 0.006, slapHarmonics: 0.72,
      timingSpread: 0.007, velocityVariation: 0.1, stereoSpread: 0.62,
      multiHitDelay: [0.0, 0.005, 0.012, 0.022, 0.035, 0.05, 0.068],
      multiHitGain: [1.0, 0.88, 0.78, 0.68, 0.55, 0.42, 0.3],
      fundamentalFreq: 1100, bodyResonance: 0.45, airCompression: 0.68,
      highFreqContent: 0.85, skinTexture: 0.38, reverseDecay: 0.14,
      roomSlap: 0.4, roomSize: 'large', earlyReflections: 0.36,
      compression: 0.82, saturation: 0.45
    },
    
    rimshot: { 
      type: 'snare', pitch: 14, decay: 0.035, tone: 90, noise: 20, lofi: 0,
      attack: 0.0002, velocitySensitivity: 0.92, stereoWidth: 0.32, harmonicContent: 80,
      drumSize: 14, shellMaterial: 'steel', rimMaterial: 'steel_die_cast',
      stickContact: 'precise_simultaneous', stickAngle: 30, stickTip: 'nylon',
      fundamentalFreq: 580, metalRing: 0.92, metalDecay: 0.042, metalFreq: 3400,
      woodContact: 0.88, woodFreq: 1550, woodDecay: 0.035,
      headResponse: 0.25, headDampening: 0.85, overtones: [1160, 1740, 2320],
      overtoneDecay: 0.032, ringOut: 0.8, clickTransient: 0.96,
      transientFreq: 4300, pitchBend: 0.16
    },
    
    tomLow: { 
      type: 'tom', pitch: 1, decay: 0.3, tone: 86, noise: 5, lofi: 0,
      attack: 0.003, velocitySensitivity: 0.89, stereoWidth: 0.38, harmonicContent: 74,
      drumSize: 14, depth: 12, shellMaterial: 'birch', shellThickness: 7,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 120, bodyResonance: 0.78, overtones: [240, 360, 480],
      overtoneBalance: [1.0, 0.65, 0.38, 0.18], sustainDecay: 0.3,
      headInteraction: 0.75, airCoupling: 0.68, headTension: 0.5,
      topBottomRatio: 0.82, dampening: 0.42, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.22, micBleed: 0.15,
      overheadBleed: 0.38, doubleHeaded: true, roomMics: 0.38,
      resonantDecay: 0.35
    },
    
    tomHigh: { 
      type: 'tom', pitch: 8, decay: 0.23, tone: 84, noise: 6, lofi: 0,
      attack: 0.0025, velocitySensitivity: 0.91, stereoWidth: 0.48, harmonicContent: 77,
      drumSize: 10, depth: 9, shellMaterial: 'birch', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 195, bodyResonance: 0.75, overtones: [390, 585, 780],
      overtoneBalance: [1.0, 0.68, 0.4, 0.2], sustainDecay: 0.23,
      headInteraction: 0.78, airCoupling: 0.7, headTension: 0.6,
      topBottomRatio: 0.85, dampening: 0.48, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.25, micBleed: 0.18,
      overheadBleed: 0.42, doubleHeaded: true, roomMics: 0.42,
      resonantDecay: 0.3
    },
  
    bass: { 
      type: 'bass', pitch: 0, decay: 0.45, tone: 78, attack: 0.001, lofi: 0, dist: 28,
      velocitySensitivity: 0.94, stereoWidth: 0.18, harmonicContent: 80,
      stringCount: 4, stringGauge: [0.105, 0.085, 0.065, 0.045],
      tuning: 'standard', stringMaterial: 'stainless_steel', stringAge: 'new',
      stringTension: 'high', fundamentalFreq: 82, subHarmonics: 0.75,
      overtones: [164, 246, 328, 410], harmonicBalance: [1.0, 0.82, 0.62, 0.42, 0.25],
      sustainDecay: 0.45, pickAttack: 0.72, fingerStyle: false,
      playingPosition: 'bridge', stringResonance: 0.68, fretNoise: 0.15,
      fretBuzz: 0.08, stringSlap: 0.0, bodyResonance: 0.62,
      bodyWood: 'ash', neckWood: 'maple', pickupType: 'jazz_bridge',
      pickupPosition: 0.75, toneKnob: 0.45, ampModel: 'modern_solid_state',
      ampGain: 0.62, ampTone: 0.55, cabinetIR: 'ampeg_8x10',
      cabinetMic: 'sm57_dual', micDistance: 8, compression: 0.75,
      modernProcessing: true
    },
    
    lead: { 
      type: 'lead', pitch: 0, decay: 0.52, tone: 84, attack: 0.003, lofi: 0,
      velocitySensitivity: 0.92, stereoWidth: 0.52, harmonicContent: 82,
      instrumentType: 'synthesizer', waveform: 'sawtooth', filterType: 'lowpass',
      filterCutoff: 2200, filterResonance: 0.68, envelopeDecay: 0.52,
      lfoRate: 6.5, lfoDepth: 0.38, portamento: 0.06, detuneAmount: 0.1,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicBalance: [1.0, 0.85, 0.7, 0.52, 0.35, 0.2],
      unison: 3, unisonDetune: 0.1, brightness: 0.85
    },
    
    fx: { 
      type: 'fx', pitch: 5, decay: 1.3, tone: 54, attack: 0.0006, lofi: 0, dist: 24,
      velocitySensitivity: 0.87, stereoWidth: 0.88, harmonicContent: 68,
      instrumentType: 'synthesizer', waveform: 'noise', filterType: 'bandpass',
      filterCutoff: 1800, filterResonance: 0.72, filterSweep: 0.65,
      envelopeDecay: 1.3, lfoRate: 3.2, lfoDepth: 0.48,
      reverb: 0.45, delay: 0.32, stereoSpread: 0.88
    }
  },

  dnb: {
    _kitMeta: { 
      roomSize: 0.48, roomBrightness: 76, micDistance: 0.38, vintageYear: 2021, wear: 0.1,
      bitDepth: 24, sampleRate: 48000, compressionRatio: 10.2, gateThreshold: -40,
      micPreamp: 'modern_transformer', parallelCompression: 0.55, masterBus: 'api_2500',
      characterCurve: 'aggressive_tight'
    },
    
    kick: { 
      type: 'kick', pitch: -1, decay: 0.17, tone: 70, noise: 12, lofi: 0, dist: 56,
      attack: 0.0004, transientGain: 1.58, velocitySensitivity: 0.94, stereoWidth: 0.12,
      harmonicContent: 74,
      drumSize: 22, shellMaterial: 'maple', headType: 'coated_single_ported',
      beaterMaterial: 'hard_plastic', beaterWeight: 'heavy', beaterAngle: 85,
      fundamentalFreq: 58, subFreq: 48, subWeight: 0.78, bodyResonance: 0.48,
      overtones: [116, 174, 232], overtoneBalance: [0.38, 0.22, 0.12, 0.05],
      clickFreq: 3600, beaterClick: 0.82, clickDecay: 0.01, clickHarmonics: 0.88,
      dampening: 0.75, portHole: 0.0, headTension: 0.38, bodyDecay: 0.17,
      transientShape: 'ultra_sharp', transientPeak: 0.0004, sustainCurve: 'tight',
      roomReflection: 0.15, earlyReflections: 0.18, micBleed: 0.08,
      proximity: 0.38, phaseAlignment: 0.97, micPlacement: 'center_aggressive',
      roomMics: 0.25, innerMic: 'akg_d112', outerMic: 'beta_91',
      compression: 0.82, gating: 0.78, punch: 0.92
    },
    
    snare: { 
      type: 'snare', pitch: 7, decay: 0.098, tone: 40, noise: 96, lofi: 0, dist: 50,
      attack: 0.00025, transientGain: 1.6, velocitySensitivity: 0.96, stereoWidth: 0.28,
      harmonicContent: 77,
      drumSize: 14, depth: 6, shellMaterial: 'steel', shellThickness: 1.0,
      metalShell: true, topHead: 'coated_emperor', bottomHead: 'snare_side_diplomat',
      wireCount: 20, wireMaterial: 'steel_coated', wireTension: 0.9, wireResponse: 0.98,
      snareRattle: 50, rattleDecay: 0.08, rattleFreqRange: [200, 11000],
      wireStrands: 'micro_crimped', snareThrow: 1.0,
      fundamentalFreq: 238, bodyFreq: 198, crackFreq: 5200,
      overtones: [476, 714, 952, 1190], overtoneSpread: 0.92,
      harmonicDecay: 0.14, rimFreq: 3100, centerStrike: 0.95,
      edgeStrike: 0.0, rimShot: 0.0, stickTip: 'nylon', stickWeight: 'heavy',
      strikeAngle: 6, topHeadTension: 0.8, bottomHeadTension: 0.88,
      headInteraction: 0.75, transientShape: 'explosive', sustainDecay: 0.098,
      crack: 0.96, bodyThunk: 0.48, metalRing: 0.55,
      roomReflection: 0.12, micBleed: 0.06, overheadBleed: 0.3,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      compression: 0.88, gating: 0.82
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 8, decay: 0.018, tone: 78, noise: 98, lofi: 0, closed: true,
      attack: 0.00012, velocitySensitivity: 0.97, stereoWidth: 0.78, harmonicContent: 87,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'heavy', cymbalProfile: 'modern',
      topCymbalThickness: 1.3, bottomCymbalThickness: 1.5, bellSize: 5,
      metalAlloy: 'b8_bronze', hammerPattern: 'machine', lathing: 'minimal',
      fundamentalFreq: 940, bellResonance: 0.28, edgeTone: 0.88, brilliance: 0.92,
      metalComplexity: 0.97, inharmonicity: 0.9, partialDecay: [0.016, 0.014, 0.012],
      frequencySpread: [940, 3000, 6600, 11200, 15800],
      overtoneBalance: [1.0, 0.85, 0.62, 0.38, 0.18],
      footPressure: 0.95, clutchTension: 'ultra_tight', standTilt: 2,
      cymbalSeparation: 0.07, airRelease: 0.03, airPressure: 0.12,
      suctionEffect: 0.72, tipContact: 'shoulder', stickMaterial: 'wood',
      stickTip: 'micro', chick: 0.98, dynamicRange: 54,
      stereoSpread: 0.78, roomReflection: 0.1, overheadBleed: 0.42,
      micType: 'condenser_pencil', micDistance: 5, micAngle: 32,
      compression: 0.8
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 7, decay: 0.09, tone: 74, noise: 95, lofi: 0, closed: false,
      attack: 0.0002, velocitySensitivity: 0.95, stereoWidth: 0.83, harmonicContent: 84,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'heavy', cymbalProfile: 'modern',
      topCymbalThickness: 1.3, bottomCymbalThickness: 1.5, bellSize: 5,
      metalAlloy: 'b8_bronze', hammerPattern: 'machine', lathing: 'minimal',
      fundamentalFreq: 940, bellResonance: 0.36, edgeTone: 0.8, brilliance: 0.88,
      metalComplexity: 0.95, inharmonicity: 0.87, shimmerDecay: 0.68,
      frequencySpread: [940, 3000, 6600, 11200, 15800],
      overtoneBalance: [1.0, 0.88, 0.7, 0.48, 0.25],
      sustainBuild: 0.008, washCharacter: 0.52, wash: 0.62,
      footPressure: 0.12, clutchTension: 'ultra_tight', cymbalSeparation: 0.95,
      airRelease: 0.8, airPressure: 0.95, suctionEffect: 0.08,
      pedalOpenness: 0.7, footBarrel: 0.48, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.52,
      bloom: 0.58, dynamicRange: 50, stereoSpread: 0.83,
      roomReflection: 0.12, overheadBleed: 0.58, micType: 'condenser_pencil',
      micDistance: 5, compression: 0.75
    },
    
    clap: { 
      type: 'clap', pitch: 4, decay: 0.078, tone: 28, noise: 98, lofi: 0, dist: 42,
      attack: 0.0002, velocitySensitivity: 0.92, stereoWidth: 0.58, harmonicContent: 70,
      handCount: 8, layered: true, layerCount: 3, handSize: 'large',
      clapTightness: 'tight', handCupping: 0.3, initialSlap: 0.88,
      slapFreq: 2300, slapDecay: 0.005, slapHarmonics: 0.78,
      timingSpread: 0.005, velocityVariation: 0.08, stereoSpread: 0.58,
      multiHitDelay: [0.0, 0.004, 0.009, 0.016, 0.026, 0.038, 0.052, 0.068],
      multiHitGain: [1.0, 0.92, 0.85, 0.75, 0.65, 0.52, 0.4, 0.28],
      fundamentalFreq: 1250, bodyResonance: 0.48, airCompression: 0.75,
      highFreqContent: 0.9, skinTexture: 0.35, reverseDecay: 0.12,
      roomSlap: 0.35, roomSize: 'medium', earlyReflections: 0.32,
      compression: 0.88, saturation: 0.5
    },
    
    rimshot: { 
      type: 'snare', pitch: 16, decay: 0.028, tone: 92, noise: 18, lofi: 0,
      attack: 0.0002, velocitySensitivity: 0.94, stereoWidth: 0.35, harmonicContent: 82,
      drumSize: 14, shellMaterial: 'steel', rimMaterial: 'steel_die_cast',
      stickContact: 'precise_simultaneous', stickAngle: 28, stickTip: 'nylon',
      fundamentalFreq: 620, metalRing: 0.96, metalDecay: 0.035, metalFreq: 3600,
      woodContact: 0.92, woodFreq: 1650, woodDecay: 0.03,
      headResponse: 0.2, headDampening: 0.9, overtones: [1240, 1860, 2480],
      overtoneDecay: 0.026, ringOut: 0.85, clickTransient: 0.98,
      transientFreq: 4600, pitchBend: 0.14
    },
    
    tomLow: { 
      type: 'tom', pitch: 2, decay: 0.24, tone: 80, noise: 7, lofi: 0,
      attack: 0.0025, velocitySensitivity: 0.91, stereoWidth: 0.4, harmonicContent: 74,
      drumSize: 13, depth: 11, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 125, bodyResonance: 0.76, overtones: [250, 375, 500],
      overtoneBalance: [1.0, 0.68, 0.4, 0.2], sustainDecay: 0.24,
      headInteraction: 0.78, airCoupling: 0.72, headTension: 0.52,
      topBottomRatio: 0.82, dampening: 0.45, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.18, micBleed: 0.12,
      overheadBleed: 0.35, doubleHeaded: true, roomMics: 0.35,
      resonantDecay: 0.32
    },
    
    tomHigh: { 
      type: 'tom', pitch: 9, decay: 0.18, tone: 78, noise: 8, lofi: 0,
      attack: 0.002, velocitySensitivity: 0.92, stereoWidth: 0.5, harmonicContent: 77,
      drumSize: 10, depth: 9, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 200, bodyResonance: 0.74, overtones: [400, 600, 800],
      overtoneBalance: [1.0, 0.7, 0.42, 0.22], sustainDecay: 0.18,
      headInteraction: 0.8, airCoupling: 0.74, headTension: 0.62,
      topBottomRatio: 0.85, dampening: 0.52, transientShape: 'sharp',
      attackCurve: 'fast', roomReflection: 0.2, micBleed: 0.15,
      overheadBleed: 0.4, doubleHeaded: true, roomMics: 0.4,
      resonantDecay: 0.28
    },
  
    bass: { 
      type: 'bass', pitch: -11, decay: 0.58, tone: 46, attack: 0.0006, lofi: 0, dist: 68,
      velocitySensitivity: 0.95, stereoWidth: 0.22, harmonicContent: 70, transientGain: 1.35,
      stringCount: 4, stringGauge: [0.105, 0.085, 0.065, 0.045],
      tuning: 'drop_d', stringMaterial: 'stainless_steel', stringAge: 'new',
      stringTension: 'extra_high', fundamentalFreq: 46, stringCount: 4, stringGauge: [0.105, 0.085, 0.065, 0.045],
      tuning: 'drop_d', stringMaterial: 'stainless_steel', stringAge: 'new',
      stringTension: 'extra_high', fundamentalFreq: 46, subHarmonics: 0.88,
      overtones: [92, 138, 184, 230], harmonicBalance: [1.0, 0.85, 0.68, 0.48, 0.28],
      sustainDecay: 0.58, pickAttack: 0.88, fingerStyle: false,
      playingPosition: 'bridge_aggressive', stringResonance: 0.52, fretNoise: 0.18,
      fretBuzz: 0.12, stringSlap: 0.0, clanking: 0.48,
      bodyResonance: 0.42, bodyWood: 'ash', neckWood: 'maple_reinforced',
      pickupType: 'emg_active', pickupPosition: 0.88, toneKnob: 0.32,
      ampModel: 'modern_high_gain', ampGain: 0.9, ampTone: 0.42,
      cabinetIR: 'ampeg_8x10', cabinetMic: 'sm57_dual', micDistance: 6,
      compression: 0.78, gating: 0.68, aggression: 0.92
    },
    
    lead: { 
      type: 'lead', pitch: 16, decay: 0.42, tone: 86, attack: 0.0025, lofi: 0,
      velocitySensitivity: 0.92, stereoWidth: 0.58, harmonicContent: 84,
      instrumentType: 'synthesizer', waveform: 'square', filterType: 'lowpass',
      filterCutoff: 2600, filterResonance: 0.72, envelopeDecay: 0.42,
      lfoRate: 7.2, lfoDepth: 0.42, portamento: 0.05, detuneAmount: 0.12,
      harmonicSeries: [1, 2, 3, 4, 5, 6, 7], harmonicBalance: [1.0, 0.88, 0.75, 0.58, 0.42, 0.28, 0.15],
      unison: 4, unisonDetune: 0.12, brightness: 0.88
    },
    
    fx: { 
      type: 'fx', pitch: -2, decay: 0.95, tone: 64, attack: 0.0005, lofi: 0, dist: 38,
      velocitySensitivity: 0.87, stereoWidth: 0.92, harmonicContent: 72,
      instrumentType: 'synthesizer', waveform: 'noise', filterType: 'highpass',
      filterCutoff: 2200, filterResonance: 0.78, filterSweep: 0.72,
      envelopeDecay: 0.95, lfoRate: 4.8, lfoDepth: 0.55,
      reverb: 0.52, delay: 0.38, stereoSpread: 0.92
    }
  },

  ambient: {
    _kitMeta: { 
      roomSize: 0.92, roomBrightness: 35, micDistance: 0.88, vintageYear: 1973, wear: 0.78,
      bitDepth: 16, sampleRate: 22050, tapeSaturation: 0.68, compressionRatio: 2.8,
      micPreamp: 'vintage_tube', micType: 'ribbon', analogChain: true,
      tapeSpeed: 7.5, tapeFormula: 'ampex_456', noiseFloor: -58, wow: 0.28, flutter: 0.15,
      roomReverb: 3.8, roomReflections: 'cathedral'
    },
    
    kick: { 
      type: 'kick', pitch: -8, decay: 1.5, tone: 30, noise: 32, lofi: 65, dist: 3,
      attack: 0.045, bleed: 20, velocitySensitivity: 0.66, stereoWidth: 0.38,
      harmonicContent: 34,
      drumSize: 24, shellMaterial: 'mahogany', headType: 'coated_double',
      beaterMaterial: 'felt_soft', beaterWeight: 'light', beaterAngle: 40,
      fundamentalFreq: 52, subFreq: 45, subWeight: 0.48, bodyResonance: 0.85,
      overtones: [104, 156, 208], overtoneBalance: [0.45, 0.32, 0.22, 0.12],
      clickFreq: 2200, beaterClick: 0.28, clickDecay: 0.035, clickHarmonics: 0.38,
      dampening: 0.22, portHole: 0.0, headTension: 0.32, bodyDecay: 1.5,
      transientShape: 'soft', transientPeak: 0.045, sustainCurve: 'natural_long',
      roomReflection: 0.88, earlyReflections: 0.78, micBleed: 0.65,
      proximity: 0.15, phaseAlignment: 0.75, micPlacement: 'distant',
      roomMics: 0.85, innerMic: 'ribbon', outerMic: 'ribbon',
      analogWarmth: 0.88, tubeSaturation: 0.55, tapeCompression: 0.62,
      vinylCrackle: 22, wowFlutter: 0.28, bitDepth: 12
    },
    
    snare: { 
      type: 'snare', pitch: -5, decay: 0.78, tone: 34, noise: 62, lofi: 62, dist: 4,
      attack: 0.038, bleed: 18, velocitySensitivity: 0.64, stereoWidth: 0.42,
      harmonicContent: 38,
      drumSize: 14, depth: 5, shellMaterial: 'maple', shellThickness: 5,
      topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 14, wireMaterial: 'steel', wireTension: 0.55, wireResponse: 0.68,
      snareRattle: 18, rattleDecay: 0.35, rattleFreqRange: [160, 6000],
      wireStrands: 'standard', snareThrow: 1.0,
      fundamentalFreq: 195, bodyFreq: 165, overtones: [390, 585, 780],
      overtoneSpread: 0.62, harmonicDecay: 0.42, rimFreq: 2200,
      centerStrike: 0.72, edgeStrike: 0.0, rimShot: 0.0,
      stickTip: 'wood', stickWeight: 'light', strikeAngle: 18,
      topHeadTension: 0.55, bottomHeadTension: 0.62, headInteraction: 0.52,
      transientShape: 'soft', sustainDecay: 0.78, roomReflection: 0.82,
      micBleed: 0.68, overheadBleed: 0.75, topMic: 'ribbon', bottomMic: 'ribbon',
      micPhase: 'inverted', ghostNoteResponse: 0.88, buzzResponse: 0.55,
      sympatheticVibration: 0.65, tubeSaturation: 0.48, vintage: 0.78,
      bitDepth: 12
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: -4, decay: 0.16, tone: 32, noise: 74, lofi: 55, closed: true,
      attack: 0.018, velocitySensitivity: 0.7, stereoWidth: 0.72, harmonicContent: 40,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.85, bottomCymbalThickness: 1.0, bellSize: 4.2,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 780, bellResonance: 0.48, edgeTone: 0.58, metalComplexity: 0.72,
      inharmonicity: 0.68, partialDecay: [0.15, 0.13, 0.11],
      frequencySpread: [780, 2000, 4800, 8200], overtoneBalance: [1.0, 0.62, 0.38, 0.18],
      footPressure: 0.58, clutchTension: 'medium', standTilt: 8,
      cymbalSeparation: 0.22, airRelease: 0.35, airPressure: 0.42,
      suctionEffect: 0.38, tipContact: 'edge', stickMaterial: 'wood',
      stickTip: 'medium', chick: 0.55, dynamicRange: 32,
      stereoSpread: 0.72, roomReflection: 0.78, overheadBleed: 0.82,
      micType: 'ribbon', micDistance: 18, micAngle: 55,
      vintage: 0.78, bitDepth: 12
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: -4, decay: 0.72, tone: 36, noise: 70, lofi: 55, closed: false,
      attack: 0.022, velocitySensitivity: 0.68, stereoWidth: 0.82, harmonicContent: 42,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.85, bottomCymbalThickness: 1.0, bellSize: 4.2,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 780, bellResonance: 0.55, edgeTone: 0.65, metalComplexity: 0.7,
      inharmonicity: 0.7, shimmerDecay: 0.88,
      frequencySpread: [780, 2000, 4800, 8200, 11500],
      overtoneBalance: [1.0, 0.72, 0.52, 0.32, 0.15],
      sustainBuild: 0.025, washCharacter: 0.82, wash: 0.85,
      footPressure: 0.18, clutchTension: 'medium', cymbalSeparation: 1.8,
      airRelease: 0.88, airPressure: 0.92, suctionEffect: 0.08,
      pedalOpenness: 0.82, footBarrel: 0.28, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'light', swell: 0.78,
      bloom: 0.85, dynamicRange: 38, stereoSpread: 0.82,
      roomReflection: 0.85, overheadBleed: 0.88, micType: 'ribbon',
      micDistance: 18, vintage: 0.78, bitDepth: 12
    },
    
    clap: { 
      type: 'clap', pitch: -4, decay: 0.42, tone: 28, noise: 80, lofi: 52, dist: 3,
      attack: 0.028, velocitySensitivity: 0.62, stereoWidth: 0.62, harmonicContent: 32,
      handCount: 3, handSize: 'medium', clapTightness: 'very_loose', handCupping: 0.52,
      initialSlap: 0.58, slapFreq: 1500, slapDecay: 0.012, slapHarmonics: 0.45,
      timingSpread: 0.025, velocityVariation: 0.28, stereoSpread: 0.62,
      multiHitDelay: [0.0, 0.022, 0.048, 0.078],
      multiHitGain: [1.0, 0.68, 0.45, 0.28],
      fundamentalFreq: 850, bodyResonance: 0.58, airCompression: 0.48,
      highFreqContent: 0.52, skinTexture: 0.55, reverseDecay: 0.32,
      roomSlap: 0.75, roomSize: 'cathedral', earlyReflections: 0.68,
      roomAbsorption: 0.25, vintage: 0.78
    },
    
    rimshot: { 
      type: 'snare', pitch: 3, decay: 0.18, tone: 50, noise: 48, lofi: 45,
      attack: 0.012, velocitySensitivity: 0.72, stereoWidth: 0.48, harmonicContent: 48,
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'loose_simultaneous', stickAngle: 38, stickTip: 'wood',
      fundamentalFreq: 420, metalRing: 0.72, metalDecay: 0.15, metalFreq: 2400,
      woodContact: 0.58, woodFreq: 1100, woodDecay: 0.12,
      headResponse: 0.48, headDampening: 0.55, overtones: [840, 1260, 1680],
      overtoneDecay: 0.14, ringOut: 0.58, clickTransient: 0.68,
      transientFreq: 3000, pitchBend: 0.32, vintage: 0.78
    },
    
    tomLow: { 
      type: 'tom', pitch: -9, decay: 1.2, tone: 48, noise: 25, lofi: 52,
      attack: 0.032, bleed: 16, velocitySensitivity: 0.66, stereoWidth: 0.52,
      harmonicContent: 42,
      drumSize: 16, depth: 16, shellMaterial: 'mahogany', shellThickness: 8,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 75, bodyResonance: 0.88, overtones: [150, 225, 300],
      overtoneBalance: [1.0, 0.58, 0.35, 0.18], sustainDecay: 1.2,
      headInteraction: 0.78, airCoupling: 0.72, headTension: 0.38,
      topBottomRatio: 0.72, dampening: 0.28, transientShape: 'soft',
      attackCurve: 'slow', roomReflection: 0.85, micBleed: 0.68,
      overheadBleed: 0.78, doubleHeaded: true, roomMics: 0.88,
      resonantDecay: 0.92, vintage: 0.78, bitDepth: 12
    },
    
    tomHigh: { 
      type: 'tom', pitch: -3, decay: 0.88, tone: 46, noise: 28, lofi: 52,
      attack: 0.028, bleed: 14, velocitySensitivity: 0.68, stereoWidth: 0.58,
      harmonicContent: 44,
      drumSize: 13, depth: 12, shellMaterial: 'mahogany', shellThickness: 7,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 130, bodyResonance: 0.82, overtones: [260, 390, 520],
      overtoneBalance: [1.0, 0.62, 0.38, 0.2], sustainDecay: 0.88,
      headInteraction: 0.75, airCoupling: 0.68, headTension: 0.45,
      topBottomRatio: 0.75, dampening: 0.35, transientShape: 'soft',
      attackCurve: 'slow', roomReflection: 0.82, micBleed: 0.65,
      overheadBleed: 0.75, doubleHeaded: true, roomMics: 0.85,
      resonantDecay: 0.82, vintage: 0.78, bitDepth: 12
    },
  
    keys: { 
      type: 'keys', pitch: 5, decay: 4.2, tone: 38, attack: 0.22, lofi: 32,
      velocitySensitivity: 0.78, stereoWidth: 0.82, harmonicContent: 40, vinylCrackle: 20,
      instrumentType: 'upright_piano', keyCount: 88, hammerAction: true,
      fundamentalFreq: 261.63, stringResonance: 0.92, sustainDecay: 4.2,
      harmonicSeries: [1, 2, 3, 4, 5, 6, 7, 8], 
      harmonicDecay: [1.0, 0.85, 0.72, 0.58, 0.45, 0.32, 0.22, 0.12],
      inharmonicity: 0.58, partialTuning: 'stretched', hammerNoise: 0.58,
      releaseNoise: 0.42, damperNoise: 0.35, pedalResonance: 0.88,
      mechanicalClick: 0.48, vintageCharacter: 0.88, warmth: 0.85,
      stereoMicing: 'distant_stereo', roomAmbience: 0.92, micType: 'ribbon',
      analogWarmth: 0.88, tubeSaturation: 0.62, tapeCompression: 0.55,
      wowFlutter: 0.25, bitDepth: 12
    },
    
    lead: { 
      type: 'lead', pitch: 17, decay: 3.5, tone: 44, attack: 0.35, lofi: 28,
      velocitySensitivity: 0.8, stereoWidth: 0.88, harmonicContent: 44, wowFlutter: 0.28,
      instrumentType: 'synthesizer', waveform: 'triangle', filterType: 'lowpass',
      filterCutoff: 800, filterResonance: 0.28, envelopeDecay: 3.5,
      lfoRate: 2.2, lfoDepth: 0.18, portamento: 0.35, detuneAmount: 0.22,
      harmonicSeries: [1, 2, 3, 4, 5], harmonicBalance: [1.0, 0.68, 0.48, 0.28, 0.15],
      analogDrift: 0.35, vintage: 0.88, chorus: 0.42, reverb: 0.72
    },
    
    riser: { 
      type: 'riser', pitch: -6, decay: 5.8, tone: 50, attack: 1.1, lofi: 22,
      velocitySensitivity: 0.74, stereoWidth: 0.96, harmonicContent: 48,
      instrumentType: 'synthesizer', waveform: 'noise_filtered', filterType: 'lowpass',
      filterCutoff: 400, filterResonance: 0.18, filterSweep: 0.92,
      envelopeDecay: 5.8, envelopeShape: 'exponential_rise',
      lfoRate: 0.8, lfoDepth: 0.48, pitchRise: 1.5, pitchCurve: 'exponential',
      reverb: 0.88, delay: 0.65, stereoSpread: 0.96, vintage: 0.68
    }
  },

  rock: {
    _kitMeta: { 
      roomSize: 0.62, roomBrightness: 60, micDistance: 0.54, vintageYear: 2012, wear: 0.22,
      bitDepth: 24, sampleRate: 44100, compressionRatio: 5.5, micPreamp: 'vintage_transformer',
      masterBus: 'analog_glue', characterCurve: 'classic_rock', roomTreatment: 'live_room'
    },
    
    kick: { 
      type: 'kick', pitch: -2, decay: 0.35, tone: 58, noise: 18, lofi: 10, dist: 20,
      attack: 0.0035, transientGain: 1.22, bleed: 10, velocitySensitivity: 0.84,
      stereoWidth: 0.2, harmonicContent: 60,
      drumSize: 22, shellMaterial: 'maple', headType: 'coated_single',
      beaterMaterial: 'felt', beaterWeight: 'medium', beaterAngle: 48,
      fundamentalFreq: 62, subFreq: 54, subWeight: 0.62, bodyResonance: 0.78,
      overtones: [124, 186, 248], overtoneBalance: [0.58, 0.35, 0.2, 0.1],
      clickFreq: 2900, beaterClick: 0.58, clickDecay: 0.02, clickHarmonics: 0.62,
      dampening: 0.52, portHole: 0.0, headTension: 0.52, bodyDecay: 0.35,
      transientShape: 'natural', transientPeak: 0.0035, sustainCurve: 'natural',
      roomReflection: 0.42, earlyReflections: 0.48, micBleed: 0.32,
      proximity: 0.48, phaseAlignment: 0.9, micPlacement: 'slightly_off_center',
      roomMics: 0.48, innerMic: 'akg_d12', outerMic: 'beta_52',
      analogWarmth: 0.68, tubeSaturation: 0.32, tapeCompression: 0.38,
      vintage: 0.28
    },
    
    snare: { 
      type: 'snare', pitch: 0, decay: 0.19, tone: 56, noise: 78, lofi: 8, dist: 18,
      attack: 0.0028, transientGain: 1.28, bleed: 12, velocitySensitivity: 0.82,
      stereoWidth: 0.32, harmonicContent: 64,
      drumSize: 14, depth: 5.5, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 16, wireMaterial: 'steel', wireTension: 0.68, wireResponse: 0.82,
      snareRattle: 40, rattleDecay: 0.2, rattleFreqRange: [180, 8000],
      wireStrands: 'standard', snareThrow: 1.0,
      fundamentalFreq: 220, bodyFreq: 185, overtones: [440, 660, 880],
      overtoneSpread: 0.72, harmonicDecay: 0.25, rimFreq: 2600,
      centerStrike: 0.8, edgeStrike: 0.0, rimShot: 0.0,
      stickTip: 'wood', stickWeight: 'medium', strikeAngle: 14,
      topHeadTension: 0.68, bottomHeadTension: 0.75, headInteraction: 0.62,
      transientShape: 'natural', sustainDecay: 0.19, crack: 0.75,
      roomReflection: 0.38, micBleed: 0.28, overheadBleed: 0.52,
      topMic: 'sm57', bottomMic: 'sm57', micPhase: 'inverted',
      ghostNoteResponse: 0.85, buzzResponse: 0.52, sympatheticVibration: 0.45,
      tubeSaturation: 0.28, vintage: 0.28
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 0, decay: 0.052, tone: 52, noise: 87, lofi: 10, closed: true,
      attack: 0.0018, velocitySensitivity: 0.86, stereoWidth: 0.7, harmonicContent: 66,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.95, bottomCymbalThickness: 1.15, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 860, bellResonance: 0.42, edgeTone: 0.68, metalComplexity: 0.82,
      inharmonicity: 0.78, partialDecay: [0.048, 0.042, 0.038],
      frequencySpread: [860, 2400, 5600, 9000], overtoneBalance: [1.0, 0.7, 0.45, 0.22],
      footPressure: 0.72, clutchTension: 'tight', standTilt: 6,
      cymbalSeparation: 0.16, airRelease: 0.22, airPressure: 0.28,
      suctionEffect: 0.48, tipContact: 'shoulder', stickMaterial: 'wood',
      stickTip: 'medium', chick: 0.72, dynamicRange: 42,
      stereoSpread: 0.7, roomReflection: 0.38, overheadBleed: 0.62,
      micType: 'condenser_small', micDistance: 9, micAngle: 42,
      vintage: 0.28
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 0, decay: 0.26, tone: 56, noise: 83, lofi: 10, closed: false,
      attack: 0.0025, velocitySensitivity: 0.84, stereoWidth: 0.76, harmonicContent: 68,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium', cymbalProfile: 'traditional',
      topCymbalThickness: 0.95, bottomCymbalThickness: 1.15, bellSize: 4.5,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 860, bellResonance: 0.48, edgeTone: 0.72, metalComplexity: 0.8,
      inharmonicity: 0.8, shimmerDecay: 0.78,
      frequencySpread: [860, 2400, 5600, 9000, 12200],
      overtoneBalance: [1.0, 0.78, 0.58, 0.38, 0.18],
      sustainBuild: 0.015, washCharacter: 0.72, wash: 0.75,
      footPressure: 0.25, clutchTension: 'tight', cymbalSeparation: 1.15,
      airRelease: 0.72, airPressure: 0.88, suctionEffect: 0.15,
      pedalOpenness: 0.75, footBarrel: 0.38, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'medium', swell: 0.62,
      bloom: 0.72, dynamicRange: 45, stereoSpread: 0.76,
      roomReflection: 0.42, overheadBleed: 0.72, micType: 'condenser_small',
      micDistance: 9, vintage: 0.28
    },
    
    clap: { 
      type: 'clap', pitch: 0, decay: 0.17, tone: 41, noise: 89, lofi: 8, dist: 12,
      attack: 0.0035, velocitySensitivity: 0.8, stereoWidth: 0.56, harmonicContent: 54,
      handCount: 5, handSize: 'medium', clapTightness: 'medium', handCupping: 0.45,
      initialSlap: 0.72, slapFreq: 1850, slapDecay: 0.01, slapHarmonics: 0.62,
      timingSpread: 0.014, velocityVariation: 0.2, stereoSpread: 0.56,
      multiHitDelay: [0.0, 0.012, 0.028, 0.048, 0.072],
      multiHitGain: [1.0, 0.72, 0.58, 0.42, 0.28],
      fundamentalFreq: 920, bodyResonance: 0.48, airCompression: 0.58,
      highFreqContent: 0.72, skinTexture: 0.42, reverseDecay: 0.2,
      roomSlap: 0.45, roomSize: 'medium', earlyReflections: 0.42,
      compression: 0.68, vintage: 0.28
    },
    
    rimshot: { 
      type: 'snare', pitch: 8, decay: 0.062, tone: 72, noise: 38, lofi: 9,
      attack: 0.0018, velocitySensitivity: 0.86, stereoWidth: 0.38, harmonicContent: 70,
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'simultaneous', stickAngle: 36, stickTip: 'wood',
      fundamentalFreq: 490, metalRing: 0.85, metalDecay: 0.068, metalFreq: 2850,
      woodContact: 0.72, woodFreq: 1320, woodDecay: 0.055,
      headResponse: 0.38, headDampening: 0.72, overtones: [980, 1470, 1960],
      overtoneDecay: 0.052, ringOut: 0.72, clickTransient: 0.88,
      transientFreq: 3500, pitchBend: 0.22, vintage: 0.28
    },
    
    tomLow: { 
      type: 'tom', pitch: -4, decay: 0.45, tone: 72, noise: 14, lofi: 10,
      attack: 0.0045, bleed: 11, velocitySensitivity: 0.83, stereoWidth: 0.42,
      harmonicContent: 64,
      drumSize: 16, depth: 14, shellMaterial: 'maple', shellThickness: 7,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 90, bodyResonance: 0.78, overtones: [180, 270, 360],
      overtoneBalance: [1.0, 0.62, 0.38, 0.18], sustainDecay: 0.45,
      headInteraction: 0.72, airCoupling: 0.65, headTension: 0.48,
      topBottomRatio: 0.8, dampening: 0.42, transientShape: 'natural',
      attackCurve: 'natural', roomReflection: 0.45, micBleed: 0.32,
      overheadBleed: 0.55, doubleHeaded: true, roomMics: 0.52,
      resonantDecay: 0.48, vintage: 0.28
    },
    
    tomHigh: { 
      type: 'tom', pitch: 3, decay: 0.34, tone: 69, noise: 16, lofi: 10,
      attack: 0.0038, bleed: 10, velocitySensitivity: 0.85, stereoWidth: 0.52,
      harmonicContent: 67,
      drumSize: 12, depth: 10, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'clear_emperor', bottomHead: 'clear_ambassador',
      fundamentalFreq: 155, bodyResonance: 0.75, overtones: [310, 465, 620],
      overtoneBalance: [1.0, 0.65, 0.4, 0.2], sustainDecay: 0.34,
      headInteraction: 0.75, airCoupling: 0.68, headTension: 0.58,
      topBottomRatio: 0.85, dampening: 0.48, transientShape: 'natural',
      attackCurve: 'natural', roomReflection: 0.48, micBleed: 0.35,
      overheadBleed: 0.58, doubleHeaded: true, roomMics: 0.55,
      resonantDecay: 0.42, vintage: 0.28
    },
    
    bass: { 
      type: 'bass', pitch: -2, decay: 0.88, tone: 65, attack: 0.0032, lofi: 11, dist: 26,
      velocitySensitivity: 0.88, stereoWidth: 0.26, harmonicContent: 64,
      stringCount: 4, stringGauge: [0.045, 0.065, 0.085, 0.105],
      tuning: 'standard', stringMaterial: 'nickel_roundwound', stringAge: 'broken_in',
      stringTension: 'medium', fundamentalFreq: 82, subHarmonics: 0.68,
      overtones: [164, 246, 328, 410], harmonicBalance: [1.0, 0.78, 0.55, 0.38, 0.22],
      sustainDecay: 0.88, pickAttack: 0.62, fingerStyle: false,
      playingPosition: 'bridge', stringResonance: 0.72, fretNoise: 0.32,
      fretBuzz: 0.18, stringSlap: 0.0, bodyResonance: 0.78,
      bodyWood: 'alder', neckWood: 'maple', pickupType: 'precision',
      pickupPosition: 0.6, toneKnob: 0.58, ampModel: 'vintage_tube',
      ampGain: 0.58, ampTone: 0.52, cabinetIR: 'ampeg_4x10',
      cabinetMic: 'u47', micDistance: 16, analogWarmth: 0.72,
      tubeSaturation: 0.38, tapeCompression: 0.42, vintage: 0.28
    },
    
    guitar: { 
      type: 'guitar', pitch: 1, decay: 1.45, tone: 71, attack: 0.002, lofi: 8, dist: 28,
      velocitySensitivity: 0.86, stereoWidth: 0.66, harmonicContent: 70,
      stringCount: 6, stringGauge: [0.010, 0.013, 0.017, 0.026, 0.036, 0.046],
      tuning: 'standard', stringMaterial: 'nickel_roundwound', stringAge: 'good',
      fundamentalFreq: 196, overtones: [392, 588, 784, 980],
      harmonicBalance: [1.0, 0.82, 0.65, 0.48, 0.32], sustainDecay: 1.45,
      pickAttack: 0.72, pickThickness: 0.88, pickMaterial: 'nylon',
      fretBuzz: 0.18, fretNoise: 0.25, stringSlide: 0.15,
      playingPosition: 'bridge', palmMute: 0.0, powerChords: 0.65,
      bodyResonance: 0.75, bodyWood: 'mahogany', topWood: 'maple',
      pickupType: 'humbucker_bridge', pickupPosition: 0.85, toneKnob: 0.48,
      ampModel: 'marshall_plexi', ampGain: 0.68, ampPresence: 0.62,
      cabinetIR: 'marshall_4x12', cabinetMic: 'sm57_angled',
      micDistance: 4, compression: 0.65, vintage: 0.28
    },
    
    keys: { 
      type: 'keys', pitch: -4, decay: 1.15, tone: 59, attack: 0.0055, lofi: 9,
      velocitySensitivity: 0.9, stereoWidth: 0.6, harmonicContent: 62,
      instrumentType: 'electric_piano', keyCount: 73, hammerAction: true,
      tineResonance: 0.78, pickupDistance: 0.62, amplification: 'transistor',
      fundamentalFreq: 261.63, stringResonance: 0.78, tineDecay: 1.15,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicDecay: [1.0, 0.78, 0.58, 0.42, 0.28, 0.15],
      inharmonicity: 0.38, partialTuning: 'stretched', hammerNoise: 0.42,
      releaseNoise: 0.28, damperNoise: 0.18, pedalResonance: 0.68,
      mechanicalClick: 0.35, bell: 0.58, bark: 0.52,
      stereoMicing: 'spaced_pair', roomAmbience: 0.42, micType: 'condenser_large',
      vintage: 0.28
    }
  },

  jazz: {
    _kitMeta: { 
      roomSize: 0.38, roomBrightness: 50, micDistance: 0.45, vintageYear: 1987, wear: 0.38,
      bitDepth: 16, sampleRate: 44100, tapeSaturation: 0.42, compressionRatio: 3.5,
      micPreamp: 'vintage_tube', micType: 'condenser_ribbon_blend', analogChain: true,
      characterCurve: 'warm_natural', roomTreatment: 'jazz_club'
    },
    
    kick: { 
      type: 'kick', pitch: -3, decay: 0.45, tone: 48, noise: 22, lofi: 24, dist: 10,
      attack: 0.0055, bleed: 14, velocitySensitivity: 0.78, stereoWidth: 0.24,
      harmonicContent: 50,
      drumSize: 18, shellMaterial: 'maple', headType: 'coated_double',
      beaterMaterial: 'felt_soft', beaterWeight: 'light', beaterAngle: 42,
      fundamentalFreq: 65, subFreq: 56, subWeight: 0.55, bodyResonance: 0.82,
      overtones: [130, 195, 260], overtoneBalance: [0.52, 0.38, 0.25, 0.12],
      clickFreq: 2600, beaterClick: 0.38, clickDecay: 0.025, clickHarmonics: 0.48,
      dampening: 0.35, portHole: 0.0, headTension: 0.42, bodyDecay: 0.45,
      transientShape: 'soft', transientPeak: 0.0055, sustainCurve: 'natural',
      roomReflection: 0.52, earlyReflections: 0.58, micBleed: 0.48,
      proximity: 0.38, phaseAlignment: 0.88, micPlacement: 'natural',
      roomMics: 0.62, innerMic: 'ribbon', outerMic: 'condenser',
      analogWarmth: 0.78, tubeSaturation: 0.42, tapeCompression: 0.48,
      vinylCrackle: 12, wowFlutter: 0.18, vintage: 0.42
    },
    
    snare: { 
      type: 'snare', pitch: -1, decay: 0.24, tone: 52, noise: 72, lofi: 22, dist: 8,
      attack: 0.0048, bleed: 16, velocitySensitivity: 0.76, stereoWidth: 0.36,
      harmonicContent: 54,
      drumSize: 14, depth: 5, shellMaterial: 'maple', shellThickness: 5,
      topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 16, wireMaterial: 'steel', wireTension: 0.62, wireResponse: 0.78,
      snareRattle: 32, rattleDecay: 0.22, rattleFreqRange: [170, 7500],
      wireStrands: 'standard', snareThrow: 1.0,
      fundamentalFreq: 210, bodyFreq: 178, overtones: [420, 630, 840],
      overtoneSpread: 0.68, harmonicDecay: 0.28, rimFreq: 2500,
      centerStrike: 0.75, edgeStrike: 0.0, rimShot: 0.0, crossStick: 0.0,
      stickTip: 'wood', stickWeight: 'light', strikeAngle: 16,
      topHeadTension: 0.62, bottomHeadTension: 0.68, headInteraction: 0.58,
      transientShape: 'natural', sustainDecay: 0.24, roomReflection: 0.48,
      micBleed: 0.42, overheadBleed: 0.68, topMic: 'condenser_small',
      bottomMic: 'ribbon', micPhase: 'inverted', ghostNoteResponse: 0.88,
      buzzResponse: 0.62, sympatheticVibration: 0.58, tubeSaturation: 0.38,
      vintage: 0.42
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: 0, decay: 0.06, tone: 46, noise: 84, lofi: 20, closed: true,
      attack: 0.0028, velocitySensitivity: 0.8, stereoWidth: 0.66, harmonicContent: 58,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_light', cymbalProfile: 'traditional',
      topCymbalThickness: 0.9, bottomCymbalThickness: 1.1, bellSize: 4.3,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 840, bellResonance: 0.45, edgeTone: 0.65, metalComplexity: 0.78,
      inharmonicity: 0.75, partialDecay: [0.055, 0.048, 0.042],
      frequencySpread: [840, 2200, 5200, 8600], overtoneBalance: [1.0, 0.68, 0.42, 0.2],
      footPressure: 0.65, clutchTension: 'medium', standTilt: 7,
      cymbalSeparation: 0.18, airRelease: 0.28, airPressure: 0.35,
      suctionEffect: 0.42, tipContact: 'edge', stickMaterial: 'wood',
      stickTip: 'medium', chick: 0.68, dynamicRange: 38,
      stereoSpread: 0.66, roomReflection: 0.52, overheadBleed: 0.72,
      micType: 'condenser_small', micDistance: 12, micAngle: 48,
      vintage: 0.42
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: 0, decay: 0.35, tone: 52, noise: 80, lofi: 20, closed: false,
      attack: 0.0035, velocitySensitivity: 0.78, stereoWidth: 0.73, harmonicContent: 60,
      topCymbal: 14, bottomCymbal: 14, cymbalWeight: 'medium_light', cymbalProfile: 'traditional',
      topCymbalThickness: 0.9, bottomCymbalThickness: 1.1, bellSize: 4.3,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 840, bellResonance: 0.52, edgeTone: 0.7, metalComplexity: 0.76,
      inharmonicity: 0.77, shimmerDecay: 0.82,
      frequencySpread: [840, 2200, 5200, 8600, 11800],
      overtoneBalance: [1.0, 0.75, 0.55, 0.35, 0.16],
      sustainBuild: 0.018, washCharacter: 0.78, wash: 0.82,
      footPressure: 0.22, clutchTension: 'medium', cymbalSeparation: 1.3,
      airRelease: 0.78, airPressure: 0.85, suctionEffect: 0.12,
      pedalOpenness: 0.78, footBarrel: 0.32, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'light', swell: 0.72,
      bloom: 0.78, dynamicRange: 42, stereoSpread: 0.73,
      roomReflection: 0.58, overheadBleed: 0.82, micType: 'condenser_small',
      micDistance: 12, vintage: 0.42
    },
    
    clap: { 
      type: 'clap', pitch: -1, decay: 0.19, tone: 38, noise: 86, lofi: 18, dist: 6,
      attack: 0.0045, velocitySensitivity: 0.74, stereoWidth: 0.54, harmonicContent: 48,
      handCount: 4, handSize: 'medium', clapTightness: 'loose', handCupping: 0.48,
      initialSlap: 0.65, slapFreq: 1700, slapDecay: 0.011, slapHarmonics: 0.58,
      timingSpread: 0.016, velocityVariation: 0.22, stereoSpread: 0.54,
      multiHitDelay: [0.0, 0.015, 0.035, 0.062],
      multiHitGain: [1.0, 0.68, 0.48, 0.28],
      fundamentalFreq: 880, bodyResonance: 0.52, airCompression: 0.55,
      highFreqContent: 0.68, skinTexture: 0.48, reverseDecay: 0.22,
      roomSlap: 0.52, roomSize: 'small', earlyReflections: 0.48,
      compression: 0.58, vintage: 0.42
    },
    
    rimshot: { 
      type: 'snare', pitch: 7, decay: 0.072, tone: 69, noise: 42, lofi: 16,
      attack: 0.0025, velocitySensitivity: 0.82, stereoWidth: 0.4, harmonicContent: 64,
      drumSize: 14, shellMaterial: 'maple', rimMaterial: 'steel_triple_flange',
      stickContact: 'simultaneous', stickAngle: 37, stickTip: 'wood',
      fundamentalFreq: 470, metalRing: 0.78, metalDecay: 0.078, metalFreq: 2700,
      woodContact: 0.68, woodFreq: 1250, woodDecay: 0.065,
      headResponse: 0.42, headDampening: 0.68, overtones: [940, 1410, 1880],
      overtoneDecay: 0.062, ringOut: 0.68, clickTransient: 0.82,
      transientFreq: 3300, pitchBend: 0.25, vintage: 0.42
    },
    
    tomLow: { 
      type: 'tom', pitch: -5, decay: 0.52, tone: 66, noise: 16, lofi: 22,
      attack: 0.0065, bleed: 13, velocitySensitivity: 0.77, stereoWidth: 0.46,
      harmonicContent: 57,
      drumSize: 14, depth: 12, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 95, bodyResonance: 0.78, overtones: [190, 285, 380],
      overtoneBalance: [1.0, 0.62, 0.38, 0.18], sustainDecay: 0.52,
      headInteraction: 0.7, airCoupling: 0.62, headTension: 0.48,
      topBottomRatio: 0.78, dampening: 0.4, transientShape: 'soft',
      attackCurve: 'natural', roomReflection: 0.55, micBleed: 0.45,
      overheadBleed: 0.68, doubleHeaded: true, roomMics: 0.65,
      resonantDecay: 0.58, vintage: 0.42
    },
    
    tomHigh: { 
      type: 'tom', pitch: 2, decay: 0.38, tone: 64, noise: 18, lofi: 22,
      attack: 0.0055, bleed: 12, velocitySensitivity: 0.79, stereoWidth: 0.56,
      harmonicContent: 60,
      drumSize: 12, depth: 10, shellMaterial: 'maple', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 160, bodyResonance: 0.75, overtones: [320, 480, 640],
      overtoneBalance: [1.0, 0.65, 0.4, 0.2], sustainDecay: 0.38,
      headInteraction: 0.72, airCoupling: 0.65, headTension: 0.58,
      topBottomRatio: 0.82, dampening: 0.48, transientShape: 'soft',
      attackCurve: 'natural', roomReflection: 0.58, micBleed: 0.48,
      overheadBleed: 0.72, doubleHeaded: true, roomMics: 0.68,
      resonantDecay: 0.52, vintage: 0.42
    },
    
    bass: { 
      type: 'bass', pitch: 1, decay: 0.72, tone: 53, attack: 0.011, lofi: 19, dist: 8,
      velocitySensitivity: 0.86, stereoWidth: 0.28, harmonicContent: 54, vinylCrackle: 12,
      stringCount: 4, stringGauge: [0.040, 0.060, 0.080, 0.100],
      tuning: 'standard', stringMaterial: 'flatwound', stringAge: 'aged',
      stringTension: 'medium_low', fundamentalFreq: 82, subHarmonics: 0.62,
      overtones: [164, 246, 328], harmonicBalance: [1.0, 0.72, 0.48, 0.28, 0.15],
      sustainDecay: 0.72, pickAttack: 0.35, fingerStyle: true,
      playingPosition: 'neck', stringResonance: 0.82, fretNoise: 0.45,
      fretBuzz: 0.22, stringSlap: 0.0, bodyResonance: 0.85,
      bodyWood: 'alder', neckWood: 'maple', pickupType: 'jazz_neck',
      pickupPosition: 0.35, toneKnob: 0.72, ampModel: 'vintage_tube',
      ampGain: 0.35, ampTone: 0.62, cabinetIR: 'ampeg_2x15',
      cabinetMic: 'ribbon', micDistance: 22, analogWarmth: 0.82,
      tubeSaturation: 0.48, tapeCompression: 0.52, wowFlutter: 0.15,
      vintage: 0.42
    },
    
    keys: { 
      type: 'keys', pitch: -5, decay: 1.38, tone: 51, attack: 0.0082, lofi: 21,
      velocitySensitivity: 0.88, stereoWidth: 0.63, harmonicContent: 57, vinylCrackle: 14,
      instrumentType: 'electric_piano_vintage', keyCount: 73, hammerAction: true,
      tineResonance: 0.82, pickupDistance: 0.68, amplification: 'transistor',
      fundamentalFreq: 261.63, stringResonance: 0.82, tineDecay: 1.38,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicDecay: [1.0, 0.78, 0.58, 0.42, 0.25, 0.12],
      inharmonicity: 0.42, partialTuning: 'stretched', hammerNoise: 0.48,
      releaseNoise: 0.32, damperNoise: 0.22, pedalResonance: 0.75,
      mechanicalClick: 0.38, bell: 0.62, bark: 0.55,
      stereoMicing: 'spaced_pair', roomAmbience: 0.48, micType: 'ribbon',
      analogWarmth: 0.78, wowFlutter: 0.18, vintage: 0.42
    },
    
    guitar: { 
      type: 'guitar', pitch: 3, decay: 1.05, tone: 61, attack: 0.0048, lofi: 20,
      velocitySensitivity: 0.84, stereoWidth: 0.68, harmonicContent: 60,
      stringCount: 6, stringGauge: [0.012, 0.016, 0.024, 0.032, 0.042, 0.053],
      tuning: 'standard', stringMaterial: 'flatwound', stringAge: 'medium',
      fundamentalFreq: 196, overtones: [392, 588, 784, 980],
      harmonicBalance: [1.0, 0.75, 0.55, 0.38, 0.22], sustainDecay: 1.05,
      pickNoise: 0.28, pickThickness: 0.60, pickMaterial: 'nylon',
      fretBuzz: 0.15, fretNoise: 0.22, stringSlide: 0.12,
      playingPosition: 'neck', archtop: true, fhole: true,
      bodyResonance: 0.88, bodyWood: 'maple', topWood: 'spruce',
      bodySize: 'archtop', pickupType: 'humbucker_neck', pickupPosition: 0.35,
      toneKnob: 0.75, ampModel: 'tube_clean', ampGain: 0.38,
      stereoMicing: 'room_ambient', roomAmbience: 0.58, micType: 'ribbon',
      vintage: 0.42
    }
  },

  vintage: {
    _kitMeta: { 
      roomSize: 0.32, roomBrightness: 40, micDistance: 0.4, vintageYear: 1969, wear: 0.72,
      bitDepth: 8, sampleRate: 22050, tapeSaturation: 0.78, compressionRatio: 3.2,
      micPreamp: 'vintage_tube_overdriven', micType: 'ribbon_old', analogChain: true,
      tapeSpeed: 7.5, tapeFormula: 'scotch_111', noiseFloor: -52, wow: 0.35, flutter: 0.18,
      roomReverb: 1.2, tapeHiss: 0.45
    },
    
    kick: { 
      type: 'kick', pitch: -4, decay: 0.32, tone: 38, noise: 28, lofi: 62, dist: 30,
      attack: 0.0075, bleed: 17, velocitySensitivity: 0.7, stereoWidth: 0.18,
      harmonicContent: 40, bitDepth: 10,
      drumSize: 20, shellMaterial: 'mahogany', headType: 'coated_double',
      beaterMaterial: 'felt_soft', beaterWeight: 'light', beaterAngle: 38,
      fundamentalFreq: 60, subFreq: 52, subWeight: 0.48, bodyResonance: 0.75,
      overtones: [120, 180, 240], overtoneBalance: [0.42, 0.28, 0.18, 0.08],
      clickFreq: 2400, beaterClick: 0.32, clickDecay: 0.028, clickHarmonics: 0.42,
      dampening: 0.42, portHole: 0.0, headTension: 0.38, bodyDecay: 0.32,
      transientShape: 'soft', transientPeak: 0.0075, sustainCurve: 'vintage',
      roomReflection: 0.55, earlyReflections: 0.62, micBleed: 0.58,
      proximity: 0.32, phaseAlignment: 0.78, micPlacement: 'close_vintage',
      roomMics: 0.65, innerMic: 'ribbon_vintage', outerMic: 'dynamic_vintage',
      analogWarmth: 0.92, tubeSaturation: 0.72, tapeCompression: 0.78,
      vinylCrackle: 25, wowFlutter: 0.32, sampleRate: 22050
    },
    
    snare: { 
      type: 'snare', pitch: -2, decay: 0.2, tone: 42, noise: 75, lofi: 58, dist: 24,
      attack: 0.0058, bleed: 20, velocitySensitivity: 0.67, stereoWidth: 0.3,
      harmonicContent: 44, bitDepth: 10,
      drumSize: 14, depth: 5, shellMaterial: 'mahogany', shellThickness: 5,
      topHead: 'coated_ambassador', bottomHead: 'snare_side',
      wireCount: 12, wireMaterial: 'steel', wireTension: 0.52, wireResponse: 0.68,
      snareRattle: 24, rattleDecay: 0.28, rattleFreqRange: [150, 6500],
      wireStrands: 'standard', snareThrow: 1.0,
      fundamentalFreq: 200, bodyFreq: 170, overtones: [400, 600, 800],
      overtoneSpread: 0.62, harmonicDecay: 0.32, rimFreq: 2300,
      centerStrike: 0.72, edgeStrike: 0.0, rimShot: 0.0,
      stickTip: 'wood', stickWeight: 'light', strikeAngle: 18,
      topHeadTension: 0.55, bottomHeadTension: 0.62, headInteraction: 0.52,
      transientShape: 'soft', sustainDecay: 0.2, roomReflection: 0.62,
      micBleed: 0.62, overheadBleed: 0.78, topMic: 'ribbon', bottomMic: 'dynamic',
      micPhase: 'inverted', ghostNoteResponse: 0.92, buzzResponse: 0.62,
      sympatheticVibration: 0.72, tubeSaturation: 0.68, vintage: 0.78,
      sampleRate: 22050
    },
    
    hihatClosed: { 
      type: 'hihat', pitch: -3, decay: 0.065, tone: 38, noise: 82, lofi: 52, closed: true,
      attack: 0.0035, velocitySensitivity: 0.72, stereoWidth: 0.6, harmonicContent: 48,
      bitDepth: 10,
      topCymbal: 13, bottomCymbal: 13, cymbalWeight: 'medium_light', cymbalProfile: 'traditional',
      topCymbalThickness: 0.8, bottomCymbalThickness: 0.95, bellSize: 4,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 800, bellResonance: 0.52, edgeTone: 0.58, metalComplexity: 0.68,
      inharmonicity: 0.65, partialDecay: [0.062, 0.055, 0.048],
      frequencySpread: [800, 2000, 4600, 7800], overtoneBalance: [1.0, 0.58, 0.35, 0.15],
      footPressure: 0.62, clutchTension: 'medium', standTilt: 9,
      cymbalSeparation: 0.2, airRelease: 0.32, airPressure: 0.38,
      suctionEffect: 0.42, tipContact: 'edge', stickMaterial: 'wood',
      stickTip: 'medium', chick: 0.62, dynamicRange: 30,
      stereoSpread: 0.6, roomReflection: 0.62, overheadBleed: 0.78,
      micType: 'ribbon', micDistance: 16, micAngle: 52,
      analogWarmth: 0.88, tubeSaturation: 0.65, vintage: 0.78,
      sampleRate: 22050
    },
    
    hihatOpen: { 
      type: 'hihat', pitch: -3, decay: 0.28, tone: 42, noise: 78, lofi: 52, closed: false,
      attack: 0.0045, velocitySensitivity: 0.7, stereoWidth: 0.66, harmonicContent: 50,
      bitDepth: 10,
      topCymbal: 13, bottomCymbal: 13, cymbalWeight: 'medium_light', cymbalProfile: 'traditional',
      topCymbalThickness: 0.8, bottomCymbalThickness: 0.95, bellSize: 4,
      metalAlloy: 'b20_bronze', hammerPattern: 'traditional', lathing: 'full',
      fundamentalFreq: 800, bellResonance: 0.58, edgeTone: 0.65, metalComplexity: 0.66,
      inharmonicity: 0.68, shimmerDecay: 0.85,
      frequencySpread: [800, 2000, 4600, 7800, 11000],
      overtoneBalance: [1.0, 0.68, 0.48, 0.28, 0.12],
      sustainBuild: 0.022, washCharacter: 0.82, wash: 0.85,
      footPressure: 0.2, clutchTension: 'medium', cymbalSeparation: 1.4,
      airRelease: 0.82, airPressure: 0.88, suctionEffect: 0.12,
      pedalOpenness: 0.8, footBarrel: 0.3, tipContact: 'edge',
      stickMaterial: 'wood', strikeForce: 'light', swell: 0.75,
      bloom: 0.82, dynamicRange: 35, stereoSpread: 0.66,
      roomReflection: 0.68, overheadBleed: 0.85, micType: 'ribbon',
      micDistance: 16, analogWarmth: 0.88, tubeSaturation: 0.65,
      vintage: 0.78, sampleRate: 22050
    },
    
    clap: { 
      type: 'clap', pitch: -2, decay: 0.18, tone: 33, noise: 88, lofi: 48, dist: 18,
      attack: 0.0055, velocitySensitivity: 0.66, stereoWidth: 0.5, harmonicContent: 38,
      handCount: 3, handSize: 'medium', clapTightness: 'loose', handCupping: 0.52,
      initialSlap: 0.62, slapFreq: 1550, slapDecay: 0.012, slapHarmonics: 0.52,
      timingSpread: 0.02, velocityVariation: 0.25, stereoSpread: 0.5,
      multiHitDelay: [0.0, 0.018, 0.042, 0.072],
      multiHitGain: [1.0, 0.65, 0.42, 0.25],
      fundamentalFreq: 850, bodyResonance: 0.55, airCompression: 0.52,
      highFreqContent: 0.62, skinTexture: 0.52, reverseDecay: 0.25,
      roomSlap: 0.62, roomSize: 'small', earlyReflections: 0.58,
      compression: 0.72, analogWarmth: 0.85, vintage: 0.78
    },
    
    rimshot: { 
      type: 'snare', pitch: 5, decay: 0.078, tone: 58, noise: 48, lofi: 42,
      attack: 0.0035, velocitySensitivity: 0.74, stereoWidth: 0.36, harmonicContent: 56,
      drumSize: 14, shellMaterial: 'mahogany', rimMaterial: 'steel_triple_flange',
      stickContact: 'loose_simultaneous', stickAngle: 38, stickTip: 'wood',
      fundamentalFreq: 440, metalRing: 0.75, metalDecay: 0.082, metalFreq: 2500,
      woodContact: 0.62, woodFreq: 1150, woodDecay: 0.068,
      headResponse: 0.45, headDampening: 0.62, overtones: [880, 1320, 1760],
      overtoneDecay: 0.068, ringOut: 0.65, clickTransient: 0.75,
      transientFreq: 3100, pitchBend: 0.28, analogWarmth: 0.82,
      vintage: 0.78
    },
    
    tomLow: { 
      type: 'tom', pitch: -6, decay: 0.48, tone: 55, noise: 20, lofi: 48,
      attack: 0.0075, bleed: 16, velocitySensitivity: 0.69, stereoWidth: 0.42,
      harmonicContent: 50, bitDepth: 10,
      drumSize: 14, depth: 12, shellMaterial: 'mahogany', shellThickness: 7,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 88, bodyResonance: 0.82, overtones: [176, 264, 352],
      overtoneBalance: [1.0, 0.58, 0.35, 0.15], sustainDecay: 0.48,
      headInteraction: 0.68, airCoupling: 0.62, headTension: 0.45,
      topBottomRatio: 0.75, dampening: 0.38, transientShape: 'soft',
      attackCurve: 'natural', roomReflection: 0.62, micBleed: 0.58,
      overheadBleed: 0.75, doubleHeaded: true, roomMics: 0.72,
      resonantDecay: 0.62, analogWarmth: 0.88, tubeSaturation: 0.62,
      vintage: 0.78, sampleRate: 22050
    },
    
    tomHigh: { 
      type: 'tom', pitch: 0, decay: 0.36, tone: 52, noise: 22, lofi: 48,
      attack: 0.0065, bleed: 15, velocitySensitivity: 0.71, stereoWidth: 0.52,
      harmonicContent: 52, bitDepth: 10,
      drumSize: 12, depth: 10, shellMaterial: 'mahogany', shellThickness: 6,
      topHead: 'coated_ambassador', bottomHead: 'clear_ambassador',
      fundamentalFreq: 150, bodyResonance: 0.78, overtones: [300, 450, 600],
      overtoneBalance: [1.0, 0.62, 0.38, 0.18], sustainDecay: 0.36,
      headInteraction: 0.7, airCoupling: 0.65, headTension: 0.55,
      topBottomRatio: 0.8, dampening: 0.45, transientShape: 'soft',
      attackCurve: 'natural', roomReflection: 0.65, micBleed: 0.62,
      overheadBleed: 0.78, doubleHeaded: true, roomMics: 0.75,
      resonantDecay: 0.55, analogWarmth: 0.88, tubeSaturation: 0.62,
      vintage: 0.78, sampleRate: 22050
    },
    
    bass: { 
      type: 'bass', pitch: -4, decay: 0.75, tone: 49, attack: 0.013, lofi: 55, dist: 23,
      velocitySensitivity: 0.8, stereoWidth: 0.23, harmonicContent: 47, vinylCrackle: 22,
      wowFlutter: 0.24, sampleRate: 22050, bitDepth: 10,
      stringCount: 4, stringGauge: [0.040, 0.060, 0.080, 0.100],
      tuning: 'standard', stringMaterial: 'flatwound', stringAge: 'very_aged',
      stringTension: 'low', fundamentalFreq: 82, subHarmonics: 0.58,
      overtones: [164, 246, 328], harmonicBalance: [1.0, 0.68, 0.42, 0.25, 0.12],
      sustainDecay: 0.75, pickAttack: 0.32, fingerStyle: true,
      playingPosition: 'neck', stringResonance: 0.88, fretNoise: 0.52,
      fretBuzz: 0.28, stringSlap: 0.0, bodyResonance: 0.88,
      bodyWood: 'mahogany', neckWood: 'maple', pickupType: 'single_coil',
      pickupPosition: 0.32, toneKnob: 0.78, ampModel: 'vintage_tube',
      ampGain: 0.32, ampTone: 0.68, cabinetIR: 'ampeg_vintage_2x15',
      cabinetMic: 'ribbon_old', micDistance: 24, analogWarmth: 0.92,
      tubeSaturation: 0.78, tapeCompression: 0.82, noiseFloor: -52
    },
    
    keys: { 
      type: 'keys', pitch: 4, decay: 1.05, tone: 46, attack: 0.016, lofi: 58,
      velocitySensitivity: 0.82, stereoWidth: 0.58, harmonicContent: 50, vinylCrackle: 24,
      wowFlutter: 0.22, bitDepth: 10,
      instrumentType: 'electric_piano_vintage', keyCount: 73, hammerAction: true,
      tineResonance: 0.72, pickupDistance: 0.72, amplification: 'tube',
      fundamentalFreq: 261.63, stringResonance: 0.85, tineDecay: 1.05,
      harmonicSeries: [1, 2, 3, 4, 5, 6], harmonicDecay: [1.0, 0.72, 0.52, 0.35, 0.22, 0.1],
      inharmonicity: 0.48, partialTuning: 'stretched', hammerNoise: 0.55,
      releaseNoise: 0.38, damperNoise: 0.28, pedalResonance: 0.78,
      mechanicalClick: 0.45, tremolo: 0.15, tremoloRate: 5.2, tremoloDepth: 0.28,
      bell: 0.58, bark: 0.52, stereoMicing: 'close_vintage',
      roomAmbience: 0.52, micType: 'ribbon', analogWarmth: 0.92,
      tubeSaturation: 0.75, tapeCompression: 0.78, sampleRate: 22050
    },
    
    guitar: { 
      type: 'guitar', pitch: -1, decay: 0.95, tone: 57, attack: 0.0088, lofi: 52,
      velocitySensitivity: 0.78, stereoWidth: 0.62, harmonicContent: 54, vinylCrackle: 20,
      wowFlutter: 0.2,
      stringCount: 6, stringGauge: [0.011, 0.014, 0.018, 0.028, 0.038, 0.048],
      tuning: 'standard', stringMaterial: 'nickel_roundwound', stringAge: 'aged',
      fundamentalFreq: 196, overtones: [392, 588, 784, 980],
      harmonicBalance: [1.0, 0.72, 0.52, 0.35, 0.2], sustainDecay: 0.95,
      pickNoise: 0.42, pickThickness: 0.71, pickMaterial: 'tortoise_shell',
      fretBuzz: 0.25, fretNoise: 0.35, stringSlide: 0.22,
      playingPosition: 'middle', bodyResonance: 0.82, bodyWood: 'mahogany',
      topWood: 'spruce', bodySize: 'dreadnought', bracing: 'ladder',
      soundholeSize: 4, pickupType: 'piezo_vintage', pickupPosition: 0.5,
      micType: 'ribbon', micPosition: '12th_fret', micDistance: 14,
      roomAmbience: 0.58, stereoWidth: 0.62, analogWarmth: 0.88,
      tubeSaturation: 0.68, tapeCompression: 0.72, vintage: 0.78
    }
  }
};

// Export for use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { sampleKits };
}

// Keep an immutable copy of the original kits so we can randomize around them
const baseSampleKits = JSON.parse(JSON.stringify(sampleKits));

const sampleInfo = {
  kick: { icon: 'ðŸ¥', name: 'Kick', category: 'drums' },
  snare: { icon: 'ðŸŽ¯', name: 'Snare', category: 'drums' },
  hihatClosed: { icon: 'ðŸ”’', name: 'Hi-Hat (Closed)', category: 'cymbals' },
  hihatOpen: { icon: 'ðŸ”“', name: 'Hi-Hat (Open)', category: 'cymbals' },
  clap: { icon: 'ðŸ‘', name: 'Clap', category: 'percussion' },
  rimshot: { icon: 'ðŸŽª', name: 'Rimshot', category: 'percussion' },
  tomLow: { icon: 'ðŸ¥', name: 'Tom (Low)', category: 'drums' },
  tomHigh: { icon: 'ðŸ¥', name: 'Tom (High)', category: 'drums' },
  bass:   { icon: 'ðŸ§¿', name: 'Bass',   category: 'instrument' },
  guitar: { icon: 'ðŸŽ¸', name: 'Guitar', category: 'instrument' },
  keys:   { icon: 'ðŸŽ¹', name: 'Keys',   category: 'instrument' },
  lead:   { icon: 'ðŸŽº', name: 'Lead',   category: 'instrument' },
  riser:  { icon: 'ðŸ“ˆ', name: 'Riser',  category: 'sfx' },
  fx:     { icon: 'âœ¨', name: 'FX',     category: 'sfx' }
};
  
let currentKit = 'lofi';
let currentSample = null;
let currentBuffer = null;
let sampleParams = {};

// Initialize UI
function initSampleLibrary() {
  renderSampleList();
  attachEventListeners();
  updateSampleCount();
}

function renderSampleList() {
  const kit = sampleKits[currentKit];
  const sampleList = document.getElementById('sampleList');
  
  sampleList.innerHTML = '';
  
  Object.keys(kit).forEach(sampleKey => {
    if (sampleKey.startsWith('_')) return; // Skip metadata
    
    const info = sampleInfo[sampleKey];
    if (!info) return; // Skip if no info available
    
    const params = kit[sampleKey];
    
    const item = document.createElement('div');
    item.className = 'sample-item';
    item.dataset.sample = sampleKey;
    
    item.innerHTML = `
      <div class="sample-icon">${info.icon}</div>
      <div class="sample-info">
        <div class="sample-name">${info.name}</div>
        <div class="sample-meta">${info.category} â€¢ ${currentKit}</div>
      </div>
      <div class="sample-actions">
        <button class="sample-action-btn" data-action="preview" title="Preview">â–¶ï¸</button>
        <button class="sample-action-btn" data-action="edit" title="Edit">âœï¸</button>
        <button class="sample-action-btn" data-action="export" title="Export">ðŸ“¥</button>
      </div>
    `;
    
    // Click to select
    item.addEventListener('click', (e) => {
      if (!e.target.closest('.sample-action-btn')) {
        selectSample(sampleKey);
      }
    });
    
    // Action buttons
    item.querySelector('[data-action="preview"]').addEventListener('click', (e) => {
      e.stopPropagation();
      previewSample(sampleKey);
    });
    
    item.querySelector('[data-action="edit"]').addEventListener('click', (e) => {
      e.stopPropagation();
      selectSample(sampleKey);
    });
    
    item.querySelector('[data-action="export"]').addEventListener('click', (e) => {
      e.stopPropagation();
      exportSample(sampleKey);
    });
    
    sampleList.appendChild(item);
  });
}

function selectSample(sampleKey) {
  currentSample = sampleKey;
  sampleParams = { ...sampleKits[currentKit][sampleKey] };
  
  // Update UI
  document.querySelectorAll('.sample-item').forEach(item => {
    item.classList.toggle('active', item.dataset.sample === sampleKey);
  });
  
  // Update editor
  updateEditor();
  generateAndDisplayWaveform();
}

function updateEditor() {
  if (!currentSample) return;
  
  const info = sampleInfo[currentSample];
  document.getElementById('selectedSampleName').textContent = info.name;
  document.getElementById('selectedSampleInfo').textContent = 
    `${info.category} â€¢ ${currentKit} kit`;
  
  // Update sliders
  document.getElementById('samplePitch').value = sampleParams.pitch || 0;
  document.getElementById('sampleDecay').value = sampleParams.decay || 0.2;
  document.getElementById('sampleTone').value = sampleParams.tone || 50;
  document.getElementById('sampleNoise').value = sampleParams.noise || 30;
  document.getElementById('sampleAttack').value = sampleParams.attack || 0.001;
  document.getElementById('sampleVolume').value = 0;
  document.getElementById('sampleLofi').value = sampleParams.lofi || 0;
  document.getElementById('sampleDist').value = sampleParams.dist || 0;
  
  updateEditorValues();
}

function updateEditorValues() {
  document.getElementById('samplePitchValue').textContent = 
    (parseFloat(document.getElementById('samplePitch').value)).toFixed(1);
  document.getElementById('sampleDecayValue').textContent = 
    (parseFloat(document.getElementById('sampleDecay').value)).toFixed(3) + 's';
  document.getElementById('sampleToneValue').textContent = 
    Math.round(document.getElementById('sampleTone').value) + '%';
  document.getElementById('sampleNoiseValue').textContent = 
    Math.round(document.getElementById('sampleNoise').value) + '%';
  document.getElementById('sampleAttackValue').textContent = 
    (parseFloat(document.getElementById('sampleAttack').value)).toFixed(3) + 's';
  document.getElementById('sampleVolumeValue').textContent = 
    parseFloat(document.getElementById('sampleVolume').value).toFixed(1) + 'dB';
  document.getElementById('sampleLofiValue').textContent = 
    Math.round(document.getElementById('sampleLofi').value) + '%';
  document.getElementById('sampleDistValue').textContent = 
    Math.round(document.getElementById('sampleDist').value) + '%';
}

function generateAndDisplayWaveform() {
  if (!currentSample) return;
  
  currentBuffer = generateSampleBuffer();
  
  const canvas = document.getElementById('sampleWaveform');
  if (canvas && currentBuffer) {
    synth.drawWaveform(currentBuffer, canvas);
  }
}

function generateSampleBuffer() {
  if (!currentSample) return null;

  const params = {
    pitch: parseFloat(document.getElementById('samplePitch').value),
    decay: parseFloat(document.getElementById('sampleDecay').value),
    tone:  parseFloat(document.getElementById('sampleTone').value),
    noise: parseFloat(document.getElementById('sampleNoise').value),
    attack:parseFloat(document.getElementById('sampleAttack').value),
    lofi:  parseFloat(document.getElementById('sampleLofi').value),
    dist:  parseFloat(document.getElementById('sampleDist').value)
  };

  const type = sampleParams.type;
  const closed = sampleParams.closed;

  switch (type) {
    case 'kick':  return synth.generateKick(params);
    case 'snare': return synth.generateSnare(params);
    case 'hihat': return synth.generateHihat(params, closed);
    case 'clap':  return synth.generateClap(params);
    case 'tom':   return synth.generateTom(params, sampleParams.pitch || 0);
    case 'bass':  return synth.generateBass(params);
    case 'guitar':return synth.generateGuitar(params);
    case 'keys':  return synth.generateKeys(params);
    case 'lead':  return synth.generateLead(params);
    case 'riser': return synth.generateRiser(params);
    case 'fx':    return synth.generateFX(params);
    default: return null;
  }
}

function generateBufferForSampleConfig(config) {
  if (!config) return null;

  const { type, closed } = config;
  let buffer = null;

  switch (type) {
    case 'kick':   buffer = synth.generateKick(config); break;
    case 'snare':  buffer = synth.generateSnare(config); break;
    case 'hihat':  buffer = synth.generateHihat(config, closed); break;
    case 'clap':   buffer = synth.generateClap(config); break;
    case 'tom':    buffer = synth.generateTom(config, config.pitch || 0); break;
    case 'bass':   buffer = synth.generateBass(config); break;
    case 'guitar': buffer = synth.generateGuitar(config); break;
    case 'keys':   buffer = synth.generateKeys(config); break;
    case 'lead':   buffer = synth.generateLead(config); break;
    case 'riser':  buffer = synth.generateRiser(config); break;
    case 'fx':     buffer = synth.generateFX(config); break;
    default: break;
  }

  return buffer;
}

function generateRandomizedKit(kitName) {
  const baseKit = baseSampleKits[kitName];
  if (!baseKit) return null;
  
  // Read generator controls
  const character = parseFloat(document.getElementById('genCharacter')?.value || 50);
  const variation = parseFloat(document.getElementById('genVariation')?.value || 0);
  const lofi = parseFloat(document.getElementById('genLofi')?.value || 0);
  
  const charNorm = (character - 50) / 50;
  const varNorm = variation / 100;
  const lofiNorm = lofi / 100;
  
  // KIT-WIDE COHESION: Real kits are recorded together with shared characteristics
  const kitCharacter = {
    roomSize: 0.3 + Math.random() * 0.4, // 0.3-0.7: small studio to large hall
    roomBrightness: 40 + (Math.random() * 2 - 1) * 15, // Shared room tone
    micDistance: 0.4 + Math.random() * 0.4, // 0.4-0.8: close to distant mic
    tuningCoherence: Math.random() * 0.3, // How well-tuned the kit is
    wear: Math.random() * lofiNorm, // Drum head wear (affects all drums)
    vintageYear: lofiNorm > 0.5 ? 1960 + Math.random() * 40 : 2020 // Vintage character
  };
  
  const newKit = {};
  
  Object.entries(baseKit).forEach(([sampleKey, base]) => {
    if (sampleKey.startsWith('_')) {
      newKit[sampleKey] = base;
      return;
    }
    
    const cfg = { ...base };
    
    // Identify sample type with more granularity
    const isDrum = ['kick', 'snare', 'tom', 'rimshot', 'clap'].some(t => sampleKey.includes(t));
    const isCymbal = ['hat', 'crash', 'ride', 'china', 'splash'].some(t => sampleKey.includes(t));
    const isPercussion = ['conga', 'bongo', 'cowbell', 'shaker', 'tamb'].some(t => sampleKey.includes(t));
    const isTonal = ['bass', 'lead', 'pad', 'keys', 'synth'].some(t => sampleKey.includes(t));
    const isKick = sampleKey.includes('kick');
    const isSnare = sampleKey.includes('snare');
    const isHat = sampleKey.includes('hat');
    
    // 1) PITCH: Musical tuning with kit coherence
    let maxPitchSpread;
    if (isDrum) {
      // Drums stay in musical intervals when well-tuned
      maxPitchSpread = (0.3 + 1.5 * varNorm) * (1 + kitCharacter.tuningCoherence);
      const musicalIntervals = [-2, -1, 0, 1, 2, 3.5, 5, 7]; // Musical intervals
      if (varNorm < 0.3 && Math.random() > 0.5) {
        // Sometimes snap to musical intervals for tonal kits
        const interval = musicalIntervals[Math.floor(Math.random() * musicalIntervals.length)];
        cfg.pitch = (base.pitch || 0) + interval + (Math.random() * 2 - 1) * 0.3;
      } else {
        cfg.pitch = (base.pitch || 0) + (Math.random() * 2 - 1) * maxPitchSpread;
      }
    } else if (isCymbal) {
      maxPitchSpread = 0.8 + 3 * varNorm;
      cfg.pitch = (base.pitch || 0) + (Math.random() * 2 - 1) * maxPitchSpread;
    } else if (isTonal) {
      // Tonal instruments need precise tuning
      maxPitchSpread = 0.05 + 0.2 * varNorm; // Very tight
      cfg.pitch = (base.pitch || 0) + (Math.random() * 2 - 1) * maxPitchSpread;
    } else {
      maxPitchSpread = 1 + 3 * varNorm;
      cfg.pitch = (base.pitch || 0) + (Math.random() * 2 - 1) * maxPitchSpread;
    }
    
    // 2) DECAY: Context-aware with room influence
    let decayVariance = 0.2;
    let decayBase = base.decay;
    
    // Room size affects decay (bigger room = longer natural reverb)
    const roomDecayMultiplier = 0.9 + kitCharacter.roomSize * 0.3;
    
    if (isKick) {
      decayVariance = 0.12; // Kicks are consistent
      decayBase *= (0.8 + charNorm * 0.4); // Character = punchier (shorter) vs boomy
    } else if (isSnare) {
      decayVariance = 0.15;
      // Snare wire rattle adds complexity
      cfg.snareRattle = 20 + Math.random() * 30 * (1 - kitCharacter.wear);
    } else if (isCymbal) {
      decayVariance = 0.3;
      decayBase *= (1 + kitCharacter.roomSize * 0.5); // Cymbals ring in big rooms
    }
    
    const decayFactor = (1 + (Math.random() * 2 - 1) * decayVariance * varNorm) * roomDecayMultiplier;
    cfg.decay = +(decayBase * decayFactor).toFixed(3);
    
    // 3) TONE: Shared room characteristics + individual tuning
    const roomToneInfluence = kitCharacter.roomBrightness * 0.3; // Room affects all samples
    const toneBaseShift = charNorm * 18 + roomToneInfluence;
    const toneRand = (Math.random() * 2 - 1) * (6 * varNorm);
    
    // Mic distance affects tone (close = more low end, far = more room)
    const micProximityEffect = isDrum ? (1 - kitCharacter.micDistance) * 8 : 0;
    
    cfg.tone = clamp(base.tone + toneBaseShift + toneRand + micProximityEffect, 0, 100);
    
    // 4) NOISE: Realistic noise sources
    let noiseAmount = 0;
    
    // Tape hiss (vintage recordings)
    const tapeHiss = kitCharacter.vintageYear < 2000 ? (2000 - kitCharacter.vintageYear) / 40 : 0;
    
    // Room noise (ambient)
    const roomNoise = kitCharacter.micDistance * 3;
    
    // Drum wear (old heads, worn cymbals)
    const wearNoise = kitCharacter.wear * (isDrum ? 8 : isCymbal ? 12 : 0);
    
    // Intentional noise for character
    const characterNoise = (Math.random() * 2 - 1) * (10 * varNorm);
    
    noiseAmount = tapeHiss + roomNoise + wearNoise + characterNoise + (lofiNorm * 15);
    cfg.noise = clamp(noiseAmount, 0, 100);
    
    // 5) DISTORTION: Context-based saturation
    let distAmount = 0;
    
    // Tape saturation (vintage)
    const tapeSat = kitCharacter.vintageYear < 1990 ? (1990 - kitCharacter.vintageYear) / 30 : 0;
    
    // Preamp drive (character)
    const preampDrive = Math.max(0, charNorm) * 15;
    
    // Transient clipping (aggressive character)
    const transientClip = Math.max(0, charNorm - 0.5) * 20;
    
    distAmount = tapeSat + preampDrive + transientClip + (Math.random() * 2 - 1) * (6 * varNorm);
    cfg.dist = clamp(distAmount, 0, 100);
    
    // 6) LO-FI: Authentic degradation
    const baseLofi = base.lofi || 0;
    let lofiAmount = baseLofi;
    
    if (lofiNorm > 0) {
      // Bit depth reduction (vintage samplers)
      cfg.bitDepth = Math.floor(16 - lofiNorm * 8); // 16-bit down to 8-bit
      
      // Sample rate reduction
      cfg.sampleRate = Math.floor(44100 * (1 - lofiNorm * 0.5)); // 44.1kHz down to 22kHz
      
      // Vinyl crackle
      cfg.vinylCrackle = lofiNorm * 30 * Math.random();
      
      // Wow and flutter (tape warble)
      cfg.wowFlutter = lofiNorm * 0.3 * Math.random(); // Â±0.3% pitch variation
      
      lofiAmount = lofiNorm * 70 + baseLofi * 0.3;
    }
    
    cfg.lofi = clamp(lofiAmount, 0, 100);
    
    // 7) DYNAMICS: Velocity response and transient shaping
    if (isDrum || isCymbal) {
      // Natural dynamic range
      cfg.velocitySensitivity = 0.6 + Math.random() * 0.35; // 60-95%
      
      // Attack transient (punch)
      cfg.attack = clamp(1 + charNorm * 3, 0.1, 5); // Punchy = faster attack
      
      // Transient emphasis
      cfg.transientGain = clamp(1 + Math.max(0, charNorm) * 0.4, 1, 1.5);
    } else if (isTonal) {
      cfg.velocitySensitivity = 0.8 + Math.random() * 0.2; // More consistent
    }
    
    // 8) BLEED: Drums bleed into each other in real recordings
    if (isDrum && kitCharacter.micDistance > 0.6) {
      cfg.bleed = Math.random() * kitCharacter.micDistance * 20; // Up to 20% bleed
    }
    
    // 9) PHASE: Slight phase variations from multi-mic setups
    if (isDrum || isCymbal) {
      cfg.phaseShift = (Math.random() * 2 - 1) * 15 * kitCharacter.micDistance; // Â±15ms
    }
    
    // 10) STEREO WIDTH: Realistic mic positioning
    if (isCymbal) {
      cfg.stereoWidth = 0.7 + Math.random() * 0.3; // Wide
    } else if (isKick || isDrum) {
      cfg.stereoWidth = 0.2 + Math.random() * 0.3; // More centered
    } else {
      cfg.stereoWidth = 0.4 + Math.random() * 0.4; // Medium
    }
    
    // 11) HARMONICS: Natural overtones
    cfg.harmonicContent = clamp(
      50 + (charNorm * 20) + (Math.random() * 2 - 1) * 10,
      20, 90
    );
    
    // Preserve original properties
    cfg.type = base.type;
    if (base.closed !== undefined) {
      cfg.closed = base.closed;
    }
    
    // Add metadata about the generation
    cfg._kitCharacter = kitCharacter; // Store for UI display
    
    newKit[sampleKey] = cfg;
  });
  
  return newKit;
}

async function buildKitZip(kitName = currentKit) {
  if (!window.JSZip) {
    alert('ZIP library (JSZip) is not loaded.');
    return null;
  }

  const kit = sampleKits[kitName];
  if (!kit) {
    alert('No kit found for "' + kitName + '".');
    return null;
  }

  const zip = new JSZip();
  const folder = zip.folder(`${kitName}_kit`);

  for (const [sampleKey, config] of Object.entries(kit)) {
    if (sampleKey.startsWith('_')) continue; // Skip metadata
    
    const buffer = generateBufferForSampleConfig(config);
    if (!buffer) continue;

    const wavArrayBuffer = synth.bufferToWav(buffer);
    const filename = `${kitName}_${sampleKey}.wav`;
    folder.file(filename, wavArrayBuffer);
  }

  const blob = await zip.generateAsync({ type: 'blob' });
  return blob;
}

async function previewSample(sampleKey) {
  const kit = sampleKits[currentKit];
  if (!kit) return;

  const params = kit[sampleKey];
  if (!params) return;

  const buffer = generateBufferForSampleConfig(params);
  if (!buffer) return;

  const ac = synth.audioContext;
  if (ac && ac.state === 'suspended') {
    try {
      await ac.resume();
    } catch (err) {
      console.warn('Could not resume audio context for preview', err);
    }
  }

  synth.play(buffer, -12);
}

function exportSample(sampleKey) {
  const params = sampleKits[currentKit][sampleKey];
  if (!params) return;

  const buffer = generateBufferForSampleConfig(params);

  if (buffer) {
    const info = sampleInfo[sampleKey];
    const filename = `${currentKit}_${sampleKey}.wav`;
    synth.exportWAV(buffer, filename);
  }
}

function updateSampleCount() {
  const count = Object.keys(sampleKits[currentKit]).filter(k => !k.startsWith('_')).length;
  const countEl = document.getElementById('sampleCount');
  if (countEl) {
    countEl.textContent = `${count} sounds`;
  }
}

function attachEventListeners() {
  // Kit selector
  document.querySelectorAll('[data-kit]').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('[data-kit]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentKit = btn.dataset.kit;
      renderSampleList();
      updateSampleCount();
      currentSample = null;
      currentBuffer = null;
      
      const nameEl = document.getElementById('selectedSampleName');
      const infoEl = document.getElementById('selectedSampleInfo');
      if (nameEl) nameEl.textContent = 'Select a sample';
      if (infoEl) infoEl.textContent = 'Click any sample to edit';
    });
  });

  // Editor sliders
  const sliders = [
    'samplePitch', 'sampleDecay', 'sampleTone', 'sampleNoise',
    'sampleAttack', 'sampleVolume', 'sampleLofi', 'sampleDist'
  ];
  
  sliders.forEach(id => {
    const slider = document.getElementById(id);
    if (slider) {
      slider.addEventListener('input', () => {
        updateEditorValues();
        generateAndDisplayWaveform();
      });
    }
  });

  // Preview button
  const previewBtn = document.getElementById('previewSampleBtn');
  if (previewBtn) {
    previewBtn.addEventListener('click', () => {
      if (currentBuffer) {
        const volume = parseFloat(document.getElementById('sampleVolume').value);
        synth.play(currentBuffer, volume);
      }
    });
  }

  // Save button
  const saveBtn = document.getElementById('saveSampleBtn');
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      if (!currentSample) return;
      
      sampleKits[currentKit][currentSample] = {
        ...sampleParams,
        pitch: parseFloat(document.getElementById('samplePitch').value),
        decay: parseFloat(document.getElementById('sampleDecay').value),
        tone: parseFloat(document.getElementById('sampleTone').value),
        noise: parseFloat(document.getElementById('sampleNoise').value),
        attack: parseFloat(document.getElementById('sampleAttack').value),
        lofi: parseFloat(document.getElementById('sampleLofi').value),
        dist: parseFloat(document.getElementById('sampleDist').value)
      };
      
      alert('âœ“ Sample saved to kit!');
    });
  }

  // Export button
  const exportBtn = document.getElementById('exportSampleBtn');
  if (exportBtn) {
    exportBtn.addEventListener('click', () => {
      if (currentBuffer && currentSample) {
        const info = sampleInfo[currentSample];
        const filename = `${currentKit}_${currentSample}_custom.wav`;
        synth.exportWAV(currentBuffer, filename);
      }
    });
  }

  // Reset button
  const resetBtn = document.getElementById('resetSampleBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (currentSample) {
        sampleParams = { ...sampleKits[currentKit][currentSample] };
        updateEditor();
        generateAndDisplayWaveform();
      }
    });
  }

  // Send current sample to multitrack
  const sendToMultitrackBtn = document.getElementById('sendSampleToMultitrackBtn');
  if (sendToMultitrackBtn) {
    sendToMultitrackBtn.addEventListener('click', () => {
      if (!currentBuffer || !currentSample) {
        alert('No sample selected / generated yet.');
        return;
      }
    
      if (typeof addExternalAudioTrackFromBuffer !== 'function') {
        alert('Multitrack system not ready yet.');
        return;
      }
    
      const name = `${currentKit}_${currentSample}_oneShot.wav`;
    
      try {
        addExternalAudioTrackFromBuffer(currentBuffer, name);
    
        if (typeof renderMultitrack === 'function') {
          renderMultitrack();
        }
    
        if (typeof showToast === 'function') {
          showToast(`ðŸ“¥ Sent "${name}" to the multitrack`, 'success');
        } else {
          alert(`ðŸ“¥ Sent "${name}" to the multitrack!`);
        }
      } catch (err) {
        console.error(err);
        alert('Failed to send sample to multitrack. Check the console for details.');
      }
    });
  }
  
  // Helper: turn an AudioBuffer from SampleSynthesizer into a Blob URL
  function bufferToObjectUrlFromSynth(buffer) {
    const wavArrayBuffer = synth.bufferToWav(buffer);
    const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
    return URL.createObjectURL(blob);
  }

  // Kit selector grid
  const kitSelector = document.getElementById('kitSelector');
  if (kitSelector) {
    kitSelector.addEventListener('click', (e) => {
      const preset = e.target.closest('.preset');
      if (!preset) return;
  
      kitSelector.querySelectorAll('.preset').forEach(btn => btn.classList.remove('active'));
      preset.classList.add('active');
      currentKit = preset.dataset.kit || 'default';
  
      if (typeof showToast === 'function') {
        showToast(`ðŸŽ› Selected "${currentKit}" kit`, 'info');
      }
    });
  }

  // Load kit button (drums + instruments)
  const loadKitBtn = document.getElementById('loadKitBtn');
  if (loadKitBtn) {
    loadKitBtn.addEventListener('click', () => {
      if (
        typeof DRUM_SAMPLES === 'undefined' ||
        typeof synths === 'undefined' ||
        typeof instruments === 'undefined'
      ) {
        alert('Sequencer is not ready yet. Try again after the app finishes loading.');
        return;
      }
    
      const kit = sampleKits[currentKit];
      if (!kit) {
        alert(`No kit found for "${currentKit}".`);
        return;
      }
    
      const synthEngine = window.synth instanceof SampleSynthesizer
        ? window.synth
        : new SampleSynthesizer();
    
      Object.entries(kit).forEach(([name, cfg]) => {
        if (name.startsWith('_')) return;
        
        let buffer = null;
    
        switch (cfg.type) {
          case 'kick':   buffer = synthEngine.generateKick(cfg);   break;
          case 'snare':  buffer = synthEngine.generateSnare(cfg);  break;
          case 'hihat':  buffer = synthEngine.generateHihat(cfg, cfg.closed); break;
          case 'clap':   buffer = synthEngine.generateClap(cfg);   break;
          case 'tom':    buffer = synthEngine.generateTom(cfg, cfg.pitch || 0); break;
          case 'bass':   buffer = synthEngine.generateBass(cfg);   break;
          case 'guitar': buffer = synthEngine.generateGuitar(cfg); break;
          case 'keys':   buffer = synthEngine.generateKeys(cfg);   break;
          case 'lead':   buffer = synthEngine.generateLead(cfg);   break;
          case 'riser':  buffer = synthEngine.generateRiser(cfg);  break;
          case 'fx':     buffer = synthEngine.generateFX(cfg);     break;
          default:
            return;
        }
    
        if (!buffer) return;
    
        if (typeof normalizeBufferInPlace === 'function') {
          normalizeBufferInPlace(buffer, -1);
        }
    
        const url = bufferToObjectUrlFromSynth(buffer);
    
        // Drum mapping
        switch (name) {
          case 'kick':
            DRUM_SAMPLES.kick = url;
            break;
          case 'snare':
            DRUM_SAMPLES.snare = url;
            break;
          case 'hihatClosed':
            DRUM_SAMPLES.hihat = url;
            break;
          case 'hihatOpen':
            DRUM_SAMPLES.crash = url;
            DRUM_SAMPLES.ride  = url;
            break;
          case 'clap':
            DRUM_SAMPLES.clap = url;
            break;
          case 'rimshot':
            DRUM_SAMPLES.rimshot = url;
            break;
          case 'tomLow':
          case 'tomHigh':
            DRUM_SAMPLES.tom = url;
            break;
          default:
            break;
        }
    
        // Drum tracks: rebuild synths
        const instMeta = instruments[name];
        if (instMeta && instMeta.type === 'drum') {
          if (synths[name]?.dispose) {
            try { synths[name].dispose(); } catch {}
          }
          synths[name] = createDrumSynth(name);
          if (instMeta.channel && synths[name]?.connect) {
            synths[name].connect(instMeta.channel);
          }
          return;
        }
    
        // Instrument tracks (bass/keys/guitar/lead/fx/riser)
        if (['bass', 'guitar', 'keys', 'lead', 'fx', 'riser'].includes(name)) {
          const inst = instruments[name];
          if (!inst) return;
        
          if (synths[name]?.dispose) {
            try { synths[name].dispose(); } catch {}
          }
        
          const player = new Tone.Player({
            url,
            autostart: false,
            fadeOut: 0.05,
            volume: -6
          });
        
          if (inst.channel) {
            player.connect(inst.channel);
          } else if (window.SEQUENCER_MASTER_BUS) {
            player.connect(window.SEQUENCER_MASTER_BUS);
          } else {
            player.toDestination();
          }
        
          synths[name] = {
            player,
        
            triggerAttackRelease: (note, duration, time, velocity = 1) => {
              if (!player.loaded) return;
        
              const when = time ?? Tone.now();
        
              const currentChord =
                state.currentChord ||
                (state.progression && state.progression[0]) ||
                null;
        
              const noteName = getInstrumentNote(name, 0, currentChord);
              const rate = getPlaybackRateForNote(noteName);
        
              player.playbackRate = rate;
              player.start(when);
            },
        
            connect: (node) => {
              player.disconnect();
              player.connect(node);
              return player;
            },
        
            toDestination: () => player.toDestination(),
            dispose: () => player.dispose(),
            get loaded() {
              return player.loaded;
            }
          };
        }
      });
    
      if (typeof showToast === 'function') {
        showToast(`ðŸŽ¹ Loaded "${currentKit}" kit (drums + instruments) into the sequencer.`, 'success');
      } else {
        alert(`ðŸŽ¹ Loaded "${currentKit}" kit into the sequencer.`);
      }
    });
  }

  // Reset to factory drum samples
  const defaultKitBtn = document.getElementById('defaultKitBtn');
  if (defaultKitBtn) {
    defaultKitBtn.addEventListener('click', () => {
      if (typeof DEFAULT_DRUM_SAMPLES !== 'undefined' && typeof DRUM_SAMPLES !== 'undefined') {
        Object.keys(DEFAULT_DRUM_SAMPLES).forEach(key => {
          DRUM_SAMPLES[key] = DEFAULT_DRUM_SAMPLES[key];
        });
      }
    
      const drumNames = ['kick','snare','hihat','tom','clap','rimshot','crash','ride','fx','riser','ambience'];
    
      drumNames.forEach(name => {
        if (typeof instruments === 'undefined' || typeof synths === 'undefined') return;
        
        const inst = instruments[name];
        if (!inst) return;
    
        if (synths[name]?.dispose) {
          try { synths[name].dispose(); } catch (e) {
            console.warn(`Error disposing old synth for ${name}`, e);
          }
        }
    
        if (typeof createDrumSynth === 'function') {
          const s = createDrumSynth(name);
          synths[name] = s;
    
          if (inst.channel && s.connect) {
            s.connect(inst.channel);
          }
        }
      });
    
      if (typeof showToast === 'function') {
        showToast('ðŸ¥ Restored factory drum samples.', 'success');
      } else {
        alert('ðŸ¥ Restored factory drum samples.');
      }
    });
  }
  
  // Generate pack (real randomizer)
  const generatePackBtn = document.getElementById('generatePackBtn');
  if (generatePackBtn) {
    generatePackBtn.addEventListener('click', () => {
      const newKit = generateRandomizedKit(currentKit);
      if (!newKit) {
        alert('Unable to generate kit â€“ base kit not found.');
        return;
      }
    
      sampleKits[currentKit] = newKit;
      renderSampleList();
    
      currentSample = null;
      currentBuffer = null;
      
      const nameEl = document.getElementById('selectedSampleName');
      const infoEl = document.getElementById('selectedSampleInfo');
      if (nameEl) nameEl.textContent = 'Select a sample';
      if (infoEl) {
        infoEl.textContent = `Randomized ${currentKit} kit â€” click any sample to edit`;
      }
    
      if (typeof showToast === 'function') {
        showToast(`ðŸŽ² Generated a new ${currentKit} kit`, 'info');
      } else {
        alert(`ðŸŽ² Generated a new variant of the "${currentKit}" kit!`);
      }
    });
  }

  // Download pack (real ZIP export)
  const downloadPackBtn = document.getElementById('downloadPackBtn');
  if (downloadPackBtn) {
    downloadPackBtn.addEventListener('click', async () => {
      try {
        downloadPackBtn.disabled = true;
        downloadPackBtn.textContent = 'â³ Building pack...';
    
        const zipBlob = await buildKitZip(currentKit);
        if (!zipBlob) return;
    
        const dateStamp = new Date().toISOString().slice(0, 10);
        const filename = `${currentKit}_kit_${dateStamp}.zip`;
    
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    
        if (typeof showToast === 'function') {
          showToast(`ðŸ“¦ Downloaded "${currentKit}" kit as ZIP`, 'success');
        } else {
          alert(`ðŸ“¦ Downloaded "${currentKit}" kit as ${filename}`);
        }
      } catch (err) {
        console.error('Error building kit ZIP:', err);
        alert('Failed to build sample pack ZIP. Check console for details.');
      } finally {
        downloadPackBtn.disabled = false;
        downloadPackBtn.textContent = 'ðŸ“¦ Download Pack';
      }
    });
  }

  // Generator sliders
  const genCharacterSlider = document.getElementById('genCharacter');
  if (genCharacterSlider) {
    genCharacterSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      const label = val < 33 ? 'Warm' : val < 66 ? 'Balanced' : 'Bright';
      const valueEl = document.getElementById('genCharacterValue');
      if (valueEl) valueEl.textContent = label;
    });
  }

  const genVariationSlider = document.getElementById('genVariation');
  if (genVariationSlider) {
    genVariationSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      const label = val < 33 ? 'Low' : val < 66 ? 'Medium' : 'High';
      const valueEl = document.getElementById('genVariationValue');
      if (valueEl) valueEl.textContent = label;
    });
  }

  const genLofiSlider = document.getElementById('genLofi');
  if (genLofiSlider) {
    genLofiSlider.addEventListener('input', (e) => {
      const valueEl = document.getElementById('genLofiValue');
      if (valueEl) valueEl.textContent = e.target.value + '%';
    });
  }

  // Refresh button
  const refreshSamplesBtn = document.getElementById('refreshSamplesBtn');
  if (refreshSamplesBtn) {
    refreshSamplesBtn.addEventListener('click', () => {
      renderSampleList();
      alert('âœ“ Sample library refreshed!');
    });
  }
}

// ==================== FAB CONTROLLER ====================
class FABController {
  constructor() {
    this.fab = document.getElementById('dawFab');
    this.fabIcon = document.getElementById('dawFabIcon');
    this.menu = document.getElementById('dawFabMenu');
    this.isOpen = false;

    // Create backdrop once
    this.backdrop = document.createElement('div');
    this.backdrop.className = 'daw-fab-backdrop';
    document.body.appendChild(this.backdrop);

    this.init();
  }

  init() {
    if (!this.fab || !this.menu) return;

    // Toggle menu on FAB click
    this.fab.addEventListener('click', () => this.toggle());

    // Close on backdrop click
    this.backdrop.addEventListener('click', () => this.close());

    // Handle menu item clicks
    const menuItems = this.menu.querySelectorAll('.daw-fab-menu-item');
    console.log('Found menu items:', menuItems.length); // ADD THIS
    
    menuItems.forEach((item, index) => {
      console.log(`Item ${index}:`, item.dataset.action); // ADD THIS
      item.addEventListener('click', (e) => {
        console.log('Item clicked:', item.dataset.action); // ADD THIS
        const action = item.dataset.action;
        this.handleAction(action);
        this.close();
      });
    });

    // Close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isOpen) this.close();
    });

    // Close when tab changes
    document.addEventListener('tabChange', () => this.close());
  }

  toggle() {
    this.isOpen ? this.close() : this.open();
  }

  open() {
    this.isOpen = true;
    this.fab.classList.add('open');
    this.menu.classList.add('open');
    this.backdrop.classList.add('open');
    if (this.fabIcon) this.fabIcon.textContent = 'Ã—';
    if (navigator.vibrate) navigator.vibrate(10);
  }

  close() {
    this.isOpen = false;
    this.fab.classList.remove('open');
    this.menu.classList.remove('open');
    this.backdrop.classList.remove('open');
    if (this.fabIcon) this.fabIcon.textContent = '+';
  }

  handleAction(action) {
    switch (action) {
      case 'add-track':
        document.getElementById('addTrackBtnLeft')?.click();
        break;
      case 'toggle-inspector':
        const inspector = document.querySelector('.daw-inspector');
        inspector?.classList.toggle('inspector-open');
        break;
      case 'toggle-fx':
        const fxPanel = document.getElementById('fxChainPanel');
        fxPanel?.classList.toggle('open');
        break;
      case 'record-arm':
        const selectedStrip = document.querySelector('.daw-track-strip.selected');
        if (selectedStrip) {
          const armBtn = selectedStrip.querySelector('.track-mini-btn.arm');
          armBtn?.click();
        }
        break;
      case 'undo':
        document.getElementById('undoBtn')?.click();
        break;
    }
  }

  addTrack() {
    if (typeof showAddTrackDialog === 'function') {
      showAddTrackDialog();
    } else if (typeof createTrack === 'function') {
      createTrack();
      if (typeof showToast === 'function') showToast('âœ… Track added', 'success');
    }
  }

  toggleInspector() {
    const inspector = document.querySelector('.daw-inspector');
    if (!inspector) return;
    inspector.classList.toggle('inspector-open');
    const isOpen = inspector.classList.contains('inspector-open');
    inspector.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    if (typeof showToast === 'function') {
      showToast(isOpen ? 'ðŸŽ›ï¸ Inspector opened' : 'ðŸŽ›ï¸ Inspector closed', 'info');
    }
  }

  toggleFX() {
    const fxPanel = document.getElementById('fxChainPanel');
    if (!fxPanel) return;
    const isOpen = !fxPanel.classList.contains('open');
    fxPanel.classList.toggle('open', isOpen);
    fxPanel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
    if (typeof showToast === 'function') {
      showToast(isOpen ? 'âœ¨ FX chain opened' : 'âœ¨ FX chain closed', 'info');
    }
  }

  quickRecordArm() {
    const selectedStrip = document.querySelector('.daw-track-strip.selected');
    if (!selectedStrip) {
      if (typeof showToast === 'function') showToast('âš ï¸ Tap a track first', 'warning');
      return;
    }
    const trackId = selectedStrip.dataset.trackId;
    const armBtn = document.querySelector(`.track-mini-btn.arm[data-track-id="${trackId}"]`);
    if (armBtn) armBtn.click();
  }

  undo() {
    if (window.multitrackHistory && typeof multitrackHistory.undo === 'function') {
      multitrackHistory.undo();
    } else if (typeof showToast === 'function') {
      showToast('âš ï¸ Nothing to undo', 'warning');
    }
  }
}

let fabController;

// === Cleanup on resize to desktop ===
window.addEventListener('resize', () => {
  if (window.innerWidth > 900 && fabController) fabController.close();
});

function initFAB() {
  if (!fabController && window.innerWidth <= 900) {
    fabController = new FABController();
  }
}


// ===================================================
// ðŸŽ¼ HARMONY TAB INTEGRATION
// ===================================================

// --- 1. Initialize selectors ---
function populateHarmonySelectors() {
  const keySelect    = document.getElementById('keySelect');
  const scaleSelect  = document.getElementById('scaleSelect');
  const octaveSelect = document.getElementById('octaveSelect');

  if (!keySelect || !scaleSelect || !octaveSelect) return;

  // âœ… use your global keysArr + scales object
  const keys       = keysArr;              // ['C','C#', ...]
  const scaleNames = Object.keys(scales);  // ['major','minor','ionian',...]
  const octaves    = [2,3,4,5];

  // sanity: keep state in-bounds
  if (!keys.includes(state.key)) {
    state.key = keys[0];
  }
  if (!scaleNames.includes(state.scale)) {
    state.scale = scaleNames[0];
  }
  if (!octaves.includes(state.octave)) {
    state.octave = 3;
  }

  keySelect.innerHTML = keys
    .map(k => `<option value="${k}" ${k === state.key ? 'selected' : ''}>${k}</option>`)
    .join('');

  scaleSelect.innerHTML = scaleNames
    .map(s => `<option value="${s}" ${s === state.scale ? 'selected' : ''}>${s}</option>`)
    .join('');

  octaveSelect.innerHTML = octaves
    .map(o => `<option value="${o}" ${o === state.octave ? 'selected' : ''}>${o}</option>`)
    .join('');

  keySelect.value    = state.key;
  scaleSelect.value  = state.scale;
  octaveSelect.value = state.octave;
}


// --- 2. Generate chords based on selected key/scale ---
function generateAvailableChords() {
  const key = document.getElementById('keySelect').value;
  const scale = document.getElementById('scaleSelect').value;
  const octave = parseInt(document.getElementById('octaveSelect').value, 10);

  const scaleData = Tonal.Scale.get(`${key} ${scale}`);
  const triads = scaleData.notes.map((n, i) => {
    const third = scaleData.notes[(i + 2) % scaleData.notes.length];
    const fifth = scaleData.notes[(i + 4) % scaleData.notes.length];
    return [n + octave, third + octave, fifth + octave];
  });

  const chordChips = document.getElementById('chordChips');
  chordChips.innerHTML = '';

  triads.forEach((chord) => {
    const chip = document.createElement('button');
    chip.className = 'chip';
    chip.textContent = chord.map(n => n.replace(/\d/, '')).join('-');
    chip.addEventListener('click', () => addChordToProgression(chord));
    chordChips.appendChild(chip);
  });
}

document.getElementById('genProgBtn')?.addEventListener('click', generateAvailableChords);

// --- 3. Manage active progression ---
function addChordToProgression(chord) {
  state.progression.push(chord);
  renderProgressionChips();
}

function renderProgressionChips() {
  const container = document.getElementById('progressionChips');
  container.innerHTML = '';

  state.progression.forEach((chord, i) => {
    const chip = document.createElement('button');
    chip.className = 'chip active';
    chip.textContent = chord.map(n => n.replace(/\d/, '')).join('-');
    chip.addEventListener('click', () => {
      state.progression.splice(i, 1);
      renderProgressionChips();
    });
    container.appendChild(chip);
  });
}

document.getElementById('clearProgBtn')?.addEventListener('click', () => {
  state.progression = [];
  renderProgressionChips();
});

// --- 4. Apply harmony settings ---
document.getElementById('keySelect')?.addEventListener('change', e => state.key = e.target.value);
document.getElementById('scaleSelect')?.addEventListener('change', e => state.scale = e.target.value);
document.getElementById('octaveSelect')?.addEventListener('change', e => state.octave = parseInt(e.target.value, 10));

// === Splash / Initialization UI ===
const splash = {
  el: null,
  messageEl: null,
  barEl: null
};

function initSplash() {
  splash.el = document.getElementById('splashOverlay');
  splash.messageEl = document.getElementById('splashMessage');
  splash.barEl = document.getElementById('splashBar');

  if (!splash.el) return;
  splash.el.classList.remove('hidden');
  // Start at a tiny bit of progress so the bar isn't empty
  if (splash.barEl) splash.barEl.style.width = '8%';
}

function updateSplash(message, percent) {
  if (!splash.el) return;

  if (message && splash.messageEl) {
    splash.messageEl.textContent = message;
  }
  if (typeof percent === 'number' && splash.barEl) {
    const clamped = Math.max(0, Math.min(100, percent));
    splash.barEl.style.width = `${clamped}%`;
  }
}

function hideSplash() {
  if (!splash.el) return;
  splash.el.classList.add('hidden');
}

// === SIMPLE MODE â€” ALL TABS, custom transport ===
(() => {
  if (window.__simpleUiBooted) return; window.__simpleUiBooted = true;

  const once = (el, evt, fn, key) => {
    if (!el) return;
    const mark = `_wired_${evt}_${key || ''}`;
    if (el.dataset && el.dataset[mark]) return;
    el.addEventListener(evt, fn);
    if (el.dataset) el.dataset[mark] = '1';
  };

  const qs  = (s, r=document) => r.querySelector(s);
  const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

  const store = {
    get ui(){ return localStorage.getItem('8beat.uiMode') || 'simple' },
    set ui(v){ localStorage.setItem('8beat.uiMode', v) },
    get last(){ return localStorage.getItem('8beat.lastTab') || 'generate' },
    set last(v){ localStorage.setItem('8beat.lastTab', v) },
    get pro(){ return localStorage.getItem('8beat.pro') === 'true' }
  };

  const shell = qs('#simpleShell');
  const mount = qs('#simpleMount');
  const steps = qsa('.simple-step');
  const note  = qs('#simpleNote');

  const byKey = {
    generate:  qs('#tab-generate'),
    sequencer: qs('#tab-sequencer'),
    mixer:     qs('#tab-mixer'),
    fx:        qs('#tab-fx'),
    harmony:   qs('#tab-harmony'),
    songbuilder: qs('#tab-songbuilder'),
    multitrack: qs('#tab-multitrack'),
    samples:   qs('#tab-samples')
  };

  function attachPanel(key){
    const panel = byKey[key];
    if (!panel) { console.warn('[simple-ui] Missing panel:', key); return; }
  
    // Remember original parent/next sibling once
    if (!panel._origParent) {
      panel._origParent = panel.parentElement || null;
      panel._origNext   = panel.nextSibling || null; // may be null (append case)
    }
  
    panel.classList.add('simple-mounted');
    mount.replaceChildren(panel);
    shell.hidden = false;
  }

  function setStep(key){
    steps.forEach(s=>s.classList.toggle('active', s.dataset.go===key));
    attachPanel(key);
    store.last = key;
    const txt = {
      generate: 'Generate beats, rhythms, and AI variations.',
      sequencer:'Edit notes and patterns on the step grid.',
      mixer:    'Balance levels, master bus, and AI mixing.',
      fx:       'Add effects to individual channels.',
      harmony:  'Set key, scale, chords, and progressions.',
      songbuilder:'Build complete song structures with sections.',
      multitrack:'Professional DAW for recording and arranging.',
      samples:  'Browse kits, edit samples, generate packs.'
    };
    if (note) note.textContent = txt[key] || '';
  }

  function markSimpleProLocks(){
    steps.forEach(btn => {
      const key   = btn.dataset.go;
      const panel = byKey[key];
      const locked = !!(panel && panel.classList.contains('pro-locked') && !store.pro);
      btn.classList.toggle('locked', locked);
      btn.setAttribute('aria-disabled', locked ? 'true' : 'false');
    });
  }

  function enableSimpleUI(){
    document.body.classList.add('simple-ui');

    // Hide pro UI elements + regular transport
    ['.sidebar-nav','.sidebar-toggle','.sidebar-backdrop','header .header-actions','.footer','.transport'].forEach(sel =>
      qsa(sel).forEach(el => el.style.display='none')
    );

    markSimpleProLocks();

    // --- Simple: Unlock Pro button (opens the same modal you use in Pro) ---
    let simpUnlockBtn = document.getElementById('simpUnlockProBtn'); // âœ… matches your HTML
    if (!simpUnlockBtn) {
      // Create it dynamically only if it's missing
      const bar = document.querySelector('#simpleToolbar') || document.querySelector('#simpleShell .simple-header') || shell;
      simpUnlockBtn = document.createElement('button');
      simpUnlockBtn.id = 'simpUnlockProBtn';
      simpUnlockBtn.className = 'btn btn-primary';
      simpUnlockBtn.textContent = 'Unlock Pro';
      bar?.appendChild(simpUnlockBtn);
    }
  
    // Show/hide depending on license
    simpUnlockBtn.style.display = store.pro ? 'none' : 'inline-flex';
  
    // Open the shared unlock modal
    once(simpUnlockBtn, 'click', () => {
      const modal = ensureUnlockModalInBody();
      if (modal) modal.classList.remove('hidden');
      else console.warn('[simple-ui] #unlockModal not found');
    }, 'simpUnlockProBtn');
  
    // When license activates, hide the button + refresh
    window.addEventListener('license:activated', () => {
      store.ui = 'pro';
      localStorage.setItem('8beat.pro', 'true');
      simpUnlockBtn.style.display = 'none';
      window.__refreshNavForPro?.();
      disableSimpleUI(); // optional: switch to full Pro mode immediately
    });

    // Transport sync
    const simpPlay = qs('#simpPlay');
    const simpStop = qs('#simpStop');
    const simpBpm = qs('#simpBpm');
    const simpBpmSlider = qs('#simpBpmSlider');
    const simpSwing = qs('#simpSwing');
    const simpTime = qs('#simpTime');
    const simpProgress = qs('#simpProgress');
    
    const realPlay = qs('#playBtn');
    const realStop = qs('#stopBtn');
    const realBpm = qs('#bpmSlider');
    const realBpmVal = qs('#bpmValue');
    const realSwing = qs('#swingSlider');
    const realSwingVal = qs('#swingValue');
    const realTime = qs('#timeDisplay');
    const realProgressFill = qs('#progressFill');

    // Init values
    if (realBpm && simpBpm) simpBpm.value = realBpm.value;
    if (realBpm && simpBpmSlider) simpBpmSlider.value = realBpm.value;
    if (realSwing && simpSwing) simpSwing.value = realSwing.value;

    // Play/Stop
    once(simpPlay, 'click', () => realPlay?.click(), 'simpPlay');
    once(simpStop, 'click', () => realStop?.click(), 'simpStop');
    
    // BPM number
    once(simpBpm, 'input', () => {
      if (realBpm){ 
        realBpm.value = simpBpm.value; 
        realBpm.dispatchEvent(new Event('input',{bubbles:true})); 
      }
      if (realBpmVal) realBpmVal.textContent = simpBpm.value;
      if (simpBpmSlider) simpBpmSlider.value = simpBpm.value;
    }, 'simpBpm');
    
    // BPM slider
    once(simpBpmSlider, 'input', () => {
      if (realBpm){ 
        realBpm.value = simpBpmSlider.value; 
        realBpm.dispatchEvent(new Event('input',{bubbles:true})); 
      }
      if (realBpmVal) realBpmVal.textContent = simpBpmSlider.value;
      if (simpBpm) simpBpm.value = simpBpmSlider.value;
    }, 'simpBpmSlider');
    
    // Swing
    once(simpSwing, 'input', () => {
      if (realSwing){ 
        realSwing.value = simpSwing.value; 
        realSwing.dispatchEvent(new Event('input',{bubbles:true})); 
      }
      if (realSwingVal) realSwingVal.textContent = simpSwing.value + '%';
    }, 'simpSwing');
    
    // Back-sync
    once(realBpm, 'input', () => { 
      if (simpBpm) simpBpm.value = realBpm.value; 
      if (simpBpmSlider) simpBpmSlider.value = realBpm.value;
    }, 'realBpm');
    once(realSwing, 'input', () => { 
      if (simpSwing) simpSwing.value = realSwing.value; 
    }, 'realSwing');

    // Progress sync (poll every 100ms)
    window.__simpleUiPoll && clearInterval(window.__simpleUiPoll);
    window.__simpleUiPoll = setInterval(() => {
      if (realTime && simpTime) simpTime.textContent = realTime.textContent;
      if (realProgressFill && simpProgress) {
        simpProgress.style.width = realProgressFill.style.width || '0%';
      }
    }, 100);
    
    // Tabs
    steps.forEach(btn => once(btn, 'click', () => {
      const key = btn.dataset.go;
      const panel = byKey[key];
      if (panel?.classList.contains('pro-locked') && !store.pro) {
        const modal = qs('#unlockModal');
        if (modal) modal.classList.remove('hidden');
        return;
      }
      setStep(key);
    }, `step_${btn.dataset.go}`));
    
    // Toggle to Pro
    once(qs('#simpToggleMode'), 'click', () => disableSimpleUI(), 'togglePro');

    setStep(store.last);
  }

  function disableSimpleUI(){
    // stop the simple-mode poll
    if (window.__simpleUiPoll) {
      clearInterval(window.__simpleUiPoll);
      window.__simpleUiPoll = null;
    }

    // 1) Unhide Pro chrome we hid in Simple
    ['.sidebar-nav','.sidebar-toggle','.sidebar-backdrop','header .header-actions','.footer','.transport']
      .forEach(sel => qsa(sel).forEach(el => el.style.display=''));
  
    // 2) Move any mounted sections back to where they came from
    Object.values(byKey).forEach(p => {
      if (!p || !p._origParent) return;
      try {
        if (p._origNext && p._origNext.parentNode === p._origParent) {
          p._origParent.insertBefore(p, p._origNext);
        } else {
          p._origParent.appendChild(p);
        }
        p.classList.remove('simple-mounted');
      } catch(e){ console.warn('restore panel failed', e); }
    });
  
    // 3) Hide the Simple shell and class
    shell.hidden = true;
    document.body.classList.remove('simple-ui');
  
    // 4) Persist preference
    store.ui = 'pro';
  }

  window.enableSimpleUI  = () => { store.ui='simple'; enableSimpleUI(); };
  window.disableSimpleUI = () => { disableSimpleUI(); }; // no reload

  const urlUi = new URL(location.href).searchParams.get('ui');
  const savedUi = localStorage.getItem('8beat.uiMode');
  const wantSimple = (urlUi === 'simple') || (!urlUi && savedUi !== 'pro');
  if (!savedUi) localStorage.setItem('8beat.uiMode', wantSimple ? 'simple' : 'pro');

  const panelsPresent = Object.values(byKey).every(Boolean);
  if (wantSimple) {
    if (panelsPresent) enableSimpleUI();
    else setTimeout(enableSimpleUI, 100);
  }

  window.__refreshNavForPro = () => {
    qsa('.sidebar-tab.locked').forEach(b => b.classList.remove('locked'));
    markSimpleProLocks();
  };
})();

// ---------- Session persistence ----------
const SESSION_KEY = '8beat.session.v1';

function getPlainPatterns() {
  const out = {};
  Object.keys(patterns).forEach(k => {
    out[k] = patterns[k].map(s => ({
      active: !!s.active,
      velocity: s.velocity ?? 0.8,
      probability: s.probability ?? 100,
      note: s.note ?? (instruments[k]?.note ?? 'C4'),
      duration: s.duration ?? '8n'
    }));
  });
  return out;
}

function saveSession() {
  try {
    const payload = {
      version: 1,
      state: {
        // Transport & timing
        bpm: state.bpm,
        swing: state.swing,
        sequenceLength: state.sequenceLength,
        resolution: state.resolution,
        duration: state.duration,
        
        // Musical settings
        currentGenre: state.currentGenre,
        key: state.key,
        scale: state.scale,
        octave: state.octave,
        progression: state.progression,
        complexity: state.complexity,
        humanize: state.humanize,
        
        // Master controls
        masterVolume: state.masterVolume,
        tapeSaturation: state.tapeSaturation,
        vinylNoise: state.vinylNoise,
        lowCut: state.lowCut,
        highCut: state.highCut,
        compressor: state.compressor,
        
        // Metronome
        metronomeEnabled: state.metronomeEnabled,
        metronomeVolume: state.metronomeVolume,
        countInBars: state.countInBars,
        
        // AI Mixing (full object)
        aiMixing: {
          enabled: state.aiMixing?.enabled ?? false,
          autoGain: state.aiMixing?.autoGain ?? true,
          autoPan: state.aiMixing?.autoPan ?? true,
          autoEQ: state.aiMixing?.autoEQ ?? true,
          autoCompression: state.aiMixing?.autoCompression ?? true,
          referenceLevel: state.aiMixing?.referenceLevel ?? -14
        },
        
        // UI state
        currentTab: state.currentTab
      },
      
      // Patterns with full data
      patterns: getPlainPatterns(),
      
      // Instruments (levels / pan / notes etc.)
      instruments: (typeof getSerializableInstruments === 'function')
        ? getSerializableInstruments()
        : {},
      
      // FX config
      fxConfig: (typeof fxConfig === 'object' && fxConfig) ? fxConfig : {},
      
      // Vibe/theme
      vibe: document.body.getAttribute('data-vibe') || null,
      
      // Transport position
      transport: {
        pos: Tone?.Transport?.seconds || 0,
        playing: !!state.isPlaying
      },
      
      ts: Date.now()
    };
    
    localStorage.setItem(SESSION_KEY, JSON.stringify(payload));
    console.log('ðŸ’¾ Session saved:', new Date().toLocaleTimeString());
  } catch (e) {
    console.warn('saveSession failed', e);
  }
}

async function restoreSessionIfAny() {
  const raw = localStorage.getItem(SESSION_KEY);
  if (!raw) return false;
  
  try {
    const sess = JSON.parse(raw) || {};
    console.log('ðŸ“‚ Restoring session from:', new Date(sess.ts).toLocaleString());
    
    // Stop playback while swapping state
    if (state?.isPlaying && typeof stop === 'function') stop();
    
    // ---- Core state (merge all saved properties) ----
    Object.assign(state, sess.state || {}, { 
      isPlaying: false, 
      currentStep: 0,
      cursorSeconds: 0
    });
    
    // ---- Patterns ----
    if (sess.patterns && typeof patterns === 'object') {
      for (const k of Object.keys(patterns)) delete patterns[k];
      Object.assign(patterns, sess.patterns);
    }
    
    // ---- Instruments (levels/pan/notes) ----
    if (sess.instruments && typeof applyLoadedInstruments === 'function') {
      applyLoadedInstruments(sess.instruments);
    }
    
    // ---- FX config ----
    if (sess.fxConfig) {
      if (typeof fxConfig !== 'object' || !fxConfig) window.fxConfig = {};
      Object.assign(fxConfig, sess.fxConfig);
    }
    
    // ---- Vibe / theme ----
    if (sess.vibe && typeof applyVibe === 'function') {
      applyVibe(sess.vibe);
    }
    
    // ---- Update ALL UI controls ----
    // BPM
    const bpmSlider = document.getElementById('bpmSlider');
    const bpmValue = document.getElementById('bpmValue');
    if (bpmSlider) bpmSlider.value = state.bpm;
    if (bpmValue) bpmValue.textContent = state.bpm;
    
    // Swing
    const swingSlider = document.getElementById('swingSlider');
    const swingValue = document.getElementById('swingValue');
    if (swingSlider) swingSlider.value = state.swing;
    if (swingValue) swingValue.textContent = state.swing + '%';
    
    // Duration
    const durSlider = document.getElementById('durSlider');
    const durValue = document.getElementById('durValue');
    if (durSlider) durSlider.value = state.duration;
    if (durValue) durValue.textContent = state.duration + ' min';
    
    // Complexity
    const complexSlider = document.getElementById('complexSlider');
    const complexValue = document.getElementById('complexValue');
    const complexLabels = ['Simple', 'Medium', 'Complex'];
    if (complexSlider) complexSlider.value = state.complexity;
    if (complexValue) complexValue.textContent = complexLabels[state.complexity - 1] || 'Medium';
    
    // Humanize
    const humanSlider = document.getElementById('humanSlider');
    const humanValue = document.getElementById('humanValue');
    if (humanSlider) humanSlider.value = state.humanize;
    if (humanValue) humanValue.textContent = state.humanize + 'ms';
    
    // Master controls (mixer panel)
    const masterVolSlider = document.getElementById('masterVolSlider');
    const masterVolValue = document.getElementById('masterVolValue');
    if (masterVolSlider) masterVolSlider.value = state.masterVolume;
    if (masterVolValue) masterVolValue.textContent = state.masterVolume + 'dB';
    
    const tapeSlider = document.getElementById('tapeSlider');
    const tapeValue = document.getElementById('tapeValue');
    if (tapeSlider) tapeSlider.value = state.tapeSaturation;
    if (tapeValue) tapeValue.textContent = state.tapeSaturation + '%';
    
    const vinylSlider = document.getElementById('vinylSlider');
    const vinylValue = document.getElementById('vinylValue');
    if (vinylSlider) vinylSlider.value = state.vinylNoise;
    if (vinylValue) vinylValue.textContent = state.vinylNoise + '%';
    
    const lowCutSlider = document.getElementById('lowCutSlider');
    const lowCutValue = document.getElementById('lowCutValue');
    if (lowCutSlider) lowCutSlider.value = state.lowCut;
    if (lowCutValue) lowCutValue.textContent = state.lowCut + 'Hz';
    
    const highCutSlider = document.getElementById('highCutSlider');
    const highCutValue = document.getElementById('highCutValue');
    if (highCutSlider) highCutSlider.value = state.highCut;
    if (highCutValue) highCutValue.textContent = state.highCut + 'Hz';
    
    const compSlider = document.getElementById('compSlider');
    const compValue  = document.getElementById('compValue');
    if (compSlider) compSlider.value = state.compressor;
    if (compValue) compValue.textContent = state.compressor + 'dB';
    
    // Metronome buttons
    const metronomeBtn = document.getElementById('metronomeBtn');
    if (metronomeBtn) {
      metronomeBtn.textContent = state.metronomeEnabled ? 'ðŸ¥ Click: On' : 'ðŸ¥ Click: Off';
    }
    
    const countInBtn = document.getElementById('countInBtn');
    if (countInBtn) {
      const countLabels = ['â±ï¸ Count: Off', 'â±ï¸ Count: 1 bar', 'â±ï¸ Count: 2 bars'];
      countInBtn.textContent = countLabels[state.countInBars] || countLabels[0];
    }
    
    // AI Mixing checkboxes
    const autoGainCheckbox = document.getElementById('autoGainCheckbox');
    if (autoGainCheckbox) autoGainCheckbox.checked = !!state.aiMixing?.autoGain;
    
    const autoPanCheckbox = document.getElementById('autoPanCheckbox');
    if (autoPanCheckbox) autoPanCheckbox.checked = !!state.aiMixing?.autoPan;
    
    const autoEQCheckbox = document.getElementById('autoEQCheckbox');
    if (autoEQCheckbox) autoEQCheckbox.checked = !!state.aiMixing?.autoEQ;
    
    const autoCompCheckbox = document.getElementById('autoCompCheckbox');
    if (autoCompCheckbox) autoCompCheckbox.checked = !!state.aiMixing?.autoCompression;
        
    // Genre selector
    const genreSelect = document.getElementById('genreSelect');
    if (genreSelect) {
      genreSelect.value = state.currentGenre || 'lofi';
    }
    
    // Apply Tone.js settings
    if (typeof Tone !== 'undefined' && Tone.Transport) {
      Tone.Transport.bpm.value = state.bpm;
      Tone.Transport.swing = state.swing / 100;
      Tone.Transport.swingSubdivision = '8n';
      Tone.Destination.volume.value = state.masterVolume;
    }
    
    // Apply master FX
    if (master) {
      if (master.tapeDistortion) {
        master.tapeDistortion.distortion = (state.tapeSaturation / 100) * 0.2;
        master.tapeDistortion.wet.value = (state.tapeSaturation / 100) * 0.6;
      }
      if (master.vinylNoise) {
        master.vinylNoise.volume.value = -50 + (state.vinylNoise / 100) * 15;
      }
      if (master.lowCutFilter) {
        master.lowCutFilter.frequency.value = state.lowCut;
      }
      if (master.highCutFilter) {
        master.highCutFilter.frequency.value = state.highCut;
      }
      if (master.comp) {
        master.comp.threshold.value = state.compressor;
      }
    }
    
    // ---- Re-render UI surfaces ----
    renderSequencer?.();
    renderMixer?.();
    renderFX?.();
    renderHarmony?.();
    renderMultitrack?.();
    updateAllDisplays?.();
    
    // Sync tempo controls
    if (typeof syncTempoControlsFromState === 'function') {
      syncTempoControlsFromState();
    }
    
    // ---- Transport position ----
    if (typeof Tone !== 'undefined' && Tone.Transport) {
      Tone.Transport.seconds = (sess.transport?.pos) || 0;
    }
    
    // ---- Resume playback if it was playing ----
    if (sess.transport?.playing && typeof play === 'function') {
      if (Tone?.getContext()?.state === 'running') {
        play();
      } else {
        state.pendingResume = true;
        showToast?.('Tap anywhere to resume playback', 'info');
      }
    }
    
    showToast?.('â†º Session fully restored', 'success');
    console.log('âœ… Session restore complete');
    return true;
  } catch (e) {
    console.warn('restoreSessionIfAny failed', e);
    return false;
  }
}

// Save often + on exit
if (!window.__sessionSaver) {
  window.__sessionSaver = setInterval(saveSession, 10000); // Every 10 seconds
}
window.addEventListener('visibilitychange', () => { if (document.hidden) saveSession(); });
window.addEventListener('beforeunload', saveSession);
window.addEventListener('pagehide', saveSession); // For mobile Safari

// Manual save function (can be called from UI)
window.saveSessionNow = saveSession;

  
// -------------------- Initialization --------------------
async function init() {
  // === 0. Splash: start ===
  initSplash();
  updateSplash('Preparing license systemâ€¦', 10);

  // === 1. Licensing & UI gating ===
  initLicenseUI();          // sets up modal + auto-unlock if localStorage says Pro
  gateTabsForFreeUsers();   // lock non-generate tabs for free users
  if (isPro()) {
    enableProFeatures();    // ensure UI is fully unlocked if already Pro
  }

  await validateProTokenIfAny();
  if (isPro()) enableProFeatures();


  updateSplash('Starting audio engineâ€¦', 35);

  // === 2. Core audio systems ===
  initAudioContext();
  initAudio();
  ensurePatternLength(state.sequenceLength);

  updateSplash('Wiring controls & multitrackâ€¦', 55);

  // === 3. Event wiring ===
  setupEventListeners();
  setupMultitrackListeners();
  setupRegionContextMenu();

  updateSplash('Rendering interfaceâ€¦', 75);

  // === 4. UI rendering ===
  renderSequencer();
  renderMixer();
  renderFX();
  renderHarmony();
  renderPresets();
  renderMultitrack();
  updateAllDisplays();

  updateSplash('Finalizing visualizer & samplesâ€¦', 90);

  // === 5. Final touches ===
  initVisualizerOnce();
  unlockAudioOnce();           // (see patch #2 below)
  checkAudioPermissions();
  checkSamplesLoaded();
  loadSavedVibe();
  setupStemImport();
  initSampleLibrary();
  setupPreviewButton();
  updateUndoRedoButtons();

  // --- 6. Init Harmony tab on load ---
  populateHarmonySelectors();
  generateAvailableChords();
  renderProgressionChips();

  initializeAIMixingSystem();
  setupAIMixingKeyboardShortcuts();

  // âœ… Restore last session (patterns, bpm/swing, harmony, FX, pos/playing)
  await restoreSessionIfAny();

  updateSplash('Ready! Have fun âœ¨', 100);

  if (!window.__dawStatusTicker) {
    window.__dawStatusTicker = setInterval(updateDAWStatus, 500);
  }
  initPlayheadFollow();

  initFAB();
  // Small delay so the user sees "Ready!" before it disappears
  setTimeout(hideSplash, 3000);
}

  
// -------------------- Entry Point --------------------
window.addEventListener('load', () => {
  if (typeof window.Tonal === 'undefined') {
    console.warn('âš ï¸ Tonal.js failed to load â€” injecting fallback.');
    window.Tonal = {
      Scale: {
        get: () => ({ notes: ['C','D','E','F','G','A','B'] })
      },
      Chord: {
        get: () => ({ notes: ['C','E','G'] })
      }
    };
  }
  init();
});

</script>

</body>
</html>
